%-Driver generated by the Bean Wizard
%-
%- WARNING !
%-
%- Do not make changes to these lines (if you make some changes, you damage this driver)
%- which begins with:
%-
%-  %-STARTUSERTYPES
%-  %-ENDUSRTYPES
%-  /* END %ModuleName. */
%-  /* MODULE %ModuleName. */
%-  %-INTERNAL_METHOD_BEG
%-  %-INTERNAL_METHOD_END
%-  %-INHERITED_EVENT_BEGIN
%-  %-INHERITED_EVENT_END
%-  %-BW_METHOD_BEGIN
%-  %-BW_METHOD_END
%-  %-BW_DEFINITION_START
%-  %-BW_DEFINITION_END
%-  %-BW_IMPLEMENT_START
%-  %-BW_IMPLEMENT_END
%-  %-BW_EVENT_DEFINITION_START
%-  %-BW_EVENT_DEFINITION_END
%-  %-BW_EVENT_IMPLEMENT_START
%-  %-BW_EVENT_IMPLEMENT_END
%-  %-BW_METHOD_MACROS_START
%-  %-BW_METHOD_MACROS_END
%-  %-BW_SECTIONS_INSERT
%-  %-BW_INTERN_COMMENTS_START
%-  %-BW_INTERN_COMMENTS_END
%-  %-BW_BEAN_CONSTANTS_START
%-  %-BW_BEAN_CONSTANTS_END
%-
%-
%- These lines are not comments, but they are necessary for Bean Wizard
%- If you change these lines, Bean Wizard will not be responsible for loosing or damaging your code!
%-
%-
%- readyCPU ...
%- readyDEVICE ...
%-
%define DriverAuthor  Author
%define DriverVersion 01.00
%define DriverDate    06.11.2008
%-
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END
%-
%-BW_INTERN_COMMENTS_START
%- List of descriptions of internal methods
%-BW_INTERN_COMMENTS_END
%-
%-BW_SECTIONS_INSERT
%if Language='ANSIC'
%-
%-
%INTERFACE
%define! Settings Common\NEOmatrixSettings.Inc
%define! Abstract Common\NEOmatrixAbstract.Inc
%include Common\Header.h

%if (defined(PEversionDecimal) && (PEversionDecimal <=0 '1283')) %- this is only supported with MCU 10.3
%if (CPUfamily = "Kinetis")
/* PEversionDecimal version: %PEversionDecimal (1283 for MCU10.3) */
#include "PE_LDD.h" /* hack for Processor Expert (e.g. in MCU10.3) and LDD: PE_LDD.h includes at the end all shared modules, causing a recursive header file include conflict */
%endif
%endif

#ifndef __%'ModuleName'_H
#define __%'ModuleName'_H

/* MODULE %ModuleName. */
#include "%@sdk@ModuleName.h" /* SDK and API used */
#include "%'ModuleName'config.h" /* configuration */

%-BW_CUSTOM_INCLUDE_START_H
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%if (%CPUDB_prph_has_feature(CPU,SDK_SUPPORT) = 'yes') %- TRUE/FALSE not defined for SDK projects
#include "PE_KSDK_Types.h" /* if this file is missing: have you added the Kinetis SDK component? */
%endif
%-
%-BW_CUSTOM_INCLUDE_END_H
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END

%define NofLedPixels 1
%:NofLedPixels=1
%:NofLedPixels*=64

#define %'ModuleName'%.NOF_LED_PIXELS                            %>40 (%'ModuleName'%.CONFIG_WIDTH*%'ModuleName'%.CONFIG_HEIGHT)
#define %'ModuleName'%.MEM_BUF_SIZE                              %>40 (%'ModuleName'%.NOF_LED_PIXELS*(%'ModuleName'%.CONFIG_PIXEL_NOF_BITS/8))

#if %'ModuleName'%.NOF_LED_PIXELS <= 255
  typedef uint8_t %'ModuleName'%.PixelCount; /*!< one byte is enough to hold a counter for all pixels */
#else
  typedef uint16_t %'ModuleName'%.PixelCount; /*!< one byte is enough to hold a counter for all pixels */
#endif

void NeoMatrix_GetLanePos(int16_t x, int16_t y, uint32_t *lane, uint32_t *pos);

/* the values below are used in MATRIX_Init() to configure the matrix.
 * See https://learn.adafruit.com/adafruit-neopixel-uberguide/neomatrix-library
 *  */
// These define the layout for a single 'unified' matrix (e.g. one made
// from NeoPixel strips, or a single NeoPixel shield), or for the pixels
// within each matrix of a tiled display (e.g. multiple NeoPixel shields).
#define NEO_MATRIX_TOP         0x00 // Pixel 0 is at top of matrix
#define NEO_MATRIX_BOTTOM      0x01 // Pixel 0 is at bottom of matrix
#define NEO_MATRIX_LEFT        0x00 // Pixel 0 is at left of matrix
#define NEO_MATRIX_RIGHT       0x02 // Pixel 0 is at right of matrix
#define NEO_MATRIX_CORNER      0x03 // Bitmask for pixel 0 matrix corner
#define NEO_MATRIX_ROWS        0x00 // Matrix is row major (horizontal): pixels are increasing in rows
#define NEO_MATRIX_COLUMNS     0x04 // Matrix is column major (vertical): pixels are increasing in columns
#define NEO_MATRIX_AXIS        0x04 // Bitmask for row/column layout
#define NEO_MATRIX_PROGRESSIVE 0x00 // Same pixel order across each line (otherwise ZIGZAG)
#define NEO_MATRIX_ZIGZAG      0x08 // Pixel order reverses between lines (otherwise Progressive)
#define NEO_MATRIX_SEQUENCE    0x08 // Bitmask for pixel line order

// These apply only to tiled displays (multiple matrices):
#define NEO_TILE_TOP           0x00 // First tile is at top of matrix
#define NEO_TILE_BOTTOM        0x10 // First tile is at bottom of matrix
#define NEO_TILE_LEFT          0x00 // First tile is at left of matrix
#define NEO_TILE_RIGHT         0x20 // First tile is at right of matrix
#define NEO_TILE_CORNER        0x30 // Bitmask for first tile corner
#define NEO_TILE_ROWS          0x00 // Tiles ordered in rows
#define NEO_TILE_COLUMNS       0x40 // Tiles ordered in columns
#define NEO_TILE_AXIS          0x40 // Bitmask for tile H/V orientation
#define NEO_TILE_PROGRESSIVE   0x00 // Same tile order across each line
#define NEO_TILE_ZIGZAG        0x80 // Tile order reverses between lines
#define NEO_TILE_SEQUENCE      0x80 // Bitmask for tile line order

%-STARTUSERTYPES - Do not make changes between lines (included this lines) marked with %-STARTUSERTYPES and %-ENDUSRTYPES

%-ENDUSRTYPES
%-BW_BEAN_CONSTANTS_START  - Do not make changes between lines (included this lines) marked with %-BW_BEAN_CONSTANTS_START and %-BW_BEAN_CONSTANTS_END
%- No constants defined in the BeanWizard for this bean
%-BW_BEAN_CONSTANTS_END
%-BW_CUSTOM_USERTYPE_START
%- Write your own types here ...
%-  Example:
%-    typedef int TMyInteger;
%-
typedef uint32_t %'ModuleName'%.PixelColor;    /* WS2812B has 24bits for a pixel */
typedef uint8_t %'ModuleName'%.PixelDim; /* one byte is enough to describe an x/y position */
extern uint8_t %'ModuleName'%.DisplayBuf[%'ModuleName'%.MEM_BUF_SIZE]; /* buffer for the display */

#define %'ModuleName'%.USE_NOF_COLOR  (3)

#if %'ModuleName'%.USE_NOF_COLOR==4
  #define %'ModuleName'%.MAKE_COLOR_RGB(r,g,b)     (((r)<<24)|((g)<<16)|((b)<<8))
  #define %'ModuleName'%.MAKE_COLOR_RGBW(r,g,b,w)  (((r)<<24)|((g)<<16)|((b)<<8)|(w))
#else /* 3 */
  #define %'ModuleName'%.MAKE_COLOR_RGB(r,g,b)     (((r)<<16)|((g)<<8)|(b))
  #define %'ModuleName'%.MAKE_COLOR_RGBW(r,g,b,w)  (((r)<<16)|((g)<<8)|(b))
#endif

#if %'ModuleName'%.USE_NOF_COLOR==4
  #define %'ModuleName'%.GET_COLOR_RED(color)     (((color)>>24)&0xff)
  #define %'ModuleName'%.GET_COLOR_GREEN(color)   (((color)>>16)&0xff)
  #define %'ModuleName'%.GET_COLOR_BLUE(color)    (((color)>>8)&0xff)
  #define %'ModuleName'%.GET_COLOR_WHITE(color)   ((color)&0xff)
#else
  #define %'ModuleName'%.GET_COLOR_RED(color)     (((color)>>16)&0xff)
  #define %'ModuleName'%.GET_COLOR_GREEN(color)   (((color)>>8)&0xff)
  #define %'ModuleName'%.GET_COLOR_BLUE(color)    ((color)&0xff)
#endif


#define %'ModuleName'%.PIXEL_ON             %'ModuleName'%.COLOR_WHITE /* value of a pixel if it is 'on' */
#define %'ModuleName'%.PIXEL_OFF            %'ModuleName'%.COLOR_BLACK /* value of a pixel if it is 'off' */
#define %'ModuleName'%.COLOR_PIXEL_SET      %'ModuleName'%.COLOR_WHITE /* color for a pixel set */
#define %'ModuleName'%.COLOR_PIXEL_CLR      %'ModuleName'%.COLOR_BLACK  /* color for a pixel cleared */
#define %'ModuleName'%.COLOR_BLACK          %'ModuleName'%.MAKE_COLOR_RGB(0,0,0)
#define %'ModuleName'%.COLOR_WHITE          %'ModuleName'%.MAKE_COLOR_RGB(0xff,0xff,0xff)
#define %'ModuleName'%.COLOR_RED            %'ModuleName'%.MAKE_COLOR_RGB(0xff,0,0)
#define %'ModuleName'%.COLOR_BRIGHT_RED     %'ModuleName'%.MAKE_COLOR_RGB(0xff,0x0f,0x37)
#define %'ModuleName'%.COLOR_DARK_RED       %'ModuleName'%.MAKE_COLOR_RGB(0x99,0x1A,0x00)
#define %'ModuleName'%.COLOR_GREEN          %'ModuleName'%.MAKE_COLOR_RGB(0,0xff,0)
#define %'ModuleName'%.COLOR_BRIGHT_GREEN   %'ModuleName'%.MAKE_COLOR_RGB(0x66,0xff,0)
#define %'ModuleName'%.COLOR_DARK_GREEN     %'ModuleName'%.MAKE_COLOR_RGB(0x01,0x32,0x20)
#define %'ModuleName'%.COLOR_BLUE           %'ModuleName'%.MAKE_COLOR_RGB(0,0,0xff)
#define %'ModuleName'%.COLOR_BRIGHT_BLUE    %'ModuleName'%.MAKE_COLOR_RGB(0x33,0,0xff)
#define %'ModuleName'%.COLOR_DARK_BLUE      %'ModuleName'%.MAKE_COLOR_RGB(0x17,0x1E,0x6C)
#define %'ModuleName'%.COLOR_YELLOW         %'ModuleName'%.MAKE_COLOR_RGB(0xff,0xff,0x00)
#define %'ModuleName'%.COLOR_BRIGHT_YELLOW  %'ModuleName'%.MAKE_COLOR_RGB(0xfd,0xfd,0x96)
#define %'ModuleName'%.COLOR_ORANGE         %'ModuleName'%.MAKE_COLOR_RGB(0xff,0xA5,0x00)
#define %'ModuleName'%.COLOR_GREY           %'ModuleName'%.MAKE_COLOR_RGB(0x80,0x80,0x80)
#define %'ModuleName'%.COLOR_BRIGHT_GREY    %'ModuleName'%.MAKE_COLOR_RGB(0xd3,0xd3,0xd3)

#define %'ModuleName'%.HW_WIDTH         %'ModuleName'%.CONFIG_WIDTH%>40 /* Logical display width in pixels */
#define %'ModuleName'%.HW_HEIGHT        %'ModuleName'%.CONFIG_HEIGHT%>40 /* Logical display height in pixels */
%if %Height <. %Width
#define %'ModuleName'%.HW_SHORTER_SIDE  %'ModuleName'%.CONFIG_HEIGHT%>40/* size of shorter display side in pixels */
#define %'ModuleName'%.HW_LONGER_SIDE   %'ModuleName'%.CONFIG_WIDTH%>40/* size of longer display side in pixels */
%else
#define %'ModuleName'%.HW_SHORTER_SIDE  %'ModuleName'%.CONFIG_WIDTH%>40/* size of shorter display side in pixels */
#define %'ModuleName'%.HW_LONGER_SIDE   %'ModuleName'%.CONFIG_HEIGHT%>40/* size of longer display side in pixels */
%endif

typedef enum {
  %'ModuleName'%.ORIENTATION_PORTRAIT    = 0,
  %'ModuleName'%.ORIENTATION_PORTRAIT180 = 1,
  %'ModuleName'%.ORIENTATION_LANDSCAPE   = 2,
  %'ModuleName'%.ORIENTATION_LANDSCAPE180= 3
} %'ModuleName'%.DisplayOrientation;

%-BW_CUSTOM_USERTYPE_END

%-BW_DEFINITION_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN UpdateFull
%ifdef UpdateFull
void %'ModuleName'%.%UpdateFull(void);
%include Common\NEOmatrixUpdateFull.Inc

%endif %- UpdateFull
%-BW_METHOD_END UpdateFull
%-************************************************************************************************************
%-BW_METHOD_BEGIN UpdateRegion
%ifdef UpdateRegion
void %'ModuleName'%.%UpdateRegion(%'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y, %'ModuleName'_PixelDim w, %'ModuleName'_PixelDim h);
%define! Parx
%define! Pary
%define! Parw
%define! Parh
%include Common\NEOmatrixUpdateRegion.Inc

%endif %- UpdateRegion
%-BW_METHOD_END UpdateRegion
%-************************************************************************************************************
%-BW_METHOD_BEGIN Enable
%ifdef Enable
void %'ModuleName'%.%Enable(void);
%include Common\NEOmatrixEnable.Inc

%endif %- Enable
%-BW_METHOD_END Enable
%-************************************************************************************************************
%-BW_METHOD_BEGIN Disable
%ifdef Disable
void %'ModuleName'%.%Disable(void);
%include Common\NEOmatrixDisable.Inc

%endif %- Disable
%-BW_METHOD_END Disable
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetDisplayOrientation
%ifdef GetDisplayOrientation
%'ModuleName'_DisplayOrientation %'ModuleName'%.%GetDisplayOrientation(void);
%define! RetVal
%include Common\NEOmatrixGetDisplayOrientation.Inc

%endif %- GetDisplayOrientation
%-BW_METHOD_END GetDisplayOrientation
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetWidth
%ifdef GetWidth
%'ModuleName'_PixelDim %'ModuleName'%.%GetWidth(void);
%define! RetVal
%include Common\NEOmatrixGetWidth.Inc

%endif %- GetWidth
%-BW_METHOD_END GetWidth
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetHeight
%ifdef GetHeight
%'ModuleName'_PixelDim %'ModuleName'%.%GetHeight(void);
%define! RetVal
%include Common\NEOmatrixGetHeight.Inc

%endif %- GetHeight
%-BW_METHOD_END GetHeight
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetDisplayOrientation
%ifdef SetDisplayOrientation
void %'ModuleName'%.%SetDisplayOrientation(%'ModuleName'_DisplayOrientation newOrientation);
%define! ParnewOrientation
%include Common\NEOmatrixSetDisplayOrientation.Inc

%endif %- SetDisplayOrientation
%-BW_METHOD_END SetDisplayOrientation
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetShorterSide
%ifdef GetShorterSide
%'ModuleName'_PixelDim %'ModuleName'%.%GetShorterSide(void);
%define! RetVal
%include Common\NEOmatrixGetShorterSide.Inc

%endif %- GetShorterSide
%-BW_METHOD_END GetShorterSide
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetLongerSide
%ifdef GetLongerSide
%'ModuleName'_PixelDim %'ModuleName'%.%GetLongerSide(void);
%define! RetVal
%include Common\NEOmatrixGetLongerSide.Inc

%endif %- GetLongerSide
%-BW_METHOD_END GetLongerSide
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetLCD
%ifdef GetLCD
void %'ModuleName'%.%GetLCD(void);
%include Common\NEOmatrixGetLCD.Inc

%endif %- GetLCD
%-BW_METHOD_END GetLCD
%-************************************************************************************************************
%-BW_METHOD_BEGIN GiveLCD
%ifdef GiveLCD
void %'ModuleName'%.%GiveLCD(void);
%include Common\NEOmatrixGiveLCD.Inc

%endif %- GiveLCD
%-BW_METHOD_END GiveLCD
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetPixel
%ifdef SetPixel
uint8_t %'ModuleName'%.%SetPixel(%'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y);
%define! Parx
%define! Pary
%define! RetVal
%include Common\NEOmatrixSetPixel.Inc

%endif %- SetPixel
%-BW_METHOD_END SetPixel
%-************************************************************************************************************
%-BW_METHOD_BEGIN ClrPixel
%ifdef ClrPixel
uint8_t %'ModuleName'%.%ClrPixel(%'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y);
%define! Parx
%define! Pary
%define! RetVal
%include Common\NEOmatrixClrPixel.Inc

%endif %- ClrPixel
%-BW_METHOD_END ClrPixel
%-************************************************************************************************************
%-BW_METHOD_BEGIN PutPixel
%ifdef PutPixel
void %'ModuleName'%.%PutPixel(%'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y, %'ModuleName'_PixelColor color);
%define! Parx
%define! Pary
%define! Parcolor
%include Common\NEOmatrixPutPixel.Inc

%endif %- PutPixel
%-BW_METHOD_END PutPixel
%-************************************************************************************************************
%-BW_METHOD_BEGIN Deinit
%ifdef Deinit
void %'ModuleName'%.%Deinit(void);
%include Common\NEOmatrixDeinit.Inc

%endif %- Deinit
%-BW_METHOD_END Deinit
%-************************************************************************************************************
%-BW_METHOD_BEGIN Init
%ifdef Init
void %'ModuleName'%.%Init(void);
%include Common\NEOmatrixInit.Inc

%endif %- Init
%-BW_METHOD_END Init
%-************************************************************************************************************
%-BW_METHOD_BEGIN NegPixel
%ifdef NegPixel
uint8_t %'ModuleName'%.%NegPixel(%'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y);
%define! Parx
%define! Pary
%define! RetVal
%include Common\NEOmatrixNegPixel.Inc

%endif %- NegPixel
%-BW_METHOD_END NegPixel
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetPixel
%ifdef GetPixel
%'ModuleName'_PixelColor %'ModuleName'%.%GetPixel(%'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y);
%define! Parx
%define! Pary
%define! RetVal
%include Common\NEOmatrixGetPixel.Inc

%endif %- GetPixel
%-BW_METHOD_END GetPixel
%-************************************************************************************************************
%-BW_METHOD_BEGIN ClearBuffer
%ifdef ClearBuffer
void %'ModuleName'%.%ClearBuffer(%'ModuleName'_PixelColor color);
%define! Parcolor
%include Common\NEOmatrixClearBuffer.Inc

%endif %- ClearBuffer
%-BW_METHOD_END ClearBuffer
%-BW_DEFINITION_END
/* END %ModuleName. */

#endif
/* ifndef __%'ModuleName'_H */
%include Common\Header.End
%-
%-BW_EVENT_DEFINITION_START
%-BW_EVENT_DEFINITION_END
%IMPLEMENTATION
%define! Settings Common\NEOmatrixSettings.Inc
%define! Abstract Common\NEOmatrixAbstract.Inc
%include Common\Header.C

/* MODULE %ModuleName. */

%for var from EventModules
#include "%var.h"
%endfor
#include "%'ModuleName'.h"
%-BW_CUSTOM_INCLUDE_START_M
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%-BW_CUSTOM_INCLUDE_END_M

%-BW_CUSTOM_VARIABLE_START
%- Write your static variables here
%-   Example:
%-     static int counter1;
%-     int %'ModuleName'%.counter2;
%-
uint8_t %'ModuleName'%.DisplayBuf[%'ModuleName'%.MEM_BUF_SIZE]; /* buffer for the display */
%if defined(Enable) | defined(Disable)
static bool %'ModuleName'%.DisplayEnabled = TRUE; /* if we allow refresh of the display */
%endif

/* prototype for function in user code: */
uint8_t NEO_SetPixelColor(uint32_t lane, uint32_t pos, %'ModuleName'_PixelColor color);
uint8_t NEO_GetPixelColor(uint32_t lane, uint32_t pos, %'ModuleName'_PixelColor *color);

static %'ModuleName'%.DisplayOrientation %'ModuleName'%.currOrientation = %'ModuleName'%.CONFIG_DEFAULT_ORIENTATION;

/*
  NeoMatrix_drawPixel() Method written by Adafruit, copyrigt notice below:

  Written by Phil Burgess / Paint Your Dragon for Adafruit Industries.

  Adafruit invests time and resources providing this open source code,
  please support Adafruit and open-source hardware by purchasing products
  from Adafruit!

  -------------------------------------------------------------------------
  This file is part of the Adafruit NeoMatrix library.

  NeoMatrix is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as
  published by the Free Software Foundation, either version 3 of
  the License, or (at your option) any later version.

  NeoMatrix is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public
  License along with NeoMatrix.  If not, see
  <http://www.gnu.org/licenses/>.
  -------------------------------------------------------------------------*/
typedef struct {
  uint8_t type;
  uint8_t matrixWidth, matrixHeight, tilesX, tilesY;
  uint16_t (*remapFn)(uint16_t x, uint16_t y);
  uint32_t passThruColor;
  bool  passThruFlag;
} MATRIX_Matrix;

static MATRIX_Matrix matrix;

void NeoMatrix_GetLanePos(int16_t x, int16_t y, uint32_t *lane, uint32_t *pos) {
  #define swap(a, b) {uint16_t swapTmp; swapTmp=a; a=b; b=swapTmp;}

  if((x < 0) || (y < 0) || (x >= %'ModuleName'%.%GetWidth()) || (y >= %'ModuleName'%.%GetHeight())) {
    return;
  }
  int tileOffset = 0, pixelOffset, val;

  if(matrix.remapFn) { // Custom X/Y remapping function
    pixelOffset = (*matrix.remapFn)(x, y);
  } else {      // Standard single matrix or tiled matrices
    uint8_t  corner = matrix.type & NEO_MATRIX_CORNER;
    uint16_t minor, major, majorScale;

    if(matrix.tilesX) { // Tiled display, multiple matrices
      uint16_t tile;

      minor = x / matrix.matrixWidth;            // Tile # X/Y; presume row major to
      major = y / matrix.matrixHeight,           // start (will swap later if needed)
      x     = x - (minor * matrix.matrixWidth);  // Pixel X/Y within tile
      y     = y - (major * matrix.matrixHeight); // (-* is less math than modulo)

      // Determine corner of entry, flip axes if needed
      if(matrix.type & NEO_TILE_RIGHT)  {
        minor = matrix.tilesX - 1 - minor;
      }
      if(matrix.type & NEO_TILE_BOTTOM) {
        major = matrix.tilesY - 1 - major;
      }
      // Determine actual major axis of tiling
      if((matrix.type & NEO_TILE_AXIS) == NEO_TILE_ROWS) {
        majorScale = matrix.tilesX;
      } else {
        swap(major, minor);
        majorScale = matrix.tilesY;
      }

      // Determine tile number
      if((matrix.type & NEO_TILE_SEQUENCE) == NEO_TILE_PROGRESSIVE) {
        // All tiles in same order
        tile = major * majorScale + minor;
      } else {
        // Zigzag; alternate rows change direction.  On these rows,
        // this also flips the starting corner of the matrix for the
        // pixel math later.
        if(major & 1) {
          corner ^= NEO_MATRIX_CORNER;
          tile = (major + 1) * majorScale - 1 - minor;
        } else {
          tile =  major      * majorScale     + minor;
        }
      }
      // Index of first pixel in tile
      tileOffset = tile * matrix.matrixWidth * matrix.matrixHeight;
    } // else no tiling (handle as single tile)
    // Find pixel number within tile
    minor = x; // Presume row major to start (will swap later if needed)
    major = y;

    // Determine corner of entry, flip axes if needed
    if(corner & NEO_MATRIX_RIGHT)  {
      minor = matrix.matrixWidth  - 1 - minor;
    }
    if(corner & NEO_MATRIX_BOTTOM) {
      major = matrix.matrixHeight - 1 - major;
    }
    // Determine actual major axis of matrix
    if((matrix.type & NEO_MATRIX_AXIS) == NEO_MATRIX_ROWS) {
      majorScale = matrix.matrixWidth;
    } else {
      swap(major, minor);
      majorScale = matrix.matrixHeight;
    }

    // Determine pixel number within tile/matrix
    if((matrix.type & NEO_MATRIX_SEQUENCE) == NEO_MATRIX_PROGRESSIVE) {
      // All lines in same order
      pixelOffset = major * majorScale + minor;
    } else {
      // Zigzag; alternate rows change direction.
      if(major & 1) {
        pixelOffset = (major + 1) * majorScale - 1 - minor;
      } else {
        pixelOffset =  major      * majorScale     + minor;
      }
    }
  }
  val = tileOffset+pixelOffset; /* overall index in matrix */

  *lane = val/%'ModuleName'%.NOF_LED_PIXELS;
  *pos = val%%%'ModuleName'%.NOF_LED_PIXELS;
}

%-BW_CUSTOM_VARIABLE_END
%-BW_INTERN_METHOD_DECL_START
%- List of internal methods headers
%-BW_INTERN_METHOD_DECL_END
%-BW_IMPLEMENT_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN UpdateFull
%ifdef UpdateFull
%include Common\NEOmatrixUpdateFull.Inc
void %'ModuleName'%.%UpdateFull(void)
{
%if defined(Enable) | defined(Disable)
  if (!%'ModuleName'%.DisplayEnabled) {
    return;
  }
%endif
}

%endif %- UpdateFull
%-BW_METHOD_END UpdateFull
%-************************************************************************************************************
%-BW_METHOD_BEGIN UpdateRegion
%ifdef UpdateRegion
%define! Parx
%define! Pary
%define! Parw
%define! Parh
%include Common\NEOmatrixUpdateRegion.Inc
void %'ModuleName'%.%UpdateRegion(%'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y, %'ModuleName'_PixelDim w, %'ModuleName'_PixelDim h)
{
  (void)x; (void)y; (void)w; (void)h;
  %'ModuleName'%.%UpdateFull();
}

%endif %- UpdateRegion
%-BW_METHOD_END UpdateRegion
%-************************************************************************************************************
%-BW_METHOD_BEGIN Enable
%ifdef Enable
%include Common\NEOmatrixEnable.Inc
void %'ModuleName'%.%Enable(void)
{
  %'ModuleName'%.DisplayEnabled = TRUE;
}

%endif %- Enable
%-BW_METHOD_END Enable
%-************************************************************************************************************
%-BW_METHOD_BEGIN Disable
%ifdef Disable
%include Common\NEOmatrixDisable.Inc
void %'ModuleName'%.%Disable(void)
{
  %'ModuleName'%.DisplayEnabled = FALSE;
}

%endif %- Disable
%-BW_METHOD_END Disable
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetDisplayOrientation
%ifdef GetDisplayOrientation
%define! RetVal
%include Common\NEOmatrixGetDisplayOrientation.Inc
%'ModuleName'_DisplayOrientation %'ModuleName'%.%GetDisplayOrientation(void)
{
  return %'ModuleName'%.currOrientation;
}

%endif %- GetDisplayOrientation
%-BW_METHOD_END GetDisplayOrientation
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetWidth
%ifdef GetWidth
%define! RetVal
%include Common\NEOmatrixGetWidth.Inc
%'ModuleName'_PixelDim %'ModuleName'%.%GetWidth(void)
{
  switch(%'ModuleName'%.currOrientation) {
    case %'ModuleName'%.ORIENTATION_PORTRAIT:
    case %'ModuleName'%.ORIENTATION_PORTRAIT180:
      return %'ModuleName'%.HW_SHORTER_SIDE;
    case %'ModuleName'%.ORIENTATION_LANDSCAPE:
    case %'ModuleName'%.ORIENTATION_LANDSCAPE180:
      return %'ModuleName'%.HW_LONGER_SIDE;
    default:
      break;
  } /* switch */
  return 0; /* error case */
}

%endif %- GetWidth
%-BW_METHOD_END GetWidth
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetHeight
%ifdef GetHeight
%define! RetVal
%include Common\NEOmatrixGetHeight.Inc
%'ModuleName'_PixelDim %'ModuleName'%.%GetHeight(void)
{
  switch(%'ModuleName'%.currOrientation) {
    case %'ModuleName'%.ORIENTATION_PORTRAIT:
    case %'ModuleName'%.ORIENTATION_PORTRAIT180:
      return %'ModuleName'%.HW_LONGER_SIDE;
    case %'ModuleName'%.ORIENTATION_LANDSCAPE:
    case %'ModuleName'%.ORIENTATION_LANDSCAPE180:
      return %'ModuleName'%.HW_SHORTER_SIDE;
    default:
      break;
  } /* switch */
  return 0; /* error case */
}

%endif %- GetHeight
%-BW_METHOD_END GetHeight
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetShorterSide
%ifdef GetShorterSide
%define! RetVal
%include Common\NEOmatrixGetShorterSide.Inc
%'ModuleName'_PixelDim %'ModuleName'%.%GetShorterSide(void)
{
  return %'ModuleName'%.HW_SHORTER_SIDE;
}

%endif %- GetShorterSide
%-BW_METHOD_END GetShorterSide
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetLongerSide
%ifdef GetLongerSide
%define! RetVal
%include Common\NEOmatrixGetLongerSide.Inc
%'ModuleName'_PixelDim %'ModuleName'%.%GetLongerSide(void)
{
  return %'ModuleName'%.HW_LONGER_SIDE;
}

%endif %- GetLongerSide
%-BW_METHOD_END GetLongerSide
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetDisplayOrientation
%ifdef SetDisplayOrientation
%define! ParnewOrientation
%include Common\NEOmatrixSetDisplayOrientation.Inc
void %'ModuleName'%.%SetDisplayOrientation(%'ModuleName'_DisplayOrientation newOrientation)
{
  %'ModuleName'%.currOrientation = newOrientation;
  /* note: the x/y first pixel (0,0) is always on top left, with x to the right and y to the bottom */
  /* see https://learn.adafruit.com/adafruit-neopixel-uberguide/neomatrix-library */
  /* HARDWARE wiring: Orientation for landscape is DIN first pixel is top-left, with x going to the right and y going to the bottom,
     next module is on the right */
  switch(%'ModuleName'%.currOrientation) {
    default:
    case %'ModuleName'%.ORIENTATION_PORTRAIT:
      matrix.type =
        NEO_MATRIX_TOP  // corner, first pixel: either NEO_MATRIX_TOP or NEO_MATRIX_BOTTOM
      + NEO_MATRIX_RIGHT // corner, first pixel: either NEO_MATRIX_TOP or NEO_MATRIX_BOTTOM
      + NEO_MATRIX_COLUMNS // axis, pixels are organized in  NEO_MATRIX_ROWS or NEO_MATRIX_COLUMNS
      + NEO_MATRIX_PROGRESSIVE // sequence, pixels either change side NEO_MATRIX_PROGRESSIVE or NEO_MATRIX_ZIGZAG
      /* tile configuration */
      + NEO_TILE_TOP    // corner, position of first tile: NEO_TILE_TOP or NEO_TILE_BOTTOM
      + NEO_TILE_RIGHT   // corner, position of first tile: NEO_TILE_LEFT or NEO_TILE_RIGHT
      + NEO_TILE_COLUMNS   // axis, organization of tiles: NEO_TILE_ROWS or NEO_TILE_COLUMNS
      + NEO_TILE_PROGRESSIVE // sequence, organization of tiles: NEO_TILE_PROGRESSIVE or NEO_TILE_ZIGZAG
      ;
      matrix.tilesX = %'ModuleName'%.HW_SHORTER_SIDE/8; /* number of tiles in X direction */
      matrix.tilesY = %'ModuleName'%.HW_LONGER_SIDE/8; /* number of tiles in Y direction */
      break;
    case %'ModuleName'%.ORIENTATION_PORTRAIT180:
      matrix.type =
        NEO_MATRIX_BOTTOM  // corner, first pixel: either NEO_MATRIX_TOP or NEO_MATRIX_BOTTOM
      + NEO_MATRIX_LEFT // corner, first pixel: either NEO_MATRIX_TOP or NEO_MATRIX_BOTTOM
      + NEO_MATRIX_COLUMNS // axis, pixels are organized in  NEO_MATRIX_ROWS or NEO_MATRIX_COLUMNS
      + NEO_MATRIX_PROGRESSIVE // sequence, pixels either change side NEO_MATRIX_PROGRESSIVE or NEO_MATRIX_ZIGZAG
      /* tile configuration */
      + NEO_TILE_BOTTOM    // corner, position of first tile: NEO_TILE_TOP or NEO_TILE_BOTTOM
      + NEO_TILE_LEFT   // corner, position of first tile: NEO_TILE_LEFT or NEO_TILE_RIGHT
      + NEO_TILE_COLUMNS   // axis, organization of tiles: NEO_TILE_ROWS or NEO_TILE_COLUMNS
      + NEO_TILE_PROGRESSIVE // sequence, organization of tiles: NEO_TILE_PROGRESSIVE or NEO_TILE_ZIGZAG
      ;
      matrix.tilesX = %'ModuleName'%.HW_SHORTER_SIDE/8; /* number of tiles in X direction */
      matrix.tilesY = %'ModuleName'%.HW_LONGER_SIDE/8; /* number of tiles in Y direction */
      break;
    case %'ModuleName'%.ORIENTATION_LANDSCAPE:
      matrix.type =
        NEO_MATRIX_TOP  // corner, first pixel: either NEO_MATRIX_TOP or NEO_MATRIX_BOTTOM
      + NEO_MATRIX_LEFT // corner, first pixel: either NEO_MATRIX_TOP or NEO_MATRIX_BOTTOM
      + NEO_MATRIX_ROWS // axis, pixels are organized in  NEO_MATRIX_ROWS or NEO_MATRIX_COLUMNS
      + NEO_MATRIX_PROGRESSIVE // sequence, pixels either change side NEO_MATRIX_PROGRESSIVE or NEO_MATRIX_ZIGZAG
      /* tile configuration */
      + NEO_TILE_TOP    // corner, position of first tile: NEO_TILE_TOP or NEO_TILE_BOTTOM
      + NEO_TILE_LEFT   // corner, position of first tile: NEO_TILE_LEFT or NEO_TILE_RIGHT
      + NEO_TILE_ROWS   // axis, organization of tiles: NEO_TILE_ROWS or NEO_TILE_COLUMNS
      + NEO_TILE_PROGRESSIVE // sequence, organization of tiles: NEO_TILE_PROGRESSIVE or NEO_TILE_ZIGZAG
      ;
      matrix.tilesX = %'ModuleName'%.HW_LONGER_SIDE/8; /* number of tiles in X direction */
      matrix.tilesY = %'ModuleName'%.HW_SHORTER_SIDE/8; /* number of tiles in Y direction */
      break;
    case %'ModuleName'%.ORIENTATION_LANDSCAPE180:
      matrix.type =
        NEO_MATRIX_BOTTOM  // corner, first pixel: either NEO_MATRIX_TOP or NEO_MATRIX_BOTTOM
      + NEO_MATRIX_RIGHT // corner, first pixel: either NEO_MATRIX_TOP or NEO_MATRIX_BOTTOM
      + NEO_MATRIX_ROWS // axis, pixels are organized in  NEO_MATRIX_ROWS or NEO_MATRIX_COLUMNS
      + NEO_MATRIX_PROGRESSIVE // sequence, pixels either change side NEO_MATRIX_PROGRESSIVE or NEO_MATRIX_ZIGZAG
      /* tile configuration */
      + NEO_TILE_BOTTOM    // corner, position of first tile: NEO_TILE_TOP or NEO_TILE_BOTTOM
      + NEO_TILE_RIGHT   // corner, position of first tile: NEO_TILE_LEFT or NEO_TILE_RIGHT
      + NEO_TILE_ROWS   // axis, organization of tiles: NEO_TILE_ROWS or NEO_TILE_COLUMNS
      + NEO_TILE_PROGRESSIVE // sequence, organization of tiles: NEO_TILE_PROGRESSIVE or NEO_TILE_ZIGZAG
      ;
      matrix.tilesX = %'ModuleName'%.HW_LONGER_SIDE/8; /* number of tiles in X direction */
      matrix.tilesY = %'ModuleName'%.HW_SHORTER_SIDE/8; /* number of tiles in Y direction */
      break;
  } /* switch */
}

%endif %- SetDisplayOrientation
%-BW_METHOD_END SetDisplayOrientation
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetLCD
%ifdef GetLCD
%include Common\NEOmatrixGetLCD.Inc
void %'ModuleName'%.%GetLCD(void)
{
  /* not implemented yet */
}

%endif %- GetLCD
%-BW_METHOD_END GetLCD
%-************************************************************************************************************
%-BW_METHOD_BEGIN GiveLCD
%ifdef GiveLCD
%include Common\NEOmatrixGiveLCD.Inc
void %'ModuleName'%.%GiveLCD(void)
{
  /* not implemented yet */
}

%endif %- GiveLCD
%-BW_METHOD_END GiveLCD
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetPixel
%ifdef SetPixel
%define! Parx
%define! Pary
%define! RetVal
%include Common\NEOmatrixSetPixel.Inc
uint8_t %'ModuleName'%.%SetPixel(%'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y)
{
  uint32_t lane, pos;

  NeoMatrix_GetLanePos(x, y, &lane, &pos);
  return NEO_SetPixelColor(lane, pos, %'ModuleName'%.COLOR_PIXEL_SET);
}

%endif %- SetPixel
%-BW_METHOD_END SetPixel
%-************************************************************************************************************
%-BW_METHOD_BEGIN ClrPixel
%ifdef ClrPixel
%define! Parx
%define! Pary
%define! RetVal
%include Common\NEOmatrixClrPixel.Inc
uint8_t %'ModuleName'%.%ClrPixel(%'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y)
{
  uint32_t lane, pos;

  NeoMatrix_GetLanePos(x, y, &lane, &pos);
  return NEO_SetPixelColor(lane, pos, %'ModuleName'%.COLOR_PIXEL_CLR);
}

%endif %- ClrPixel
%-BW_METHOD_END ClrPixel
%-************************************************************************************************************
%-BW_METHOD_BEGIN NegPixel
%ifdef NegPixel
%define! Parx
%define! Pary
%define! RetVal
%include Common\NEOmatrixNegPixel.Inc
uint8_t %'ModuleName'%.%NegPixel(%'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y)
{
  uint32_t lane, pos;
  uint8_t res;
  uint32_t color;

  NeoMatrix_GetLanePos(x, y, &lane, &pos);
  res = NEO_GetPixelColor(lane, pos, &color);
  if (res!=ERR_OK) {
    return res;
  }
  return NEO_SetPixelColor(lane, pos, ~color);
}

%endif %- NegPixel
%-BW_METHOD_END NegPixel
%-************************************************************************************************************
%-BW_METHOD_BEGIN PutPixel
%ifdef PutPixel
%define! Parx
%define! Pary
%define! Parcolor
%include Common\NEOmatrixPutPixel.Inc
void %'ModuleName'%.%PutPixel(%'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y, %'ModuleName'_PixelColor color)
{
  uint32_t lane, pos;

  NeoMatrix_GetLanePos(x, y, &lane, &pos);
  NEO_SetPixelColor(lane, pos, color);
}

%endif %- PutPixel
%-BW_METHOD_END PutPixel
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetPixel
%ifdef GetPixel
%define! Parx
%define! Pary
%define! RetVal
%include Common\NEOmatrixGetPixel.Inc
%'ModuleName'_PixelColor %'ModuleName'%.%GetPixel(%'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y)
{
  uint32_t lane, pos;
  uint32_t color;

  NeoMatrix_GetLanePos(x, y, &lane, &pos);
  if (NEO_GetPixelColor(lane, pos, &color)==ERR_OK) {
    return 0;
  }
  return color;
}

%endif %- GetPixel
%-BW_METHOD_END GetPixel
%-************************************************************************************************************
%-BW_METHOD_BEGIN Deinit
%ifdef Deinit
%include Common\NEOmatrixDeinit.Inc
void %'ModuleName'%.%Deinit(void)
{
  /* noting to do */
}

%endif %- Deinit
%-BW_METHOD_END Deinit
%-************************************************************************************************************
%-BW_METHOD_BEGIN Init
%ifdef Init
%include Common\NEOmatrixInit.Inc
void %'ModuleName'%.%Init(void)
{
  matrix.matrixWidth = 8; /* size of *each* matrix */
  matrix.matrixHeight = 8; /* size of *each* matrix */
  matrix.remapFn = NULL; /* remapping function */
  matrix.passThruColor = 0;
  matrix.passThruFlag = FALSE;
  %'ModuleName'%.%SetDisplayOrientation(%'ModuleName'%.CONFIG_DEFAULT_ORIENTATION);
}

%endif %- Init
%-BW_METHOD_END Init
%-************************************************************************************************************
%-BW_METHOD_BEGIN ClearBuffer
%ifdef ClearBuffer
%define! Parcolor
%include Common\NEOmatrixClearBuffer.Inc
void %'ModuleName'%.%ClearBuffer(%'ModuleName'_PixelColor color)
{
  (void)color;
}

%endif %- ClearBuffer
%-BW_METHOD_END ClearBuffer
%-BW_IMPLEMENT_END
/* END %ModuleName. */

%include Common\Header.End
%-
%-
%-BW_EVENT_IMPLEMENT_START
%-BW_EVENT_IMPLEMENT_END
%INITIALIZATION
%CODE_BEGIN
%'ModuleName'%.%Init(); /* ### %DeviceType "%DeviceName" init code ... */
%CODE_END
%ENABLE
%CODE_BEGIN
%CODE_END
%-
%else %- Language (& Compiler)
  %error^ This bean is not implemented in selected language & compiler !
%endif %- Language (& Compiler)
%DEBUG
%ALL_SYMBOLS
%-
%-----------------------------------------------------------------------------------------
%if defined(sdk) & %@sdk@ConfigFilesFolderName <> ""
  %define  ConfigSrcDirFolder %%@sdk@ConfigFilesFolderName/
%else
  %define  ConfigSrcDirFolder
%endif
%----------------------------
%FILE %'DirRel_Code'%'ConfigSrcDirFolder'%'ModuleName'config.h
#ifndef __%'ModuleName'_CONFIG_H
#define __%'ModuleName'_CONFIG_H

#ifndef %'ModuleName'%.CONFIG_PIXEL_NOF_BITS
  #define %'ModuleName'%.CONFIG_PIXEL_NOF_BITS                   %>40 (24)
    /*!< number of bits per pixel */
#endif

#ifndef %'ModuleName'%.CONFIG_WIDTH
  #define %'ModuleName'%.CONFIG_WIDTH                            %>40 (%Width)
    /*!< number of pixels in x direction */
#endif

#ifndef %'ModuleName'%.CONFIG_HEIGHT
  #define %'ModuleName'%.CONFIG_HEIGHT                           %>40 (%Height)
    /*!< number of pixels in y direction */
#endif

#ifndef %'ModuleName'%.CONFIG_DEFAULT_ORIENTATION
  #define %'ModuleName'%.CONFIG_DEFAULT_ORIENTATION              %>40 (%'ModuleName'%.ORIENTATION_LANDSCAPE)
    /*!< number of pixels in y direction */
#endif

#endif /* __%'ModuleName'_CONFIG_H */
%-----------------------------------------------------------------------------------------
