%-Driver generated by the Bean Wizard
%-
%- WARNING !
%-
%- Do not make changes to these lines (if you make some changes, you damage this driver)
%- which begins with:
%-
%-  %-STARTUSERTYPES
%-  %-ENDUSRTYPES
%-  /* END %ModuleName. */
%-  /* MODULE %ModuleName. */
%-  %-INTERNAL_METHOD_BEG
%-  %-INTERNAL_METHOD_END
%-  %-INHERITED_EVENT_BEGIN
%-  %-INHERITED_EVENT_END
%-  %-BW_METHOD_BEGIN
%-  %-BW_METHOD_END
%-  %-BW_DEFINITION_START
%-  %-BW_DEFINITION_END
%-  %-BW_IMPLEMENT_START
%-  %-BW_IMPLEMENT_END
%-  %-BW_EVENT_DEFINITION_START
%-  %-BW_EVENT_DEFINITION_END
%-  %-BW_EVENT_IMPLEMENT_START
%-  %-BW_EVENT_IMPLEMENT_END
%-  %-BW_METHOD_MACROS_START
%-  %-BW_METHOD_MACROS_END
%-  %-BW_SECTIONS_INSERT
%-  %-BW_INTERN_COMMENTS_START
%-  %-BW_INTERN_COMMENTS_END
%-  %-BW_BEAN_CONSTANTS_START
%-  %-BW_BEAN_CONSTANTS_END
%-
%-
%- These lines are not comments, but they are necessary for Bean Wizard
%- If you change these lines, Bean Wizard will not be responsible for loosing or damaging your code!
%-
%-
%- readyCPU ...
%- readyDEVICE ...
%-
%define DriverAuthor  Author
%define DriverVersion 01.00
%define DriverDate    06.11.2008
%-
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END
%-
%-BW_INTERN_COMMENTS_START
%- List of descriptions of internal methods
%-BW_INTERN_COMMENTS_END
%-
%-BW_SECTIONS_INSERT
%if Language='ANSIC'
%-
%-
%INTERFACE
%define! Settings Common\NEOmatrixSettings.Inc
%define! Abstract Common\NEOmatrixAbstract.Inc
%include Common\Header.h

%if (defined(PEversionDecimal) && (PEversionDecimal <=0 '1283')) %- this is only supported with MCU 10.3
%if (CPUfamily = "Kinetis")
/* PEversionDecimal version: %PEversionDecimal (1283 for MCU10.3) */
#include "PE_LDD.h" /* hack for Processor Expert (e.g. in MCU10.3) and LDD: PE_LDD.h includes at the end all shared modules, causing a recursive header file include conflict */
%endif
%endif

#ifndef __%'ModuleName'_H
#define __%'ModuleName'_H

/* MODULE %ModuleName. */
#include "%@sdk@ModuleName.h" /* SDK and API used */
#include "%'ModuleName'config.h" /* configuration */

%-BW_CUSTOM_INCLUDE_START_H
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%if (%CPUDB_prph_has_feature(CPU,SDK_SUPPORT) = 'yes') %- TRUE/FALSE not defined for SDK projects
#include "PE_KSDK_Types.h" /* if this file is missing: have you added the Kinetis SDK component? */
%endif
%-
%-BW_CUSTOM_INCLUDE_END_H
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END

%define NofLedPixels 1
%:NofLedPixels=1
%:NofLedPixels*=64

#define %'ModuleName'%.NOF_LED_PIXELS                            %>40 (%'ModuleName'%.CONFIG_WIDTH*%'ModuleName'%.CONFIG_HEIGHT)
#define %'ModuleName'%.MEM_BUF_SIZE                              %>40 (%'ModuleName'%.NOF_LED_PIXELS*(%'ModuleName'%.CONFIG_PIXEL_NOF_BITS/8))

#if %'ModuleName'%.NOF_LED_PIXELS <= 255
  typedef uint8_t %'ModuleName'%.PixelCount; /*!< one byte is enough to hold a counter for all pixels */
#else
  typedef uint16_t %'ModuleName'%.PixelCount; /*!< one byte is enough to hold a counter for all pixels */
#endif

/* the values below are used in MATRIX_Init() to configure the matrix.
 * See https://learn.adafruit.com/adafruit-neopixel-uberguide/neomatrix-library
 *  */
// These define the layout for a single 'unified' matrix (e.g. one made
// from NeoPixel strips, or a single NeoPixel shield), or for the pixels
// within each matrix of a tiled display (e.g. multiple NeoPixel shields).
#define NEO_MATRIX_TOP         0x00 // Pixel 0 is at top of matrix
#define NEO_MATRIX_BOTTOM      0x01 // Pixel 0 is at bottom of matrix
#define NEO_MATRIX_LEFT        0x00 // Pixel 0 is at left of matrix
#define NEO_MATRIX_RIGHT       0x02 // Pixel 0 is at right of matrix
#define NEO_MATRIX_CORNER      0x03 // Bitmask for pixel 0 matrix corner
#define NEO_MATRIX_ROWS        0x00 // Matrix is row major (horizontal): pixels are increasing in rows
#define NEO_MATRIX_COLUMNS     0x04 // Matrix is column major (vertical): pixels are increasing in columns
#define NEO_MATRIX_AXIS        0x04 // Bitmask for row/column layout
#define NEO_MATRIX_PROGRESSIVE 0x00 // Same pixel order across each line (otherwise ZIGZAG)
#define NEO_MATRIX_ZIGZAG      0x08 // Pixel order reverses between lines (otherwise Progressive)
#define NEO_MATRIX_SEQUENCE    0x08 // Bitmask for pixel line order

// These apply only to tiled displays (multiple matrices):
#define NEO_TILE_TOP           0x00 // First tile is at top of matrix
#define NEO_TILE_BOTTOM        0x10 // First tile is at bottom of matrix
#define NEO_TILE_LEFT          0x00 // First tile is at left of matrix
#define NEO_TILE_RIGHT         0x20 // First tile is at right of matrix
#define NEO_TILE_CORNER        0x30 // Bitmask for first tile corner
#define NEO_TILE_ROWS          0x00 // Tiles ordered in rows
#define NEO_TILE_COLUMNS       0x40 // Tiles ordered in columns
#define NEO_TILE_AXIS          0x40 // Bitmask for tile H/V orientation
#define NEO_TILE_PROGRESSIVE   0x00 // Same tile order across each line
#define NEO_TILE_ZIGZAG        0x80 // Tile order reverses between lines
#define NEO_TILE_SEQUENCE      0x80 // Bitmask for tile line order

%-STARTUSERTYPES - Do not make changes between lines (included this lines) marked with %-STARTUSERTYPES and %-ENDUSRTYPES

%-ENDUSRTYPES
%-BW_BEAN_CONSTANTS_START  - Do not make changes between lines (included this lines) marked with %-BW_BEAN_CONSTANTS_START and %-BW_BEAN_CONSTANTS_END
%- No constants defined in the BeanWizard for this bean
%-BW_BEAN_CONSTANTS_END
%-BW_CUSTOM_USERTYPE_START
%- Write your own types here ...
%-  Example:
%-    typedef int TMyInteger;
%-
typedef uint32_t %'ModuleName'%.PixelColor;    /* WS2812B has 24bits for a pixel */
typedef uint8_t %'ModuleName'%.PixelDim; /* one byte is enough to describe an x/y position */
extern uint8_t %'ModuleName'%.DisplayBuf[%'ModuleName'%.MEM_BUF_SIZE]; /* buffer for the display */

#define %'ModuleName'%.PIXEL_ON             %'ModuleName'%.COLOR_WHITE /* value of a pixel if it is 'on' */
#define %'ModuleName'%.PIXEL_OFF            %'ModuleName'%.COLOR_BLACK /* value of a pixel if it is 'off' */
#define %'ModuleName'%.COLOR_PIXEL_SET      %'ModuleName'%.PIXEL_OFF /* color for a pixel set */
#define %'ModuleName'%.COLOR_PIXEL_CLR      %'ModuleName'%.PIXEL_ON  /* color for a pixel cleared */
#define %'ModuleName'%.COLOR_BLACK          1
#define %'ModuleName'%.COLOR_WHITE          0
#define %'ModuleName'%.COLOR_RED            1
#define %'ModuleName'%.COLOR_BRIGHT_RED     1
#define %'ModuleName'%.COLOR_DARK_RED       1
#define %'ModuleName'%.COLOR_GREEN          1
#define %'ModuleName'%.COLOR_BRIGHT_GREEN   1
#define %'ModuleName'%.COLOR_DARK_GREEN     1
#define %'ModuleName'%.COLOR_BLUE           1
#define %'ModuleName'%.COLOR_BRIGHT_BLUE    1
#define %'ModuleName'%.COLOR_DARK_BLUE      1
#define %'ModuleName'%.COLOR_YELLOW         1
#define %'ModuleName'%.COLOR_BRIGHT_YELLOW  1
#define %'ModuleName'%.COLOR_ORANGE         1
#define %'ModuleName'%.COLOR_GREY           1
#define %'ModuleName'%.COLOR_BRIGHT_GREY    1

#define %'ModuleName'%.HW_WIDTH         %'ModuleName'%.CONFIG_WIDTH%>40 /* Logical display width in pixels */
#define %'ModuleName'%.HW_HEIGHT        %'ModuleName'%.CONFIG_HEIGHT%>40 /* Logical display height in pixels */
%if %Height <. %Width
#define %'ModuleName'%.HW_SHORTER_SIDE  %'ModuleName'%.CONFIG_HEIGHT%>40/* size of shorter display side in pixels */
#define %'ModuleName'%.HW_LONGER_SIDE   %'ModuleName'%.CONFIG_WIDTH%>40/* size of longer display side in pixels */
%else
#define %'ModuleName'%.HW_SHORTER_SIDE  %'ModuleName'%.CONFIG_WIDTH%>40/* size of shorter display side in pixels */
#define %'ModuleName'%.HW_LONGER_SIDE   %'ModuleName'%.CONFIG_HEIGHT%>40/* size of longer display side in pixels */
%endif

typedef enum {
  %'ModuleName'%.ORIENTATION_PORTRAIT    = 0,
  %'ModuleName'%.ORIENTATION_PORTRAIT180 = 1,
  %'ModuleName'%.ORIENTATION_LANDSCAPE   = 2,
  %'ModuleName'%.ORIENTATION_LANDSCAPE180= 3
} %'ModuleName'%.DisplayOrientation;

%-BW_CUSTOM_USERTYPE_END

%-BW_DEFINITION_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN UpdateFull
%ifdef UpdateFull
void %'ModuleName'%.%UpdateFull(void);
%include Common\NEOmatrixUpdateFull.Inc

%endif %- UpdateFull
%-BW_METHOD_END UpdateFull
%-************************************************************************************************************
%-BW_METHOD_BEGIN UpdateRegion
%ifdef UpdateRegion
void %'ModuleName'%.%UpdateRegion(%'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y, %'ModuleName'_PixelDim w, %'ModuleName'_PixelDim h);
%define! Parx
%define! Pary
%define! Parw
%define! Parh
%include Common\NEOmatrixUpdateRegion.Inc

%endif %- UpdateRegion
%-BW_METHOD_END UpdateRegion
%-************************************************************************************************************
%-BW_METHOD_BEGIN Enable
%ifdef Enable
void %'ModuleName'%.%Enable(void);
%include Common\NEOmatrixEnable.Inc

%endif %- Enable
%-BW_METHOD_END Enable
%-************************************************************************************************************
%-BW_METHOD_BEGIN Disable
%ifdef Disable
void %'ModuleName'%.%Disable(void);
%include Common\NEOmatrixDisable.Inc

%endif %- Disable
%-BW_METHOD_END Disable
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetDisplayOrientation
%ifdef GetDisplayOrientation
%'ModuleName'_DisplayOrientation %'ModuleName'%.%GetDisplayOrientation(void);
%define! RetVal
%include Common\NEOmatrixGetDisplayOrientation.Inc

%endif %- GetDisplayOrientation
%-BW_METHOD_END GetDisplayOrientation
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetWidth
%ifdef GetWidth
%'ModuleName'_PixelDim %'ModuleName'%.%GetWidth(void);
%define! RetVal
%include Common\NEOmatrixGetWidth.Inc

%endif %- GetWidth
%-BW_METHOD_END GetWidth
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetHeight
%ifdef GetHeight
%'ModuleName'_PixelDim %'ModuleName'%.%GetHeight(void);
%define! RetVal
%include Common\NEOmatrixGetHeight.Inc

%endif %- GetHeight
%-BW_METHOD_END GetHeight
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetDisplayOrientation
%ifdef SetDisplayOrientation
void %'ModuleName'%.%SetDisplayOrientation(%'ModuleName'_DisplayOrientation newOrientation);
%define! ParnewOrientation
%include Common\NEOmatrixSetDisplayOrientation.Inc

%endif %- SetDisplayOrientation
%-BW_METHOD_END SetDisplayOrientation
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetShorterSide
%ifdef GetShorterSide
%'ModuleName'_PixelDim %'ModuleName'%.%GetShorterSide(void);
%define! RetVal
%include Common\NEOmatrixGetShorterSide.Inc

%endif %- GetShorterSide
%-BW_METHOD_END GetShorterSide
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetLongerSide
%ifdef GetLongerSide
%'ModuleName'_PixelDim %'ModuleName'%.%GetLongerSide(void);
%define! RetVal
%include Common\NEOmatrixGetLongerSide.Inc

%endif %- GetLongerSide
%-BW_METHOD_END GetLongerSide
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetLCD
%ifdef GetLCD
void %'ModuleName'%.%GetLCD(void);
%include Common\NEOmatrixGetLCD.Inc

%endif %- GetLCD
%-BW_METHOD_END GetLCD
%-************************************************************************************************************
%-BW_METHOD_BEGIN GiveLCD
%ifdef GiveLCD
void %'ModuleName'%.%GiveLCD(void);
%include Common\NEOmatrixGiveLCD.Inc

%endif %- GiveLCD
%-BW_METHOD_END GiveLCD
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetPixel
%ifdef SetPixel
uint8_t %'ModuleName'%.%SetPixel(%'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y);
%define! Parx
%define! Pary
%define! RetVal
%include Common\NEOmatrixSetPixel.Inc

%endif %- SetPixel
%-BW_METHOD_END SetPixel
%-************************************************************************************************************
%-BW_METHOD_BEGIN ClrPixel
%ifdef ClrPixel
uint8_t %'ModuleName'%.%ClrPixel(%'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y);
%define! Parx
%define! Pary
%define! RetVal
%include Common\NEOmatrixClrPixel.Inc

%endif %- ClrPixel
%-BW_METHOD_END ClrPixel
%-************************************************************************************************************
%-BW_METHOD_BEGIN PutPixel
%ifdef PutPixel
uint8_t %'ModuleName'%.%PutPixel(%'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y, %'ModuleName'_PixelColor color);
%define! Parx
%define! Pary
%define! Parcolor
%define! RetVal
%include Common\NEOmatrixPutPixel.Inc

%endif %- PutPixel
%-BW_METHOD_END PutPixel
%-************************************************************************************************************
%-BW_METHOD_BEGIN Deinit
%ifdef Deinit
void %'ModuleName'%.%Deinit(void);
%include Common\NEOmatrixDeinit.Inc

%endif %- Deinit
%-BW_METHOD_END Deinit
%-************************************************************************************************************
%-BW_METHOD_BEGIN Init
%ifdef Init
void %'ModuleName'%.%Init(void);
%include Common\NEOmatrixInit.Inc

%endif %- Init
%-BW_METHOD_END Init
%-************************************************************************************************************
%-BW_METHOD_BEGIN NegPixel
%ifdef NegPixel
uint8_t %'ModuleName'%.%NegPixel(%'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y);
%define! Parx
%define! Pary
%define! RetVal
%include Common\NEOmatrixNegPixel.Inc

%endif %- NegPixel
%-BW_METHOD_END NegPixel
%-BW_DEFINITION_END
/* END %ModuleName. */

#endif
/* ifndef __%'ModuleName'_H */
%include Common\Header.End
%-
%-BW_EVENT_DEFINITION_START
%-BW_EVENT_DEFINITION_END
%IMPLEMENTATION
%define! Settings Common\NEOmatrixSettings.Inc
%define! Abstract Common\NEOmatrixAbstract.Inc
%include Common\Header.C

/* MODULE %ModuleName. */

%for var from EventModules
#include "%var.h"
%endfor
#include "%'ModuleName'.h"
%-BW_CUSTOM_INCLUDE_START_M
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%-BW_CUSTOM_INCLUDE_END_M

%-BW_CUSTOM_VARIABLE_START
%- Write your static variables here
%-   Example:
%-     static int counter1;
%-     int %'ModuleName'%.counter2;
%-
uint8_t %'ModuleName'%.DisplayBuf[%'ModuleName'%.MEM_BUF_SIZE]; /* buffer for the display */
%if defined(Enable) | defined(Disable)
static bool %'ModuleName'%.DisplayEnabled = TRUE; /* if we allow refresh of the display */
%endif

static %'ModuleName'%.DisplayOrientation %'ModuleName'%.currOrientation = %'ModuleName'%.CONFIG_DEFAULT_ORIENTATION;

/*
  NeoMatrix_drawPixel() Method written by Adafruit, copyrigt notice below:

  Written by Phil Burgess / Paint Your Dragon for Adafruit Industries.

  Adafruit invests time and resources providing this open source code,
  please support Adafruit and open-source hardware by purchasing products
  from Adafruit!

  -------------------------------------------------------------------------
  This file is part of the Adafruit NeoMatrix library.

  NeoMatrix is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as
  published by the Free Software Foundation, either version 3 of
  the License, or (at your option) any later version.

  NeoMatrix is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public
  License along with NeoMatrix.  If not, see
  <http://www.gnu.org/licenses/>.
  -------------------------------------------------------------------------*/
typedef struct {
  uint8_t type;
  uint8_t matrixWidth, matrixHeight, tilesX, tilesY;
  uint16_t (*remapFn)(uint16_t x, uint16_t y);
  uint32_t passThruColor;
  bool  passThruFlag;
} MATRIX_Matrix;

static MATRIX_Matrix matrix;

void NeoMatrix_drawPixel(int16_t x, int16_t y, uint8_t red, uint8_t green, uint8_t blue) {
  #define swap(a, b) {uint16_t swapTmp; swapTmp=a; a=b; b=swapTmp;}

  if((x < 0) || (y < 0) || (x >= %'ModuleName'%.%GetWidth()) || (y >= %'ModuleName'%.%GetHeight())) {
    return;
  }
  int tileOffset = 0, pixelOffset, val;

  if(matrix.remapFn) { // Custom X/Y remapping function
    pixelOffset = (*matrix.remapFn)(x, y);
  } else {      // Standard single matrix or tiled matrices
    uint8_t  corner = matrix.type & NEO_MATRIX_CORNER;
    uint16_t minor, major, majorScale;

    if(matrix.tilesX) { // Tiled display, multiple matrices
      uint16_t tile;

      minor = x / matrix.matrixWidth;            // Tile # X/Y; presume row major to
      major = y / matrix.matrixHeight,           // start (will swap later if needed)
      x     = x - (minor * matrix.matrixWidth);  // Pixel X/Y within tile
      y     = y - (major * matrix.matrixHeight); // (-* is less math than modulo)

      // Determine corner of entry, flip axes if needed
      if(matrix.type & NEO_TILE_RIGHT)  minor = matrix.tilesX - 1 - minor;
      if(matrix.type & NEO_TILE_BOTTOM) major = matrix.tilesY - 1 - major;

      // Determine actual major axis of tiling
      if((matrix.type & NEO_TILE_AXIS) == NEO_TILE_ROWS) {
        majorScale = matrix.tilesX;
      } else {
        swap(major, minor);
        majorScale = matrix.tilesY;
      }

      // Determine tile number
      if((matrix.type & NEO_TILE_SEQUENCE) == NEO_TILE_PROGRESSIVE) {
        // All tiles in same order
        tile = major * majorScale + minor;
      } else {
        // Zigzag; alternate rows change direction.  On these rows,
        // this also flips the starting corner of the matrix for the
        // pixel math later.
        if(major & 1) {
          corner ^= NEO_MATRIX_CORNER;
          tile = (major + 1) * majorScale - 1 - minor;
        } else {
          tile =  major      * majorScale     + minor;
        }
      }
      // Index of first pixel in tile
      tileOffset = tile * matrix.matrixWidth * matrix.matrixHeight;
    } // else no tiling (handle as single tile)
    // Find pixel number within tile
    minor = x; // Presume row major to start (will swap later if needed)
    major = y;

    // Determine corner of entry, flip axes if needed
    if(corner & NEO_MATRIX_RIGHT)  minor = matrix.matrixWidth  - 1 - minor;
    if(corner & NEO_MATRIX_BOTTOM) major = matrix.matrixHeight - 1 - major;

    // Determine actual major axis of matrix
    if((matrix.type & NEO_MATRIX_AXIS) == NEO_MATRIX_ROWS) {
      majorScale = matrix.matrixWidth;
    } else {
      swap(major, minor);
      majorScale = matrix.matrixHeight;
    }

    // Determine pixel number within tile/matrix
    if((matrix.type & NEO_MATRIX_SEQUENCE) == NEO_MATRIX_PROGRESSIVE) {
      // All lines in same order
      pixelOffset = major * majorScale + minor;
    } else {
      // Zigzag; alternate rows change direction.
      if(major & 1) pixelOffset = (major + 1) * majorScale - 1 - minor;
      else          pixelOffset =  major      * majorScale     + minor;
    }
  }
  val = tileOffset+pixelOffset; /* overall index in matrix */
  NEO_SetPixelRGB(val/%'ModuleName'%.NOF_LED_PIXELS, val%%%'ModuleName'%.NOF_LED_PIXELS, red, green, blue);
  //NEO_SetPixelRGB(0, tileOffset + pixelOffset, red, green, blue); /* single lane version */
}

%-BW_CUSTOM_VARIABLE_END
%-BW_INTERN_METHOD_DECL_START
%- List of internal methods headers
%-BW_INTERN_METHOD_DECL_END
%-BW_IMPLEMENT_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN UpdateFull
%ifdef UpdateFull
%include Common\NEOmatrixUpdateFull.Inc
void %'ModuleName'%.%UpdateFull(void)
{
%if defined(Enable) | defined(Disable)
  if (!%'ModuleName'%.DisplayEnabled) {
    return;
  }
%endif
}

%endif %- UpdateFull
%-BW_METHOD_END UpdateFull
%-************************************************************************************************************
%-BW_METHOD_BEGIN UpdateRegion
%ifdef UpdateRegion
%define! Parx
%define! Pary
%define! Parw
%define! Parh
%include Common\NEOmatrixUpdateRegion.Inc
void %'ModuleName'%.%UpdateRegion(%'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y, %'ModuleName'_PixelDim w, %'ModuleName'_PixelDim h)
{
  (void)x; (void)y; (void)w; (void)h;
  %'ModuleName'%.%UpdateFull();
}

%endif %- UpdateRegion
%-BW_METHOD_END UpdateRegion
%-************************************************************************************************************
%-BW_METHOD_BEGIN Enable
%ifdef Enable
%include Common\NEOmatrixEnable.Inc
void %'ModuleName'%.%Enable(void)
{
  %'ModuleName'%.DisplayEnabled = TRUE;
}

%endif %- Enable
%-BW_METHOD_END Enable
%-************************************************************************************************************
%-BW_METHOD_BEGIN Disable
%ifdef Disable
%include Common\NEOmatrixDisable.Inc
void %'ModuleName'%.%Disable(void)
{
  %'ModuleName'%.DisplayEnabled = FALSE;
}

%endif %- Disable
%-BW_METHOD_END Disable
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetDisplayOrientation
%ifdef GetDisplayOrientation
%define! RetVal
%include Common\NEOmatrixGetDisplayOrientation.Inc
%'ModuleName'_DisplayOrientation %'ModuleName'%.%GetDisplayOrientation(void)
{
  return %'ModuleName'%.currOrientation;
}

%endif %- GetDisplayOrientation
%-BW_METHOD_END GetDisplayOrientation
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetWidth
%ifdef GetWidth
%define! RetVal
%include Common\NEOmatrixGetWidth.Inc
%'ModuleName'_PixelDim %'ModuleName'%.%GetWidth(void)
{
  switch(%'ModuleName'%.currOrientation) {
    case %'ModuleName'%.ORIENTATION_PORTRAIT:
    case %'ModuleName'%.ORIENTATION_PORTRAIT180:
      return %'ModuleName'%.HW_SHORTER_SIDE;
    case %'ModuleName'%.ORIENTATION_LANDSCAPE:
    case %'ModuleName'%.ORIENTATION_LANDSCAPE180:
      return %'ModuleName'%.HW_LONGER_SIDE;
    default:
      break;
  } /* switch */
  return 0; /* error case */
}

%endif %- GetWidth
%-BW_METHOD_END GetWidth
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetHeight
%ifdef GetHeight
%define! RetVal
%include Common\NEOmatrixGetHeight.Inc
%'ModuleName'_PixelDim %'ModuleName'%.%GetHeight(void)
{
  switch(%'ModuleName'%.currOrientation) {
    case %'ModuleName'%.ORIENTATION_PORTRAIT:
    case %'ModuleName'%.ORIENTATION_PORTRAIT180:
      return %'ModuleName'%.HW_LONGER_SIDE;
    case %'ModuleName'%.ORIENTATION_LANDSCAPE:
    case %'ModuleName'%.ORIENTATION_LANDSCAPE180:
      return %'ModuleName'%.HW_SHORTER_SIDE;
    default:
      break;
  } /* switch */
  return 0; /* error case */
}

%endif %- GetHeight
%-BW_METHOD_END GetHeight
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetShorterSide
%ifdef GetShorterSide
%define! RetVal
%include Common\NEOmatrixGetShorterSide.Inc
%'ModuleName'_PixelDim %'ModuleName'%.%GetShorterSide(void)
{
  return %'ModuleName'%.HW_SHORTER_SIDE;
}

%endif %- GetShorterSide
%-BW_METHOD_END GetShorterSide
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetLongerSide
%ifdef GetLongerSide
%define! RetVal
%include Common\NEOmatrixGetLongerSide.Inc
%'ModuleName'_PixelDim %'ModuleName'%.%GetLongerSide(void)
{
  return %'ModuleName'%.HW_LONGER_SIDE;
}

%endif %- GetLongerSide
%-BW_METHOD_END GetLongerSide
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetDisplayOrientation
%ifdef SetDisplayOrientation
%define! ParnewOrientation
%include Common\NEOmatrixSetDisplayOrientation.Inc
void %'ModuleName'%.%SetDisplayOrientation(%'ModuleName'_DisplayOrientation newOrientation)
{
  %'ModuleName'%.currOrientation = newOrientation;
  /* note: the x/y first pixel (0,0) is always on top left, with x to the right and y to the bottom */
  /* see https://learn.adafruit.com/adafruit-neopixel-uberguide/neomatrix-library */
  /* HARDWARE wiring: Orientation for landscape is DIN first pixel is top-left, with x going to the right and y going to the bottom,
     next module is on the right */
  switch(%'ModuleName'%.currOrientation) {
    default:
    case %'ModuleName'%.ORIENTATION_PORTRAIT:
      matrix.type =
        NEO_MATRIX_TOP  // corner, first pixel: either NEO_MATRIX_TOP or NEO_MATRIX_BOTTOM
      + NEO_MATRIX_RIGHT // corner, first pixel: either NEO_MATRIX_TOP or NEO_MATRIX_BOTTOM
      + NEO_MATRIX_COLUMNS // axis, pixels are organized in  NEO_MATRIX_ROWS or NEO_MATRIX_COLUMNS
      + NEO_MATRIX_PROGRESSIVE // sequence, pixels either change side NEO_MATRIX_PROGRESSIVE or NEO_MATRIX_ZIGZAG
      /* tile configuration */
      + NEO_TILE_TOP    // corner, position of first tile: NEO_TILE_TOP or NEO_TILE_BOTTOM
      + NEO_TILE_RIGHT   // corner, position of first tile: NEO_TILE_LEFT or NEO_TILE_RIGHT
      + NEO_TILE_COLUMNS   // axis, organization of tiles: NEO_TILE_ROWS or NEO_TILE_COLUMNS
      + NEO_TILE_PROGRESSIVE // sequence, organization of tiles: NEO_TILE_PROGRESSIVE or NEO_TILE_ZIGZAG
      ;
      matrix.tilesX = %'ModuleName'%.HW_SHORTER_SIDE/8; /* number of tiles in X direction */
      matrix.tilesY = %'ModuleName'%.HW_LONGER_SIDE/8; /* number of tiles in Y direction */
      break;
    case %'ModuleName'%.ORIENTATION_PORTRAIT180:
      matrix.type =
        NEO_MATRIX_BOTTOM  // corner, first pixel: either NEO_MATRIX_TOP or NEO_MATRIX_BOTTOM
      + NEO_MATRIX_LEFT // corner, first pixel: either NEO_MATRIX_TOP or NEO_MATRIX_BOTTOM
      + NEO_MATRIX_COLUMNS // axis, pixels are organized in  NEO_MATRIX_ROWS or NEO_MATRIX_COLUMNS
      + NEO_MATRIX_PROGRESSIVE // sequence, pixels either change side NEO_MATRIX_PROGRESSIVE or NEO_MATRIX_ZIGZAG
      /* tile configuration */
      + NEO_TILE_BOTTOM    // corner, position of first tile: NEO_TILE_TOP or NEO_TILE_BOTTOM
      + NEO_TILE_LEFT   // corner, position of first tile: NEO_TILE_LEFT or NEO_TILE_RIGHT
      + NEO_TILE_COLUMNS   // axis, organization of tiles: NEO_TILE_ROWS or NEO_TILE_COLUMNS
      + NEO_TILE_PROGRESSIVE // sequence, organization of tiles: NEO_TILE_PROGRESSIVE or NEO_TILE_ZIGZAG
      ;
      matrix.tilesX = %'ModuleName'%.HW_SHORTER_SIDE/8; /* number of tiles in X direction */
      matrix.tilesY = %'ModuleName'%.HW_LONGER_SIDE/8; /* number of tiles in Y direction */
      break;
    case %'ModuleName'%.ORIENTATION_LANDSCAPE:
      matrix.type =
        NEO_MATRIX_TOP  // corner, first pixel: either NEO_MATRIX_TOP or NEO_MATRIX_BOTTOM
      + NEO_MATRIX_LEFT // corner, first pixel: either NEO_MATRIX_TOP or NEO_MATRIX_BOTTOM
      + NEO_MATRIX_ROWS // axis, pixels are organized in  NEO_MATRIX_ROWS or NEO_MATRIX_COLUMNS
      + NEO_MATRIX_PROGRESSIVE // sequence, pixels either change side NEO_MATRIX_PROGRESSIVE or NEO_MATRIX_ZIGZAG
      /* tile configuration */
      + NEO_TILE_TOP    // corner, position of first tile: NEO_TILE_TOP or NEO_TILE_BOTTOM
      + NEO_TILE_LEFT   // corner, position of first tile: NEO_TILE_LEFT or NEO_TILE_RIGHT
      + NEO_TILE_ROWS   // axis, organization of tiles: NEO_TILE_ROWS or NEO_TILE_COLUMNS
      + NEO_TILE_PROGRESSIVE // sequence, organization of tiles: NEO_TILE_PROGRESSIVE or NEO_TILE_ZIGZAG
      ;
      matrix.tilesX = %'ModuleName'%.HW_LONGER_SIDE/8; /* number of tiles in X direction */
      matrix.tilesY = %'ModuleName'%.HW_SHORTER_SIDE/8; /* number of tiles in Y direction */
      break;
    case %'ModuleName'%.ORIENTATION_LANDSCAPE180:
      matrix.type =
        NEO_MATRIX_BOTTOM  // corner, first pixel: either NEO_MATRIX_TOP or NEO_MATRIX_BOTTOM
      + NEO_MATRIX_RIGHT // corner, first pixel: either NEO_MATRIX_TOP or NEO_MATRIX_BOTTOM
      + NEO_MATRIX_ROWS // axis, pixels are organized in  NEO_MATRIX_ROWS or NEO_MATRIX_COLUMNS
      + NEO_MATRIX_PROGRESSIVE // sequence, pixels either change side NEO_MATRIX_PROGRESSIVE or NEO_MATRIX_ZIGZAG
      /* tile configuration */
      + NEO_TILE_BOTTOM    // corner, position of first tile: NEO_TILE_TOP or NEO_TILE_BOTTOM
      + NEO_TILE_RIGHT   // corner, position of first tile: NEO_TILE_LEFT or NEO_TILE_RIGHT
      + NEO_TILE_ROWS   // axis, organization of tiles: NEO_TILE_ROWS or NEO_TILE_COLUMNS
      + NEO_TILE_PROGRESSIVE // sequence, organization of tiles: NEO_TILE_PROGRESSIVE or NEO_TILE_ZIGZAG
      ;
      matrix.tilesX = %'ModuleName'%.HW_LONGER_SIDE/8; /* number of tiles in X direction */
      matrix.tilesY = %'ModuleName'%.HW_SHORTER_SIDE/8; /* number of tiles in Y direction */
      break;
  } /* switch */
}

%endif %- SetDisplayOrientation
%-BW_METHOD_END SetDisplayOrientation
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetLCD
%ifdef GetLCD
%include Common\NEOmatrixGetLCD.Inc
void %'ModuleName'%.%GetLCD(void)
{
  /* not implemented yet */
}

%endif %- GetLCD
%-BW_METHOD_END GetLCD
%-************************************************************************************************************
%-BW_METHOD_BEGIN GiveLCD
%ifdef GiveLCD
%include Common\NEOmatrixGiveLCD.Inc
void %'ModuleName'%.%GiveLCD(void)
{
  /* not implemented yet */
}

%endif %- GiveLCD
%-BW_METHOD_END GiveLCD
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetPixel
%ifdef SetPixel
%define! Parx
%define! Pary
%define! RetVal
%include Common\NEOmatrixSetPixel.Inc
uint8_t %'ModuleName'%.%SetPixel(%'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y)
{
  NeoMatrix_drawPixel(x, y, 0xff/4, 0xff/4, 0xff/4);
  return ERR_OK;
}

%endif %- SetPixel
%-BW_METHOD_END SetPixel
%-************************************************************************************************************
%-BW_METHOD_BEGIN ClrPixel
%ifdef ClrPixel
%define! Parx
%define! Pary
%define! RetVal
%include Common\NEOmatrixClrPixel.Inc
uint8_t %'ModuleName'%.%ClrPixel(%'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y)
{
  NeoMatrix_drawPixel(x, y, 0, 0, 0);
  return ERR_OK;
}

%endif %- ClrPixel
%-BW_METHOD_END ClrPixel
%-************************************************************************************************************
%-BW_METHOD_BEGIN NegPixel
%ifdef NegPixel
%define! Parx
%define! Pary
%define! RetVal
%include Common\NEOmatrixNegPixel.Inc
uint8_t %'ModuleName'%.%NegPixel(%'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y)
{
  /* \todo */
  return ERR_OK;
}

%endif %- NegPixel
%-BW_METHOD_END NegPixel
%-************************************************************************************************************
%-BW_METHOD_BEGIN PutPixel
%ifdef PutPixel
%define! Parx
%define! Pary
%define! Parcolor
%define! RetVal
%include Common\NEOmatrixPutPixel.Inc
uint8_t %'ModuleName'%.%PutPixel(%'ModuleName'_PixelDim x, %'ModuleName'_PixelDim y, %'ModuleName'_PixelColor color)
{
  NeoMatrix_drawPixel(x, y, (color&0xff0000)>>16, (color&0xff00)>>8, color&0xff);
  return ERR_OK;
}

%endif %- PutPixel
%-BW_METHOD_END PutPixel
%-************************************************************************************************************
%-BW_METHOD_BEGIN Deinit
%ifdef Deinit
%include Common\NEOmatrixDeinit.Inc
void %'ModuleName'%.%Deinit(void)
{
  /* noting to do */
}

%endif %- Deinit
%-BW_METHOD_END Deinit
%-************************************************************************************************************
%-BW_METHOD_BEGIN Init
%ifdef Init
%include Common\NEOmatrixInit.Inc
void %'ModuleName'%.%Init(void)
{
  matrix.matrixWidth = 8; /* size of *each* matrix */
  matrix.matrixHeight = 8; /* size of *each* matrix */
  matrix.tilesX = %'ModuleName'%.HW_WIDTH/8; /* number of tiles in X direction */
  matrix.tilesY = %'ModuleName'%.HW_HEIGHT/8; /* number of tiles in Y direction */
  matrix.remapFn = NULL; /* remapping function */
  matrix.passThruColor = 0;
  matrix.passThruFlag = FALSE;
  %'ModuleName'%.%SetDisplayOrientation(%'ModuleName'%.CONFIG_DEFAULT_ORIENTATION);
}

%endif %- Init
%-BW_METHOD_END Init
%-BW_IMPLEMENT_END
/* END %ModuleName. */

%include Common\Header.End
%-
%-
%-BW_EVENT_IMPLEMENT_START
%-BW_EVENT_IMPLEMENT_END
%INITIALIZATION
%CODE_BEGIN
%'ModuleName'%.%Init(); /* ### %DeviceType "%DeviceName" init code ... */
%CODE_END
%ENABLE
%CODE_BEGIN
%CODE_END
%-
%else %- Language (& Compiler)
  %error^ This bean is not implemented in selected language & compiler !
%endif %- Language (& Compiler)
%DEBUG
%ALL_SYMBOLS
%-
%-----------------------------------------------------------------------------------------
%if defined(sdk) & %@sdk@ConfigFilesFolderName <> ""
  %define  ConfigSrcDirFolder %%@sdk@ConfigFilesFolderName/
%else
  %define  ConfigSrcDirFolder
%endif
%----------------------------
%FILE %'DirRel_Code'%'ConfigSrcDirFolder'%'ModuleName'config.h
#ifndef __%'ModuleName'_CONFIG_H
#define __%'ModuleName'_CONFIG_H

#ifndef %'ModuleName'%.CONFIG_PIXEL_NOF_BITS
  #define %'ModuleName'%.CONFIG_PIXEL_NOF_BITS                   %>40 (24)
    /*!< number of bits per pixel */
#endif

#ifndef %'ModuleName'%.CONFIG_WIDTH
  #define %'ModuleName'%.CONFIG_WIDTH                            %>40 (%Width)
    /*!< number of pixels in x direction */
#endif

#ifndef %'ModuleName'%.CONFIG_HEIGHT
  #define %'ModuleName'%.CONFIG_HEIGHT                           %>40 (%Height)
    /*!< number of pixels in y direction */
#endif

#ifndef %'ModuleName'%.CONFIG_DEFAULT_ORIENTATION
  #define %'ModuleName'%.CONFIG_DEFAULT_ORIENTATION              %>40 (%'ModuleName'%.ORIENTATION_LANDSCAPE)
    /*!< number of pixels in y direction */
#endif

#endif /* __%'ModuleName'_CONFIG_H */
%-----------------------------------------------------------------------------------------
