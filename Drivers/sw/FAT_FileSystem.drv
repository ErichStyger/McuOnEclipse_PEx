%-Driver generated by the Bean Wizard
%-
%- WARNING !
%-
%- Do not make changes to these lines (if you make some changes, you damage this driver)
%- which begins with:
%-
%-  %-STARTUSERTYPES
%-  %-ENDUSRTYPES
%-  /* END %ModuleName. */
%-  /* MODULE %ModuleName. */
%-  %-INTERNAL_METHOD_BEG
%-  %-INTERNAL_METHOD_END
%-  %-INHERITED_EVENT_BEGIN
%-  %-INHERITED_EVENT_END
%-  %-BW_METHOD_BEGIN
%-  %-BW_METHOD_END
%-  %-BW_DEFINITION_START
%-  %-BW_DEFINITION_END
%-  %-BW_IMPLEMENT_START
%-  %-BW_IMPLEMENT_END
%-  %-BW_EVENT_DEFINITION_START
%-  %-BW_EVENT_DEFINITION_END
%-  %-BW_EVENT_IMPLEMENT_START
%-  %-BW_EVENT_IMPLEMENT_END
%-  %-BW_METHOD_MACROS_START
%-  %-BW_METHOD_MACROS_END
%-  %-BW_SECTIONS_INSERT
%-  %-BW_INTERN_COMMENTS_START
%-  %-BW_INTERN_COMMENTS_END
%-  %-BW_BEAN_CONSTANTS_START
%-  %-BW_BEAN_CONSTANTS_END
%-
%-
%- These lines are not comments, but they are necessary for Bean Wizard
%- If you change these lines, Bean Wizard will not be responsible for loosing or damaging your code!
%-
%-
%- readyCPU ...
%- readyDEVICE ...
%-
%define DriverAuthor  Author
%define DriverVersion 01.00
%define DriverDate    21.07.2009
%-
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END
%-
%-BW_INTERN_COMMENTS_START
%- List of descriptions of internal methods
%-BW_INTERN_COMMENTS_END
%-
%-BW_SECTIONS_INSERT
%if Language='ANSIC'
%-
%include FatFS_Files.prg
%-
%INTERFACE
%define! Settings Common\FAT_FileSystemSettings.Inc
%define! Abstract Common\FAT_FileSystemAbstract.Inc
%include Common\Header.h

#ifndef __%'ModuleName'_H
#define __%'ModuleName'_H

/* MODULE %ModuleName. */

#include "%@sdk@ModuleName.h" /* SDK and API used */
#include "%'ModuleName'config.h" /* configuration */

/* Wrappers to FatFS types and constants */
#define %'ModuleName'%.FATFS            FATFS
#define %'ModuleName'%.DIR              DIR
#define %'ModuleName'%.FIL              FIL
#define %'ModuleName'%.FILINFO          FILINFO
#define %'ModuleName'%.FRESULT          FRESULT
#define %'ModuleName'%.DRESULT          DRESULT
#if %@sdk@'ModuleName'%.CONFIG_SDK_VERSION_USED == %@sdk@'ModuleName'%.CONFIG_SDK_PROCESSOR_EXPERT
  #define %'ModuleName'%.USE_LFN          _USE_LFN
  #define %'ModuleName'%.MAX_LFN          _MAX_LFN
  #define %'ModuleName'%.MAX_SS           _MAX_SS
  #define %'ModuleName'%.FS_RPATH         _FS_RPATH
  #define %'ModuleName'%.FS_READONLY      _FS_READONLY
  #define %'ModuleName'%.FS_REENTRANT     _FS_REENTRANT
  #define %'ModuleName'%.SYNC_t           _SYNC_t
  #define %'ModuleName'%.FS_TIMEOUT       _FS_TIMEOUT
  #define %'ModuleName'%.VOLUMES          _VOLUMES
#else /* use newer defines in NXP SDK and FatFS */
  #define %'ModuleName'%.USE_LFN          FF_USE_LFN
  #define %'ModuleName'%.MAX_LFN          FF_MAX_LFN
  #define %'ModuleName'%.MAX_SS           FF_MAX_SS
  #define %'ModuleName'%.FS_RPATH         FF_FS_RPATH
  #define %'ModuleName'%.FS_READONLY      FF_FS_READONLY
  #define %'ModuleName'%.FS_REENTRANT     FF_FS_REENTRANT
  #define %'ModuleName'%.SYNC_t           FF_SYNC_t
  #define %'ModuleName'%.FS_TIMEOUT       FF_FS_TIMEOUT
  #define %'ModuleName'%.VOLUMES          FF_VOLUMES
#endif

/* prototypes for application callbacks */
extern bool %'ModuleName'%.CONFIG_IS_DISK_PRESENT_CALLBACK(uint8_t drive);
extern bool %'ModuleName'%.CONFIG_IS_WRITE_PROTECTED_CALLBACK(uint8_t drive);

%-BW_CUSTOM_INCLUDE_START_H
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
#if %'ModuleName'%.CONFIG_SHELL_ENABLED
%if defined(Shell)
  #include "%@Shell@ModuleName.h"
%else
  #include "McuShell.h"
%endif
#endif
%if defined(Utility)
#include "%@Utility@ModuleName.h"
%else
#include "McuUtility.h"
%endif
%if defined(Wait)
#include "%@Wait@ModuleName.h"
%else
#include "McuWait.h"
%endif
%if defined(RTC)
#include "%@RTC@ModuleName.h"
%else
#include "McuTimeDate.h"
%endif

%if defined(Reentrant) & %Reentrant='yes'
%if defined(RTOSenabled) & %RTOSenabled='yes'
%if defined(RTOS)
#include "%@RTOS@ModuleName.h"
%else
#include "McuRTOS.h"
%endif
%endif
%endif

#include "ff.h"
#include "diskio.h"
%-
%-BW_CUSTOM_INCLUDE_END_H
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END

%include sw\CommonSupport.prg

%-STARTUSERTYPES - Do not make changes between lines (included this lines) marked with %-STARTUSERTYPES and %-ENDUSRTYPES

#ifndef __BWUserType_%'ModuleName'_CHARP
#define __BWUserType_%'ModuleName'_CHARP
  typedef char * %'ModuleName'%.CHARP;                           %>40/* alias to a char pointer */
#endif
#ifndef __BWUserType_%'ModuleName'_INT
#define __BWUserType_%'ModuleName'_INT
  typedef int %'ModuleName'%.INT;                                %>40/* alias to int type. */
#endif

%-ENDUSRTYPES
%-BW_BEAN_CONSTANTS_START  - Do not make changes between lines (included this lines) marked with %-BW_BEAN_CONSTANTS_START and %-BW_BEAN_CONSTANTS_END
%- No constants defined in the BeanWizard for this bean
%-BW_BEAN_CONSTANTS_END
%-BW_CUSTOM_USERTYPE_START
%- Write your own types here ...
%-  Example:
%-    typedef int TMyInteger;
#define %'ModuleName'%.PARSE_COMMAND_ENABLED  %'ModuleName'%.CONFIG_SHELL_ENABLED  /* set to 1 if method ParseCommand() is present, 0 otherwise */

%if defined(UseRTOSDynamicMemory) & %UseRTOSDynamicMemory='yes'
#define %'ModuleName'%.USE_RTOS_DYNAMIC_MEMORY  (1 && configSUPPORT_DYNAMIC_ALLOCATION)  /* 1: use RTOS dynamic memory allocation, 0: use static memory */
%else
#define %'ModuleName'%.USE_RTOS_DYNAMIC_MEMORY  (0 && configSUPPORT_DYNAMIC_ALLOCATION)  /* 1: use RTOS dynamic memory allocation, 0: use static memory */
%endif

%-BW_CUSTOM_USERTYPE_END


%-BW_DEFINITION_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN open
%ifdef open
#define %'ModuleName'%.%open(fp, path, mode) \
  f_open(fp, path, mode)
%define! Parfp
%define! Parpath
%define! Parmode
%define! RetVal
%include Common\FAT_FileSystemopen.Inc

%endif %- open
%-BW_METHOD_END open
%-************************************************************************************************************
%-BW_METHOD_BEGIN close
%ifdef close
#define %'ModuleName'%.%close(fp) \
  f_close(fp)

%define! Parfp
%define! RetVal
%include Common\FAT_FileSystemclose.Inc

%endif %- close
%-BW_METHOD_END close
%-************************************************************************************************************
%-BW_METHOD_BEGIN read
%ifdef read
#define %'ModuleName'%.%read(fp, buff, btr, br) \
  f_read(fp, buff, btr, br)

%define! Parfp
%define! Parbuff
%define! Parbtr
%define! Parbr
%define! RetVal
%include Common\FAT_FileSystemread.Inc

%endif %- read
%-BW_METHOD_END read
%-************************************************************************************************************
%-BW_METHOD_BEGIN write
%ifdef write
#define %'ModuleName'%.%write(fp, buff, btw, bw) \
  f_write(fp, buff, btw, bw)

%define! Parfp
%define! Parbuff
%define! Parbtw
%define! Parbw
%define! RetVal
%include Common\FAT_FileSystemwrite.Inc

%endif %- write
%-BW_METHOD_END write
%-************************************************************************************************************
%-BW_METHOD_BEGIN opendir
%ifdef opendir
#define %'ModuleName'%.%opendir(dj, path) \
  f_opendir(dj, path)

%define! Pardj
%define! Parpath
%define! RetVal
%include Common\FAT_FileSystemopendir.Inc

%endif %- opendir
%-BW_METHOD_END opendir
%-************************************************************************************************************
%-BW_METHOD_BEGIN readdir
%ifdef readdir
#define %'ModuleName'%.%readdir(dj, fno) \
  f_readdir(dj, fno)

%define! Pardir
%define! Parfno
%define! RetVal
%include Common\FAT_FileSystemreaddir.Inc

%endif %- readdir
%-BW_METHOD_END readdir
%-************************************************************************************************************
%-BW_METHOD_BEGIN lseek
%ifdef lseek
#define %'ModuleName'%.%lseek(fp, ofs) \
  f_lseek(fp, ofs)

%define! Parfp
%define! Parofs
%define! RetVal
%include Common\FAT_FileSystemlseek.Inc

%endif %- lseek
%-BW_METHOD_END lseek
%-************************************************************************************************************
%-BW_METHOD_BEGIN unlink
%ifdef unlink
#define %'ModuleName'%.%unlink(path) \
  f_unlink(path)

%define! Parpath
%define! RetVal
%include Common\FAT_FileSystemunlink.Inc

%endif %- unlink
%-BW_METHOD_END unlink
%-************************************************************************************************************
%-BW_METHOD_BEGIN mount
%ifdef mount
#define %'ModuleName'%.%mount(fs, path, opt) \
  f_mount(fs, path, opt)

%define! Parfs
%define! Parpath
%define! Paropt
%define! RetVal
%include Common\FAT_FileSystemmount.Inc

%endif %- mount
%-BW_METHOD_END mount
%-************************************************************************************************************
%-BW_METHOD_BEGIN getfree
%ifdef getfree
#define %'ModuleName'%.getfree(path, nclst, fs) f_getfree(path, nclst, fs)
%define! Parpath
%define! Parnclst
%define! Parfatfs
%define! RetVal
%include Common\FAT_FileSystemgetfree.Inc

%endif %- getfree
%-BW_METHOD_END getfree
%-************************************************************************************************************
%-BW_METHOD_BEGIN sync
%ifdef sync
#define %'ModuleName'%.%sync(fp) \
  f_sync(fp)

%define! Parfp
%define! RetVal
%include Common\FAT_FileSystemsync.Inc

%endif %- sync
%-BW_METHOD_END sync
%-************************************************************************************************************
%-BW_METHOD_BEGIN rename
%ifdef rename
#define %'ModuleName'%.%rename(path_old, path_new) \
  f_rename(path_old, path_new)
%define! Parpath_old
%define! Parpath_new
%define! RetVal
%include Common\FAT_FileSystemrename.Inc

%endif %- rename
%-BW_METHOD_END rename
%-************************************************************************************************************
%-BW_METHOD_BEGIN isWriteProtected
%ifdef isWriteProtected
bool %'ModuleName'%.%isWriteProtected(uint8_t *drvStr);

%define! PardrvStr
%define! RetVal
%include Common\FAT_FileSystemisWriteProtected.Inc

%endif %- isWriteProtected
%-BW_METHOD_END isWriteProtected
%-************************************************************************************************************
%-BW_METHOD_BEGIN mkdir
%ifdef mkdir
#define %'ModuleName'%.%mkdir(path) \
  f_mkdir(path)
%define! Parpath
%define! RetVal
%include Common\FAT_FileSystemmkdir.Inc

%endif %- mkdir
%-BW_METHOD_END mkdir
%-************************************************************************************************************
%-BW_METHOD_BEGIN chmod
%ifdef chmod
#define %'ModuleName'%.%chmod(FileName, Attribute, AttributeMask) \
  f_chmod(FileName, Attribute, AttributeMask)

%define! ParFileName
%define! ParAttribute
%define! ParAttributeMask
%define! RetVal
%include Common\FAT_FileSystemchmod.Inc

%endif %- chmod
%-BW_METHOD_END chmod
%-************************************************************************************************************
%-BW_METHOD_BEGIN truncate
%ifdef truncate
#define %'ModuleName'%.%truncate(FILP) \
  f_truncate(FILP)

%define! ParFileObject
%define! RetVal
%include Common\FAT_FileSystemtruncate.Inc

%endif %- truncate
%-BW_METHOD_END truncate
%-************************************************************************************************************
%-BW_METHOD_BEGIN stat
%ifdef stat
#define %'ModuleName'%.%stat(FileName, FileInfo) \
  f_stat(FileName, FileInfo)

%define! ParFileName
%define! ParFileInfo
%define! RetVal
%include Common\FAT_FileSystemstat.Inc

%endif %- stat
%-BW_METHOD_END stat
%-************************************************************************************************************
%-BW_METHOD_BEGIN utime
%ifdef utime
#define %'ModuleName'%.%utime(FileName, TimeDate) \
  f_utime(FileName, TimeDate)

%define! ParFileName
%define! ParTimeDate
%define! RetVal
%include Common\FAT_FileSystemutime.Inc

%endif %- utime
%-BW_METHOD_END utime
%-************************************************************************************************************
%-BW_METHOD_BEGIN mkfs
%ifdef mkfs
#define %'ModuleName'%.%mkfs(drive, PartitioningRule, AllocSize) \
  f_mkfs(drive, PartitioningRule, AllocSize)

%define! Pardrive
%define! ParPartitioningRule
%define! ParAllocSize
%define! RetVal
%include Common\FAT_FileSystemmkfs.Inc

%endif %- mkfs
%-BW_METHOD_END mkfs
%-************************************************************************************************************
%-BW_METHOD_BEGIN forward
%ifdef forward
#define %'ModuleName'%.%forward(FileObject, Func, ByteToFwd, ByteFwd) \
  f_forward(FileObject, Func, ByteToFwd, ByteFwd)

%define! ParFileObject
%define! ParFunc
%define! ParByteToFwd
%define! ParByteFwd
%define! RetVal
%include Common\FAT_FileSystemforward.Inc

%endif %- forward
%-BW_METHOD_END forward
%-************************************************************************************************************
%-BW_METHOD_BEGIN chdir
%ifdef chdir
#define %'ModuleName'%.%chdir(Path) \
  f_chdir(Path)

%define! ParPath
%define! RetVal
%include Common\FAT_FileSystemchdir.Inc

%endif %- chdir
%-BW_METHOD_END chdir
%-************************************************************************************************************
%-BW_METHOD_BEGIN chdrive
%ifdef chdrive
#define %'ModuleName'%.%chdrive(Drive) \
  f_chdrive(Drive)

%define! ParDrive
%define! RetVal
%include Common\FAT_FileSystemchdrive.Inc

%endif %- chdrive
%-BW_METHOD_END chdrive
%-************************************************************************************************************
%-BW_METHOD_BEGIN getcwd
%ifdef getcwd
#define %'ModuleName'%.%getcwd(Buffer, BufferLen) \
  f_getcwd(Buffer, BufferLen)

%define! ParBuffer
%define! ParBufferLen
%define! RetVal
%include Common\FAT_FileSystemgetcwd.Inc

%endif %- getcwd
%-BW_METHOD_END getcwd
%-************************************************************************************************************
%-BW_METHOD_BEGIN errFResultMsg
%ifdef errFResultMsg
char* %'ModuleName'%.%errFResultMsg(int errNo);
%define! ParerrNo
%define! RetVal
%include Common\FAT_FileSystemerrFResultMsg.Inc

%endif %- errFResultMsg
%-BW_METHOD_END errFResultMsg
%-************************************************************************************************************
%-BW_METHOD_BEGIN errDResultMsg
%ifdef errDResultMsg
char* %'ModuleName'%.%errDResultMsg(int errNo);
%define! ParerrNo
%define! RetVal
%include Common\FAT_FileSystemerrDResultMsg.Inc

%endif %- errDResultMsg
%-BW_METHOD_END errDResultMsg
%-************************************************************************************************************
%-BW_METHOD_BEGIN isDiskPresent
%ifdef isDiskPresent
bool %'ModuleName'%.%isDiskPresent(uint8_t *drvStr);

%define! PardrvStr
%define! RetVal
%include Common\FAT_FileSystemisDiskPresent.Inc

%endif %- isDiskPresent
%-BW_METHOD_END isDiskPresent
%-************************************************************************************************************
%-BW_METHOD_BEGIN f_gets
%ifdef f_gets
#define %'ModuleName'%.%f_gets(buff, len, fil) \
  f_gets(buff,len,fil)

%define! Parbuff
%define! Parlen
%define! Parfil
%define! RetVal
%include Common\FAT_FileSystemf_gets.Inc

%endif %- f_gets
%-BW_METHOD_END f_gets
%-************************************************************************************************************
%-BW_METHOD_BEGIN f_puts
%ifdef f_puts
#define %'ModuleName'%.%f_puts(str, fil) \
  f_puts(str, fil)

%define! Parbuff
%define! Parfil
%define! RetVal
%include Common\FAT_FileSystemf_puts.Inc

%endif %- f_puts
%-BW_METHOD_END f_puts
%-************************************************************************************************************
%-BW_METHOD_BEGIN f_putc
%ifdef f_putc
#define %'ModuleName'%.%f_putc(c, fil) \
  f_putc(c, fil)

%define! Parbuff
%define! Parfil
%define! RetVal
%include Common\FAT_FileSystemf_putc.Inc

%endif %- f_putc
%-BW_METHOD_END f_putc
%-************************************************************************************************************
%-BW_METHOD_BEGIN f_printf
%ifdef f_printf
#define %'ModuleName'%.%f_printf \
  f_printf

%define! ParVariable_1
%define! Parstr
%define! ParVariable_2
%define! RetVal
%include Common\FAT_FileSystemf_printf.Inc

%endif %- f_printf
%-BW_METHOD_END f_printf
%-************************************************************************************************************
%-BW_METHOD_BEGIN f_eof
%ifdef f_eof
#define %'ModuleName'%.%f_eof(fp) \
  f_eof(fp)

%define! Parfp
%define! RetVal
%include Common\FAT_FileSystemf_eof.Inc

%endif %- f_eof
%-BW_METHOD_END f_eof
%-************************************************************************************************************
%-BW_METHOD_BEGIN f_error
%ifdef f_error
#define %'ModuleName'%.%f_error(fp) \
  f_error(fp)

%define! Parfp
%define! RetVal
%include Common\FAT_FileSystemf_error.Inc

%endif %- f_error
%-BW_METHOD_END f_error
%-************************************************************************************************************
%-BW_METHOD_BEGIN f_tell
%ifdef f_tell
#define %'ModuleName'%.%f_tell(fp) \
  f_tell(fp)

%define! Parfp
%define! RetVal
%include Common\FAT_FileSystemf_tell.Inc

%endif %- f_tell
%-BW_METHOD_END f_tell
%-************************************************************************************************************
%-BW_METHOD_BEGIN f_size
%ifdef f_size
#define %'ModuleName'%.%f_size(fp) \
  f_size(fp)

%define! Parfp
%define! RetVal
%include Common\FAT_FileSystemf_size.Inc

%endif %- f_size
%-BW_METHOD_END f_size
%-************************************************************************************************************
%-BW_METHOD_BEGIN Init
%ifdef Init
uint8_t %'ModuleName'%.%Init(void);
%define! RetVal
%include Common\FAT_FileSystemInit.Inc

%endif %- Init
%-BW_METHOD_END Init
%-************************************************************************************************************
%-BW_METHOD_BEGIN Deinit
%ifdef Deinit
uint8_t %'ModuleName'%.%Deinit(void);
%define! RetVal
%include Common\FAT_FileSystemDeinit.Inc

%endif %- Deinit
%-BW_METHOD_END Deinit
%-************************************************************************************************************
%-BW_METHOD_BEGIN get_fattime
%ifdef get_fattime
uint32_t %'ModuleName'%.%get_fattime(void);
%define! RetVal
%include Common\FAT_FileSystemget_fattime.Inc

%endif %- get_fattime
%-BW_METHOD_END get_fattime
%-************************************************************************************************************
%-BW_METHOD_BEGIN ParseCommand
%ifdef ParseCommand
uint8_t %'ModuleName'%.%ParseCommand(const unsigned char *cmd, bool *handled, const %@Shell@'ModuleName'%.StdIOType *io);
%define! Parcmd
%define! Parhandled
%define! Pario
%define! RetVal
%include Common\FAT_FileSystemParseCommand.Inc

%endif %- ParseCommand
%-BW_METHOD_END ParseCommand
%-************************************************************************************************************
%-BW_METHOD_BEGIN CheckCardPresence
%ifdef CheckCardPresence
uint8_t %'ModuleName'%.%CheckCardPresence(bool *cardMounted, uint8_t *drive, FATFS *fileSystemObject, const %@Shell@'ModuleName'%.StdIOType *io);
%define! ParcardMounted
%define! Pardrive
%define! ParfileSystemObject
%define! Pario
%define! RetVal
%include Common\FAT_FileSystemCheckCardPresence.Inc

%endif %- CheckCardPresence
%-BW_METHOD_END CheckCardPresence
%-************************************************************************************************************
%-BW_METHOD_BEGIN MountFileSystem
%ifdef MountFileSystem
uint8_t %'ModuleName'%.%MountFileSystem(FATFS *fileSystemObject, uint8_t *logicalDrive, const %@Shell@'ModuleName'%.StdIOType *io);
%define! ParfileSystemObject
%define! ParlogicalDrive
%define! Pario
%define! RetVal
%include Common\FAT_FileSystemMountFileSystem.Inc

%endif %- MountFileSystem
%-BW_METHOD_END MountFileSystem
%-************************************************************************************************************
%-BW_METHOD_BEGIN UnMountFileSystem
%ifdef UnMountFileSystem
uint8_t %'ModuleName'%.%UnMountFileSystem(uint8_t *logicalDrive, const %@Shell@'ModuleName'%.StdIOType *io);
%define! ParlogicalDrive
%define! Pario
%define! RetVal
%include Common\FAT_FileSystemUnMountFileSystem.Inc

%endif %- UnMountFileSystem
%-BW_METHOD_END UnMountFileSystem
%-************************************************************************************************************
%-BW_METHOD_BEGIN PrintDirectory
%ifdef PrintDirectory
uint8_t %'ModuleName'%.%PrintDirectory(const uint8_t *dirName, const %@Shell@'ModuleName'%.StdIOType *io);
%define! PardirName
%define! Pario
%define! RetVal
%include Common\FAT_FileSystemPrintDirectory.Inc

%endif %- PrintDirectory
%-BW_METHOD_END PrintDirectory
%-************************************************************************************************************
%-BW_METHOD_BEGIN CopyFile
%ifdef CopyFile
uint8_t %'ModuleName'%.%CopyFile(const uint8_t*srcFileName, const uint8_t *dstFileName, const %@Shell@'ModuleName'%.StdIOType *io);
%define! ParsrcFileName
%define! PardstFileName
%define! Pario
%define! RetVal
%include Common\FAT_FileSystemCopyFile.Inc

%endif %- CopyFile
%-BW_METHOD_END CopyFile
%-************************************************************************************************************
%-BW_METHOD_BEGIN DeleteFile
%ifdef DeleteFile
uint8_t %'ModuleName'%.%DeleteFile(const uint8_t *fileName, const %@Shell@'ModuleName'%.StdIOType *io);
%define! ParfileName
%define! Pario
%define! RetVal
%include Common\FAT_FileSystemDeleteFile.Inc

%endif %- DeleteFile
%-BW_METHOD_END DeleteFile
%-************************************************************************************************************
%-BW_METHOD_BEGIN PrintFile
%ifdef PrintFile
uint8_t %'ModuleName'%.%PrintFile(const uint8_t *fileName, const %@Shell@'ModuleName'%.StdIOType *io);
%define! ParfileName
%define! Pario
%define! RetVal
%include Common\FAT_FileSystemPrintFile.Inc

%endif %- PrintFile
%-BW_METHOD_END PrintFile
%-************************************************************************************************************
%-BW_METHOD_BEGIN MakeDirectory
%ifdef MakeDirectory
uint8_t %'ModuleName'%.%MakeDirectory(const uint8_t *dirName, const %@Shell@'ModuleName'%.StdIOType *io);
%define! PardirName
%define! Pario
%define! RetVal
%include Common\FAT_FileSystemMakeDirectory.Inc

%endif %- MakeDirectory
%-BW_METHOD_END MakeDirectory
%-************************************************************************************************************
%-BW_METHOD_BEGIN ChangeDirectory
%ifdef ChangeDirectory
uint8_t %'ModuleName'%.%ChangeDirectory(const uint8_t *dirName, const %@Shell@'ModuleName'%.StdIOType *io);
%define! PardirName
%define! Pario
%define! RetVal
%include Common\FAT_FileSystemChangeDirectory.Inc

%endif %- ChangeDirectory
%-BW_METHOD_END ChangeDirectory
%-************************************************************************************************************
%-BW_METHOD_BEGIN RenameFile
%ifdef RenameFile
uint8_t %'ModuleName'%.%RenameFile(const uint8_t *srcFileName, const uint8_t *dstFileName, const %@Shell@'ModuleName'%.StdIOType *io);
%define! ParsrcFileName
%define! PardstFileName
%define! Pario
%define! RetVal
%include Common\FAT_FileSystemRenameFile.Inc

%endif %- RenameFile
%-BW_METHOD_END RenameFile
%-************************************************************************************************************
%-BW_METHOD_BEGIN PrintSector
%ifdef PrintSector
uint8_t %'ModuleName'%.%PrintSector(uint8_t drive, uint32_t sectorNo, const %@Shell@'ModuleName'%.StdIOType *io);
%define! Pardrive
%define! ParsectorNo
%define! Pario
%define! RetVal
%include Common\FAT_FileSystemPrintSector.Inc

%endif %- PrintSector
%-BW_METHOD_END PrintSector
%-************************************************************************************************************
%-BW_METHOD_BEGIN PrintDiskInfo
%ifdef PrintDiskInfo
uint8_t %'ModuleName'%.%PrintDiskInfo(uint8_t *drive, const %@Shell@'ModuleName'%.StdIOType *io);
%define! Pardrive
%define! Pario
%define! RetVal
%include Common\FAT_FileSystemPrintDiskInfo.Inc

%endif %- PrintDiskInfo
%-BW_METHOD_END PrintDiskInfo
%-************************************************************************************************************
%-BW_METHOD_BEGIN Benchmark
%ifdef Benchmark
uint8_t %'ModuleName'%.%Benchmark(const %@Shell@'ModuleName'%.StdIOType *io);
%define! Pario
%define! RetVal
%include Common\FAT_FileSystemBenchmark.Inc

%endif %- Benchmark
%-BW_METHOD_END Benchmark
%-************************************************************************************************************
%-BW_METHOD_BEGIN PrintHexFile
%ifdef PrintHexFile
uint8_t %'ModuleName'%.%PrintHexFile(const uint8_t *fileName, const %@Shell@'ModuleName'%.StdIOType *io);
%define! ParfileName
%define! Pario
%define! RetVal
%include Common\FAT_FileSystemPrintHexFile.Inc

%endif %- PrintHexFile
%-BW_METHOD_END PrintHexFile
%-************************************************************************************************************
%-BW_METHOD_BEGIN CreateFile
%ifdef CreateFile
uint8_t %'ModuleName'%.%CreateFile(const uint8_t *fileName, const %@Shell@'ModuleName'%.StdIOType *io);
%define! ParfileName
%define! Pario
%define! RetVal
%include Common\FAT_FileSystemCreateFile.Inc

%endif %- CreateFile
%-BW_METHOD_END CreateFile
%-************************************************************************************************************
%-BW_METHOD_BEGIN f_getlabel
%ifdef f_getlabel
#define %'ModuleName'%.%f_getlabel(path, label, vsn) \
  f_getlabel(path, label, vsn)
%define! Parpath
%define! Parlabel
%define! Parvsn
%define! RetVal
%include Common\FAT_FileSystemf_getlabel.Inc

%endif %- f_getlabel
%-BW_METHOD_END f_getlabel
%-************************************************************************************************************
%-BW_METHOD_BEGIN f_setlabel
%ifdef f_setlabel
#define %'ModuleName'%.%f_setlabel(label) \
  f_setlabel(label);
%define! Parlabel
%define! RetVal
%include Common\FAT_FileSystemf_setlabel.Inc

%endif %- f_setlabel
%-BW_METHOD_END f_setlabel
%-************************************************************************************************************
%-BW_METHOD_BEGIN f_expand
%ifdef f_expand
#define %'ModuleName'%.%f_expand(fp, fsz, opt) \
  f_expand(fp, fsz, opt);
%define! Parfp
%define! Parfsz
%define! Paropt
%define! RetVal
%include Common\FAT_FileSystemf_expand.Inc

%endif %- f_expand
%-BW_METHOD_END f_expand
%-************************************************************************************************************
%-BW_METHOD_BEGIN f_findfirst
%ifdef f_findfirst
#define %'ModuleName'%.%f_findfirst(dp, fno, path, pattern) \
  f_findfirst(dp, fno, path, pattern)
%define! Pardp
%define! Parfno
%define! Parpath
%define! Parpattern
%define! RetVal
%include Common\FAT_FileSystemf_findfirst.Inc

%endif %- f_findfirst
%-BW_METHOD_END f_findfirst
%-************************************************************************************************************
%-BW_METHOD_BEGIN f_findnext
%ifdef f_findnext
#define %'ModuleName'%.%f_findnext(dp, fno) \
  f_findnext(dp, fno)
%define! Pardp
%define! Parfno
%define! RetVal
%include Common\FAT_FileSystemf_findnext.Inc

%endif %- f_findnext
%-BW_METHOD_END f_findnext
%-************************************************************************************************************
%-BW_METHOD_BEGIN f_opendir
%ifdef f_opendir
#define %'ModuleName'%.%f_opendir(dp, path) \
  f_opendir(dp, path)
%define! Pardp
%define! Parpath
%define! RetVal
%include Common\FAT_FileSystemf_opendir.Inc

%endif %- f_opendir
%-BW_METHOD_END f_opendir
%-************************************************************************************************************
%-BW_METHOD_BEGIN f_closedir
%ifdef f_closedir
#define %'ModuleName'%.%f_closedir(dp) \
  f_closedir(dp)
%define! Pardp
%define! RetVal
%include Common\FAT_FileSystemf_closedir.Inc

%endif %- f_closedir
%-BW_METHOD_END f_closedir
%-************************************************************************************************************
%-BW_METHOD_BEGIN f_readdir
%ifdef f_readdir
#define %'ModuleName'%.%f_readdir(dj, fno) \
  f_readdir(dj, fno)
%define! Pardir
%define! Parfno
%define! RetVal
%include Common\FAT_FileSystemf_readdir.Inc

%endif %- f_readdir
%-BW_METHOD_END f_readdir
%-BW_DEFINITION_END
/* END %ModuleName. */

#endif
/* ifndef __%'ModuleName'_H */
%include Common\Header.End
%-
%-BW_EVENT_DEFINITION_START
%-BW_METHOD_BEGIN OnIdle
%ifdef OnIdle
%INTERFACE OnIdle
void %OnIdle(void);
%include Common\FAT_FileSystemOnIdle.Inc

%endif %- OnIdle
%-BW_METHOD_END OnIdle
%-BW_METHOD_BEGIN OnSchedule
%ifdef OnSchedule
%INTERFACE OnSchedule
void %OnSchedule(void);
%include Common\FAT_FileSystemOnSchedule.Inc

%endif %- OnSchedule
%-BW_METHOD_END OnSchedule
%-BW_METHOD_BEGIN OnCreateSyncObject
%ifdef OnCreateSyncObject
%INTERFACE OnCreateSyncObject
void %OnCreateSyncObject(void *sobj);
%define! Parsobj
%include Common\FAT_FileSystemOnCreateSyncObject.Inc

%endif %- OnCreateSyncObject
%-BW_METHOD_END OnCreateSyncObject
%-BW_EVENT_DEFINITION_END
%IMPLEMENTATION
%define! Settings Common\FAT_FileSystemSettings.Inc
%define! Abstract Common\FAT_FileSystemAbstract.Inc
%include Common\Header.C

/* MODULE %ModuleName. */

%for var from EventModules
#include "%var.h"
%endfor
#include "ff.h"
#include "%'ModuleName'.h"

#if %@sdk@'ModuleName'%.CONFIG_SDK_VERSION_USED == %@sdk@'ModuleName'%.CONFIG_SDK_PROCESSOR_EXPERT
%- -------------------------------------------------------------------------------------------
%:maxDrive=%DriveSymbolNumItems
%:maxDrive-=1
%for i from [0..%maxDrive]
#include "%@Drive%i@ModuleName.h"
%endfor
#endif

%-BW_CUSTOM_INCLUDE_START_M
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%-BW_CUSTOM_INCLUDE_END_M

%-BW_CUSTOM_VARIABLE_START
%- Write your static variables here
%-   Example:
%-     static int counter1;
%-     int %'ModuleName'%.counter2;
/*-----------------------------------------------------------------------*/
static uint8_t StrToDriveNumber(uint8_t *drvStr) {
  uint8_t drv = 0;
  const unsigned char *p;

  if (drvStr==NULL || *drvStr=='\0') { /* default, "" */
    drv = 0;
  } else {
    p = drvStr;
    if (%@Utility@'ModuleName'%.ScanDecimal8uNumber(&p, &drv)!=ERR_OK) { /* "0", "1", ... */
      drv = 0; /* error, use default number */
    }
  }
  return drv;
}
/*-----------------------------------------------------------------------*/
#if %@sdk@'ModuleName'%.CONFIG_SDK_VERSION_USED == %@sdk@'ModuleName'%.CONFIG_SDK_PROCESSOR_EXPERT
/* Initialize a Drive                                                    */
DSTATUS disk_initialize (
        uint8_t drv                                              %>40 /* Physical drive number (0..) */
)
{
  switch(drv) {
    %for i from [0..%maxDrive]
    case %i:
      return %@Drive%i@'ModuleName'%.disk_initialize(drv);
    %endfor
    default:
      break;
  } /* switch */
  return (DSTATUS)RES_PARERR;
}
#endif
/*-----------------------------------------------------------------------*/
#if %@sdk@'ModuleName'%.CONFIG_SDK_VERSION_USED == %@sdk@'ModuleName'%.CONFIG_SDK_PROCESSOR_EXPERT
/* Return Disk Status                                                    */
DSTATUS disk_status (
        uint8_t drv                                              %>40 /* Physical drive number (0..) */
)
{
  switch(drv) {
    %for i from [0..%maxDrive]
    case %i:
      return %@Drive%i@'ModuleName'%.disk_status(drv);
    %endfor
    default:
      break;
  } /* switch */
  return (DSTATUS)RES_PARERR;
}
#endif
/*-----------------------------------------------------------------------*/
#if %@sdk@'ModuleName'%.CONFIG_SDK_VERSION_USED == %@sdk@'ModuleName'%.CONFIG_SDK_PROCESSOR_EXPERT
/* Read Sector(s)                                                        */
DRESULT disk_read (
        uint8_t drv,                                             %>40 /* Physical drive number (0..) */
        uint8_t *buff,                                           %>40 /* Data buffer to store read data */
        uint32_t sector,                                         %>40 /* Sector address (LBA) */
        unsigned int count                                       %>40 /* Number of sectors to read */
)
{
  switch(drv) {
    %for i from [0..%maxDrive]
    case %i:
      return %@Drive%i@'ModuleName'%.disk_read(drv, buff, sector, count);
    %endfor
    default:
      break;
  } /* switch */
  return RES_PARERR;
}
#endif
/*-----------------------------------------------------------------------*/
#if %@sdk@'ModuleName'%.CONFIG_SDK_VERSION_USED == %@sdk@'ModuleName'%.CONFIG_SDK_PROCESSOR_EXPERT
/* Write Sector(s)                                                       */
#if _READONLY == 0
DRESULT disk_write (
        uint8_t drv,                                             %>40 /* Physical drive number (0..) */
        const uint8_t *buff,                                     %>40 /* Data to be written */
        uint32_t sector,                                         %>40 /* Sector address (LBA) */
        unsigned int count                                       %>40 /* Number of sectors to write */
)
{
  switch(drv) {
    %for i from [0..%maxDrive]
    case %i:
      return %@Drive%i@'ModuleName'%.disk_write(drv, buff, sector, count);
    %endfor
    default:
      break;
  } /* switch */
  return RES_PARERR;
}
#endif /* _READONLY == 0 */
#endif
/*-----------------------------------------------------------------------*/
#if %@sdk@'ModuleName'%.CONFIG_SDK_VERSION_USED == %@sdk@'ModuleName'%.CONFIG_SDK_PROCESSOR_EXPERT
DRESULT disk_ioctl (
        uint8_t drv,                                             %>40 /* Physical drive number (0..) */
        uint8_t ctrl,                                            %>40 /* Control code */
        void *buff                                               %>40 /* Buffer to send/receive control data */
)
{
  switch(drv) {
    %for i from [0..%maxDrive]
    case %i:
      return %@Drive%i@'ModuleName'%.disk_ioctl(drv, ctrl, buff);
    %endfor
    default:
      break;
  } /* switch */
  return RES_PARERR;
}
#endif
/*-----------------------------------------------------------------------*/
%if defined(Shell)
#define %'ModuleName'_8_3_SIZE       sizeof("0:/12345678.txt") /* length of a 8.3 file name (13 including the zero byte) including the optional drive letter */

#if %'ModuleName'%.USE_LFN == 0                                  %>40 /* No LFN */
#define %'ModuleName'%.DEF_NAMEBUF(name)                         %>40 uint8_t name[%'ModuleName'%.8_3_SIZE]
#define %'ModuleName'%.PTR_NAMEBUF(name)                         %>40 &name[0]
#define %'ModuleName'%.SIZE_NAMEBUF(name)                        %>40 sizeof(name)
#define %'ModuleName'%.INIT_NAMEBUF(name)
#define %'ModuleName'%.FREE_NAMEBUF(name)

#elif %'ModuleName'%.USE_LFN == 1                                %>40 /* LFN with static LFN working buffer */
static TCHAR %'ModuleName'%.FileName[%'ModuleName'%.MAX_LFN+1];
#define %'ModuleName'%.DEF_NAMEBUF(name)
#define %'ModuleName'%.PTR_NAMEBUF(name)                         %>40 &%'ModuleName'%.FileName[0]
#define %'ModuleName'%.SIZE_NAMEBUF(name)                        %>40 sizeof(%'ModuleName'%.FileName)
#define %'ModuleName'%.INIT_NAMEBUF(name)
#define %'ModuleName'%.FREE_NAMEBUF(name)

#elif %'ModuleName'%.USE_LFN == 2                                %>40 /* LFN with dynamic LFN working buffer on the stack */
#define %'ModuleName'%.DEF_NAMEBUF(name)                         %>40 uint8_t name[%'ModuleName'%.MAX_LFN+1]
#define %'ModuleName'%.PTR_NAMEBUF(name)                         %>40 &name[0]
#define %'ModuleName'%.SIZE_NAMEBUF(name)                        %>40 sizeof(name)
#define %'ModuleName'%.INIT_NAMEBUF(name)
#define %'ModuleName'%.FREE_NAMEBUF(name)

#elif %'ModuleName'%.USE_LFN == 3                                %>40 /* LFN with dynamic LFN working buffer on the heap */
#define %'ModuleName'%.DEF_NAMEBUF(name)                         %>40 uint8_t *name
#define %'ModuleName'%.PTR_NAMEBUF(name)                         %>40 name
#define %'ModuleName'%.SIZE_NAMEBUF(name)                        %>40 (%'ModuleName'%.MAX_LFN+1)
#define %'ModuleName'%.INIT_NAMEBUF(name)                        %>40 { name = ff_memalloc(%'ModuleName'%.MAX_LFN+1); \
                                                                 %>40   if (!name) { \
                                                                 %>40     %@Shell@'ModuleName'%.SendStr((unsigned char*)"ff_memalloc failed!", io->stdErr); \
                                                                 %>40     return ERR_FAILED; \
                                                                 %>40   } \
                                                                 %>40 }
#define %'ModuleName'%.FREE_NAMEBUF(name)                        %>40 ff_memfree(name)

#else
  #error Wrong LFN configuration.
#endif

static void FatFsFResultMsg(uint8_t *msg, %'ModuleName'_FRESULT errNo, const %@Shell@'ModuleName'%.StdIOType *io) {
  unsigned char buf[sizeof("1234")];

  %@Shell@'ModuleName'%.SendStr((unsigned char*)"ERROR: ", io->stdErr);
  %@Shell@'ModuleName'%.SendStr(msg, io->stdErr);
  %@Shell@'ModuleName'%.SendStr((unsigned char*)": (", io->stdErr);
  %@Utility@'ModuleName'%.Num16sToStr(buf, sizeof(buf), (int16_t)errNo);
  %@Shell@'ModuleName'%.SendStr(buf, io->stdErr);
  %@Shell@'ModuleName'%.SendStr((unsigned char*)") ", io->stdErr);
  %@Shell@'ModuleName'%.SendStr((unsigned char*)%'ModuleName'%.errFResultMsg((int)errNo), io->stdErr);
  %@Shell@'ModuleName'%.SendStr((unsigned char*)"\r\n", io->stdErr);
}
%ifdef PrintSector

static void FatFsDResultMsg(uint8_t *msg, %'ModuleName'_DRESULT errNo, const %@Shell@'ModuleName'%.StdIOType *io) {
  unsigned char buf[sizeof("1234")];

  %@Shell@'ModuleName'%.SendStr((unsigned char*)"ERROR: ", io->stdErr);
  %@Shell@'ModuleName'%.SendStr(msg, io->stdErr);
  %@Shell@'ModuleName'%.SendStr((unsigned char*)": (", io->stdErr);
  %@Utility@'ModuleName'%.Num16sToStr(buf, sizeof(buf), (int16_t)errNo);
  %@Shell@'ModuleName'%.SendStr(buf, io->stdErr);
  %@Shell@'ModuleName'%.SendStr((unsigned char*)") ", io->stdErr);
  %@Shell@'ModuleName'%.SendStr((unsigned char*)%'ModuleName'%.errDResultMsg((int)errNo), io->stdErr);
  %@Shell@'ModuleName'%.SendStr((unsigned char*)"\r\n", io->stdErr);
}
%endif %- PrintSector

static void CmdUsageError(const unsigned char *cmd, uint8_t *usage, const %@Shell@'ModuleName'%.StdIOType *io) {
  %@Shell@'ModuleName'%.SendStr((unsigned char*)"*** error while reading command: ", io->stdErr);
  %@Shell@'ModuleName'%.SendStr(cmd, io->stdErr);
  %@Shell@'ModuleName'%.SendStr((unsigned char*)"\r\n*** Usage: ", io->stdErr);
  %@Shell@'ModuleName'%.SendStr((unsigned char*)usage, io->stdErr);
  %@Shell@'ModuleName'%.SendStr((unsigned char*)"\r\n", io->stdErr);
}

static void PrintInASCII(uint8_t *buf, size_t bufSize, size_t LineLen, uint8_t nonASCIIchar, uint8_t fillChar, const %@Shell@'ModuleName'%.StdIOType *io) {
  unsigned int i;
  uint8_t ch;

  /* print in ASCII */
  %@Shell@'ModuleName'%.SendCh(' ', io->stdOut);
  for (i=0; i<bufSize; i++) {
    ch = buf[i];
    if (ch >= ' ' && ch <= 0x7f) {
      %@Shell@'ModuleName'%.SendCh(ch, io->stdOut);
    } else {
      %@Shell@'ModuleName'%.SendCh(nonASCIIchar, io->stdOut); /* place holder */
    }
  }
  for (/*empty*/; i<LineLen; i++) { /* fill up line */
    %@Shell@'ModuleName'%.SendCh(fillChar, io->stdOut);
  }
}

/*!
 * \brief Writes a directory listing of the given path
 * \param[in] dirPathPtr Pointer to a directory path string. Pass e.g. "0:/" for the root directory
 * \param[in] io Callback to write directory output
 * \return Error code, otherwise ERR_OK
 */
static uint8_t PrintDir(const uint8_t *dirPathPtr, const %@Shell@'ModuleName'%.StdIOType *io) {
  %'ModuleName'%.FILINFO fInfo;
  %'ModuleName'%.FRESULT fres;
  uint32_t p1;
  UINT s1, s2;
  %'ModuleName'%.DIR dir;  /* Directory object */
  uint8_t buf[sizeof("yyyy-mm-dd hh:ss")+1];
#if !%'ModuleName'%.FS_READONLY
  %'ModuleName'%.FATFS *fs;
#endif

  %@Shell@'ModuleName'%.SendStr((unsigned char*)"Directory of ", io->stdOut);
  %@Shell@'ModuleName'%.SendStr(dirPathPtr, io->stdOut);
  %@Shell@'ModuleName'%.SendStr((unsigned char*)"\r\n", io->stdOut);
  fres = %'ModuleName'%.f_opendir(&dir, (const TCHAR*)dirPathPtr);
  if (fres != FR_OK) {
    FatFsFResultMsg((unsigned char*)"opendir failed", fres, io);
    return ERR_FAULT;
  }
  p1 = s1 = s2 = 0;
  for(;;) {
    fres = %'ModuleName'%.readdir(&dir, &fInfo);
    if (fres != FR_OK) {
      FatFsFResultMsg((unsigned char*)"readdir failed", fres, io);
      break;
    }
    if (!fInfo.fname[0]) { /* end of directory list */
      break;
    }
    /* file attributes */
    if (fInfo.fattrib & AM_DIR) { /* directory */
      s2++;
      io->stdOut('D');
    } else {
      s1++;
      p1 += fInfo.fsize;
      io->stdOut('-');
    }
    if (fInfo.fattrib & AM_RDO) { /* read only */
      io->stdOut('R');
    } else {
      io->stdOut('-');
    }
    if (fInfo.fattrib & AM_HID) { /* hidden */
      io->stdOut('H');
    } else {
      io->stdOut('-');
    }
    if (fInfo.fattrib & AM_SYS) { /* system */
      io->stdOut('S');
    } else {
      io->stdOut('-');
    }
    if (fInfo.fattrib & AM_ARC) { /* archive */
      io->stdOut('A');
    } else {
      io->stdOut('-');
    }
    io->stdOut(' ');
    /* file date & time */
    buf[0] = '\0';
    %@Utility@'ModuleName'%.strcatNum16sFormatted(buf, sizeof(buf), (int16_t)((fInfo.fdate >> 9) + 1980), ' ', 4); /* year */
    %@Utility@'ModuleName'%.strcat(buf, sizeof(buf), (unsigned char*)"-");
    %@Utility@'ModuleName'%.strcatNum16sFormatted(buf, sizeof(buf), (int16_t)((fInfo.fdate >> 5) & 15), '0', 2); /* month */
    %@Utility@'ModuleName'%.strcat(buf, sizeof(buf), (unsigned char*)"-");
    %@Utility@'ModuleName'%.strcatNum16sFormatted(buf, sizeof(buf), (int16_t)(fInfo.fdate & 31), '0', 2); /* day */
    %@Utility@'ModuleName'%.strcat(buf, sizeof(buf), (unsigned char*)" ");
    %@Utility@'ModuleName'%.strcatNum16sFormatted(buf, sizeof(buf), (int16_t)((fInfo.ftime >> 11)), '0', 2); /* hour */
    %@Utility@'ModuleName'%.strcat(buf, sizeof(buf), (unsigned char*)":");
    %@Utility@'ModuleName'%.strcatNum16sFormatted(buf, sizeof(buf), (int16_t)((fInfo.ftime >> 5) & 63), '0', 2); /* minute */
    %@Shell@'ModuleName'%.SendStr(buf, io->stdOut);
    io->stdOut(' ');
    buf[0] = '\0';
    /* file size */
    %@Utility@'ModuleName'%.strcatNum32uFormatted(buf, sizeof(buf), fInfo.fsize, ' ', 10); /* size */
    %@Shell@'ModuleName'%.SendStr(buf, io->stdOut);
    /* file name */
    io->stdOut(' ');
    %@Shell@'ModuleName'%.SendStr((unsigned char*)fInfo.fname, io->stdOut);
#if %'ModuleName'%.USE_LFN
    io->stdOut(' ');
    %@Shell@'ModuleName'%.SendStr((unsigned char*)fInfo.altname, io->stdOut);
#endif
    io->stdOut('\r');
    io->stdOut('\n');
  }
  /* number of files and bytes used */
  buf[0] = '\0';
  %@Utility@'ModuleName'%.strcatNum16u(buf, sizeof(buf), (uint16_t)s1);
  %@Shell@'ModuleName'%.SendStr(buf, io->stdOut);
  %@Shell@'ModuleName'%.SendStr((unsigned char*)" File(s), ", io->stdOut);
  buf[0] = '\0';
  %@Utility@'ModuleName'%.strcatNum32u(buf, sizeof(buf), p1);
  %@Shell@'ModuleName'%.SendStr(buf, io->stdOut);
  %@Shell@'ModuleName'%.SendStr((unsigned char*)" bytes total\r\n", io->stdOut);
  /* number of directories and number of free bytes */
  buf[0] = '\0';
  %@Utility@'ModuleName'%.strcatNum16u(buf, sizeof(buf), (uint16_t)s2);
  %@Shell@'ModuleName'%.SendStr(buf, io->stdOut);
  %@Shell@'ModuleName'%.SendStr((unsigned char*)" Dir(s)", io->stdOut);
#if !%'ModuleName'%.FS_READONLY
  /* number of free bytes */
  fres = %'ModuleName'%.getfree((const TCHAR*)dirPathPtr, &p1, &fs);
  if (fres != FR_OK) {
    FatFsFResultMsg((unsigned char*)"getfree failed", fres, io);
  } else {
    io->stdOut(',');
    io->stdOut(' ');
    buf[0] = '\0';
    %@Utility@'ModuleName'%.strcatNum32s(buf, sizeof(buf), (long)(p1*fs->csize/2));
    %@Shell@'ModuleName'%.SendStr(buf, io->stdOut);
    %@Shell@'ModuleName'%.SendStr((unsigned char*)" KBytes free", io->stdOut);
  }
#endif
  (void)%'ModuleName'%.f_closedir(&dir); /* close directory */
  io->stdOut('\r');
  io->stdOut('\n');
  return ERR_OK;
}

%-BW_METHOD_BEGIN PrintDirectory
%define! RetVal
%define! PardirName
%define! Pario
%ifdef PrintDirectory
static uint8_t DirCmd(const unsigned char *cmd, const %@Shell@'ModuleName'%.ConstStdIOType *io) {
  /* precondition: cmd starts with "dir" */
  uint8_t res = ERR_OK;
  %'ModuleName'%.DEF_NAMEBUF(fileName);

  %'ModuleName'%.INIT_NAMEBUF(fileName);
  if (*(cmd+sizeof("dir")-1)== ' ') { /* space after "dir": read name */
    if (%@Utility@'ModuleName'%.ReadEscapedName(cmd+sizeof("dir"), (uint8_t*)%'ModuleName'%.PTR_NAMEBUF(fileName),
          %'ModuleName'%.SIZE_NAMEBUF(fileName), NULL, NULL, NULL)==ERR_OK
       )
    {
      /* ok, have now directory name */
    } else {
      %@Shell@'ModuleName'%.SendStr((unsigned char*)"reading directory name failed!\r\n", io->stdErr);
      res = ERR_FAILED;
    }
  } else { /* use current directory */
#if %'ModuleName'%.FS_RPATH >= 2
    %'ModuleName'%.FRESULT fres;
    fres = %'ModuleName'%.getcwd((TCHAR*)%'ModuleName'%.PTR_NAMEBUF(fileName), %'ModuleName'%.SIZE_NAMEBUF(fileName));
    if(fres!=FR_OK) {
      FatFsFResultMsg((unsigned char*)"getcwd failed", fres, io);
      res = ERR_FAILED;
    } else {
      /* ok, have now directory name */
    }
#else
    %@Utility@'ModuleName'%.strcpy(%'ModuleName'%.PTR_NAMEBUF(fileName), %'ModuleName'%.SIZE_NAMEBUF(fileName), (unsigned char*)%'ModuleName'%.CONFIG_DEFAULT_DRIVE_STRING); /* use root */
#endif
  }
  if (res == ERR_OK) {
    res = %'ModuleName'%.%PrintDirectory((const uint8_t*)%'ModuleName'%.PTR_NAMEBUF(fileName), io);
  }
  %'ModuleName'%.FREE_NAMEBUF(fileName);
  return res;
}

%endif %- PrintDirectory
%-BW_METHOD_END PrintDirectory
%-BW_METHOD_BEGIN CopyFile
%define! RetVal
%define! ParsrcFileName
%define! PardstFileName
%define! Pario
%ifdef CopyFile
static uint8_t CopyCmd(const unsigned char *cmd, const %@Shell@'ModuleName'%.ConstStdIOType *io) {
  /* precondition: cmd starts with "copy" */
  uint8_t res = ERR_OK;
  size_t lenRead;
  %'ModuleName'%.DEF_NAMEBUF(fileName);
  %'ModuleName'%.DEF_NAMEBUF(fileName2);

  %'ModuleName'%.INIT_NAMEBUF(fileName);
  %'ModuleName'%.INIT_NAMEBUF(fileName2);
  if (   (%@Utility@'ModuleName'%.ReadEscapedName(cmd+sizeof("copy"), (uint8_t*)%'ModuleName'%.PTR_NAMEBUF(fileName),
          %'ModuleName'%.SIZE_NAMEBUF(fileName), &lenRead, NULL, NULL)==ERR_OK)
      && *(cmd+sizeof("copy")+lenRead)==' '
      && (%@Utility@'ModuleName'%.ReadEscapedName(cmd+sizeof("copy")+lenRead+1, (uint8_t*)%'ModuleName'%.PTR_NAMEBUF(fileName2),
          %'ModuleName'%.SIZE_NAMEBUF(fileName2), NULL, NULL, NULL)==ERR_OK)
     )
  {
    res = %'ModuleName'%.%CopyFile((uint8_t*)%'ModuleName'%.PTR_NAMEBUF(fileName), %'ModuleName'%.PTR_NAMEBUF(fileName2), io);
  } else {
    CmdUsageError(cmd, (unsigned char*)"copy srcFileName dstFileName", io);
    res = ERR_FAILED;
  }
  %'ModuleName'%.FREE_NAMEBUF(fileName);
  %'ModuleName'%.FREE_NAMEBUF(fileName2);
  return res;
}
%endif %- CopyFile
%-BW_METHOD_END CopyFile

%-BW_METHOD_BEGIN DeleteFile
%define! RetVal
%define! ParfileName
%define! Pario
%ifdef DeleteFile
static uint8_t DeleteCmd(const unsigned char *cmd, const %@Shell@'ModuleName'%.ConstStdIOType *io) {
  /* precondition: cmd starts with "delete" */
  uint8_t res = ERR_OK;
  %'ModuleName'%.DEF_NAMEBUF(fileName);

  %'ModuleName'%.INIT_NAMEBUF(fileName);
  if (%@Utility@'ModuleName'%.ReadEscapedName(cmd+sizeof("delete"), (uint8_t*)%'ModuleName'%.PTR_NAMEBUF(fileName),
        %'ModuleName'%.SIZE_NAMEBUF(fileName), NULL, NULL, NULL)==ERR_OK
     )
  {
    res = %'ModuleName'%.%DeleteFile((uint8_t*)%'ModuleName'%.PTR_NAMEBUF(fileName), io);
  } else {
    CmdUsageError(cmd, (unsigned char*)"delete fileName", io);
    res = ERR_FAILED;
  }
  %'ModuleName'%.FREE_NAMEBUF(fileName);
  return res;
}

%endif %- DeleteFile
%-BW_METHOD_END DeleteFile
%-BW_METHOD_BEGIN MakeDirectory
%define! PardirName
%define! Pario
%define! RetVal
%ifdef MakeDirectory
static uint8_t MkdirCmd(const unsigned char *cmd, const %@Shell@'ModuleName'%.ConstStdIOType *io) {
  /* precondition: cmd starts with "mkdir" */
  uint8_t res = ERR_OK;
  %'ModuleName'%.DEF_NAMEBUF(fileName);

  %'ModuleName'%.INIT_NAMEBUF(fileName);
  if (%@Utility@'ModuleName'%.ReadEscapedName(cmd+sizeof("mkdir"), (uint8_t*)%'ModuleName'%.PTR_NAMEBUF(fileName),
        %'ModuleName'%.SIZE_NAMEBUF(fileName), NULL, NULL, NULL)==ERR_OK
     )
  {
    res = %'ModuleName'%.%MakeDirectory((uint8_t*)%'ModuleName'%.PTR_NAMEBUF(fileName), io);
  } else {
    CmdUsageError(cmd, (unsigned char*)"mkdir directoryName", io);
    res = ERR_FAILED;
  }
  %'ModuleName'%.FREE_NAMEBUF(fileName);
  return res;
}

%endif %- MakeDirectory
%-BW_METHOD_END MakeDirectory
static uint8_t RenameCmd(const unsigned char *cmd, const %@Shell@'ModuleName'%.ConstStdIOType *io) {
  /* precondition: cmd starts with "rename" */
  uint8_t res = ERR_OK;
  size_t lenRead;
  %'ModuleName'%.DEF_NAMEBUF(fileName);
  %'ModuleName'%.DEF_NAMEBUF(fileName2);

  %'ModuleName'%.INIT_NAMEBUF(fileName);
  %'ModuleName'%.INIT_NAMEBUF(fileName2);
  if (   (%@Utility@'ModuleName'%.ReadEscapedName(cmd+sizeof("rename"), (uint8_t*)%'ModuleName'%.PTR_NAMEBUF(fileName),
          %'ModuleName'%.SIZE_NAMEBUF(fileName), &lenRead, NULL, NULL)==ERR_OK)
      && *(cmd+sizeof("rename")+lenRead)==' '
      && (%@Utility@'ModuleName'%.ReadEscapedName(cmd+sizeof("rename")+lenRead+1,
          (uint8_t*)%'ModuleName'%.PTR_NAMEBUF(fileName2),
          %'ModuleName'%.SIZE_NAMEBUF(fileName2), NULL, NULL, NULL)==ERR_OK)
     )
  {
    res = %'ModuleName'%.%RenameFile((unsigned char*)%'ModuleName'%.PTR_NAMEBUF(fileName), (unsigned char*)%'ModuleName'%.PTR_NAMEBUF(fileName2), io);
  } else {
    CmdUsageError(cmd, (unsigned char*)"rename srcFileName dstFileName", io);
    res = ERR_FAILED;
  }
  %'ModuleName'%.FREE_NAMEBUF(fileName);
  %'ModuleName'%.FREE_NAMEBUF(fileName2);
  return res;
}
%if defined(PrintSector)

static uint8_t SectorCmd(const unsigned char *cmd, const %@Shell@'ModuleName'%.ConstStdIOType *io) {
  /* precondition: cmd starts with "sector" */
  uint8_t res;
  uint32_t sectorNo;
  const unsigned char *p = cmd+sizeof("printsector");

  res = %@Utility@'ModuleName'%.ScanDecimal32uNumber(&p, &sectorNo);
  if (res == ERR_OK) { /* format fine */
    res = %'ModuleName'%.%PrintSector(0, sectorNo, io);
    if (res!=ERR_OK) {
      return res;
    }
  } else {
    CmdUsageError(cmd, (unsigned char*)"printsector <number>", io);
    return ERR_FAILED;
  }
  return ERR_OK;
}
%endif %-defined(PrintSector)
%if defined(PrintFile)

static uint8_t PrintCmd(const unsigned char *cmd, const %@Shell@'ModuleName'%.ConstStdIOType *io) {
  /* precondition: cmd starts with "print" */
  uint8_t res = ERR_OK;
  %'ModuleName'%.DEF_NAMEBUF(fileName);

  %'ModuleName'%.INIT_NAMEBUF(fileName);
  if (%@Utility@'ModuleName'%.ReadEscapedName(cmd+sizeof("print"), (uint8_t*)%'ModuleName'%.PTR_NAMEBUF(fileName),
        %'ModuleName'%.SIZE_NAMEBUF(fileName), NULL, NULL, NULL)==ERR_OK
     )
  {
    res = %'ModuleName'%.%PrintFile((uint8_t*)%'ModuleName'%.PTR_NAMEBUF(fileName), io);
  } else {
    CmdUsageError(cmd, (unsigned char*)"print fileName", io);
    res = ERR_FAILED;
  }
  %'ModuleName'%.FREE_NAMEBUF(fileName);
  return res;
}

%endif %-defined(PrintFile)
%if defined(PrintHexFile)
static uint8_t PrintHexCmd(const unsigned char *cmd, const %@Shell@'ModuleName'%.ConstStdIOType *io) {
  /* precondition: cmd starts with "printhex" */
  uint8_t res = ERR_OK;
  %'ModuleName'%.DEF_NAMEBUF(fileName);

  %'ModuleName'%.INIT_NAMEBUF(fileName);
  if (%@Utility@'ModuleName'%.ReadEscapedName(cmd+sizeof("printhex"), (uint8_t*)%'ModuleName'%.PTR_NAMEBUF(fileName),
        %'ModuleName'%.SIZE_NAMEBUF(fileName), NULL, NULL, NULL)==ERR_OK
     )
  {
    res = %'ModuleName'%.%PrintHexFile((uint8_t*)%'ModuleName'%.PTR_NAMEBUF(fileName), io);
  } else {
    CmdUsageError(cmd, (unsigned char*)"printhex fileName", io);
    res = ERR_FAILED;
  }
  %'ModuleName'%.FREE_NAMEBUF(fileName);
  return res;
}
%endif %-defined(PrintHexFile)
%if defined(ChangeDirectory)

static uint8_t CdCmd(const unsigned char *cmd, const %@Shell@'ModuleName'%.ConstStdIOType *io) {
  /* precondition: cmd starts with "cd" */
#if %'ModuleName'%.FS_RPATH > 0
  uint8_t res = ERR_OK;
  %'ModuleName'%.DEF_NAMEBUF(fileName);

  %'ModuleName'%.INIT_NAMEBUF(fileName);
  if (*(cmd+sizeof("cd")-1)== ' ') { /* space after "cd": read name */
    if (%@Utility@'ModuleName'%.ReadEscapedName(cmd+sizeof("cd"), (uint8_t*)%'ModuleName'%.PTR_NAMEBUF(fileName),
          %'ModuleName'%.SIZE_NAMEBUF(fileName), NULL, NULL, NULL)==ERR_OK
       )
    {
      res = %'ModuleName'%.%ChangeDirectory((uint8_t*)%'ModuleName'%.PTR_NAMEBUF(fileName), io);
    } else {
      %@Shell@'ModuleName'%.SendStr((unsigned char*)"reading directory name failed!\r\n", io->stdErr);
      res = ERR_FAILED;
    }
  } else { /* print current directory */
#if %'ModuleName'%.FS_RPATH >= 2
    %'ModuleName'%.FRESULT fres;

    fres = %'ModuleName'%.getcwd((TCHAR*)%'ModuleName'%.PTR_NAMEBUF(fileName), %'ModuleName'%.SIZE_NAMEBUF(fileName));
    if(fres!=FR_OK) {
      FatFsFResultMsg((unsigned char*)"getcwd failed", fres, io);
      res = ERR_FAILED;
    } else {
      %@Shell@'ModuleName'%.SendStr((uint8_t*)%'ModuleName'%.PTR_NAMEBUF(fileName), io->stdOut);
      %@Shell@'ModuleName'%.SendStr((unsigned char*)"\r\n", io->stdOut);
    }
#else
    %@Utility@'ModuleName'%.strcpy(%'ModuleName'%.PTR_NAMEBUF(fileName), %'ModuleName'%.SIZE_NAMEBUF(fileName), (unsigned char*)%'ModuleName'%.CONFIG_DEFAULT_DRIVE_STRING); /* use root */
#endif
  }
  %'ModuleName'%.FREE_NAMEBUF(fileName);
  return res;
#else
  (void)cmd;
  #warning "relative directories not enabled in FatFS!"
  %@Shell@'ModuleName'%.SendStr((unsigned char*)"relative directories not available in file system\r\n", io->stdErr);
  return ERR_FAILED;
#endif
}

%endif %- defined(ChangeDirectory)
%if defined(CreateFile)

static uint8_t CreateCmd(const unsigned char *cmd, const %@Shell@'ModuleName'%.ConstStdIOType *io) {
  /* precondition: cmd starts with "create" */
  uint8_t res = ERR_OK;
  %'ModuleName'%.DEF_NAMEBUF(fileName);

  %'ModuleName'%.INIT_NAMEBUF(fileName);
  if (%@Utility@'ModuleName'%.ReadEscapedName(cmd+sizeof("create"), (uint8_t*)%'ModuleName'%.PTR_NAMEBUF(fileName),
        %'ModuleName'%.SIZE_NAMEBUF(fileName), NULL, NULL, NULL)==ERR_OK
     )
  {
    res = %'ModuleName'%.%CreateFile((uint8_t*)%'ModuleName'%.PTR_NAMEBUF(fileName), io);
  } else {
    CmdUsageError(cmd, (unsigned char*)"create fileName", io);
    res = ERR_FAILED;
  }
  %'ModuleName'%.FREE_NAMEBUF(fileName);
  return res;
}

%endif %-defined(CreateFile)
static uint8_t PrintStatus(const %@Shell@'ModuleName'%.StdIOType *io) {
  %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"%'ModuleName'", (unsigned char*)"FatFs status\r\n", io->stdOut);
%for i from [0..%maxDrive]
  %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"  present", %'ModuleName'%.isDiskPresent((uint8_t*)"%i")?(unsigned char*)"drive%i: yes\r\n":(unsigned char*)"drive%i: no\r\n", io->stdOut);
  %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"  protected", %'ModuleName'%.isWriteProtected((uint8_t*)"%i")?(unsigned char*)"drive%i: yes\r\n":(unsigned char*)"drive%i: no\r\n", io->stdOut);
%endfor
  %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"  default drv", (unsigned char*)%'ModuleName'%.CONFIG_DEFAULT_DRIVE_STRING "\r\n", io->stdOut);
  return ERR_OK;
}

static uint8_t PrintHelp(const %@Shell@'ModuleName'%.StdIOType *io) {
  %@Shell@'ModuleName'%.SendHelpStr((unsigned char*)"%'ModuleName'", (unsigned char*)"Group of %'ModuleName' commands\r\n", io->stdOut);
  %@Shell@'ModuleName'%.SendHelpStr((unsigned char*)"  help|status", (unsigned char*)"Print help or status information\r\n", io->stdOut);
%ifdef ChangeDirectory
  %@Shell@'ModuleName'%.SendHelpStr((unsigned char*)"  cd [<directoryName>]", (const unsigned char*)"Change the current directory or display the name of the current directory\r\n", io->stdOut);
%endif %- ChangeDirectory
%ifdef PrintDirectory
  %@Shell@'ModuleName'%.SendHelpStr((unsigned char*)"  dir [<directoryName>]", (const unsigned char*)"Prints a directory\r\n", io->stdOut);
%endif %- PrintDirectory
%ifdef CopyFile
  %@Shell@'ModuleName'%.SendHelpStr((unsigned char*)"  copy <src> <dst>", (const unsigned char*)"Copy a file\r\n", io->stdOut);
%endif %- CopyFile
%ifdef DeleteFile
  %@Shell@'ModuleName'%.SendHelpStr((unsigned char*)"  delete <filename>", (const unsigned char*)"Delete a file\r\n", io->stdOut);
%endif %- DeleteFile
%ifdef CreateFile
  %@Shell@'ModuleName'%.SendHelpStr((unsigned char*)"  create <filename>", (const unsigned char*)"Create a file\r\n", io->stdOut);
%endif %- CreateFile
%ifdef MakeDirectory
  %@Shell@'ModuleName'%.SendHelpStr((unsigned char*)"  mkdir <directory>", (const unsigned char*)"Create a directory\r\n", io->stdOut);
%endif %- MakeDirectory
%ifdef RenameFile
  %@Shell@'ModuleName'%.SendHelpStr((unsigned char*)"  rename <src> <dst>", (const unsigned char*)"Rename a file\r\n", io->stdOut);
%endif %- RenameFile
%ifdef PrintFile
  %@Shell@'ModuleName'%.SendHelpStr((unsigned char*)"  print <filename>", (const unsigned char*)"Print a file\r\n", io->stdOut);
%endif %- PrintFile
%ifdef PrintHexFile
  %@Shell@'ModuleName'%.SendHelpStr((unsigned char*)"  printhex <filename>", (const unsigned char*)"Print a file as hexdump\r\n", io->stdOut);
%endif %- PrintHexFile
%ifdef PrintSector
  %@Shell@'ModuleName'%.SendHelpStr((unsigned char*)"  printsector <number>", (const unsigned char*)"Print disk sector\r\n", io->stdOut);
%endif %- PrintSector
%ifdef PrintDiskInfo
  %@Shell@'ModuleName'%.SendHelpStr((unsigned char*)"  diskinfo", (const unsigned char*)"Print disk information\r\n", io->stdOut);
%endif %- PrintDiskInfo
%ifdef Benchmark
  %@Shell@'ModuleName'%.SendHelpStr((unsigned char*)"  benchmark", (const unsigned char*)"Run disk benchmark\r\n", io->stdOut);
%endif %- Benchmark
  return ERR_OK;
}

%endif
%-BW_CUSTOM_VARIABLE_END
%-BW_INTERN_METHOD_DECL_START
%- List of internal methods headers
%-BW_INTERN_METHOD_DECL_END
%-BW_IMPLEMENT_START
%-************************************************************************************************************

/* Unicode support functions */
#if %'ModuleName'%.USE_LFN  /* Unicode - OEM code conversion */
#if %'ModuleName'%.USE_LFN == 3   /* Memory functions */
void *ff_memalloc(UINT size) { /* Allocate memory block */
%if defined(RTOS)
  /* FreeRTOS */
  return %@RTOS@'ModuleName'%.pvPortMalloc(size);
%else
  #error "No RTOS defined?"
%endif
}

void ff_memfree (void* ptr) {  /* Free memory block */
%if defined(RTOS)
  /* FreeRTOS */
  %@RTOS@'ModuleName'%.vPortFree(ptr);
%else
  #error "No RTOS defined?"
%endif
}
#endif
#endif

#if %'ModuleName'%.FS_REENTRANT
/*!
* \brief Create a Synchronization Object
* This function is called in f_mount function to create a new
* synchronization object, such as semaphore and mutex. When a FALSE is
* returned, the f_mount function fails with FR_INT_ERR.
* \param[in] vol Corresponding logical drive being processed
* \param[out] sobj Pointer to return the created sync object
* \return TRUE: Function succeeded, FALSE: Could not create due to any error
*/
%if defined(UserSyncFunctions) & %UserSyncFunctions='yes'
#if 0
int ff_cre_syncobj(uint8_t vol, %'ModuleName'%.SYNC_t *sobj)
{
  /* You have decided in the component properties to implement your own user sync functions,
     with you own %'ModuleName'%.SYNC_t type (e.g. HANDLE).
     You need to implement your own version of this function in your application.
  */
}
#endif
%else
#if configSUPPORT_STATIC_ALLOCATION
  static StaticSemaphore_t xMutexBuffer[_VOLUMES];
#endif

int ff_cre_syncobj(uint8_t vol, %'ModuleName'%.SYNC_t *sobj) {
  (void)vol; /* argument not used */
%if defined(RTOS)
#if configSUPPORT_STATIC_ALLOCATION
  *sobj = xSemaphoreCreateMutexStatic(&xMutexBuffer[vol]);
#else
  *sobj = xSemaphoreCreateMutex(); /* create semaphore */
#endif
  %if defined(OnCreateSyncObject)
  %OnCreateSyncObject(*sobj);
  %endif
  if (*sobj!=NULL) {
    vQueueAddToRegistry(*sobj, "%'ModuleName'%.Mutex");
  }
  return (*sobj != NULL) ? TRUE : FALSE;
%- *sobj = OSMutexCreate(0, &err);                         /* uC/OS-II */
%- ret = (err == OS_NO_ERR) ? TRUE : FALSE;
%else
  /* %'ModuleName'%.FS_REENTRANT enabled, no RTOS enabled, and you don't want to provide your own sync method.
     That means that you cannot have parallel access to the file system object.
     If you have parallel access to the memory bus, you need to handle this from the memory component.
   */
  (void)sobj;
  return TRUE;
%endif
}
%endif

/*!
* \brief Delete a Synchronization Object
* This function is called in f_mount function to delete a synchronization
* object that created with ff_cre_syncobj function. When a FALSE is
* returned, the f_mount function fails with FR_INT_ERR.
* \param[out] sobj Sync object tied to the logical drive to be deleted
* \return TRUE: Function succeeded, FALSE: Could not create due to any error
*/
%if defined(UserSyncFunctions) & %UserSyncFunctions='yes'
#if 0
int ff_del_syncobj(%'ModuleName'%.SYNC_t sobj) {
  /* You have decided in the component properties to implement your own user sync functions,
     with you own %'ModuleName'%.SYNC_t type (e.g. HANDLE).
     You need to implement your own version of this function in your application.
  */
}
#endif
%else
int ff_del_syncobj(%'ModuleName'%.SYNC_t sobj) {
%if defined(RTOS)
  vQueueUnregisterQueue(sobj);
  %@RTOS@'ModuleName'%.vSemaphoreDelete(sobj); /* FreeRTOS: free up memory for semaphore */
  return TRUE; /* everything ok */
%-      OSMutexDel(sobj, OS_DEL_ALWAYS, &err);          /* uC/OS-II */
%-      ret = (err == OS_NO_ERR) ? TRUE : FALSE;
%else
  /* %'ModuleName'%.FS_REENTRANT enabled, no RTOS enabled, and you don't want to provide your own sync method.
     That means that you cannot have parallel access to the file system object.
     If you have parallel access to the memory bus, you need to handle this from the memory component.
   */
  (void)sobj; /* unused parameter */
  return TRUE;
%endif
}
%endif

/*!
* \brief Request Grant to Access the Volume
* This function is called on entering file functions to lock the volume.
* When a FALSE is returned, the file function fails with FR_TIMEOUT.
* \param[in] sobj Sync object to wait
* \return TRUE: Function succeeded, FALSE: Could not create due to any error
*/
%if defined(UserSyncFunctions) & %UserSyncFunctions='yes'
#if 0
int ff_req_grant (%'ModuleName'%.SYNC_t sobj) {
  /* You have decided in the component properties to implement your own user sync functions,
     with you own %'ModuleName'%.SYNC_t type (e.g. HANDLE).
     You need to implement your own version of this function in your application.
  */
}
#endif
%else
int ff_req_grant (%'ModuleName'%.SYNC_t sobj) {
%if defined(RTOS)
  if (%@RTOS@'ModuleName'%.xSemaphoreTake(sobj, %'ModuleName'%.FS_TIMEOUT) == pdTRUE) {
    return TRUE; /* success */
  } else {  /* failed to get the sync object? */
    return FALSE; /* failure */
  }
%-      OSMutexPend(sobj, _FS_TIMEOUT, &err));                  /* uC/OS-II */
%-      return (err == OS_NO_ERR) ? TRUE : FALSE;
%else
  /* %'ModuleName'%.FS_REENTRANT enabled, no RTOS enabled, and you don't want to provide your own sync method.
     That means that you cannot have parallel access to the file system object.
     If you have parallel access to the memory bus, you need to handle this from the memory component.
   */
  (void)sobj; /* unused parameter */
  return TRUE; /* success */
%endif
}
%endif

/*!
* \brief Release Grant to Access the Volume
* This function is called on leaving file functions to unlock the volume.
* \param[in] sobj Sync object to be signaled
*/
%if defined(UserSyncFunctions) & %UserSyncFunctions='yes'
#if 0
void ff_rel_grant (%'ModuleName'%.SYNC_t sobj) {
  /* You have decided in the component properties to implement your own user sync functions,
     with you own %'ModuleName'%.SYNC_t type (e.g. HANDLE).
     You need to implement your own version of this function in your application.
  */
}
#endif
%else
void ff_rel_grant (%'ModuleName'%.SYNC_t sobj) {
%if defined(RTOS)
  (void)%@RTOS@'ModuleName'%.xSemaphoreGive(sobj); /* FreeRTOS */
%-      OSMutexPost(sobj);              /* uC/OS-II */
%else
  /* %'ModuleName'%.FS_REENTRANT enabled, no RTOS enabled, and you don't want to provide your own sync method.
     That means that you cannot have parallel access to the file system object.
     If you have parallel access to the memory bus, you need to handle this from the memory component.
   */
  (void)sobj; /* unused parameter */
%endif
}
%endif
#endif /* %'ModuleName'%.FS_REENTRANT */

%-BW_METHOD_BEGIN open
%ifdef open
%define! Parfp
%define! Parpath
%define! Parmode
%define! RetVal
%include Common\FAT_FileSystemopen.Inc
/*
FRESULT %'ModuleName'%.%open(FIL *fp, const XCHAR *path, BYTE mode)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- open
%-BW_METHOD_END open
%-************************************************************************************************************
%-BW_METHOD_BEGIN close
%ifdef close
%define! Parfp
%define! RetVal
%include Common\FAT_FileSystemclose.Inc
/*
FRESULT %'ModuleName'%.%close(FIL *fp)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- close
%-BW_METHOD_END close
%-************************************************************************************************************
%-BW_METHOD_BEGIN read
%ifdef read
%define! Parfp
%define! Parbuff
%define! Parbtr
%define! Parbr
%define! RetVal
%include Common\FAT_FileSystemread.Inc
/*
FRESULT %'ModuleName'%.%read(FIL *fp, void *buff, UINT btr, UINT *br)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- read
%-BW_METHOD_END read
%-************************************************************************************************************
%-BW_METHOD_BEGIN write
%ifdef write
%define! Parfp
%define! Parbuff
%define! Parbtw
%define! Parbw
%define! RetVal
%include Common\FAT_FileSystemwrite.Inc
/*
FRESULT %'ModuleName'%.%write(FIL *fp, const *void buff, UINT btw, UINT *bw)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- write
%-BW_METHOD_END write
%-************************************************************************************************************
%-BW_METHOD_BEGIN opendir
%ifdef opendir
%define! Pardj
%define! Parpath
%define! RetVal
%include Common\FAT_FileSystemopendir.Inc
/*
FRESULT %'ModuleName'%.%opendir(DIR *dj, const XCHAR *path)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- opendir
%-BW_METHOD_END opendir
%-************************************************************************************************************
%-BW_METHOD_BEGIN readdir
%ifdef readdir
%define! Pardir
%define! Parfno
%define! RetVal
%include Common\FAT_FileSystemreaddir.Inc
/*
FRESULT %'ModuleName'%.%readdir(DIR *dj, FILINFO *fno)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- readdir
%-BW_METHOD_END readdir
%-************************************************************************************************************
%-BW_METHOD_BEGIN lseek
%ifdef lseek
%define! Parfp
%define! Parofs
%define! RetVal
%include Common\FAT_FileSystemlseek.Inc
/*
FRESULT %'ModuleName'%.%lseek(FIL *fp, DWORD ofs)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- lseek
%-BW_METHOD_END lseek
%-************************************************************************************************************
%-BW_METHOD_BEGIN unlink
%ifdef unlink
%define! Parpath
%define! RetVal
%include Common\FAT_FileSystemunlink.Inc
/*
FRESULT %'ModuleName'%.%unlink(const XCHAR *path)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- unlink
%-BW_METHOD_END unlink
%-************************************************************************************************************
%-BW_METHOD_BEGIN mount
%ifdef mount
%define! Parfs
%define! Parpath
%define! Paropt
%define! RetVal
%include Common\FAT_FileSystemmount.Inc
/*
FRESULT %'ModuleName'%.%mount(FATFS *fs, const TCHAR* path, uint8_t opt)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- mount
%-BW_METHOD_END mount
%-************************************************************************************************************
%-BW_METHOD_BEGIN getfree
%ifdef getfree
%define! Parpath
%define! Parnclst
%define! Parfatfs
%define! RetVal
%include Common\FAT_FileSystemgetfree.Inc
/*
FRESULT %'ModuleName'%.%getfree(const XCHAR *path, dword *nclst, FATFS **fatfs)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- getfree
%-BW_METHOD_END getfree
%-************************************************************************************************************
%-BW_METHOD_BEGIN sync
%ifdef sync
%define! Parfp
%define! RetVal
%include Common\FAT_FileSystemsync.Inc
/*
FRESULT %'ModuleName'%.%sync(FIL *fp)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- sync
%-BW_METHOD_END sync
%-************************************************************************************************************
%-BW_METHOD_BEGIN rename
%ifdef rename
%define! Parpath_old
%define! Parpath_new
%define! RetVal
%include Common\FAT_FileSystemrename.Inc
/*
FRESULT %'ModuleName'%.%rename(const XCHAR *path_old, const XCHAR *path_new)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- rename
%-BW_METHOD_END rename
%-************************************************************************************************************
%-BW_METHOD_BEGIN mkdir
%ifdef mkdir
%define! Parpath
%define! RetVal
%include Common\FAT_FileSystemmkdir.Inc
/*
FRESULT %'ModuleName'%.%mkdir(const XCHAR *path)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- mkdir
%-BW_METHOD_END mkdir
%-************************************************************************************************************
%-BW_METHOD_BEGIN chmod
%ifdef chmod
%define! ParFileName
%define! ParAttribute
%define! ParAttributeMask
%define! RetVal
%include Common\FAT_FileSystemchmod.Inc
/*
FRESULT %'ModuleName'%.%chmod(const TCHAR* FileName, uint8_t Attribute, uint8_t AttributeMask)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- chmod
%-BW_METHOD_END chmod
%-************************************************************************************************************
%-BW_METHOD_BEGIN truncate
%ifdef truncate
%define! ParFileObject
%define! RetVal
%include Common\FAT_FileSystemtruncate.Inc
/*
FRESULT %'ModuleName'%.%truncate(FIL *FileObject)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- truncate
%-BW_METHOD_END truncate
%-************************************************************************************************************
%-BW_METHOD_BEGIN stat
%ifdef stat
%define! ParFileName
%define! ParFileInfo
%define! RetVal
%include Common\FAT_FileSystemstat.Inc
/*
FRESULT %'ModuleName'%.%stat(const TCHAR* FileName, FILINFO* FileInfo)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- stat
%-BW_METHOD_END stat
%-************************************************************************************************************
%-BW_METHOD_BEGIN utime
%ifdef utime
%define! ParFileName
%define! ParTimeDate
%define! RetVal
%include Common\FAT_FileSystemutime.Inc
/*
FRESULT %'ModuleName'%.%utime(const TCHAR* FileName, const FILINFO* TimeDate)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- utime
%-BW_METHOD_END utime
%-************************************************************************************************************
%-BW_METHOD_BEGIN mkfs
%ifdef mkfs
%define! Pardrive
%define! ParPartitioningRule
%define! ParAllocSize
%define! RetVal
%include Common\FAT_FileSystemmkfs.Inc
/*
FRESULT %'ModuleName'%.%mkfs(uint8_t drive, uint8_t PartitioningRule, UINT  AllocSize)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- mkfs
%-BW_METHOD_END mkfs
%-************************************************************************************************************
%-BW_METHOD_BEGIN forward
%ifdef forward
%define! ParFileObject
%define! ParFunc
%define! ParByteToFwd
%define! ParByteFwd
%define! RetVal
%include Common\FAT_FileSystemforward.Inc
/*
FRESULT %'ModuleName'%.%forward(FIL* FileObject, UINT (*Func)(const BYTE*,UINT), UINT ByteToFwd, UINT* ByteFwd )
{
  *** method is implemented as macro in the header file
}
*/

%endif %- forward
%-BW_METHOD_END forward
%-************************************************************************************************************
%-BW_METHOD_BEGIN chdir
%ifdef chdir
%define! ParPath
%define! RetVal
%include Common\FAT_FileSystemchdir.Inc
/*
FRESULT %'ModuleName'%.%chdir(const TCHAR* Path)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- chdir
%-BW_METHOD_END chdir
%-************************************************************************************************************
%-BW_METHOD_BEGIN chdrive
%ifdef chdrive
%define! ParDrive
%define! RetVal
%include Common\FAT_FileSystemchdrive.Inc
/*
FRESULT %'ModuleName'%.%chdrive(uint8_t Drive)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- chdrive
%-BW_METHOD_END chdrive
%-************************************************************************************************************
%-BW_METHOD_BEGIN getcwd
%ifdef getcwd
%define! ParBuffer
%define! ParBufferLen
%define! RetVal
%include Common\FAT_FileSystemgetcwd.Inc
/*
FRESULT %'ModuleName'%.%getcwd(TCHAR* Buffer, UINT BufferLen)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- getcwd
%-BW_METHOD_END getcwd
%-************************************************************************************************************
%-BW_METHOD_BEGIN errFResultMsg
%ifdef errFResultMsg
%define! ParerrNo
%define! RetVal
%include Common\FAT_FileSystemerrFResultMsg.Inc
char* %'ModuleName'%.%errFResultMsg(int errNo)
{
  switch(errNo) {
    case FR_OK:                  return (char*)"Succeeded";
    case FR_DISK_ERR:            return (char*)"A hard error occurred in the low level disk I/O layer";
    case FR_INT_ERR:             return (char*)"Assertion failed";
    case FR_NOT_READY:           return (char*)"The physical drive cannot work";
    case FR_NO_FILE:             return (char*)"Could not find the file";
    case FR_NO_PATH:             return (char*)"Could not find the path";
    case FR_INVALID_NAME:        return (char*)"The path name format is invalid";
    case FR_DENIED:              return (char*)"Access denied due to prohibited access or directory full";
    case FR_EXIST:               return (char*)"Access denied due to prohibited access";
    case FR_INVALID_OBJECT:      return (char*)"The file/directory object is invalid";
    case FR_WRITE_PROTECTED:     return (char*)"The physical drive is write protected";
    case FR_INVALID_DRIVE:       return (char*)"The logical drive number is invalid";
    case FR_NOT_ENABLED:         return (char*)"The volume has no work area";
    case FR_NO_FILESYSTEM:       return (char*)"There is no valid FAT volume on the physical drive";
    case FR_MKFS_ABORTED:        return (char*)"The f_mkfs() aborted due to any parameter error";
    case FR_TIMEOUT:             return (char*)"Could not get a grant to access the volume within defined period";
    case FR_LOCKED:              return (char*)"The operation is rejected according to the file sharing policy";
    case FR_NOT_ENOUGH_CORE:     return (char*)"LFN working buffer could not be allocated";
    case FR_TOO_MANY_OPEN_FILES: return (char*)"Number of open files > _FS_SHARE";
    /*default:                     return (char*)"unknown";*/
  } /* switch */
  return (char*)"*error*";
}

%endif %- errFResultMsg
%-BW_METHOD_END errFResultMsg
%-************************************************************************************************************
%-BW_METHOD_BEGIN errDResultMsg
%ifdef errDResultMsg
%define! ParerrNo
%define! RetVal
%include Common\FAT_FileSystemerrDResultMsg.Inc
char* %'ModuleName'%.%errDResultMsg(int errNo)
{
  switch(errNo) {
    case RES_OK:     return (char*)"Successful";
    case RES_ERROR:  return (char*)"R/W Error";
    case RES_WRPRT:  return (char*)"Write Protected";
    case RES_NOTRDY: return (char*)"Not Ready";
    case RES_PARERR: return (char*)"Invalid Parameter";
    /*default:         return (char*)"unknown";*/
  } /* switch */
  return (char*)"*error*";
}

%endif %- errDResultMsg
%-BW_METHOD_END errDResultMsg
%-************************************************************************************************************
%-BW_METHOD_BEGIN isWriteProtected
%ifdef isWriteProtected
%define! PardrvStr
%define! RetVal
%include Common\FAT_FileSystemisWriteProtected.Inc
bool %'ModuleName'%.%isWriteProtected(uint8_t *drvStr)
{
%if WriteEnabled='no'
  return %'ModuleName'%.FS_READONLY;
%else
  uint8_t drv;

  drv = StrToDriveNumber(drvStr);
#if %@sdk@'ModuleName'%.CONFIG_SDK_VERSION_USED == %@sdk@'ModuleName'%.CONFIG_SDK_PROCESSOR_EXPERT
  switch(drv) {
    %for i from [0..%maxDrive]
    case %i:
      return %@Drive%i@'ModuleName'%.isWriteProtected();
    %endfor
    default:
      break;
  } /* switch */
  return TRUE;
#else
  return %'ModuleName'%.CONFIG_IS_WRITE_PROTECTED_CALLBACK(drv);
#endif
%endif
}

%endif %- isWriteProtected
%-BW_METHOD_END isWriteProtected
%-************************************************************************************************************
%-BW_METHOD_BEGIN isDiskPresent
%ifdef isDiskPresent
%define! PardrvStr
%define! RetVal
%include Common\FAT_FileSystemisDiskPresent.Inc
bool %'ModuleName'%.%isDiskPresent(uint8_t *drvStr)
{
  uint8_t drv;

  drv = StrToDriveNumber(drvStr);
#if %@sdk@'ModuleName'%.CONFIG_SDK_VERSION_USED == %@sdk@'ModuleName'%.CONFIG_SDK_PROCESSOR_EXPERT
  switch(drv) {
    %for i from [0..%maxDrive]
    case %i:
      return %@Drive%i@'ModuleName'%.CardPresent();
    %endfor
    default:
      break;
  } /* switch */
  return FALSE;
#else
  return %'ModuleName'%.CONFIG_IS_DISK_PRESENT_CALLBACK(drv);
#endif
}

%endif %- isDiskPresent
%-BW_METHOD_END isDiskPresent
%-************************************************************************************************************
%-BW_METHOD_BEGIN f_gets
%ifdef f_gets
%define! Parbuff
%define! Parlen
%define! Parfil
%define! RetVal
%include Common\FAT_FileSystemf_gets.Inc
/*
%'ModuleName'_CHARP %'ModuleName'%.%f_gets(TCHAR* buff, int len, FIL *fil)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- f_gets
%-BW_METHOD_END f_gets
%-************************************************************************************************************
%-BW_METHOD_BEGIN f_puts
%ifdef f_puts
%define! Parbuff
%define! Parfil
%define! RetVal
%include Common\FAT_FileSystemf_puts.Inc
/*
%'ModuleName'_INT %'ModuleName'%.%f_puts(const TCHAR* str, FIL *fil)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- f_puts
%-BW_METHOD_END f_puts
%-************************************************************************************************************
%-BW_METHOD_BEGIN f_putc
%ifdef f_putc
%define! Parbuff
%define! Parfil
%define! RetVal
%include Common\FAT_FileSystemf_putc.Inc
/*
%'ModuleName'_INT %'ModuleName'%.%f_putc(TCHAR c, FIL *fil)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- f_putc
%-BW_METHOD_END f_putc
%-************************************************************************************************************
%-BW_METHOD_BEGIN f_printf
%ifdef f_printf
%define! ParVariable_1
%define! Parstr
%define! ParVariable_2
%define! RetVal
%include Common\FAT_FileSystemf_printf.Inc
/*
%'ModuleName'_INT %'ModuleName'%.%f_printf(FIL* fil, const TCHAR* str, ...)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- f_printf
%-BW_METHOD_END f_printf
%-************************************************************************************************************
%-BW_METHOD_BEGIN f_eof
%ifdef f_eof
%define! Parfp
%define! RetVal
%include Common\FAT_FileSystemf_eof.Inc
/*
uint8_t %'ModuleName'%.%f_eof(FIL *fil)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- f_eof
%-BW_METHOD_END f_eof
%-************************************************************************************************************
%-BW_METHOD_BEGIN f_error
%ifdef f_error
%define! Parfp
%define! RetVal
%include Common\FAT_FileSystemf_error.Inc
/*
uint8_t %'ModuleName'%.%f_error(FIL *fil)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- f_error
%-BW_METHOD_END f_error
%-************************************************************************************************************
%-BW_METHOD_BEGIN f_tell
%ifdef f_tell
%define! Parfp
%define! RetVal
%include Common\FAT_FileSystemf_tell.Inc
/*
dword %'ModuleName'%.%f_tell(FIL *fil)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- f_tell
%-BW_METHOD_END f_tell
%-************************************************************************************************************
%-BW_METHOD_BEGIN f_size
%ifdef f_size
%define! Parfp
%define! RetVal
%include Common\FAT_FileSystemf_size.Inc
/*
dword %'ModuleName'%.%f_size(FIL *fil)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- f_size
%-BW_METHOD_END f_size
%-************************************************************************************************************
%-BW_METHOD_BEGIN Init
%ifdef Init
%define! RetVal
%include Common\FAT_FileSystemInit.Inc
uint8_t %'ModuleName'%.%Init(void)
{
  uint8_t res = ERR_OK;
#if %@sdk@'ModuleName'%.CONFIG_SDK_VERSION_USED == %@sdk@'ModuleName'%.CONFIG_SDK_PROCESSOR_EXPERT
%for i from [0..%maxDrive]
  if (%@Drive%i@'ModuleName'%.Init(NULL)!=ERR_OK) {
    res = ERR_FAILED;
  }
%endfor
#endif
  return res;
}

%endif %- Init
%-BW_METHOD_END Init
%-************************************************************************************************************
%-BW_METHOD_BEGIN Deinit
%ifdef Deinit
%define! RetVal
%include Common\FAT_FileSystemDeinit.Inc
uint8_t %'ModuleName'%.%Deinit(void)
{
  uint8_t res = ERR_OK;
#if %@sdk@'ModuleName'%.CONFIG_SDK_VERSION_USED == %@sdk@'ModuleName'%.CONFIG_SDK_PROCESSOR_EXPERT
%for i from [0..%maxDrive]
  if (%@Drive%i@'ModuleName'%.Deinit(NULL)!=ERR_OK) {
    res = ERR_FAILED;
  }
%endfor
#endif
  return res;
}

%endif %- Deinit
%-BW_METHOD_END Deinit
%-************************************************************************************************************
%-BW_METHOD_BEGIN get_fattime
%ifdef get_fattime
%if defined(UseTimeDate) & %UseTimeDate='no'
#if 0 /* usage of DateTime component disabled in properties */
%endif

#if !%'ModuleName'%.FS_READONLY
%define! RetVal
%include Common\FAT_FileSystemget_fattime.Inc
uint32_t %'ModuleName'%.%get_fattime(void)
{
  /* 31-25: Year(0-127 org.1980), 24-21: Month(1-12), 20-16: Day(1-31) */
  /* 15-11: Hour(0-23), 10-5: Minute(0-59), 4-0: Second(0-29 *2) */
  /* Pack date and time into a uint32_t variable */
%if defined(RTC)
  TIMEREC time;
  DATEREC date;
  uint8_t res;

  res = %@RTC@'ModuleName'%.GetTime(&time);                      %>40 /* get time information */
  if (res!=ERR_OK) {
    return 0; /* failed */
  }
  res = %@RTC@'ModuleName'%.GetDate(&date);                      %>40 /* get date information */
  if (res!=ERR_OK) {
    return 0; /* failed */
  }
  return ((uint32_t)(date.Year - 1980) << 25)
       | ((uint32_t)date.Month << 21)
       | ((uint32_t)date.Day << 16)
       | ((uint32_t)time.Hour << 11)
       | ((uint32_t)time.Min << 5)
       | ((uint32_t)time.Sec);
%else
  /* Get time and date information and store it in 'time' and 'date'.
     If not using the DateTime component, you need to implement your own method here.
   */
  return 0;
%endif
}

uint32_t get_fattime(void) {
  return %'ModuleName'%.get_fattime();
}
#endif /* !%'ModuleName'%.FS_READONLY */

%if defined(UseTimeDate) & %UseTimeDate='no'
#endif /* usage of DateTime component disabled in properties */
%endif

%endif %- get_fattime
%-BW_METHOD_END get_fattime
%-************************************************************************************************************
%-BW_METHOD_BEGIN ParseCommand
%ifdef ParseCommand
%define! Parcmd
%define! Parhandled
%define! Pario
%define! RetVal
%include Common\FAT_FileSystemParseCommand.Inc
uint8_t %'ModuleName'%.%ParseCommand(const unsigned char *cmd, bool *handled, const %@Shell@'ModuleName'%.StdIOType *io)
{
  if (%@Utility@'ModuleName'%.strcmp((char*)cmd, %@Shell@'ModuleName'%.CMD_HELP)==0 || %@Utility@'ModuleName'%.strcmp((char*)cmd, "%'ModuleName' help")==0) {
    *handled = TRUE;
    return PrintHelp(io);
  } else if ((%@Utility@'ModuleName'%.strcmp((char*)cmd, %@Shell@'ModuleName'%.CMD_STATUS)==0) || (%@Utility@'ModuleName'%.strcmp((char*)cmd, "%'ModuleName' status")==0)) {
    *handled = TRUE;
    return PrintStatus(io);
%ifdef ChangeDirectory
  } else if (%@Utility@'ModuleName'%.strncmp((char*)cmd, "%'ModuleName' cd", sizeof("%'ModuleName' cd")-1)==0) {
    *handled = TRUE;
    return CdCmd(cmd+sizeof("%'ModuleName'"), io);
%endif %- ChangeDirectory
%ifdef PrintDirectory
  } else if (%@Utility@'ModuleName'%.strncmp((char*)cmd, "%'ModuleName' dir", sizeof("%'ModuleName' dir")-1)==0) {
    *handled = TRUE;
    return DirCmd(cmd+sizeof("%'ModuleName'"), io);
%endif %- PrintDirectory
%ifdef CopyFile
  } else if (%@Utility@'ModuleName'%.strncmp((char*)cmd, "%'ModuleName' copy ", sizeof("%'ModuleName' copy ")-1)==0) {
    *handled = TRUE;
    return CopyCmd(cmd+sizeof("%'ModuleName'"), io);
%endif %- CopyFile
%ifdef DeleteFile
  } else if (%@Utility@'ModuleName'%.strncmp((char*)cmd, "%'ModuleName' delete ", sizeof("%'ModuleName' delete ")-1)==0) {
    *handled = TRUE;
    return DeleteCmd(cmd+sizeof("%'ModuleName'"), io);
%endif %- DeleteFile
%ifdef CreateFile
  } else if (%@Utility@'ModuleName'%.strncmp((char*)cmd, "%'ModuleName' create ", sizeof("%'ModuleName' create ")-1)==0) {
    *handled = TRUE;
    return CreateCmd(cmd+sizeof("%'ModuleName'"), io);
%endif %- CreateFile
%ifdef MakeDirectory
  } else if (%@Utility@'ModuleName'%.strncmp((char*)cmd, "%'ModuleName' mkdir ", sizeof("%'ModuleName' mkdir ")-1)==0) {
    *handled = TRUE;
    return MkdirCmd(cmd+sizeof("%'ModuleName'"), io);
%endif %- MakeDirectory
%ifdef RenameFile
  } else if (%@Utility@'ModuleName'%.strncmp((char*)cmd, "%'ModuleName' rename ", sizeof("%'ModuleName' rename ")-1)==0) {
    *handled = TRUE;
    return RenameCmd(cmd+sizeof("%'ModuleName'"), io);
%endif %- RenameFile
%ifdef PrintHexFile
  } else if (%@Utility@'ModuleName'%.strncmp((char*)cmd, "%'ModuleName' printhex ", sizeof("%'ModuleName' printhex ")-1)==0) {
    *handled = TRUE;
    return PrintHexCmd(cmd+sizeof("%'ModuleName'"), io);
%endif %- PrintHexFile
%ifdef PrintSector
  } else if (%@Utility@'ModuleName'%.strncmp((char*)cmd, "%'ModuleName' printsector ", sizeof("%'ModuleName' printsector ")-1)==0) {
    *handled = TRUE;
    return SectorCmd(cmd+sizeof("%'ModuleName'"), io);
%endif %- PrintSector
%ifdef PrintFile
  } else if (%@Utility@'ModuleName'%.strncmp((char*)cmd, "%'ModuleName' print ", sizeof("%'ModuleName' print ")-1)==0) {
    *handled = TRUE;
    return PrintCmd(cmd+sizeof("%'ModuleName'"), io);
%endif %- PrintFile
%ifdef PrintDiskInfo
  } else if (%@Utility@'ModuleName'%.strcmp((char*)cmd, "%'ModuleName' diskinfo")==0) {
    *handled = TRUE;
    return %'ModuleName'%.%PrintDiskInfo((unsigned char*)%'ModuleName'%.CONFIG_DEFAULT_DRIVE_STRING, io);
%endif %- PrintDiskInfo
%ifdef Benchmark
  } else if (%@Utility@'ModuleName'%.strcmp((char*)cmd, "%'ModuleName' benchmark")==0) {
    *handled = TRUE;
    return %'ModuleName'%.%Benchmark(io);
%endif %- Benchmark
  }
  return ERR_OK;
}

%endif %- ParseCommand
%-BW_METHOD_END ParseCommand
%-************************************************************************************************************
%-BW_METHOD_BEGIN CheckCardPresence
%ifdef CheckCardPresence
%define! ParcardMounted
%define! Pardrive
%define! ParfileSystemObject
%define! Pario
%define! RetVal
%include Common\FAT_FileSystemCheckCardPresence.Inc
uint8_t %'ModuleName'%.%CheckCardPresence(bool *cardMounted, uint8_t *drive, FATFS *fileSystemObject, const %@Shell@'ModuleName'%.StdIOType *io)
{
  if (drive==NULL) { /* backward compatibility with drive numbers before (which could be zero or NULL) */
    drive = (unsigned char*)%'ModuleName'%.CONFIG_DEFAULT_DRIVE_STRING;
  }
  if (!(*cardMounted) && %'ModuleName'%.isDiskPresent(drive)) {
    /* card inserted */
    #if %'ModuleName'%.CONFIG_CARD_INSERT_DELAY_TIME_MS>0
        %@Wait@'ModuleName'%.WaitOSms(%'ModuleName'%.CONFIG_CARD_INSERT_DELAY_TIME_MS); /* give card some time to power up */
    #endif
    if (%'ModuleName'%.MountFileSystem(fileSystemObject, drive, io)==ERR_OK) {
      *cardMounted = TRUE;
      if (io!=NULL) {
        %@Shell@'ModuleName'%.SendStr((unsigned char*)"File System mounted\r\n", io->stdOut);
      }
  #if (%'ModuleName'%.FS_RPATH >= 1U && %'ModuleName'%.VOLUMES >= 2)
      if (f_chdrive((char const *)drive)!=FR_OK) { /* change default drive */
        return ERR_FAILED;
      }
  #endif
    } else {
      return ERR_FAILED;
    }
  } else if (*cardMounted && !%'ModuleName'%.isDiskPresent(drive)) {
    /* card removed */
    if (%'ModuleName'%.UnMountFileSystem(drive, io)==ERR_OK) {
      *cardMounted = FALSE;
      if (io!=NULL) {
        %@Shell@'ModuleName'%.SendStr((unsigned char*)"File System unmounted\r\n", io->stdOut);
      }
    } else {
      return ERR_FAILED;
    }
  }
  return ERR_OK;
}

%endif %- CheckCardPresence
%-BW_METHOD_END CheckCardPresence
%-************************************************************************************************************
%-BW_METHOD_BEGIN MountFileSystem
%ifdef MountFileSystem
%define! ParfileSystemObject
%define! ParlogicalDrive
%define! Pario
%define! RetVal
%include Common\FAT_FileSystemMountFileSystem.Inc
/*!
 * \brief Mounts the file system for a drive
 * \param[in] fileSystemObject Pointer to the file system object
 * \param[in] logicalDrive The drive number to be used
 * \param[in] io IO handler for output
 * \return Error code, ERR_OK for success.
 */
uint8_t %'ModuleName'%.%MountFileSystem(FATFS *fileSystemObject, uint8_t *logicalDrive, const %@Shell@'ModuleName'%.StdIOType *io)
{
  %'ModuleName'%.FRESULT fres;

  fres = %'ModuleName'%.mount(fileSystemObject, (const TCHAR*)logicalDrive, 1 /* 1: mount immediately; 0: delayed mount */);
  if (fres != FR_OK) {
    if (io!=NULL) {
      FatFsFResultMsg((unsigned char*)"mount failed", fres, io);
    }
    return ERR_FAILED;
  }
  return ERR_OK;
}

%endif %- MountFileSystem
%-BW_METHOD_END MountFileSystem
%-************************************************************************************************************
%-BW_METHOD_BEGIN UnMountFileSystem
%ifdef UnMountFileSystem
%define! ParlogicalDrive
%define! Pario
%define! RetVal
%include Common\FAT_FileSystemUnMountFileSystem.Inc
/*!
 * \brief Unmounts the file system for a drive
 * \param[in] logicalDrive The drive number to be used
 * \param[in] io IO handler for output
 * \return Error code, ERR_OK for success.
 */
uint8_t %'ModuleName'%.%UnMountFileSystem(uint8_t *logicalDrive, const %@Shell@'ModuleName'%.StdIOType *io)
{
  %'ModuleName'%.FRESULT fres;

  fres = %'ModuleName'%.mount(NULL, (const TCHAR*)logicalDrive, 0);
  if (fres != FR_OK) {
    if (io!=NULL) {
      FatFsFResultMsg((unsigned char*)"unmount failed", fres, io);
    }
    return ERR_FAILED;
  }
  return ERR_OK;
}

%endif %- UnMountFileSystem
%-BW_METHOD_END UnMountFileSystem
%-************************************************************************************************************
%-BW_METHOD_BEGIN PrintDirectory
%ifdef PrintDirectory
%define! PardirName
%define! Pario
%define! RetVal
%include Common\FAT_FileSystemPrintDirectory.Inc
/*!
 * \brief Prints a directory listing
 * \param[in] dirName Directory to be used
 * \param[in] io IO handler for output
 * \return Error code, ERR_OK for success.
 */
uint8_t %'ModuleName'%.%PrintDirectory(const uint8_t *dirName, const %@Shell@'ModuleName'%.StdIOType *io)
{
  uint8_t res;

  res = PrintDir(dirName, io);
  if (res != ERR_OK) {
    %@Shell@'ModuleName'%.SendStr((unsigned char*)"PrintDir failed\r\n", io->stdErr);
    return res;
  }
  return ERR_OK;
}

%endif %- PrintDirectory
%-BW_METHOD_END PrintDirectory
%-************************************************************************************************************
%-BW_METHOD_BEGIN CopyFile
%ifdef CopyFile
%define! ParsrcFileName
%define! PardstFileName
%define! Pario
%define! RetVal
%include Common\FAT_FileSystemCopyFile.Inc
/*!
 * \brief Copy the source file to a destination file
 * \param[in] srcFileName Source file name
 * \param[in] dstFileName Destination file name
 * \param[in] io IO handler for output
 * \return Error code, ERR_OK for success.
 */
uint8_t %'ModuleName'%.%CopyFile(const uint8_t*srcFileName, const uint8_t *dstFileName, const %@Shell@'ModuleName'%.StdIOType *io)
{
#if !%'ModuleName'%.FS_READONLY
  %'ModuleName'%.FIL fsrc, fdst;  /* file objects */
  %'ModuleName'%.FRESULT fres;
  uint8_t buffer[%FileCopyBufferSize];   /* copy buffer */
  UINT br, bw;          /* file read/write counters */
  uint8_t res =  ERR_OK;

  if (%'ModuleName'%.isWriteProtected((uint8_t*)%'ModuleName'%.CONFIG_DEFAULT_DRIVE_STRING)) {
    %@Shell@'ModuleName'%.SendStr((unsigned char*)"disk is write protected!\r\n", io->stdErr);
    return ERR_FAILED;
  }
  /* open source file */
  fres = %'ModuleName'%.open(&fsrc, (const TCHAR*)srcFileName, FA_OPEN_EXISTING | FA_READ);
  if (fres != FR_OK) {
    FatFsFResultMsg((unsigned char*)"open source file failed", fres, io);
    return ERR_FAILED;
  }
  /* create destination file */
  fres = %'ModuleName'%.open(&fdst, (const TCHAR*)dstFileName, FA_CREATE_ALWAYS | FA_WRITE);
  if (fres != FR_OK) {
    (void)%'ModuleName'%.close(&fsrc); /* close the source file which we have open */
    FatFsFResultMsg((unsigned char*)"open destination file failed", fres, io);
    return ERR_FAILED;
  }
  /* now copy source to destination */
  for (;;) {
    fres = %'ModuleName'%.read(&fsrc, buffer, sizeof(buffer), &br);
    if (fres != FR_OK) {
      FatFsFResultMsg((unsigned char*)"reading source file failed", fres, io);
      res = ERR_FAILED;
      break;
    }
    if (br == 0) { /* EOF */
      break; /* get out of loop */
    }
    fres = %'ModuleName'%.write(&fdst, buffer, br, &bw);
    if (fres != FR_OK) {
      FatFsFResultMsg((unsigned char*)"writing destination file failed", fres, io);
      res = ERR_FAILED;
      break;
    }
    if (bw < br) {
      %@Shell@'ModuleName'%.SendStr((unsigned char*)"failed writing destination file, or disk full\r\n", io->stdErr);
      res = ERR_FAILED;
      break;
    }
  } /* for */
  /* close all files */
  fres = %'ModuleName'%.close(&fsrc);
  if (fres != FR_OK) {
    FatFsFResultMsg((unsigned char*)"closing source file failed", fres, io);
    res = ERR_FAILED;
  }
  fres = %'ModuleName'%.close(&fdst);
  if (fres != FR_OK) {
    FatFsFResultMsg((unsigned char*)"closing destination file failed", fres, io);
    res = ERR_FAILED;
  }
  return res;
#else
  (void)srcFileName; /* unused argument */
  (void)dstFileName; /* unused argument */
  %@Shell@'ModuleName'%.SendStr((unsigned char*)"File System is in Read-Only mode\r\n", io->stdErr);
  return ERR_FAILED;
#endif
}

%endif %- CopyFile
%-BW_METHOD_END CopyFile
%-************************************************************************************************************
%-BW_METHOD_BEGIN DeleteFile
%ifdef DeleteFile
%define! ParfileName
%define! Pario
%define! RetVal
%include Common\FAT_FileSystemDeleteFile.Inc
/*!
 * \brief Deletes a file
 * \param[in] fileName Name of file to be deleted
 * \param[in] io IO handler for output
 * \return Error code, ERR_OK for success.
 */
uint8_t %'ModuleName'%.%DeleteFile(const uint8_t *fileName, const %@Shell@'ModuleName'%.StdIOType *io)
{
  %'ModuleName'%.FRESULT fres;

  if (%'ModuleName'%.isWriteProtected((uint8_t*)%'ModuleName'%.CONFIG_DEFAULT_DRIVE_STRING)) {
    %@Shell@'ModuleName'%.SendStr((unsigned char*)"disk is write protected!\r\n", io->stdErr);
    return ERR_FAILED;
  }
  fres = %'ModuleName'%.unlink((const TCHAR*)fileName);
  if (fres != FR_OK) {
    FatFsFResultMsg((unsigned char*)"unlink failed", fres, io);
    return ERR_FAILED;
  }
  return ERR_OK;
}

%endif %- DeleteFile
%-BW_METHOD_END DeleteFile
%-************************************************************************************************************
%-BW_METHOD_BEGIN CreateFile
%ifdef CreateFile
%define! ParfileName
%define! Pario
%define! RetVal
%include Common\FAT_FileSystemCreateFile.Inc
uint8_t %'ModuleName'%.%CreateFile(const uint8_t *fileName, const %@Shell@'ModuleName'%.StdIOType *io)
{
  %'ModuleName'%.FRESULT fres;
  FIL fp;

  if (%'ModuleName'%.isWriteProtected((uint8_t*)%'ModuleName'%.CONFIG_DEFAULT_DRIVE_STRING)) {
    %@Shell@'ModuleName'%.SendStr((unsigned char*)"disk is write protected!\r\n", io->stdErr);
    return ERR_FAILED;
  }
  fres = %'ModuleName'%.open(&fp, (const TCHAR*)fileName, FA_CREATE_NEW);
  if (fres != FR_OK) {
    FatFsFResultMsg((unsigned char*)"creating new file failed", fres, io);
    return ERR_FAILED;
  }
  fres = %'ModuleName'%.close(&fp);
  if (fres != FR_OK) {
    FatFsFResultMsg((unsigned char*)"closing file failed", fres, io);
    return ERR_FAILED;
  }
  return ERR_OK;
}

%endif %- CreateFile
%-BW_METHOD_END CreateFile
%-************************************************************************************************************
%-BW_METHOD_BEGIN PrintFile
%ifdef PrintFile
%define! ParfileName
%define! Pario
%define! RetVal
%include Common\FAT_FileSystemPrintFile.Inc
/*!
 * \brief Print the content of a file
 * \param[in] fileName Name of file to be printed
 * \param[in] io IO handler for output
 * \return Error code, ERR_OK for success.
 */
uint8_t %'ModuleName'%.%PrintFile(const uint8_t *fileName, const %@Shell@'ModuleName'%.StdIOType *io)
{
  %'ModuleName'%.FIL file;
  %'ModuleName'%.FRESULT fres;
  UINT nofRead = 0;
  uint8_t buf[%FilePrintBufferSize];
  uint8_t res = ERR_OK;

  fres = %'ModuleName'%.open(&file, (const TCHAR *)fileName, FA_READ);
  if (fres == FR_OK) {
    do {
      nofRead = 0;
      fres=%'ModuleName'%.read(&file, buf, sizeof(buf)-1, &nofRead); /* read one byte less for zero byte */
      if (fres != FR_OK) {
        %@Shell@'ModuleName'%.SendStr((unsigned char*)"fread failed\r\n", io->stdErr);
        res = ERR_FAILED;
      } else {
        buf[nofRead] = '\0'; /* terminate buffer */
        %@Shell@'ModuleName'%.SendStr(buf, io->stdOut);
      }
    } while(nofRead>0 && fres==FR_OK);
    fres=%'ModuleName'%.close(&file);
    if (fres != FR_OK) {
      %@Shell@'ModuleName'%.SendStr((unsigned char*)"fclose failed\r\n", io->stdErr);
      res = ERR_FAILED;
    }
  } else {
    FatFsFResultMsg((unsigned char*)"open file failed", fres, io);
    res = ERR_FAILED;
  }
  %@Shell@'ModuleName'%.SendStr((unsigned char*)"\r\n", io->stdOut);
  return res;
}

%endif %- PrintFile
%-BW_METHOD_END PrintFile
%-************************************************************************************************************
%-BW_METHOD_BEGIN PrintHexFile
%ifdef PrintHexFile
%define! ParfileName
%define! Pario
%define! RetVal
%include Common\FAT_FileSystemPrintHexFile.Inc
uint8_t %'ModuleName'%.%PrintHexFile(const uint8_t *fileName, const %@Shell@'ModuleName'%.StdIOType *io)
{
  %'ModuleName'%.FIL file;
  %'ModuleName'%.FRESULT fres;
  UINT nofRead = 0;
  #define PRINT_HEX_NOF_BYTES_PER_LINE 16
  uint8_t filebuf[PRINT_HEX_NOF_BYTES_PER_LINE];
  uint8_t buf[16];
  uint8_t res = ERR_OK;
  uint32_t address;
  UINT i;

  fres = %'ModuleName'%.open(&file, (const TCHAR *)fileName, FA_READ);
  if (fres == FR_OK) {
    address = 0;
    do {
      nofRead = 0;
      fres=%'ModuleName'%.read(&file, filebuf, sizeof(filebuf), &nofRead); /* read one byte less for zero byte */
      if (fres != FR_OK) {
        %@Shell@'ModuleName'%.SendStr((unsigned char*)"fread failed\r\n", io->stdErr);
        res = ERR_FAILED;
      } else if (nofRead>0) {
        for(i=0; i<nofRead; i++) {
          if ((i%%PRINT_HEX_NOF_BYTES_PER_LINE)==0) { /* new line to make things readable */
            %@Shell@'ModuleName'%.SendStr((unsigned char*)"0x", io->stdOut);
            buf[0] = '\0';
            %@Utility@'ModuleName'%.strcatNum32Hex(buf, sizeof(buf), address);
            %@Shell@'ModuleName'%.SendStr(buf, io->stdOut);
            %@Shell@'ModuleName'%.SendStr((unsigned char*)": ", io->stdOut);
            address += PRINT_HEX_NOF_BYTES_PER_LINE;
          }
          buf[0] = '\0';
          %@Utility@'ModuleName'%.strcatNum8Hex(buf, sizeof(buf), filebuf[i]);
          %@Shell@'ModuleName'%.SendStr(buf, io->stdOut);
          %@Shell@'ModuleName'%.SendStr((unsigned char*)" ", io->stdOut);
        }
        /* fill up line if not a full line */
        for (/*empty*/; i<PRINT_HEX_NOF_BYTES_PER_LINE; i++) {
          %@Shell@'ModuleName'%.SendStr((unsigned char*)"-- ", io->stdOut);
        }
        /* print in ASCII */
        PrintInASCII(&filebuf[0], nofRead, PRINT_HEX_NOF_BYTES_PER_LINE, '.', '-', io);
        %@Shell@'ModuleName'%.SendStr((unsigned char*)"\r\n", io->stdOut);
      }
    } while(nofRead>0 && fres==FR_OK);
    fres=%'ModuleName'%.close(&file);
    if (fres != FR_OK) {
      %@Shell@'ModuleName'%.SendStr((unsigned char*)"fclose failed\r\n", io->stdErr);
      res = ERR_FAILED;
    }
  } else {
    FatFsFResultMsg((unsigned char*)"open file failed\r\n", fres, io);
    res = ERR_FAILED;
  }
  return res;
}

%endif %- PrintHexFile
%-BW_METHOD_END PrintHexFile
%-************************************************************************************************************
%-BW_METHOD_BEGIN MakeDirectory
%ifdef MakeDirectory
%define! PardirName
%define! Pario
%define! RetVal
%include Common\FAT_FileSystemMakeDirectory.Inc
/*!
 * \brief Creates a new directory
 * \param[in] dirName Name of the directory to be created
 * \param[in] io IO handler for output
 * \return Error code, ERR_OK for success.
 */
uint8_t %'ModuleName'%.%MakeDirectory(const uint8_t *dirName, const %@Shell@'ModuleName'%.StdIOType *io)
{
  %'ModuleName'%.FRESULT fres;

  if (%'ModuleName'%.isWriteProtected((uint8_t*)%'ModuleName'%.CONFIG_DEFAULT_DRIVE_STRING)) {
    %@Shell@'ModuleName'%.SendStr((unsigned char*)"disk is write protected!\r\n", io->stdErr);
    return ERR_FAILED;
  }
  fres = %'ModuleName'%.mkdir((const TCHAR*)dirName);
  if(fres!=FR_OK) {
    FatFsFResultMsg((unsigned char*)"mkdir failed", fres, io);
    return ERR_FAILED;
  }
  return ERR_OK;
}

%endif %- MakeDirectory
%-BW_METHOD_END MakeDirectory
%-************************************************************************************************************
%-BW_METHOD_BEGIN ChangeDirectory
%ifdef ChangeDirectory
%define! PardirName
%define! Pario
%define! RetVal
%include Common\FAT_FileSystemChangeDirectory.Inc
uint8_t %'ModuleName'%.%ChangeDirectory(const uint8_t *dirName, const %@Shell@'ModuleName'%.StdIOType *io)
{
#if %'ModuleName'%.FS_RPATH > 0
  %'ModuleName'%.FRESULT fres;

  if ((fres=%'ModuleName'%.chdir((const TCHAR*)dirName)) != FR_OK) {
    FatFsFResultMsg((unsigned char*)"chdir failed", fres, io);
    return ERR_FAILED;
  }
  return ERR_OK;
#else
  (void)dirName;
  #warning "relative directories not enabled in FatFS!"
  %@Shell@'ModuleName'%.SendStr((unsigned char*)"cd command not available as relative directories not enable in file system\r\n", io->stdErr);
  return ERR_FAILED;
#endif
}

%endif %- ChangeDirectory
%-BW_METHOD_END ChangeDirectory
%-************************************************************************************************************
%-BW_METHOD_BEGIN RenameFile
%ifdef RenameFile
%define! ParsrcFileName
%define! PardstFileName
%define! Pario
%define! RetVal
%include Common\FAT_FileSystemRenameFile.Inc
/*!
 * \brief Renames a file
 * \param[in] srcFileName Source/existing file name
 * \param[in] dstFileName Destination/new file name
 * \param[in] io IO handler for output
 * \return Error code, ERR_OK for success.
 */
uint8_t %'ModuleName'%.%RenameFile(const uint8_t *srcFileName, const uint8_t *dstFileName, const %@Shell@'ModuleName'%.StdIOType *io)
{
  %'ModuleName'%.FRESULT fres;

  if (%'ModuleName'%.isWriteProtected((uint8_t*)%'ModuleName'%.CONFIG_DEFAULT_DRIVE_STRING)) {
    %@Shell@'ModuleName'%.SendStr((unsigned char*)"disk is write protected!\r\n", io->stdErr);
    return ERR_FAILED;
  }
  fres = %'ModuleName'%.rename((const TCHAR*)srcFileName, (const TCHAR*)dstFileName);
  if(fres!=FR_OK) {
    FatFsFResultMsg((unsigned char*)"rename failed", fres, io);
    return ERR_FAILED;
  }
  return ERR_OK;
}

%endif %- RenameFile
%-BW_METHOD_END RenameFile
%-************************************************************************************************************
%-BW_METHOD_BEGIN PrintSector
%ifdef PrintSector
%define! Pardrive
%define! ParsectorNo
%define! Pario
%define! RetVal
%include Common\FAT_FileSystemPrintSector.Inc
#if %'ModuleName'%.USE_RTOS_DYNAMIC_MEMORY
#if %@sdk@'ModuleName'%.CONFIG_SDK_VERSION_USED == %@sdk@'ModuleName'%.CONFIG_SDK_PROCESSOR_EXPERT
  %for i from [0..%maxDrive]
  #define SECTOR_BUF_SIZE%i   %@Drive%i@'ModuleName'%.BLOCK_SIZE
  %endfor
#else
  #define SECTOR_BUF_SIZE0   512
#endif
#else
#if %@sdk@'ModuleName'%.CONFIG_SDK_VERSION_USED == %@sdk@'ModuleName'%.CONFIG_SDK_PROCESSOR_EXPERT
  %for i from [0..%maxDrive]
  static uint8_t print_buf%i[%@Drive%i@'ModuleName'%.BLOCK_SIZE];
  #define SECTOR_BUF_SIZE%i   sizeof(print_buf%i)
  %endfor
#else
  static uint8_t print_buf0[512];
  #define SECTOR_BUF_SIZE0   sizeof(print_buf0)
#endif
#endif
uint8_t %'ModuleName'%.%PrintSector(uint8_t drive, uint32_t sectorNo, const %@Shell@'ModuleName'%.StdIOType *io)
{
  #define PRINT_SECTOR_NOF_BYTES_PER_LINE  16
  uint16_t i;
  unsigned char buf[8];
  %'ModuleName'%.DRESULT dres;
#if %'ModuleName'%.USE_RTOS_DYNAMIC_MEMORY
  #if configFRTOS_MEMORY_SCHEME==1 /* this scheme does not allow deallocation of memory */
    static unsigned char *print_buf0=NULL; /* use global buffer pointer, allocated only once, and not deallocated! */
  #else
    unsigned char *print_buf0;
  #endif
#endif

  if ((disk_initialize(drive)&STA_NOINIT)!=(DSTATUS)RES_OK) {
    %@Shell@'ModuleName'%.SendStr((unsigned char*)"disk initialize failed\r\n", io->stdErr);
    return ERR_FAILED;
  }
#if %'ModuleName'%.USE_RTOS_DYNAMIC_MEMORY
  #if configFRTOS_MEMORY_SCHEME==1 /* this scheme does not allow deallocation of memory */
  if (print_buf0==NULL) { /* only if not allocated yet */
    print_buf0 = pvPortMalloc(SECTOR_BUF_SIZE0);
  }
  #else
  print_buf0 = pvPortMalloc(SECTOR_BUF_SIZE0);
  #endif
  if (print_buf0 == NULL) {
    %@Shell@'ModuleName'%.SendStr((unsigned char*)"allocating memory failed\r\n", io->stdErr);
    return ERR_FAILED;
  }
#endif
  dres = disk_read(drive, &print_buf0[0], sectorNo, 1);
  if (dres==RES_OK) { /* read one sector */
    %@Shell@'ModuleName'%.SendStr((unsigned char*)"dumping disk sector: 0x", io->stdOut);
    buf[0] = '\0';
    %@Utility@'ModuleName'%.strcatNum32Hex(buf, sizeof(buf), sectorNo);
    %@Shell@'ModuleName'%.SendStr(buf, io->stdOut);
    %@Shell@'ModuleName'%.SendStr((unsigned char*)", sector size ", io->stdOut);
    %@Shell@'ModuleName'%.SendNum32u(SECTOR_BUF_SIZE0, io->stdOut);
    for(i=0; i<SECTOR_BUF_SIZE0; i++) {
      if ((i%%PRINT_SECTOR_NOF_BYTES_PER_LINE)==0) { /* new line to make things readable */
        if (i!=0) { /* not for first line */
          PrintInASCII(&print_buf0[i-PRINT_SECTOR_NOF_BYTES_PER_LINE], PRINT_SECTOR_NOF_BYTES_PER_LINE, PRINT_SECTOR_NOF_BYTES_PER_LINE, '.', '-', io);
        }
        %@Shell@'ModuleName'%.SendStr((unsigned char*)"\r\n0x", io->stdOut);
        buf[0] = '\0';
        %@Utility@'ModuleName'%.strcatNum16Hex(buf, sizeof(buf), i);
        %@Shell@'ModuleName'%.SendStr(buf, io->stdOut);
        %@Shell@'ModuleName'%.SendStr((unsigned char*)": ", io->stdOut);
      }
      buf[0] = '\0';
      %@Utility@'ModuleName'%.strcatNum8Hex(buf, sizeof(buf), (uint8_t)print_buf0[i]);
      %@Shell@'ModuleName'%.SendStr(buf, io->stdOut);
      %@Shell@'ModuleName'%.SendStr((unsigned char*)" ", io->stdOut);
    }
    PrintInASCII(&print_buf0[i-PRINT_SECTOR_NOF_BYTES_PER_LINE], PRINT_SECTOR_NOF_BYTES_PER_LINE, PRINT_SECTOR_NOF_BYTES_PER_LINE, '.', '-', io);
    %@Shell@'ModuleName'%.SendStr((unsigned char*)"\r\n", io->stdOut);
  } else {
    FatFsDResultMsg((unsigned char*)"disk_read failed", dres, io);
  }
#if %'ModuleName'%.USE_RTOS_DYNAMIC_MEMORY
  #if configFRTOS_MEMORY_SCHEME!=1 /* this scheme does not allow deallocation of memory */
    vPortFree(print_buf0);
  #endif
#endif
  if (dres==RES_OK) {
    return ERR_OK;
  } else {
    return ERR_FAILED;
  }
}

%endif %- PrintSector
%-BW_METHOD_END PrintSector
%-************************************************************************************************************
%-BW_METHOD_BEGIN PrintDiskInfo
%ifdef PrintDiskInfo
%define! Pardrive
%define! Pario
%define! RetVal
%include Common\FAT_FileSystemPrintDiskInfo.Inc
/*!
 * \brief Prints information about the disk
 * \param[in] drive Disk drive number, starting with zero
 * \param[in] io IO handler for output
 * \return Error code, ERR_OK for success.
 */
uint8_t %'ModuleName'%.%PrintDiskInfo(uint8_t *drvStr, const %@Shell@'ModuleName'%.StdIOType *io)
{
  /* see for details:
   * http://www.retroleum.co.uk/electronics-articles/basic-mmc-card-access/
   */
  uint8_t buf[8];
  int32_t val32;
  int16_t val16;
  int8_t val8;
  uint8_t buff[64];
  uint8_t driverVersion; /* 0: SPI, 1: SDHC_LDD */
  uint8_t driveNr;

  driveNr = StrToDriveNumber(drvStr);
  if (!%'ModuleName'%.isDiskPresent(drvStr)) {
    %@Shell@'ModuleName'%.SendStr((unsigned char*)"disk not present!\r\n", io->stdErr);
    return ERR_FAILED;
  }
  if ((disk_initialize(StrToDriveNumber(drvStr))&STA_NOINIT)!=0) {
    %@Shell@'ModuleName'%.SendStr((unsigned char*)"disk initialize failed!\r\n", io->stdErr);
    return ERR_FAILED;
  }
  if (disk_ioctl(driveNr, MMC_GET_DRIVER_VERSION, &driverVersion)!=RES_OK) {
    %@Shell@'ModuleName'%.SendStr((unsigned char*)"failed identification of driver version\r\n", io->stdErr);
    return ERR_FAILED;
  }
  %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"Card type", (unsigned char*)"", io->stdOut);
  if (disk_ioctl(driveNr, MMC_GET_TYPE, &val8)==RES_OK) {
    if (val8&CT_SD1) {
      %@Shell@'ModuleName'%.SendStr((unsigned char*)"SD1 ", io->stdOut);
    }
    if (val8&CT_SD2) {
      %@Shell@'ModuleName'%.SendStr((unsigned char*)"SD2 ", io->stdOut);
    }
    if (val8&CT_BLOCK) {
      %@Shell@'ModuleName'%.SendStr((unsigned char*)"BLOCK ", io->stdOut);
    }
    if (val8&CT_MMC) {
      %@Shell@'ModuleName'%.SendStr((unsigned char*)"MMC ", io->stdOut);
    }
    if (val8&CT_SDC) {
      %@Shell@'ModuleName'%.SendStr((unsigned char*)"SDC ", io->stdOut);
    }
    if (val8&CT_ATA) {
      %@Shell@'ModuleName'%.SendStr((unsigned char*)"ATA ", io->stdOut);
    }
    %@Shell@'ModuleName'%.SendStr((unsigned char*)"\r\n", io->stdOut);
  } else {
    %@Shell@'ModuleName'%.SendStr((unsigned char*)"ERROR\r\n", io->stdOut);
  }
  if (driverVersion==0) { /* only SPI cards implement this */
    %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"SDC version", (unsigned char*)"", io->stdOut);
    if (disk_ioctl(driveNr, MMC_GET_SDC_VERSION, &val8)==RES_OK) {
      if (val8==1) {
        %@Shell@'ModuleName'%.SendStr((unsigned char*)"SDC ver 1.XX or MMC\r\n", io->stdOut);
      } else if (val8==2) {
        %@Shell@'ModuleName'%.SendStr((unsigned char*)"SDC ver 2.00\r\n", io->stdOut);
      } else {
        %@Shell@'ModuleName'%.SendStr((unsigned char*)"unknown\r\n", io->stdOut);
      }
    } else {
      %@Shell@'ModuleName'%.SendStr((unsigned char*)"ERROR\r\n", io->stdOut);
    }
  }
  %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"Sector count", (unsigned char*)"", io->stdOut);
  if (disk_ioctl(driveNr, GET_SECTOR_COUNT, &val32)==RES_OK) {
    %@Utility@'ModuleName'%.Num32sToStr(buf, sizeof(buf), val32);
    %@Shell@'ModuleName'%.SendStr(buf, io->stdOut);
    %@Shell@'ModuleName'%.SendStr((unsigned char*)"\r\n", io->stdOut);
  } else {
    %@Shell@'ModuleName'%.SendStr((unsigned char*)"ERROR\r\n", io->stdOut);
  }
  %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"Sector size", (unsigned char*)"", io->stdOut);
  if (disk_ioctl(driveNr, GET_SECTOR_SIZE, &val16)==RES_OK) {
    %@Utility@'ModuleName'%.Num16sToStr(buf, sizeof(buf), val16);
    %@Shell@'ModuleName'%.SendStr(buf, io->stdOut);
    %@Shell@'ModuleName'%.SendStr((unsigned char*)"\r\n", io->stdOut);
  } else {
    %@Shell@'ModuleName'%.SendStr((unsigned char*)"ERROR\r\n", io->stdOut);
  }
  %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"READ_BL_LEN", (unsigned char*)"", io->stdOut);
  if (disk_ioctl(driveNr, MMC_GET_READ_BL_LEN, &val16)==RES_OK) {
    %@Utility@'ModuleName'%.Num16sToStr(buf, sizeof(buf), val16);
    %@Shell@'ModuleName'%.SendStr(buf, io->stdOut);
    %@Shell@'ModuleName'%.SendStr((unsigned char*)"\r\n", io->stdOut);
  } else {
    %@Shell@'ModuleName'%.SendStr((unsigned char*)"ERROR\r\n", io->stdOut);
  }
  if (driverVersion==0) { /* only SPI cards implement this */
    %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"Block size", (unsigned char*)"", io->stdOut);
    if (disk_ioctl(driveNr, GET_BLOCK_SIZE, &val32)==RES_OK) {
      %@Utility@'ModuleName'%.Num32sToStr(buf, sizeof(buf), val32);
      %@Shell@'ModuleName'%.SendStr(buf, io->stdOut);
      %@Shell@'ModuleName'%.SendStr((unsigned char*)"\r\n", io->stdOut);
    } else {
      %@Shell@'ModuleName'%.SendStr((unsigned char*)"ERROR\r\n", io->stdOut);
    }
    %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"CSD", (unsigned char*)"", io->stdOut);
    if (disk_ioctl(driveNr, MMC_GET_CSD, &buff[0])==RES_OK) {
      for(val8=0; val8<16; val8++) {
        buf[0] = '\0';
        %@Utility@'ModuleName'%.strcatNum8Hex(buf, sizeof(buf), (uint8_t)buff[val8]);
        %@Shell@'ModuleName'%.SendStr(buf, io->stdOut);
        %@Shell@'ModuleName'%.SendStr((unsigned char*)" ", io->stdOut);
      }
      %@Shell@'ModuleName'%.SendStr((unsigned char*)"\r\n", io->stdOut);
    } else {
      %@Shell@'ModuleName'%.SendStr((unsigned char*)"ERROR\r\n", io->stdOut);
    }
    %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"CID", (unsigned char*)"", io->stdOut);
    if (disk_ioctl(driveNr, MMC_GET_CID, &buff[0])==RES_OK) {
      for(val8=0; val8<16; val8++) {
        buf[0] = '\0';
        %@Utility@'ModuleName'%.strcatNum8Hex(buf, sizeof(buf), (uint8_t)buff[val8]);
        %@Shell@'ModuleName'%.SendStr(buf, io->stdOut);
        %@Shell@'ModuleName'%.SendStr((unsigned char*)" ", io->stdOut);
      }
      %@Shell@'ModuleName'%.SendStr((unsigned char*)"\r\n               Manufacturer ", io->stdOut);
      for(val8=3; val8<=8; val8++) {
        io->stdOut(buff[val8]);
      }
      %@Shell@'ModuleName'%.SendStr((unsigned char*)"\r\n               Serial Number ", io->stdOut);
      buf[0] = '\0';
      %@Utility@'ModuleName'%.strcatNum32Hex(buf, sizeof(buf), (uint32_t)((buff[0xa]<<24)|(buff[0xb]<<16)|(buff[0xc]<<8)|buff[0xd]));
      %@Shell@'ModuleName'%.SendStr(buf, io->stdOut);
      %@Shell@'ModuleName'%.SendStr((unsigned char*)"\r\n", io->stdOut);
    } else {
      %@Shell@'ModuleName'%.SendStr((unsigned char*)"ERROR\r\n", io->stdOut);
    }
    %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"OCR", (unsigned char*)"", io->stdOut);
    if (disk_ioctl(driveNr, MMC_GET_OCR, &buff[0])==RES_OK) {
      for(val8=0; val8<4; val8++) {
        buf[0] = '\0';
        %@Utility@'ModuleName'%.strcatNum8Hex(buf, sizeof(buf), (uint8_t)buff[val8]);
        %@Shell@'ModuleName'%.SendStr(buf, io->stdOut);
        %@Shell@'ModuleName'%.SendStr((unsigned char*)" ", io->stdOut);
      }
      %@Shell@'ModuleName'%.SendStr((unsigned char*)"\r\n", io->stdOut);
    } else {
      %@Shell@'ModuleName'%.SendStr((unsigned char*)"ERROR\r\n", io->stdOut);
    }
    %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"SD Status", (unsigned char*)"", io->stdOut);
    if (disk_ioctl(driveNr, MMC_GET_SDSTAT, &buff[0])==RES_OK) {
      for(val8=0; val8<64; val8++) {
        buf[0] = '\0';
        if (val8!=0 && (val8%%16)==0) { /* new line to make things readable */
          %@Shell@'ModuleName'%.SendStr((unsigned char*)"\r\n               ", io->stdOut);
        }
        %@Utility@'ModuleName'%.strcatNum8Hex(buf, sizeof(buf), (uint8_t)buff[val8]);
       %@Shell@'ModuleName'%.SendStr(buf, io->stdOut);
       %@Shell@'ModuleName'%.SendStr((unsigned char*)" ", io->stdOut);
      }
      %@Shell@'ModuleName'%.SendStr((unsigned char*)"\r\n", io->stdOut);
    } else {
      %@Shell@'ModuleName'%.SendStr((unsigned char*)"ERROR\r\n", io->stdOut);
    }
  }
  if (driverVersion==1) { /* only LLD_SDHD cards implement this */
    buff[1] = sizeof(buf)-2; /* size of buffer */
    buff[0] = MMC_GET_LLD_CMD_HIGH_CAPACITY; /* cmd */
    if (disk_ioctl(driveNr, MMC_GET_LLD_INFO, &buff[0])==RES_OK) {
      %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"High capacity", (unsigned char*)(buff[2]!=0?"yes\r\n":"no\r\n"), io->stdOut);
    }
    buff[0] = MMC_GET_LLD_CMD_HIGH_SPEED; /* cmd */
    if (disk_ioctl(driveNr, MMC_GET_LLD_INFO, &buff[0])==RES_OK) {
      %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"High speed", (unsigned char*)(buff[2]!=0?"yes\r\n":"no\r\n"), io->stdOut);
    }
    buff[0] = MMC_GET_LLD_CMD_LOW_VOLTAGE; /* cmd */
    if (disk_ioctl(driveNr, MMC_GET_LLD_INFO, &buff[0])==RES_OK) {
      %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"Low voltage", (unsigned char*)(buff[2]!=0?"yes\r\n":"no\r\n"), io->stdOut);
    }
    buff[0] = MMC_GET_LLD_CMD_DATA_WIDTHS; /* cmd */
    if (disk_ioctl(driveNr, MMC_GET_LLD_INFO, &buff[0])==RES_OK) {
      %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"Data widths", (unsigned char*)"", io->stdOut);
      if (buff[2]&0x1) {
        %@Shell@'ModuleName'%.SendStr((unsigned char*)"1 ", io->stdOut);
      }
      if (buff[2]&0x2) {
        %@Shell@'ModuleName'%.SendStr((unsigned char*)"4 ", io->stdOut);
      }
      if (buff[2]&0x4) {
        %@Shell@'ModuleName'%.SendStr((unsigned char*)"8 ", io->stdOut);
      }
      %@Shell@'ModuleName'%.SendStr((unsigned char*)"\r\n", io->stdOut);
    }
    buff[0] = MMC_GET_LLD_CMD_OPERATIONS; /* cmd */
    if (disk_ioctl(driveNr, MMC_GET_LLD_INFO, &buff[0])==RES_OK) {
      %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"Operations", (unsigned char*)"", io->stdOut);
      if (buff[2]&0x1) {
        %@Shell@'ModuleName'%.SendStr((unsigned char*)"BlockRead ", io->stdOut);
      }
      if (buff[2]&0x2) {
        %@Shell@'ModuleName'%.SendStr((unsigned char*)"BlockWrite ", io->stdOut);
      }
      if (buff[2]&0x4) {
        %@Shell@'ModuleName'%.SendStr((unsigned char*)"BlockErase ", io->stdOut);
      }
      if (buff[2]&0x8) {
        %@Shell@'ModuleName'%.SendStr((unsigned char*)"WriteProtect ", io->stdOut);
      }
      if (buff[2]&0x10) {
        %@Shell@'ModuleName'%.SendStr((unsigned char*)"I/O ", io->stdOut);
      }
      %@Shell@'ModuleName'%.SendStr((unsigned char*)"\r\n", io->stdOut);
    }
  }
  return ERR_OK;
}

%endif %- PrintDiskInfo
%-BW_METHOD_END PrintDiskInfo
%-************************************************************************************************************
%-BW_METHOD_BEGIN Benchmark
%ifdef Benchmark
%define! Pario
%define! RetVal
%include Common\FAT_FileSystemBenchmark.Inc
/*! \brief Simple benchmark function: first we are going to write a file, then we will copy it */
uint8_t %'ModuleName'%.%Benchmark(const %@Shell@'ModuleName'%.StdIOType *io)
{
  static FIL fp;
  uint16_t i;
  UINT bw;
  uint8_t read_buf[10];
  TIMEREC time, startTime;
  int32_t start_mseconds, mseconds;

  if (%'ModuleName'%.isWriteProtected((uint8_t*)%'ModuleName'%.CONFIG_DEFAULT_DRIVE_STRING)) {
    %@Shell@'ModuleName'%.SendStr((unsigned char*)"disk is write protected!\r\n", io->stdErr);
    return ERR_FAILED;
  }
  /* write benchmark */
  %@Shell@'ModuleName'%.SendStr((const unsigned char*)"Benchmark: write/copy/read a 100kB file:\r\n", io->stdOut);
  %@Shell@'ModuleName'%.SendStr((const unsigned char*)"Delete existing benchmark files...\r\n", io->stdOut);
  (void)%'ModuleName'%.%DeleteFile((const unsigned char*)"./bench.txt", io);
  (void)%'ModuleName'%.%DeleteFile((const unsigned char*)"./copy.txt", io);

  %@Shell@'ModuleName'%.SendStr((const unsigned char*)"Create benchmark file...\r\n", io->stdOut);
  (void)%@RTC@'ModuleName'%.GetTime(&startTime);
  if (%'ModuleName'%.%open(&fp, (const TCHAR*)"./bench.txt", FA_CREATE_ALWAYS|FA_WRITE)!=FR_OK) {
    %@Shell@'ModuleName'%.SendStr((const unsigned char*)"*** Failed opening benchmark file!\r\n", io->stdErr);
    return ERR_FAILED;
  }
  for(i=0;i<10240;i++) {
    if (%'ModuleName'%.%write(&fp, "benchmark ", sizeof("benchmark ")-1, &bw)!=FR_OK) {
      %@Shell@'ModuleName'%.SendStr((const unsigned char*)"*** Failed writing file!\r\n", io->stdErr);
      (void)%'ModuleName'%.%close(&fp);
      return ERR_FAILED;
    }
  }
  (void)%'ModuleName'%.%close(&fp);
  (void)%@RTC@'ModuleName'%.GetTime(&time);
  start_mseconds = startTime.Hour*60*60*1000 + startTime.Min*60*1000 + startTime.Sec*1000
#if %@RTC@'ModuleName'%.HAS_SEC100_IN_TIMEREC
  + startTime.Sec100*10
#endif
  ;
  mseconds = time.Hour*60*60*1000 + time.Min*60*1000 + time.Sec*1000
#if %@RTC@'ModuleName'%.HAS_SEC100_IN_TIMEREC
  + time.Sec100*10
#endif
  - start_mseconds;
  %@Shell@'ModuleName'%.SendNum32s(mseconds, io->stdOut);
  %@Shell@'ModuleName'%.SendStr((const unsigned char*)" ms for writing (", io->stdOut);
  %@Shell@'ModuleName'%.SendNum32s((100*1000)/mseconds, io->stdOut);
  %@Shell@'ModuleName'%.SendStr((const unsigned char*)" kB/s)\r\n", io->stdOut);

  /* read benchmark */
  %@Shell@'ModuleName'%.SendStr((const unsigned char*)"Read 100kB benchmark file...\r\n", io->stdOut);
  (void)%@RTC@'ModuleName'%.GetTime(&startTime);
  if (%'ModuleName'%.%open(&fp, (const TCHAR*)"./bench.txt", FA_READ)!=FR_OK) {
    %@Shell@'ModuleName'%.SendStr((const unsigned char*)"*** Failed opening benchmark file!\r\n", io->stdErr);
    return ERR_FAILED;
  }
  for(i=0;i<10240;i++) {
    if (%'ModuleName'%.%read(&fp, &read_buf[0], sizeof(read_buf), &bw)!=FR_OK) {
      %@Shell@'ModuleName'%.SendStr((const unsigned char*)"*** Failed reading file!\r\n", io->stdErr);
      (void)%'ModuleName'%.%close(&fp);
      return ERR_FAILED;
    }
  }
  (void)%'ModuleName'%.%close(&fp);
  (void)%@RTC@'ModuleName'%.GetTime(&time);
  start_mseconds = startTime.Hour*60*60*1000 + startTime.Min*60*1000 + startTime.Sec*1000
#if %@RTC@'ModuleName'%.HAS_SEC100_IN_TIMEREC
  + startTime.Sec100*10
#endif
  ;
  mseconds = time.Hour*60*60*1000 + time.Min*60*1000 + time.Sec*1000
#if %@RTC@'ModuleName'%.HAS_SEC100_IN_TIMEREC
  + time.Sec100*10
#endif
  - start_mseconds;
  %@Shell@'ModuleName'%.SendNum32s(mseconds, io->stdOut);
  %@Shell@'ModuleName'%.SendStr((const unsigned char*)" ms for reading (", io->stdOut);
  %@Shell@'ModuleName'%.SendNum32s((100*1000)/mseconds, io->stdOut);
  %@Shell@'ModuleName'%.SendStr((const unsigned char*)" kB/s)\r\n", io->stdOut);

  /* copy benchmark */
  %@Shell@'ModuleName'%.SendStr((const unsigned char*)"Copy 100kB file...\r\n", io->stdOut);
  (void)%@RTC@'ModuleName'%.GetTime(&startTime);
  (void)%'ModuleName'%.%CopyFile((const unsigned char*)"./bench.txt", (const unsigned char*)"./copy.txt", io);
  (void)%@RTC@'ModuleName'%.GetTime(&time);
  start_mseconds = startTime.Hour*60*60*1000 + startTime.Min*60*1000 + startTime.Sec*1000
#if %@RTC@'ModuleName'%.HAS_SEC100_IN_TIMEREC
  + startTime.Sec100*10
#endif
  ;
  mseconds = time.Hour*60*60*1000 + time.Min*60*1000 + time.Sec*1000
#if %@RTC@'ModuleName'%.HAS_SEC100_IN_TIMEREC
  + time.Sec100*10
#endif
  - start_mseconds;
  %@Shell@'ModuleName'%.SendNum32s(mseconds, io->stdOut);
  %@Shell@'ModuleName'%.SendStr((const unsigned char*)" ms for copy (", io->stdOut);
  %@Shell@'ModuleName'%.SendNum32s((100*1000)/mseconds, io->stdOut);
  %@Shell@'ModuleName'%.SendStr((const unsigned char*)" kB/s)\r\n", io->stdOut);
  %@Shell@'ModuleName'%.SendStr((const unsigned char*)"done!\r\n", io->stdOut);
  return ERR_OK;
}

%endif %- Benchmark
%-BW_METHOD_END Benchmark
%-************************************************************************************************************
%-BW_METHOD_BEGIN f_getlabel
%ifdef f_getlabel
%define! Parpath
%define! Parlabel
%define! Parvsn
%define! RetVal
%include Common\FAT_FileSystemf_getlabel.Inc
/*
FRESULT %'ModuleName'%.%f_getlabel(const TCHAR* path, TCHAR* label, DWORD* vsn)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- f_getlabel
%-BW_METHOD_END f_getlabel
%-************************************************************************************************************
%-BW_METHOD_BEGIN f_setlabel
%ifdef f_setlabel
%define! Parlabel
%define! RetVal
%include Common\FAT_FileSystemf_setlabel.Inc
/*
FRESULT %'ModuleName'%.%f_setlabel(const TCHAR* label)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- f_setlabel
%-BW_METHOD_END f_setlabel
%-************************************************************************************************************
%-BW_METHOD_BEGIN f_expand
%ifdef f_expand
%define! Parfp
%define! Parfsz
%define! Paropt
%define! RetVal
%include Common\FAT_FileSystemf_expand.Inc
/*
FRESULT %'ModuleName'%.%f_expand(FIL* fp, FSIZE_t fsz, BYTE opt)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- f_expand
%-BW_METHOD_END f_expand
%-************************************************************************************************************
%-BW_METHOD_BEGIN f_findfirst
%ifdef f_findfirst
%define! Pardp
%define! Parfno
%define! Parpath
%define! Parpattern
%define! RetVal
%include Common\FAT_FileSystemf_findfirst.Inc
/*
FRESULT %'ModuleName'%.%f_findfirst(DIR* dp, FILINFO* fno, const TCHAR* path, const TCHAR* pattern)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- f_findfirst
%-BW_METHOD_END f_findfirst
%-************************************************************************************************************
%-BW_METHOD_BEGIN f_findnext
%ifdef f_findnext
%define! Pardp
%define! Parfno
%define! RetVal
%include Common\FAT_FileSystemf_findnext.Inc
/*
FRESULT %'ModuleName'%.%f_findnext(DIR* dp, FILINFO* fno)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- f_findnext
%-BW_METHOD_END f_findnext
%-************************************************************************************************************
%-BW_METHOD_BEGIN f_opendir
%ifdef f_opendir
%define! Pardp
%define! Parpath
%define! RetVal
%include Common\FAT_FileSystemf_opendir.Inc
/*
FRESULT %'ModuleName'%.%f_opendir(DIR* dp, const TCHAR* path)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- f_opendir
%-BW_METHOD_END f_opendir
%-************************************************************************************************************
%-BW_METHOD_BEGIN f_closedir
%ifdef f_closedir
%define! Pardp
%define! RetVal
%include Common\FAT_FileSystemf_closedir.Inc
/*
FRESULT %'ModuleName'%.%f_closedir(DIR* dp)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- f_closedir
%-BW_METHOD_END f_closedir
%-************************************************************************************************************
%-BW_METHOD_BEGIN f_readdir
%ifdef f_readdir
%define! Pardir
%define! Parfno
%define! RetVal
%include Common\FAT_FileSystemf_readdir.Inc
/*
FRESULT %'ModuleName'%.%f_readdir(DIR *dj, FILINFO *fno)
{
  *** method is implemented as macro in the header file
}
*/

%endif %- f_readdir
%-BW_METHOD_END f_readdir
%-BW_IMPLEMENT_END
/* END %ModuleName. */

%include Common\Header.End
%-
%-
%-BW_EVENT_IMPLEMENT_START
%-BW_METHOD_BEGIN OnIdle
%ifdef OnIdle
%IMPLEMENTATION OnIdle
%include Common\FAT_FileSystemOnIdle.Inc
void %OnIdle(void)
{
  /* Write your code here ... */
}

%endif %- OnIdle
%-BW_METHOD_END OnIdle
%-BW_METHOD_BEGIN OnSchedule
%ifdef OnSchedule
%IMPLEMENTATION OnSchedule
%include Common\FAT_FileSystemOnSchedule.Inc
void %OnSchedule(void)
{
  /* Write your code here ... */
}

%endif %- OnSchedule
%-BW_METHOD_END OnSchedule
%-BW_METHOD_BEGIN OnCreateSyncObject
%ifdef OnCreateSyncObject
%IMPLEMENTATION OnCreateSyncObject
%define! Parsobj
%include Common\FAT_FileSystemOnCreateSyncObject.Inc
void %OnCreateSyncObject(void *sobj)
{
  /* Write your code here ... */
}

%endif %- OnCreateSyncObject
%-BW_METHOD_END OnCreateSyncObject
%-BW_EVENT_IMPLEMENT_END
%INITIALIZATION
  /* ### %DeviceType "%DeviceName" init code ... */
%CODE_BEGIN
%CODE_END
%-
%ENABLE
%CODE_BEGIN
%CODE_END
%-
%-----------------------------------------------------------------------------------------
%if defined(sdk) & %@sdk@ConfigFilesFolderName <> ""
  %define  ConfigSrcDirFolder %%@sdk@ConfigFilesFolderName/
%else
  %define  ConfigSrcDirFolder
%endif
%----------------------------
%FILE %'DirRel_Code'%'ConfigSrcDirFolder'%'ModuleName'config.h
/**
 * \file
 * \brief Configuration header file for FAT_FileSystem
 *
 * This header file is used to configure settings of the Generic I2C module.
 */

#ifndef __%'ModuleName'_CONFIG_H
#define __%'ModuleName'_CONFIG_H

#ifndef %'ModuleName'%.CONFIG_CARD_INSERT_DELAY_TIME_MS
  %if defined(CardInsertDelayTime)
  #define %'ModuleName'%.CONFIG_CARD_INSERT_DELAY_TIME_MS    (%CardInsertDelayTime)
  %else
  #define %'ModuleName'%.CONFIG_CARD_INSERT_DELAY_TIME_MS    (0)
  %endif
    /*!< Delay time in milliseconds after insertion of the card detected */
#endif

#ifndef %'ModuleName'%.CONFIG_SHELL_ENABLED
  %if defined(Shell) & defined(ParseCommand)
  #define %'ModuleName'%.CONFIG_SHELL_ENABLED    (1)
  %else
  #define %'ModuleName'%.CONFIG_SHELL_ENABLED    (0)
  %endif
    /*!< 1: Shell support is enabled; 0: no shell support enabled */
#endif

#ifndef %'ModuleName'%.CONFIG_IS_DISK_PRESENT_CALLBACK
  #define %'ModuleName'%.CONFIG_IS_DISK_PRESENT_CALLBACK    %'ModuleName'%.IsDiskPresent
    /*!< 1: callback name to be used to decide if a device is present or not */
#endif

#ifndef %'ModuleName'%.CONFIG_IS_WRITE_PROTECTED_CALLBACK
  #define %'ModuleName'%.CONFIG_IS_WRITE_PROTECTED_CALLBACK    %'ModuleName'%.IsWriteProtected
    /*!< 1: callback name to be used to decide if a device is present or not */
#endif

#ifndef %'ModuleName'%.CONFIG_DEFAULT_DRIVE_STRING
  #define %'ModuleName'%.CONFIG_DEFAULT_DRIVE_STRING    "0:/"
    /*!< default drive used for commands. The first letter defines the drive */
#endif

#endif /* __%'ModuleName'_CONFIG_H */
%-----------------------------------------------------------------------------------------

%else %- Language (& Compiler)
  %error^ This bean is not implemented in selected language & compiler !
%endif %- Language (& Compiler)
%DEBUG
%ALL_SYMBOLS
%-
