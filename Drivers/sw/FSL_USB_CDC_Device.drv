%-Driver generated by the Component Wizard
%-
%- WARNING !
%-
%- Do not make changes to these lines (if you make some changes, you damage this driver)
%- which begins with:
%-
%-  %-STARTUSERTYPES
%-  %-ENDUSRTYPES
%-  /* END %ModuleName. */
%-  /* MODULE %ModuleName. */
%-  %-INTERNAL_METHOD_BEG
%-  %-INTERNAL_METHOD_END
%-  %-INHERITED_EVENT_BEGIN
%-  %-INHERITED_EVENT_END
%-  %-BW_METHOD_BEGIN
%-  %-BW_METHOD_END
%-  %-BW_DEFINITION_START
%-  %-BW_DEFINITION_END
%-  %-BW_IMPLEMENT_START
%-  %-BW_IMPLEMENT_END
%-  %-BW_EVENT_DEFINITION_START
%-  %-BW_EVENT_DEFINITION_END
%-  %-BW_EVENT_IMPLEMENT_START
%-  %-BW_EVENT_IMPLEMENT_END
%-  %-BW_METHOD_MACROS_START
%-  %-BW_METHOD_MACROS_END
%-  %-BW_SECTIONS_INSERT
%-  %-BW_INTERN_COMMENTS_START
%-  %-BW_INTERN_COMMENTS_END
%-  %-BW_BEAN_CONSTANTS_START
%-  %-BW_BEAN_CONSTANTS_END
%-
%-
%- These lines are not comments, but they are necessary for Component Wizard
%- If you change these lines, Component Wizard will not be responsible for loosing or damaging your code!
%-
%-
%- readyCPU ...
%- readyDEVICE ...
%-
%define DriverAuthor  Author
%define DriverVersion 01.00
%define DriverDate    13.12.2011
%-
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END
%-
%-BW_INTERN_COMMENTS_START
%- List of descriptions of internal methods
%define! Description_SendDataBlock Sends a USB data block
%define! Description_RunUsbEngine Runs the USB polling engine
%-BW_INTERN_COMMENTS_END
%-
%-BW_SECTIONS_INSERT
%if Language='ANSIC'
%- copy files
%include FSL_USB_CDC_Device_Files.prg
%-
%-
%INTERFACE
%define! Settings Common\FSL_USB_CDC_DeviceSettings.Inc
%define! Abstract Common\FSL_USB_CDC_DeviceAbstract.Inc
%include Common\Header.h

#ifndef __%'ModuleName'_H
#define __%'ModuleName'_H

/* MODULE %ModuleName. */
#include "%@sdk@ModuleName.h" /* SDK and API used */
#include "%'ModuleName'config.h" /* configuration */

%-BW_CUSTOM_INCLUDE_START_H
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
#include <stddef.h> /* for size_t */
#include "%@Shell@'ModuleName'.h" /* shell interface */
#include "%@RxBuffer@'ModuleName'.h"
#include "%@TxBuffer@'ModuleName'.h"
%-
%-BW_CUSTOM_INCLUDE_END_H
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END

%-STARTUSERTYPES - Do not make changes between lines (included this lines) marked with %-STARTUSERTYPES and %-ENDUSRTYPES

#ifndef __BWUserType_%'ModuleName'_TComData
#define __BWUserType_%'ModuleName'_TComData
  typedef uint8_t %'ModuleName'_TComData ;                       %>40/* User type for communication data type. */
#endif

%-ENDUSRTYPES
%-BW_BEAN_CONSTANTS_START  - Do not make changes between lines (included this lines) marked with %-BW_BEAN_CONSTANTS_START and %-BW_BEAN_CONSTANTS_END
%- No constants defined in the BeanWizard for this bean
%-BW_BEAN_CONSTANTS_END
%-BW_CUSTOM_USERTYPE_START
%- Write your own types here ...
%-  Example:
%-    typedef int TMyInteger;
%-
/*
   DATA_BUFF_SIZE should be greater than or equal to the endpoint buffer size,
   otherwise there will be data loss. For MC9S08JS16, maximum DATA_BUFF_SIZE
   supported is 16 Bytes
*/
%if CPUDevice="MC9S08JS16"
#define %'ModuleName'%.DATA_BUFF_SIZE    16
%else
#define %'ModuleName'%.DATA_BUFF_SIZE    %'ModuleName'%.CONFIG_DATA_BUF_SIZE
%endif

#define %'ModuleName'%.USB_ERR_SEND            1  /* Error while sending */
#define %'ModuleName'%.USB_ERR_BUSOFF          2  /* Bus not ready */
#define %'ModuleName'%.USB_ERR_INIT            3  /* USB initialization error */
#define %'ModuleName'%.USB_ERR_TX_CHAR         4  /* Error sending character */
#define %'ModuleName'%.USB_ERR_TX_STRING       5  /* Error sending string */
#define %'ModuleName'%.USB_ERR_CHECKED_TXFULL  6  /* Error during sending a checked block */
#define %'ModuleName'%.USB_ERR_RECEIVE         7  /* Error while starting an receive transaction */
#define %'ModuleName'%.USB_ERR_RX_PUT          8  /* Error while putting RX byte into buffer */
#define %'ModuleName'%.USB_ERR_TX_BLOCK        9  /* Error sending data block */
#define %'ModuleName'%.USB_TIMEOUT_SEND       10  /* Timeout while sending */
#define %'ModuleName'%.USB_ERR_DEINIT         11  /* USB deinitialization error */

%if (CPUDevice="MCF51MM256") | (CPUDevice="MCF51JE256")
/* special USB interrupt handling for %CPUDevice */
extern volatile uint8_t %'ModuleName'%.usb_int_disable;
extern volatile uint8_t %'ModuleName'%.usb_int_en_copy;

%endif
extern %@Shell@'ModuleName'%.ConstStdIOType %'ModuleName'%.stdio; /* default standard I/O */
extern uint8_t %'ModuleName'%.DefaultShellBuffer[%@Shell@'ModuleName'%.DEFAULT_SHELL_BUFFER_SIZE]; /* default buffer which can be used by the application */

%-BW_CUSTOM_USERTYPE_END
%-BW_DEFINITION_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetFreeInTxBuf
%ifdef GetFreeInTxBuf
#define %'ModuleName'%.%GetFreeInTxBuf() \
  %@TxBuffer@'ModuleName'%.NofFreeElements()
%define! RetVal
%include Common\FSL_USB_CDC_DeviceGetFreeInTxBuf.Inc

%endif %- GetFreeInTxBuf
%-BW_METHOD_END GetFreeInTxBuf
%-************************************************************************************************************
%-BW_METHOD_BEGIN RecvChar
%ifdef RecvChar
uint8_t %'ModuleName'%.%RecvChar(%'ModuleName'_TComData *Chr);
%define! ParChr
%define! RetVal
%include Common\FSL_USB_CDC_DeviceRecvChar.Inc

%endif %- RecvChar
%-BW_METHOD_END RecvChar
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendChar
%ifdef SendChar
uint8_t %'ModuleName'%.%SendChar(%'ModuleName'_TComData Chr);
%define! ParChr
%define! RetVal
%include Common\FSL_USB_CDC_DeviceSendChar.Inc

%endif %- SendChar
%-BW_METHOD_END SendChar
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetCharsInTxBuf
%ifdef GetCharsInTxBuf
#define %'ModuleName'%.%GetCharsInTxBuf() \
  %@TxBuffer@'ModuleName'%.NofElements()
%define! RetVal
%include Common\FSL_USB_CDC_DeviceGetCharsInTxBuf.Inc

%endif %- GetCharsInTxBuf
%-BW_METHOD_END GetCharsInTxBuf
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetCharsInRxBuf
%ifdef GetCharsInRxBuf
uint16_t %'ModuleName'%.%GetCharsInRxBuf(void);
%define! RetVal
%include Common\FSL_USB_CDC_DeviceGetCharsInRxBuf.Inc

%endif %- GetCharsInRxBuf
%-BW_METHOD_END GetCharsInRxBuf
%-************************************************************************************************************
%-BW_METHOD_BEGIN Init
%ifdef Init
uint8_t %'ModuleName'%.%Init(void);
%define! RetVal
%include Common\FSL_USB_CDC_DeviceInit.Inc

%endif %- Init
%-BW_METHOD_END Init
%-************************************************************************************************************
%-BW_METHOD_BEGIN App_Task
%ifdef App_Task
uint8_t %'ModuleName'%.%App_Task(uint8_t *txBuf, size_t txBufSize);
%define! PartxBuf
%define! PartxBufSize
%define! RetVal
%include Common\FSL_USB_CDC_DeviceApp_Task.Inc

%endif %- App_Task
%-BW_METHOD_END App_Task
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendString
%ifdef SendString
uint8_t %'ModuleName'%.%SendString(%'ModuleName'_TComData *Chr);
%define! ParChr
%define! RetVal
%include Common\FSL_USB_CDC_DeviceSendString.Inc

%endif %- SendString
%-BW_METHOD_END SendString
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetChar
%ifdef GetChar
#define %'ModuleName'%.%GetChar(Chr) \
  %@RxBuffer@'ModuleName'%.Get(Chr)

%define! ParChr
%define! RetVal
%include Common\FSL_USB_CDC_DeviceGetChar.Inc

%endif %- GetChar
%-BW_METHOD_END GetChar
%-************************************************************************************************************
%-BW_METHOD_BEGIN PutBufferChecked
%ifdef PutBufferChecked
uint8_t %'ModuleName'%.%PutBufferChecked(uint8_t *buf, size_t bufSize);
%define! Parbuf
%define! Parbufsize
%define! RetVal
%include Common\FSL_USB_CDC_DevicePutBufferChecked.Inc

%endif %- PutBufferChecked
%-BW_METHOD_END PutBufferChecked
%-************************************************************************************************************
%-BW_METHOD_BEGIN App_Callback
%ifdef App_Callback
void %'ModuleName'%.%App_Callback(uint8_t controller_ID, uint8_t event_type, void *val);
%define! Parcontroller_ID
%define! Parevent_type
%define! Parval
%include Common\FSL_USB_CDC_DeviceUSB_App_Callback.Inc

%endif %- App_Callback
%-BW_METHOD_END App_Callback
%-************************************************************************************************************
%-BW_METHOD_BEGIN Notify_Callback
%ifdef Notify_Callback
void %'ModuleName'%.%Notify_Callback(uint8_t controller_ID, uint8_t event_type, void *val);
%define! Parcontroller_ID
%define! Parevent_type
%define! Parval
%include Common\FSL_USB_CDC_DeviceUSB_Notify_Callback.Inc

%endif %- Notify_Callback
%-BW_METHOD_END Notify_Callback
%-************************************************************************************************************
%-BW_METHOD_BEGIN ClearRxBuffer
%ifdef ClearRxBuffer
#define %'ModuleName'%.%ClearRxBuffer() \
    %@RxBuffer@'ModuleName'%.Clear()
%include Common\FSL_USB_CDC_DeviceClearRxBuffer.Inc

%endif %- ClearRxBuffer
%-BW_METHOD_END ClearRxBuffer
%-************************************************************************************************************
%-BW_METHOD_BEGIN ClearTxBuffer
%ifdef ClearTxBuffer
#define %'ModuleName'%.%ClearTxBuffer() \
    %@TxBuffer@'ModuleName'%.Clear()
%include Common\FSL_USB_CDC_DeviceClearTxBuffer.Inc

%endif %- ClearTxBuffer
%-BW_METHOD_END ClearTxBuffer
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG RunUsbEngine
void %'ModuleName'%.RunUsbEngine(void);
%include Common\GeneralInternal.inc (RunUsbEngine)

%-INTERNAL_METHOD_END RunUsbEngine
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendBlock
%ifdef SendBlock
uint8_t %'ModuleName'%.%SendBlock(uint8_t *data, size_t dataSize);
%define! Pardata
%define! PardataSize
%define! RetVal
%include Common\FSL_USB_CDC_DeviceSendBlock.Inc

%endif %- SendBlock
%-BW_METHOD_END SendBlock
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG SendDataBlock
uint8_t %'ModuleName'%.SendDataBlock(uint8_t *data, size_t dataSize);
%define! Pardata
%define! PardataSize
%define! RetVal
%include Common\GeneralInternal.inc (SendDataBlock)

%-INTERNAL_METHOD_END SendDataBlock
%-************************************************************************************************************
%-BW_METHOD_BEGIN Deinit
%ifdef Deinit
uint8_t %'ModuleName'%.%Deinit(void);
%define! RetVal
%include Common\FSL_USB_CDC_DeviceDeinit.Inc

%endif %- Deinit
%-BW_METHOD_END Deinit
%-************************************************************************************************************
%-BW_METHOD_BEGIN StdIOKeyPressed
%ifdef StdIOKeyPressed
bool %'ModuleName'%.%StdIOKeyPressed(void);
%define! RetVal
%include Common\FSL_USB_CDC_DeviceStdIOKeyPressed.Inc

%endif %- StdIOKeyPressed
%-BW_METHOD_END StdIOKeyPressed
%-************************************************************************************************************
%-BW_METHOD_BEGIN StdIOReadChar
%ifdef StdIOReadChar
void %'ModuleName'%.%StdIOReadChar(uint8_t *c);
%define! Parc
%include Common\FSL_USB_CDC_DeviceStdIOReadChar.Inc

%endif %- StdIOReadChar
%-BW_METHOD_END StdIOReadChar
%-************************************************************************************************************
%-BW_METHOD_BEGIN StdIOSendChar
%ifdef StdIOSendChar
void %'ModuleName'%.%StdIOSendChar(uint8_t ch);
%define! Parch
%include Common\FSL_USB_CDC_DeviceStdIOSendChar.Inc

%endif %- StdIOSendChar
%-BW_METHOD_END StdIOSendChar
%-************************************************************************************************************
%-BW_METHOD_BEGIN ApplicationStarted
%ifdef ApplicationStarted
bool %'ModuleName'%.%ApplicationStarted(void);
%define! RetVal
%include Common\FSL_USB_CDC_DeviceApplicationStarted.Inc

%endif %- ApplicationStarted
%-BW_METHOD_END ApplicationStarted
%-************************************************************************************************************
%-BW_METHOD_BEGIN TransactionsStarted
%ifdef TransactionsStarted
bool %'ModuleName'%.%TransactionsStarted(void);
%define! RetVal
%include Common\FSL_USB_CDC_DeviceTransactionsStarted.Inc

%endif %- TransactionsStarted
%-BW_METHOD_END TransactionsStarted
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetStdio
%ifdef GetStdio
%@Shell@'ModuleName'%.ConstStdIOTypePtr %'ModuleName'%.%GetStdio(void);
%define! RetVal
%include Common\FSL_USB_CDC_DeviceGetStdio.Inc

%endif %- GetStdio
%-BW_METHOD_END GetStdio
%-BW_DEFINITION_END
/* END %ModuleName. */

#endif
/* ifndef __%'ModuleName'_H */
%include Common\Header.End
%-
%-BW_EVENT_DEFINITION_START
%-BW_METHOD_BEGIN OnError
%ifdef OnError
%INTERFACE OnError
void %OnError(uint8_t error);
%define! Parerror
%include Common\FSL_USB_CDC_DeviceOnError.Inc

%endif %- OnError
%-BW_METHOD_END OnError
%-BW_METHOD_BEGIN OnLineStateChanged
%ifdef OnLineStateChanged
%INTERFACE OnLineStateChanged
void %OnLineStateChanged(uint8_t value);
%define! Parvalue
%include Common\FSL_USB_CDC_DeviceOnLineStateChanged.Inc

%endif %- OnLineStateChanged
%-BW_METHOD_END OnLineStateChanged
%-BW_EVENT_DEFINITION_END
%IMPLEMENTATION
%define! Settings Common\FSL_USB_CDC_DeviceSettings.Inc
%define! Abstract Common\FSL_USB_CDC_DeviceAbstract.Inc
%include Common\Header.C

/* MODULE %ModuleName. */

%for var from EventModules
#include "%var.h"
%endfor
#include "%'ModuleName'.h"
%-BW_CUSTOM_INCLUDE_START_M
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
#include "hidef.h"          /* for EnableInterrupts macro */
#include "derivative.h"     /* include peripheral declarations */
#include "types.h"          /* Contains User Defined Data Types */
#include "usb_cdc.h"        /* USB CDC Class Header File */
#include <stdio.h>
/* skip the inclusion in dependency state */
#ifndef __NO_SETJMP
  #include <stdio.h>
#endif
#include <stdlib.h>
#include <string.h>
#if %'ModuleName'%.CONFIG_USE_TIMEOUT
%if defined(Timeout)
  #include "%@Timeout@'ModuleName'.h"
%else
  #include "Timeout.h"
%endif
#endif
#include "%@Wait@'ModuleName'.h"
%-
%-BW_CUSTOM_INCLUDE_END_M

%-BW_CUSTOM_VARIABLE_START
%- Write your static variables here
%-   Example:
%-     static int counter1;
%-     int %'ModuleName'%.counter2;
#define  CONTROLLER_ID      (0)   /* ID to identify USB CONTROLLER */

#if HIGH_SPEED_DEVICE
static uint_32 g_cdcBuffer[DIC_BULK_OUT_ENDP_PACKET_SIZE>>1];
#endif

/* Virtual COM Application start Init Flag */
static volatile boolean start_app = FALSE;

/* Virtual COM Application Carrier Activate Flag */
static volatile boolean start_transactions = FALSE;
static volatile boolean transactionOngoing = FALSE;

/* default standard I/O struct */
%@Shell@'ModuleName'%.ConstStdIOType %'ModuleName'%.stdio = {
    (%@Shell@'ModuleName'%.StdIO_In_FctType)%'ModuleName'%.StdIOReadChar, /* stdin */
    (%@Shell@'ModuleName'%.StdIO_OutErr_FctType)%'ModuleName'%.StdIOSendChar, /* stdout */
    (%@Shell@'ModuleName'%.StdIO_OutErr_FctType)%'ModuleName'%.StdIOSendChar, /* stderr */
    %'ModuleName'%.StdIOKeyPressed /* if input is not empty */
  };
uint8_t %'ModuleName'%.DefaultShellBuffer[%@Shell@'ModuleName'%.DEFAULT_SHELL_BUFFER_SIZE]; /* default buffer which can be used by the application */
%-
%-BW_CUSTOM_VARIABLE_END
%-BW_INTERN_METHOD_DECL_START
%- List of internal methods headers
%-BW_INTERN_METHOD_DECL_END
%-BW_IMPLEMENT_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetFreeInTxBuf
%ifdef GetFreeInTxBuf
%define! RetVal
%include Common\FSL_USB_CDC_DeviceGetFreeInTxBuf.Inc
/*
uint16_t %'ModuleName'%.%GetFreeInTxBuf(void)
{
  *** Implemented as macro in the header file
}
*/

%endif %- GetFreeInTxBuf
%-BW_METHOD_END GetFreeInTxBuf
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetCharsInTxBuf
%ifdef GetCharsInTxBuf
%define! RetVal
%include Common\FSL_USB_CDC_DeviceGetCharsInTxBuf.Inc
/*
uint16_t %'ModuleName'%.%GetCharsInTxBuf(void)
{
  *** implemented as macro in the header file
  return (uint16_t)%@TxBuffer@'ModuleName'%.NofElements();
}
*/

%endif %- GetCharsInTxBuf
%-BW_METHOD_END GetCharsInTxBuf
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetCharsInRxBuf
%ifdef GetCharsInRxBuf
%define! RetVal
%include Common\FSL_USB_CDC_DeviceGetCharsInRxBuf.Inc
uint16_t %'ModuleName'%.%GetCharsInRxBuf(void)
{
  static uint8_t txBuf[%'ModuleName'%.DATA_BUFF_SIZE];

  if (%'ModuleName'%.%App_Task(txBuf, sizeof(txBuf))!=ERR_OK) { /* call USB handler: if active, then this will empty the buffer */
%if defined(OnError)
    %OnError(%'ModuleName'%.USB_ERR_TX_CHAR);
%endif
  }
  return (uint16_t)%@RxBuffer@'ModuleName'%.NofElements();
}

%endif %- GetCharsInRxBuf
%-BW_METHOD_END GetCharsInRxBuf
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetChar
%ifdef GetChar
%define! ParChr
%define! RetVal
%include Common\FSL_USB_CDC_DeviceGetChar.Inc
/**
uint8_t %'ModuleName'%.%GetChar(%'ModuleName'_TComData *Chr)
{
  *** implemented as macro in the header file
  return %@RxBuffer@'ModuleName'%.Get(Chr);
}
*/
%endif %- GetChar
%-BW_METHOD_END GetChar
%-************************************************************************************************************
%-BW_METHOD_BEGIN RecvChar
%ifdef RecvChar
%define! ParChr
%define! RetVal
%include Common\FSL_USB_CDC_DeviceRecvChar.Inc
uint8_t %'ModuleName'%.%RecvChar(%'ModuleName'_TComData *Chr)
{
  while(%@RxBuffer@'ModuleName'%.Get(Chr)!=ERR_OK) {
    %@Wait@'ModuleName'%.WaitOSms(10); /* avoid to completely block */
    /* retry receiving until success */
  }
  return ERR_OK;
}

%endif %- RecvChar
%-BW_METHOD_END RecvChar
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendChar
%ifdef SendChar
%define! ParChr
%define! RetVal
%include Common\FSL_USB_CDC_DeviceSendChar.Inc
uint8_t %'ModuleName'%.%SendChar(%'ModuleName'_TComData Chr)
{
  static uint8_t txBuf[%'ModuleName'%.DATA_BUFF_SIZE];
  uint8_t res;

  if (%@TxBuffer@'ModuleName'%.Put(Chr)==ERR_TXFULL) { /* retry once, otherwise throw it away  */
    res = %'ModuleName'%.%App_Task(txBuf, sizeof(txBuf)); /* call USB handler: if active, then this will empty the buffer */
    if (res==ERR_BUSOFF) { /* USB not enumerated */
%if defined(OnError)
      %OnError(%'ModuleName'%.USB_ERR_BUSOFF);
%endif
      return ERR_FAILED;
    } else if (res!=ERR_OK) {
%if defined(OnError)
      %OnError(%'ModuleName'%.USB_ERR_TX_CHAR);
%endif
      return ERR_TXFULL;
    } else { /* retry, as USB App_Task() should have sent the buffer */
      return %@TxBuffer@'ModuleName'%.Put(Chr); /* retry. If buffer is still full, we will lose the character */
    }
  }
  return ERR_OK;
}

%endif %- SendChar
%-BW_METHOD_END SendChar
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendBlock
%ifdef SendBlock
%define! Pardata
%define! PardataSize
%define! RetVal
%include Common\FSL_USB_CDC_DeviceSendBlock.Inc
uint8_t %'ModuleName'%.%SendBlock(uint8_t *data, size_t dataSize)
{
  uint8_t res = ERR_OK;

  while(dataSize > 0) {
    if (%'ModuleName'%.%SendChar(*data)!=ERR_OK) {
      res = ERR_TXFULL;
    }
    dataSize--; data++;
  }
%if defined(OnError)
  if (res!=ERR_OK) {
    %OnError(%'ModuleName'%.USB_ERR_TX_BLOCK);
  }
%endif
  return res;
}

%endif %- SendBlock
%-BW_METHOD_END SendBlock
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendString
%ifdef SendString
%define! ParChr
%define! RetVal
%include Common\FSL_USB_CDC_DeviceSendString.Inc
uint8_t %'ModuleName'%.%SendString(%'ModuleName'_TComData *Chr)
{
  uint8_t res = ERR_OK;

  while(*Chr != '\0') {
    if (%'ModuleName'%.%SendChar(*Chr)!=ERR_OK) {
      res = ERR_TXFULL;
    }
    Chr++;
  }
%if defined(OnError)
  if (res!=ERR_OK) {
    %OnError(%'ModuleName'%.USB_ERR_TX_STRING);
  }
%endif
  return res;
}

%endif %- SendString
%-BW_METHOD_END SendString
%-************************************************************************************************************
%-BW_METHOD_BEGIN App_Callback
%ifdef App_Callback
%define! Parcontroller_ID
%define! Parevent_type
%define! Parval
%include Common\FSL_USB_CDC_DeviceApp_Callback.Inc
void %'ModuleName'%.%App_Callback(uint8_t controller_ID, uint8_t event_type, void *val)
{
  UNUSED(controller_ID);
  UNUSED(val);
  if (event_type == USB_APP_BUS_RESET) {
    start_app = FALSE;
  } else if (event_type == USB_APP_ENUM_COMPLETE) {
#if HIGH_SPEED_DEVICE
    /* prepare for the next receive event */
    USB_Class_CDC_Interface_DIC_Recv_Data(&controller_ID,
                                           (uint_8_ptr)g_cdcBuffer,
                                           DIC_BULK_OUT_ENDP_PACKET_SIZE);
#else
    (void)USB_Class_CDC_Interface_DIC_Recv_Data(CONTROLLER_ID, NULL, 0);
#endif
    start_app = TRUE;
  } else if ((event_type==USB_APP_DATA_RECEIVED) && (start_transactions==TRUE)) {
    /* Copy Received Data buffer to Application Buffer */
    USB_PACKET_SIZE BytesToBeCopied;
    APP_DATA_STRUCT *dp_rcv = (APP_DATA_STRUCT*)val;
    uint_8 idx;

    BytesToBeCopied = (USB_PACKET_SIZE)((dp_rcv->data_size>%'ModuleName'%.DATA_BUFF_SIZE) ? %'ModuleName'%.DATA_BUFF_SIZE:dp_rcv->data_size);
    for(idx = 0; idx<BytesToBeCopied ; idx++) {
      if (%@RxBuffer@'ModuleName'%.Put(dp_rcv->data_ptr[idx])!=ERR_OK) {
        /* Failed to put byte into buffer. Is the buffer to small? Then increase the Rx buffer.
           Otherwise not much we could do here, so we are loosing byte here.
         */
        %if defined(OnError)
        %OnError(%'ModuleName'%.USB_ERR_RX_PUT);
        %else
        /* Enable OnError() event so this event will be called here */
        %endif
      }
    }
    (void)USB_Class_CDC_Interface_DIC_Recv_Data(CONTROLLER_ID, NULL, 0); /* see http://eprints.utar.edu.my/143/1/BI-2011-0708672-1.pdf, page 131 */
  } else if ((event_type==USB_APP_SEND_COMPLETE) && (start_transactions==TRUE)) {
    transactionOngoing = FALSE;
    /* Previous Send is complete. Queue next receive */
#if HIGH_SPEED_DEVICE
    //(void)USB_Class_CDC_Interface_DIC_Recv_Data(CONTROLLER_ID, g_cdcBuffer, 0);
#else
    //(void)USB_Class_CDC_Interface_DIC_Recv_Data(CONTROLLER_ID, NULL, 0);
#endif
  } else if (event_type == USB_APP_ERROR) { /* detach? */
    start_app = FALSE;
    start_transactions = FALSE;
  } else if (event_type == USB_APP_BUS_SUSPEND) { /* disconnected cable? */
    start_app = FALSE;
    start_transactions = FALSE;
  }
}

%endif %- App_Callback
%-BW_METHOD_END App_Callback
%-************************************************************************************************************
%-BW_METHOD_BEGIN Notify_Callback
%ifdef Notify_Callback
%define! Parcontroller_ID
%define! Parevent_type
%define! Parval
%include Common\FSL_USB_CDC_DeviceNotify_Callback.Inc
void %'ModuleName'%.%Notify_Callback(uint8_t controller_ID, uint8_t event_type, void *val)
{
  UNUSED(controller_ID);
  UNUSED(val);
  if (start_app == TRUE) {
    if(event_type == USB_APP_CDC_CARRIER_ACTIVATED) {
      start_transactions = TRUE;
    } else if(event_type == USB_APP_CDC_CARRIER_DEACTIVATED) {
      start_transactions = FALSE;
    }
  }
#if 1 /* not needed any more? see https://community.freescale.com/message/605537?et=watches.email.thread# */
  start_transactions = TRUE; /* ??? see http://forums.freescale.com/t5/Freescale-MQX-trade-USB-Host/Cant-get-CDC-virtual-com-demo-to-work-with-VB2005-on-xp-sp3/m-p/92713#M302 */
#endif
}

%endif %- Notify_Callback
%-BW_METHOD_END Notify_Callback
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG RunUsbEngine
%include Common\GeneralInternal.inc (RunUsbEngine)
void %'ModuleName'%.RunUsbEngine(void)
{
%if (CPUDevice="MC9S08JE128") | (CPUDevice="MC9S08JM16") | (CPUDevice="MC9S08JM60") | (CPUDevice="MC9S08JS16") | (CPUDevice="MC9S08MM128")
  if (USB_PROCESS_PENDING()) { /* doing this only for MC9S08JE128, MC9S08JM16, MC9S08JM60, MC9S08JS16 and MC9S08MM128 */
    USB_Engine();
  }
%else
  /* not needed */
%endif
}

%-INTERNAL_METHOD_END RunUsbEngine
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG SendDataBlock
%define! Pardata
%define! PardataSize
%define! RetVal
%include Common\GeneralInternal.inc (SendDataBlock)
uint8_t %'ModuleName'%.SendDataBlock(uint8_t *data, size_t dataSize)
{
#if %'ModuleName'%.CONFIG_USE_TIMEOUT && %'ModuleName'%.CONFIG_APP_TASK_TIMEOUT_MS>0
%if defined(Timeout)
  %@Timeout@'ModuleName'%.CounterHandle timeout;
%else
  TimeoutCounterHandle timeout;
%endif
#endif
  uint8_t res = ERR_OK;

  transactionOngoing = TRUE;
  if (USB_Class_CDC_Interface_DIC_Send_Data(CONTROLLER_ID, data, dataSize)!=USB_OK) {
    transactionOngoing = FALSE;
%if defined(OnError)
    %OnError(%'ModuleName'%.USB_ERR_SEND);
%endif
    return ERR_FAULT;
  }
  /* wait for transaction finish */
#if %'ModuleName'%.CONFIG_USE_TIMEOUT && %'ModuleName'%.CONFIG_APP_TASK_TIMEOUT_MS>0
%if defined(Timeout)
  timeout = %@Timeout@'ModuleName'%.GetCounter(%'ModuleName'%.CONFIG_APP_TASK_TIMEOUT_MS/%@Timeout@'ModuleName'%.TICK_PERIOD_MS); /* set up timeout counter */
%else
  timeout = Timeout_GetCounter(%'ModuleName'%.CONFIG_APP_TASK_TIMEOUT_MS/Timout_TICK_PERIOD_MS); /* set up timeout counter */
%endif
#endif
  while(transactionOngoing) { /* wait until transaction is finished */
    /*lint -save -e522 function lacks side-effects */
    %'ModuleName'%.RunUsbEngine();
    /*lint -restore */
#if %'ModuleName'%.CONFIG_USE_TIMEOUT && %'ModuleName'%.CONFIG_APP_TASK_TIMEOUT_MS>0
%if defined(Timeout)
    if (%@Timeout@'ModuleName'%.CounterExpired(timeout)) {
%if defined(OnError)
      %OnError(%'ModuleName'%.USB_TIMEOUT_SEND);
%endif
      res = ERR_FAILED;
      break;
    }
%else
    if (Timout_CounterExpired(timeout)) {
%if defined(OnError)
      %OnError(%'ModuleName'%.USB_TIMEOUT_SEND);
%endif
      res = ERR_FAILED;
      break;
    }
%endif
#endif
%if defined(SendDataBlockWaitms) & SendDataBlockWaitms >. '0'
    %@Wait@'ModuleName'%.WaitOSms(%SendDataBlockWaitms); /* wait some time */
%endif
  }
#if %'ModuleName'%.CONFIG_USE_TIMEOUT && %'ModuleName'%.CONFIG_APP_TASK_TIMEOUT_MS>0
%if defined(Timeout)
  %@Timeout@'ModuleName'%.LeaveCounter(timeout); /* return timeout counter */
%else
  Timout_LeaveCounter(timeout); /* return timeout counter */
%endif
#endif
  return res;
}

%-INTERNAL_METHOD_END SendDataBlock
%-************************************************************************************************************
%-BW_METHOD_BEGIN App_Task
%ifdef App_Task
%define! PartxBuf
%define! PartxBufSize
%define! RetVal
%include Common\FSL_USB_CDC_DeviceApp_Task.Inc
uint8_t %'ModuleName'%.%App_Task(uint8_t *txBuf, size_t txBufSize)
{
  size_t i;
  uint8_t res;

  /* device is %CPUDevice */
  /*lint -save -e522 function lacks side-effects */
  %'ModuleName'%.RunUsbEngine();
  /*lint -restore */
  /* call the periodic task function */
  USB_Class_CDC_Periodic_Task();
  /* check whether enumeration is complete or not */
  if ((start_app==TRUE) && (start_transactions==TRUE)) {
    if (%@TxBuffer@'ModuleName'%.NofElements()!=0) {
      i = 0;
      while(i<txBufSize && %@TxBuffer@'ModuleName'%.Get(&txBuf[i])==ERR_OK) {
        i++;
      }
      res = %'ModuleName'%.SendDataBlock(txBuf, i);
      if (res!=ERR_OK) {
        return res;
      }
#if 1 /* workaround for problem in USB stack v3.1.1: if last block is 8, 16, 32, 40, 48, ... bytes, it does not get out until the next transfer? */
      if ((i%%8)==0) {
        /* workaround: sending a dummy block of zero bytes */
        res = %'ModuleName'%.SendDataBlock(txBuf, 0);
        if (res!=ERR_OK) {
          return res;
        }
      }
#endif
    } /* if */
    return ERR_OK;
  } else {
%if defined(OnError)
    %OnError(%'ModuleName'%.USB_ERR_BUSOFF);
%endif
    return ERR_BUSOFF; /* USB bus not available yet */
  }
}

%endif %- App_Task
%-BW_METHOD_END App_Task
%-************************************************************************************************************
%-BW_METHOD_BEGIN Deinit
%ifdef Deinit
%define! RetVal
%include Common\FSL_USB_CDC_DeviceDeinit.Inc
uint8_t %'ModuleName'%.%Deinit(void)
{
  uint_8 err;

  err = USB_Class_CDC_DeInit(CONTROLLER_ID);
  %@RxBuffer@'ModuleName'%.Deinit();
  %@TxBuffer@'ModuleName'%.Deinit();
  start_app = FALSE;
  start_transactions = FALSE;
  transactionOngoing = FALSE;
  if(err != USB_OK) {
    /* Error deinitializing USB-CDC Class */
%if defined(OnError)
    %OnError(%'ModuleName'%.USB_ERR_DEINIT);
%endif
    return ERR_FAILED;
  }
  return ERR_OK;
}

%endif %- Deinit
%-BW_METHOD_END Deinit
%-************************************************************************************************************
%-BW_METHOD_BEGIN Init
%ifdef Init
%define! RetVal
%include Common\FSL_USB_CDC_DeviceInit.Inc
uint8_t %'ModuleName'%.%Init(void)
{
  uint_8 err;

  start_app = FALSE;
  start_transactions = FALSE;
  transactionOngoing = FALSE;
  %@RxBuffer@'ModuleName'%.Init();
  %@TxBuffer@'ModuleName'%.Init();
  err = USB_Class_CDC_Init(CONTROLLER_ID, %'ModuleName'%.%App_Callback, NULL, %'ModuleName'%.%Notify_Callback, TRUE);
  if(err != USB_OK) {
    /* Error initializing USB-CDC Class */
%if defined(OnError)
    %OnError(%'ModuleName'%.USB_ERR_INIT);
%endif
    return ERR_FAILED;
  }
  return ERR_OK;
}

%endif %- Init
%-BW_METHOD_END Init
%-************************************************************************************************************
%-BW_METHOD_BEGIN PutBufferChecked
%ifdef PutBufferChecked
%define! Parbuf
%define! Parbufsize
%define! RetVal
%include Common\FSL_USB_CDC_DevicePutBufferChecked.Inc
uint8_t %'ModuleName'%.%PutBufferChecked(uint8_t *buf, size_t bufSize)
{
  uint8_t res;

  if(bufSize>%'ModuleName'%.%GetFreeInTxBuf()) { /* no room at the Inn... */
%if defined(OnError)
    %OnError(%'ModuleName'%.USB_ERR_CHECKED_TXFULL);
%endif
    res = ERR_TXFULL;
  } else {
    res = ERR_OK;
    while(bufSize>0 && res==ERR_OK) {
      res = %@TxBuffer@'ModuleName'%.Put(*buf);
      bufSize--;
      buf++;
    }
  }
  return res;
}

%endif %- PutBufferChecked
%-BW_METHOD_END PutBufferChecked
%-************************************************************************************************************
%-BW_METHOD_BEGIN ClearRxBuffer
%ifdef ClearRxBuffer
%include Common\FSL_USB_CDC_DeviceClearRxBuffer.Inc
/**
void %'ModuleName'%.%ClearRxBuffer(void)
{
  Implemented as macro in the header file
}
*/

%endif %- ClearRxBuffer
%-BW_METHOD_END ClearRxBuffer
%-************************************************************************************************************
%-BW_METHOD_BEGIN ClearTxBuffer
%ifdef ClearTxBuffer
%include Common\FSL_USB_CDC_DeviceClearTxBuffer.Inc
/**
void %'ModuleName'%.%ClearTxBuffer(void)
{
  Implemented as macro in the header file
}
*/

%endif %- ClearTxBuffer
%-BW_METHOD_END ClearTxBuffer
%-************************************************************************************************************
%-BW_METHOD_BEGIN StdIOKeyPressed
%ifdef StdIOKeyPressed
%define! RetVal
%include Common\FSL_USB_CDC_DeviceStdIOKeyPressed.Inc
bool %'ModuleName'%.%StdIOKeyPressed(void)
{
  return (bool)((%'ModuleName'%.%GetCharsInRxBuf()==0U) ? FALSE : TRUE); /* true if there are characters in receive buffer */
}

%endif %- StdIOKeyPressed
%-BW_METHOD_END StdIOKeyPressed
%-************************************************************************************************************
%-BW_METHOD_BEGIN StdIOReadChar
%ifdef StdIOReadChar
%define! Parc
%include Common\FSL_USB_CDC_DeviceStdIOReadChar.Inc
void %'ModuleName'%.%StdIOReadChar(uint8_t *c)
{
  if (%'ModuleName'%.%RecvChar((uint8_t *)c) != ERR_OK) {
    /* failed to receive character: return a zero character */
    *c = '\0';
  }
}

%endif %- StdIOReadChar
%-BW_METHOD_END StdIOReadChar
%-************************************************************************************************************
%-BW_METHOD_BEGIN StdIOSendChar
%ifdef StdIOSendChar
%define! Parch
%include Common\FSL_USB_CDC_DeviceStdIOSendChar.Inc
void %'ModuleName'%.%StdIOSendChar(uint8_t ch)
{
  while (%'ModuleName'%.%SendChar((uint8_t)ch)==ERR_TXFULL){} /* Send char */
}

%endif %- StdIOSendChar
%-BW_METHOD_END StdIOSendChar
%-************************************************************************************************************
%-BW_METHOD_BEGIN ApplicationStarted
%ifdef ApplicationStarted
%define! RetVal
%include Common\FSL_USB_CDC_DeviceApplicationStarted.Inc
bool %'ModuleName'%.%ApplicationStarted(void)
{
  return start_app; /* TRUE if CDC is running */
}

%endif %- ApplicationStarted
%-BW_METHOD_END ApplicationStarted
%-************************************************************************************************************
%-BW_METHOD_BEGIN TransactionsStarted
%ifdef TransactionsStarted
%define! RetVal
%include Common\FSL_USB_CDC_DeviceTransactionsStarted.Inc
bool %'ModuleName'%.%TransactionsStarted(void)
{
  return start_transactions; /* port open on host */
}

%endif %- TransactionsStarted
%-BW_METHOD_END TransactionsStarted
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetStdio
%ifdef GetStdio
%define! RetVal
%include Common\FSL_USB_CDC_DeviceGetStdio.Inc
%@Shell@'ModuleName'%.ConstStdIOTypePtr %'ModuleName'%.%GetStdio(void)
{
  return &%'ModuleName'%.stdio;
}

%endif %- GetStdio
%-BW_METHOD_END GetStdio
%-BW_IMPLEMENT_END
/* END %ModuleName. */

%include Common\Header.End
%-
%-
%-BW_EVENT_IMPLEMENT_START
%-BW_METHOD_BEGIN OnError
%ifdef OnError
%IMPLEMENTATION OnError
%define! Parerror
%include Common\FSL_USB_CDC_DeviceOnError.Inc
void %OnError(uint8_t error)
{
  /* Write your code here ... */
}

%endif %- OnError
%-BW_METHOD_END OnError
%-BW_METHOD_BEGIN OnLineStateChanged
%ifdef OnLineStateChanged
%IMPLEMENTATION OnLineStateChanged
%define! Parvalue
%include Common\FSL_USB_CDC_DeviceOnLineStateChanged.Inc
void %OnLineStateChanged(uint8_t value)
{
  /* Write your code here ... */
}

%endif %- OnLineStateChanged
%-BW_METHOD_END OnLineStateChanged
%-BW_EVENT_IMPLEMENT_END
%INITIALIZATION
%CODE_BEGIN
%CODE_END
%-
%ENABLE
%CODE_BEGIN
%CODE_END
%-
%-----------------------------------------------------------------------------------------
%if defined(sdk) & %@sdk@ConfigFilesFolderName <> ""
  %define  ConfigSrcDirFolder %%@sdk@ConfigFilesFolderName/
%else
  %define  ConfigSrcDirFolder
%endif
%----------------------------
%FILE %'DirRel_Code'%'ConfigSrcDirFolder'%'ModuleName'config.h

/**
 * \file
 * \brief Configuration header file for FSL_USB_CDC_Device
 * Copyright (c) 2020, Erich Styger
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * This header file is used to configure settings of the USB CDC Device I/O module.
 */

#ifndef __%'ModuleName'_CONFIG_H
#define __%'ModuleName'_CONFIG_H

#ifndef %'ModuleName'%.CONFIG_USE_TIMEOUT
%if defined(Timeout)
  #define %'ModuleName'%.CONFIG_USE_TIMEOUT           1
    /*!< 1: Use timeout; 0: do not use timeout */
%else
  #define %'ModuleName'%.CONFIG_USE_TIMEOUT           0
    /*!< 1: Use timeout; 0: do not use timeout */
%endif
#endif

#ifndef %'ModuleName'%.CONFIG_APP_TASK_TIMEOUT_MS
%if defined(AppTaskTimeout)
  #define %'ModuleName'%.CONFIG_APP_TASK_TIMEOUT_MS   %AppTaskTimeout
    /*!< App Task timeout in milliseconds, 0 to disable timeout */
%else
  #define %'ModuleName'%.CONFIG_APP_TASK_TIMEOUT_MS   0
    /*!< App Task timeout in milliseconds, 0 to disable timeout */
%endif
#endif

#ifndef %'ModuleName'%.CONFIG_DATA_BUF_SIZE
%if defined(DataBufSize)
  #define %'ModuleName'%.CONFIG_DATA_BUF_SIZE           (%DataBufSize)
%else
  #define %'ModuleName'%.CONFIG_DATA_BUF_SIZE           (64)
%endif
    /*!< Value used for %'ModuleName'%.DATA_BUF_SIZE, must be a multiple of endpoint size. The greater the value, the better the performance */
#endif


#endif /* __%'ModuleName'_CONFIG_H */
%-----------------------------------------------------------------------------------------
%else %- Language (& Compiler)
  %error^ This component is not implemented in selected language & compiler !
%endif %- Language (& Compiler)
%DEBUG
%ALL_SYMBOLS
%-
