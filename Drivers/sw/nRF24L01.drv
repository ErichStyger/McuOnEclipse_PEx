%-Driver generated by the Component Wizard
%-
%- WARNING !
%-
%- Do not make changes to these lines (if you make some changes, you damage this driver)
%- which begins with:
%-
%-  %-STARTUSERTYPES
%-  %-ENDUSRTYPES
%-  /* END %ModuleName. */
%-  /* MODULE %ModuleName. */
%-  %-INTERNAL_METHOD_BEG
%-  %-INTERNAL_METHOD_END
%-  %-INHERITED_EVENT_BEGIN
%-  %-INHERITED_EVENT_END
%-  %-BW_METHOD_BEGIN
%-  %-BW_METHOD_END
%-  %-BW_DEFINITION_START
%-  %-BW_DEFINITION_END
%-  %-BW_IMPLEMENT_START
%-  %-BW_IMPLEMENT_END
%-  %-BW_EVENT_DEFINITION_START
%-  %-BW_EVENT_DEFINITION_END
%-  %-BW_EVENT_IMPLEMENT_START
%-  %-BW_EVENT_IMPLEMENT_END
%-  %-BW_METHOD_MACROS_START
%-  %-BW_METHOD_MACROS_END
%-  %-BW_SECTIONS_INSERT
%-  %-BW_INTERN_COMMENTS_START
%-  %-BW_INTERN_COMMENTS_END
%-  %-BW_BEAN_CONSTANTS_START
%-  %-BW_BEAN_CONSTANTS_END
%-
%-
%- These lines are not comments, but they are necessary for Component Wizard
%- If you change these lines, Component Wizard will not be responsible for loosing or damaging your code!
%-
%-
%- readyCPU ...
%- readyDEVICE ...
%-
%define DriverAuthor  Author
%define DriverVersion 01.00
%define DriverDate    15.07.2013
%-
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END
%-
%-BW_INTERN_COMMENTS_START
%- List of descriptions of internal methods
%define! Description_SPIWriteRead Write a byte to the SPI and reads the shifted value
%define! Description_SPIWriteReadBuffer Write a buffer to the SPI and the same time reads the shifted values
%define! Description_SPIWriteBuffer Write a buffer to the SPI bus without returning the shifted in values
%ifdef IRQ
  %ifdef @IRQ@OnInterrupt
    %define! Description_%@IRQ@OnInterrupt This event is called when an active signal edge/level has occurred. The event services the event of the inherited component and eventually invokes other events.
  %endif %- @IRQ@OnInterrupt
%endif %- IRQ
%-BW_INTERN_COMMENTS_END
%-
%-BW_SECTIONS_INSERT
%if Language='ANSIC'
%-
%-
%INTERFACE
%define! Settings Common\nRF24L01Settings.Inc
%define! Abstract Common\nRF24L01Abstract.Inc
%include Common\Header.h

#ifndef __%'ModuleName'_H
#define __%'ModuleName'_H

/* MODULE %ModuleName. */
#include "%@sdk@ModuleName.h" /* SDK and API used */
#include "%'ModuleName'config.h" /* configuration */

/* Include inherited beans */
%ifdef InhrSymbolList
  %for var from InhrSymbolList
#include "%@%var@ModuleName.h"
  %endfor
%endif

/* event handler prototypes */
void %'ModuleName'%.OnInterrupt(void);
void %'ModuleName'%.OnActivate(void);
void %'ModuleName'%.OnDeactivate(void);

%-BW_CUSTOM_INCLUDE_START_H
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%-BW_CUSTOM_INCLUDE_END_H
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END

%-STARTUSERTYPES - Do not make changes between lines (included this lines) marked with %-STARTUSERTYPES and %-ENDUSRTYPES

%-ENDUSRTYPES
%-BW_BEAN_CONSTANTS_START  - Do not make changes between lines (included this lines) marked with %-BW_BEAN_CONSTANTS_START and %-BW_BEAN_CONSTANTS_END
%- No constants defined in the BeanWizard for this bean
%-BW_BEAN_CONSTANTS_END
%-BW_CUSTOM_USERTYPE_START
%- Write your own types here ...
%-  Example:
%-    typedef int TMyInteger;
/* if having multiple users on the SPI bus, enable bus sharing/switching */
%if defined(SwitchBusEnabled) & SwitchBusEnabled='yes'
  #define %'ModuleName'%.SWITCH_BUS   1
  #define %'ModuleName'%.BAUD_RATE_MODE   %BaudRateMode /* Index of baud rate mode */
%else
  #define %'ModuleName'%.SWITCH_BUS   0
  #define %'ModuleName'%.BAUD_RATE_MODE   0 /* dummy */
%endif

/* Memory Map - register address defines */
#define %'ModuleName'%.CONFIG      0x00 /* CONFIG register */

#define %'ModuleName'%.EN_AA       0x01 /* EN_AA register: configures auto-acknowledge per pipe */
  /* EN_AA register bitwise definitions */
  /* masks for auto acknowledge per pipe */
  #define %'ModuleName'%.EN_AA_RESERVED      0xC0
  #define %'ModuleName'%.EN_AA_ENAA_ALL      0x3F
  #define %'ModuleName'%.EN_AA_ENAA_P5       0x20
  #define %'ModuleName'%.EN_AA_ENAA_P4       0x10
  #define %'ModuleName'%.EN_AA_ENAA_P3       0x08
  #define %'ModuleName'%.EN_AA_ENAA_P2       0x04
  #define %'ModuleName'%.EN_AA_ENAA_P1       0x02
  #define %'ModuleName'%.EN_AA_ENAA_P0       0x01
  #define %'ModuleName'%.EN_AA_ENAA_NONE     0x00

#define %'ModuleName'%.EN_RXADDR   0x02 /* EN_RXADDR register */
#define %'ModuleName'%.SETUP_AW    0x03 /* SETUP_AW register */
#define %'ModuleName'%.SETUP_RETR  0x04

#define %'ModuleName'%.RF_CH       0x05 /* Channel register, valid channels from 0x0 to 0x7F */
  /* RF_CH register bitwise definitions */
  #define %'ModuleName'%.RF_CH_RESERVED    0x80

#define %'ModuleName'%.RF_SETUP    0x06 /* RF_SETUP register */
  /* RF_SETUP register bits: */
  #define %'ModuleName'%.RF_SETUP_CONT_WAVE      (1<<7) /* Enables continuous carrier transmit when high. */
  #define %'ModuleName'%.RF_SETUP_PLL_LOCK       (1<<4) /* Force PLL lock signal. Only used in test */

  #define %'ModuleName'%.RF_SETUP_RF_DR_MASK     (%'ModuleName'%.RF_SETUP_RF_DR_LOW|%'ModuleName'%.RF_SETUP_RF_DR_HIGH) /* xx: mask bits */
  #define %'ModuleName'%.RF_SETUP_RF_DR_LOW      (1<<5) /* Set RF Data Rate to 250kbps. See RF_DR_HIGH for encoding. */
  #define %'ModuleName'%.RF_SETUP_RF_DR_HIGH     (1<<3) /* Select between the high speed data rates. */
  #define %'ModuleName'%.RF_SETUP_RF_DR_1000     (0) /* RF_DR_LOW|RF_DR_HIGH: 00 */
  #define %'ModuleName'%.RF_SETUP_RF_DR_2000     (%'ModuleName'%.RF_SETUP_RF_DR_HIGH) /* RF_DR_LOW|RF_DR_HIGH: 01 */
  #define %'ModuleName'%.RF_SETUP_RF_DR_250      (%'ModuleName'%.RF_SETUP_RF_DR_LOW)  /* RF_DR_LOW|RF_DR_HIGH: 10 */

  #define %'ModuleName'%.RF_SETUP_RF_PWR_MASK    (3<<1) /* xx: mask bits */
  #define %'ModuleName'%.RF_SETUP_RF_PWR_18      (0<<1) /* 00: -18dBm */
  #define %'ModuleName'%.RF_SETUP_RF_PWR_12      (1<<1) /* 01: -12dBm */
  #define %'ModuleName'%.RF_SETUP_RF_PWR_10      (2<<1) /* 10: -10dBm */
  #define %'ModuleName'%.RF_SETUP_RF_PWR_0       (3<<1) /* 11: 0dBm, default */

#define %'ModuleName'%.STATUS      0x07
  /* STATUS register bits */
  #define %'ModuleName'%.STATUS_RESERVED                    0x80   /* bit 1xxx xxxx: This bit is reserved */
  #define %'ModuleName'%.STATUS_RX_DR                       0x40   /* bit x1xx xxxx: Data ready RX FIFO interrupt. Asserted when new data arrives RX FIFO */
  #define %'ModuleName'%.STATUS_TX_DS                       0x20   /* bit xx1x xxxx: Data sent TX FIFO interrupt. Asserted when packet transmitted on TX. */
  #define %'ModuleName'%.STATUS_MAX_RT                      0x10   /* bit xxx1 xxxx: maximum number of TX retransmit interrupts */
  #define %'ModuleName'%.STATUS_RX_P_NO                     0x0E
  #define %'ModuleName'%.STATUS_RX_P_NO_RX_FIFO_EMPTY       0x0E
  #define %'ModuleName'%.STATUS_RX_P_NO_UNUSED              0x0C
  #define %'ModuleName'%.STATUS_RX_P_NO_5                   0x0A
  #define %'ModuleName'%.STATUS_RX_P_NO_4                   0x08
  #define %'ModuleName'%.STATUS_RX_P_NO_3                   0x06
  #define %'ModuleName'%.STATUS_RX_P_NO_2                   0x04
  #define %'ModuleName'%.STATUS_RX_P_NO_1                   0x02
  #define %'ModuleName'%.STATUS_RX_P_NO_0                   0x00   /* bit xxxx 111x: pipe number for payload */
  #define %'ModuleName'%.STATUS_TX_FULL                     0x01   /* bit xxxx xxx1: if bit set, then TX FIFO is full */


#define %'ModuleName'%.OBSERVE_TX  0x08
#define %'ModuleName'%.RPD         0x09 /* Received Power Detector */
#define %'ModuleName'%.RX_ADDR_P0  0x0A
#define %'ModuleName'%.RX_ADDR_P1  0x0B
#define %'ModuleName'%.RX_ADDR_P2  0x0C
#define %'ModuleName'%.RX_ADDR_P3  0x0D
#define %'ModuleName'%.RX_ADDR_P4  0x0E
#define %'ModuleName'%.RX_ADDR_P5  0x0F
#define %'ModuleName'%.TX_ADDR     0x10
#define %'ModuleName'%.RX_PW_P0    0x11 /* register to set static RX payload on pipe 0, 0 to 32 bytes */
#define %'ModuleName'%.RX_PW_P1    0x12 /* register to set static RX payload on pipe 1, 0 to 32 bytes */
#define %'ModuleName'%.RX_PW_P2    0x13 /* register to set static RX payload on pipe 2, 0 to 32 bytes */
#define %'ModuleName'%.RX_PW_P3    0x14 /* register to set static RX payload on pipe 3, 0 to 32 bytes */
#define %'ModuleName'%.RX_PW_P4    0x15 /* register to set static RX payload on pipe 4, 0 to 32 bytes */
#define %'ModuleName'%.RX_PW_P5    0x16 /* register to set static RX payload on pipe 5, 0 to 32 bytes */

#define %'ModuleName'%.FIFO_STATUS 0x17 /* FIFO status register */
  /* FIFO_STATUS register bits */
  #define %'ModuleName'%.FIFO_STATUS_RESERVED  (0x8C) /* reserved bits */
  #define %'ModuleName'%.FIFO_STATUS_TX_REUSE  (1<<6)
  #define %'ModuleName'%.FIFO_STATUS_TX_FULL   (1<<5)
  #define %'ModuleName'%.FIFO_STATUS_TX_EMPTY  (1<<4)
  #define %'ModuleName'%.FIFO_STATUS_RX_FULL   (1<<1)
  #define %'ModuleName'%.FIFO_STATUS_RX_EMPTY  (1<<0)

#define %'ModuleName'%.DYNPD       0x1C /* enable dynamic payload length */
  /* DYNPD register bits: */
  #define %'ModuleName'%.DYNPD_DPL_ALL (0x3F) /* enable DPL for all pipes */
  #define %'ModuleName'%.DYNPD_DPL_P0  (1<<0) /* enable DPL for pipe 0 */
  #define %'ModuleName'%.DYNPD_DPL_P1  (1<<1) /* enable DPL for pipe 1 */
  #define %'ModuleName'%.DYNPD_DPL_P2  (1<<2) /* enable DPL for pipe 2 */
  #define %'ModuleName'%.DYNPD_DPL_P3  (1<<3) /* enable DPL for pipe 3 */
  #define %'ModuleName'%.DYNPD_DPL_P4  (1<<4) /* enable DPL for pipe 4 */
  #define %'ModuleName'%.DYNPD_DPL_P5  (1<<5) /* enable DPL for pipe 5 */
#define %'ModuleName'%.FEATURE     0x1D /* feature register */
  /* FEATURE register bits: */
  #define %'ModuleName'%.FEATURE_EN_DPL       (1<<2) /* enables dynamic payload length */
  #define %'ModuleName'%.FEATURE_EN_ACK_PAY   (1<<1) /* enables payload with ACK */
  #define %'ModuleName'%.FEATURE_EN_DYN_PAY   (1<<0) /* enables the W_TX_PAYLOAD_NOACK command */

/* Bit Mnemonics */
/* CONFIG Register Bits */
#define %'ModuleName'%.MASK_RX_DR  (1<<6)  /* Mask interrupt caused by RX_DR: 1: interrupt masked. 0: interrupt enabled */
#define %'ModuleName'%.MASK_TX_DS  (1<<5)  /* Mask interrupt caused by TX_DS: 1: interrupt masked. 0: interrupt enabled */
#define %'ModuleName'%.MASK_MAX_RT (1<<4)  /* Mask interrupt caused by MAX_RT. 1: interrupt not reflected on IRQ pin. 0: reflect MAX_RT as active low interrupt on IRQ pin */
#define %'ModuleName'%.EN_CRC      (1<<3)  /* Enable CRC. Forced high if on of the bits in EN_AA is high */
#define %'ModuleName'%.CRCO        (1<<2)  /* CRC encoding scheme, 0: 1 byte, 1: 2 bytes */
#define %'ModuleName'%.PWR_UP      (1<<1)  /* 1: Power up, 0: Power down */
#define %'ModuleName'%.PRIM_RX     (1<<0)  /* 1: PRX, 0: PTX */
#define %'ModuleName'%.PRIM_TX     (0)     /* 0: PTX */

#define %'ModuleName'%.ERX_P5      5
#define %'ModuleName'%.ERX_P4      4
#define %'ModuleName'%.ERX_P3      3
#define %'ModuleName'%.ERX_P2      2
#define %'ModuleName'%.ERX_P1      1
#define %'ModuleName'%.ERX_P0      0
#define %'ModuleName'%.AW          0
#define %'ModuleName'%.ARD         4
#define %'ModuleName'%.ARC         0
#define %'ModuleName'%.PLL_LOCK    4
#define %'ModuleName'%.RF_DR_HIGH  3
#define %'ModuleName'%.RF_DR_LOW   5
#define %'ModuleName'%.RF_PWR      1
#define %'ModuleName'%.LNA_HCURR   0
#define %'ModuleName'%.RX_DR       6
#define %'ModuleName'%.TX_DS       5
#define %'ModuleName'%.MAX_RT      4
#define %'ModuleName'%.RX_P_NO     1
#define %'ModuleName'%.TX_FULL     0
#define %'ModuleName'%.PLOS_CNT    4
#define %'ModuleName'%.ARC_CNT     0
#define %'ModuleName'%.TX_REUSE    6
#define %'ModuleName'%.FIFO_FULL   5
#define %'ModuleName'%.TX_EMPTY    4
#define %'ModuleName'%.RX_FULL     1
#define %'ModuleName'%.RX_EMPTY    0

/* Command Name Mnemonics (Instructions) */
#define %'ModuleName'%.R_REGISTER           0x00 /* read register command, the address is encoded into the command (000A AAAA) */
#define %'ModuleName'%.W_REGISTER           0x20 /* write register command, the address is encoded into the command (001A AAAA) */
#define %'ModuleName'%.REGISTER_MASK        0x1F /* mask used for R_REGISTER and W_REGISTER commands */
#define %'ModuleName'%.R_RX_PAYLOAD         0x61 /* read RX payload command */
#define %'ModuleName'%.W_TX_PAYLOAD         0xA0 /* write TX payload command */
#define %'ModuleName'%.FLUSH_TX             0xE1 /* flush TX FIFO command */
#define %'ModuleName'%.FLUSH_RX             0xE2 /* flush RX FIFO command */
#define %'ModuleName'%.REUSE_TX_PL          0xE3 /* reuse last transmitted payload command */
#define %'ModuleName'%.R_RX_PL_WID          0x60 /* read RX payload width for the top R_RX_PAYLOAD in the RX FIFO */
#define %'ModuleName'%.W_ACK_PAYLOAD        0xA8 /* used in RX mode. Write payload to be transmitted with ACK packet to pipe (1010 1PPP) */
#define %'ModuleName'%.W_TX_PAYLOAD_NO_ACK  0xB0 /* used in TX mode. Disable AUTOACK on this specific packet */
#define %'ModuleName'%.NOP                  0xFF /* no operation command, used for reading STATUS register */

#define %'ModuleName'%.CONFIG_DEFAULT_VAL         0x08
#define %'ModuleName'%.EN_AA_DEFAULT_VAL          0x3F
#define %'ModuleName'%.EN_RXADDR_DEFAULT_VAL      0x03
#define %'ModuleName'%.SETUP_AW_DEFAULT_VAL       0x03
#define %'ModuleName'%.SETUP_RETR_DEFAULT_VAL     0x03
#define %'ModuleName'%.RF_CH_DEFAULT_VAL          0x02
#define %'ModuleName'%.RF_SETUP_DEFAULT_VAL       0x0F
#define %'ModuleName'%.STATUS_DEFAULT_VAL         0x0E
#define %'ModuleName'%.OBSERVE_TX_DEFAULT_VAL     0x00
#define %'ModuleName'%.CD_DEFAULT_VAL             0x00
#define %'ModuleName'%.RX_ADDR_P0_B0_DEFAULT_VAL  0xE7
#define %'ModuleName'%.RX_ADDR_P0_B1_DEFAULT_VAL  0xE7
#define %'ModuleName'%.RX_ADDR_P0_B2_DEFAULT_VAL  0xE7
#define %'ModuleName'%.RX_ADDR_P0_B3_DEFAULT_VAL  0xE7
#define %'ModuleName'%.RX_ADDR_P0_B4_DEFAULT_VAL  0xE7
#define %'ModuleName'%.RX_ADDR_P1_B0_DEFAULT_VAL  0xC2
#define %'ModuleName'%.RX_ADDR_P1_B1_DEFAULT_VAL  0xC2
#define %'ModuleName'%.RX_ADDR_P1_B2_DEFAULT_VAL  0xC2
#define %'ModuleName'%.RX_ADDR_P1_B3_DEFAULT_VAL  0xC2
#define %'ModuleName'%.RX_ADDR_P1_B4_DEFAULT_VAL  0xC2
#define %'ModuleName'%.RX_ADDR_P2_DEFAULT_VAL     0xC3
#define %'ModuleName'%.RX_ADDR_P3_DEFAULT_VAL     0xC4
#define %'ModuleName'%.RX_ADDR_P4_DEFAULT_VAL     0xC5
#define %'ModuleName'%.RX_ADDR_P5_DEFAULT_VAL     0xC6
#define %'ModuleName'%.TX_ADDR_B0_DEFAULT_VAL     0xE7
#define %'ModuleName'%.TX_ADDR_B1_DEFAULT_VAL     0xE7
#define %'ModuleName'%.TX_ADDR_B2_DEFAULT_VAL     0xE7
#define %'ModuleName'%.TX_ADDR_B3_DEFAULT_VAL     0xE7
#define %'ModuleName'%.TX_ADDR_B4_DEFAULT_VAL     0xE7
#define %'ModuleName'%.RX_PW_P0_DEFAULT_VAL       0x00
#define %'ModuleName'%.RX_PW_P1_DEFAULT_VAL       0x00
#define %'ModuleName'%.RX_PW_P2_DEFAULT_VAL       0x00
#define %'ModuleName'%.RX_PW_P3_DEFAULT_VAL       0x00
#define %'ModuleName'%.RX_PW_P4_DEFAULT_VAL       0x00
#define %'ModuleName'%.RX_PW_P5_DEFAULT_VAL       0x00
#define %'ModuleName'%.FIFO_STATUS_DEFAULT_VAL    0x11

/* CONFIG register bitwise definitions */
#define %'ModuleName'%.CONFIG_RESERVED     0x80
#define %'ModuleName'%.CONFIG_MASK_RX_DR   0x40
#define %'ModuleName'%.CONFIG_MASK_TX_DS   0x20
#define %'ModuleName'%.CONFIG_MASK_MAX_RT  0x10
#define %'ModuleName'%.CONFIG_EN_CRC       0x08
#define %'ModuleName'%.CONFIG_CRCO         0x04
#define %'ModuleName'%.CONFIG_PWR_UP       0x02
#define %'ModuleName'%.CONFIG_PRIM_RX      0x01

/* EN_RXADDR register bitwise definitions */
#define %'ModuleName'%.EN_RXADDR_RESERVED  0xC0
#define %'ModuleName'%.EN_RXADDR_ERX_ALL   0x3F
#define %'ModuleName'%.EN_RXADDR_ERX_P5    0x20
#define %'ModuleName'%.EN_RXADDR_ERX_P4    0x10
#define %'ModuleName'%.EN_RXADDR_ERX_P3    0x08
#define %'ModuleName'%.EN_RXADDR_ERX_P2    0x04
#define %'ModuleName'%.EN_RXADDR_ERX_P1    0x02
#define %'ModuleName'%.EN_RXADDR_ERX_P0    0x01
#define %'ModuleName'%.EN_RXADDR_ERX_NONE  0x00

/* SETUP_AW register bitwise definitions */
#define %'ModuleName'%.SETUP_AW_RESERVED 0xFC
#define %'ModuleName'%.SETUP_AW          0x03
#define %'ModuleName'%.SETUP_AW_5BYTES   0x03
#define %'ModuleName'%.SETUP_AW_4BYTES   0x02
#define %'ModuleName'%.SETUP_AW_3BYTES   0x01
#define %'ModuleName'%.SETUP_AW_ILLEGAL  0x00

/* SETUP_RETR register bitwise definitions */
#define %'ModuleName'%.SETUP_RETR_ARD        0xF0
#define %'ModuleName'%.SETUP_RETR_ARD_4000   0xF0 /* 4400 us retry delay */
#define %'ModuleName'%.SETUP_RETR_ARD_3750   0xE0 /* 3750 us retry delay */
#define %'ModuleName'%.SETUP_RETR_ARD_3500   0xD0 /* 3500 us retry delay */
#define %'ModuleName'%.SETUP_RETR_ARD_3250   0xC0 /* 3250 us retry delay */
#define %'ModuleName'%.SETUP_RETR_ARD_3000   0xB0 /* 3000 us retry delay */
#define %'ModuleName'%.SETUP_RETR_ARD_2750   0xA0 /* 2750 us retry delay */
#define %'ModuleName'%.SETUP_RETR_ARD_2500   0x90 /* 2500 us retry delay */
#define %'ModuleName'%.SETUP_RETR_ARD_2250   0x80 /* 2250 us retry delay */
#define %'ModuleName'%.SETUP_RETR_ARD_2000   0x70 /* 2000 us retry delay */
#define %'ModuleName'%.SETUP_RETR_ARD_1750   0x60 /* 1750 us retry delay */
#define %'ModuleName'%.SETUP_RETR_ARD_1500   0x50 /* 1500 us retry delay */
#define %'ModuleName'%.SETUP_RETR_ARD_1250   0x40 /* 1250 us retry delay */
#define %'ModuleName'%.SETUP_RETR_ARD_1000   0x30 /* 1000 us retry delay */
#define %'ModuleName'%.SETUP_RETR_ARD_750    0x20 /* 750 us retry delay */
#define %'ModuleName'%.SETUP_RETR_ARD_500    0x10 /* 500 us retry delay */
#define %'ModuleName'%.SETUP_RETR_ARD_250    0x00 /* 250 us retry delay */
#define %'ModuleName'%.SETUP_RETR_ARC        0x0F
#define %'ModuleName'%.SETUP_RETR_ARC_15     0x0F /* 15 retry count */
#define %'ModuleName'%.SETUP_RETR_ARC_14     0x0E /* 14 retry count */
#define %'ModuleName'%.SETUP_RETR_ARC_13     0x0D /* 13 retry count */
#define %'ModuleName'%.SETUP_RETR_ARC_12     0x0C /* 12 retry count */
#define %'ModuleName'%.SETUP_RETR_ARC_11     0x0B /* 11 retry count */
#define %'ModuleName'%.SETUP_RETR_ARC_10     0x0A /* 10 retry count */
#define %'ModuleName'%.SETUP_RETR_ARC_9      0x09 /* 9 retry count */
#define %'ModuleName'%.SETUP_RETR_ARC_8      0x08 /* 8 retry count */
#define %'ModuleName'%.SETUP_RETR_ARC_7      0x07 /* 7 retry count */
#define %'ModuleName'%.SETUP_RETR_ARC_6      0x06 /* 6 retry count */
#define %'ModuleName'%.SETUP_RETR_ARC_5      0x05 /* 5 retry count */
#define %'ModuleName'%.SETUP_RETR_ARC_4      0x04 /* 4 retry count */
#define %'ModuleName'%.SETUP_RETR_ARC_3      0x03 /* 3 retry count */
#define %'ModuleName'%.SETUP_RETR_ARC_2      0x02 /* 2 retry count */
#define %'ModuleName'%.SETUP_RETR_ARC_1      0x01 /* 1 retry count */
#define %'ModuleName'%.SETUP_RETR_ARC_0      0x00 /* 0 retry count, retry disabled */

/* OBSERVE_TX register bitwise definitions */
#define %'ModuleName'%.OBSERVE_TX_PLOS_CNT   0xF0
#define %'ModuleName'%.OBSERVE_TX_ARC_CNT    0x0F

/* CD register bitwise definitions for nRF24L01 */
//#define %'ModuleName'%.CD_RESERVED   0xFE
//#define %'ModuleName'%.CD_CD         0x01

/* RPD register bitwise definitions for nRF24L01+ */
#define %'ModuleName'%.RPD_RESERVED    0xFE
#define %'ModuleName'%.RPD_RPD         0x01

/* RX_PW_P0 register bitwise definitions */
#define %'ModuleName'%.RX_PW_P0_RESERVED 0xC0

/* RX_PW_P0 register bitwise definitions */
#define %'ModuleName'%.RX_PW_P0_RESERVED 0xC0

/* RX_PW_P1 register bitwise definitions */
#define %'ModuleName'%.RX_PW_P1_RESERVED 0xC0

/* RX_PW_P2 register bitwise definitions */
#define %'ModuleName'%.RX_PW_P2_RESERVED 0xC0

/* RX_PW_P3 register bitwise definitions */
#define %'ModuleName'%.RX_PW_P3_RESERVED 0xC0

/* RX_PW_P4 register bitwise definitions */
#define %'ModuleName'%.RX_PW_P4_RESERVED 0xC0

/* RX_PW_P5 register bitwise definitions */
#define %'ModuleName'%.RX_PW_P5_RESERVED 0xC0

%-
%-BW_CUSTOM_USERTYPE_END


%-BW_DEFINITION_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN Init
%ifdef Init
void %'ModuleName'%.%Init(void);
%include Common\nRF24L01Init.Inc

%endif %- Init
%-BW_METHOD_END Init
%-INHERITED_EVENT_BEGIN IRQ OnInterrupt
%if defined(IRQ) & defined(@IRQ@OnInterrupt)
void %@IRQ@OnInterrupt(void);

%endif %- @IRQ@OnInterrupt
%-INHERITED_EVENT_END IRQ OnInterrupt
%-************************************************************************************************************
%-BW_METHOD_BEGIN WriteRegister
%ifdef WriteRegister
void %'ModuleName'%.%WriteRegister(uint8_t reg, uint8_t val);
%define! Parreg
%define! Parval
%include Common\nRF24L01WriteRegister.Inc

%endif %- WriteRegister
%-BW_METHOD_END WriteRegister
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadRegister
%ifdef ReadRegister
uint8_t %'ModuleName'%.%ReadRegister(uint8_t reg);
%define! Parreg
%define! RetVal
%include Common\nRF24L01ReadRegister.Inc

%endif %- ReadRegister
%-BW_METHOD_END ReadRegister
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadRegisterData
%ifdef ReadRegisterData
void %'ModuleName'%.%ReadRegisterData(uint8_t reg, uint8_t *buf, uint8_t bufSize);
%define! Parreg
%define! Parbuf
%define! ParbufSize
%include Common\nRF24L01ReadRegisterData.Inc

%endif %- ReadRegisterData
%-BW_METHOD_END ReadRegisterData
%-************************************************************************************************************
%-BW_METHOD_BEGIN WriteRegisterData
%ifdef WriteRegisterData
void %'ModuleName'%.%WriteRegisterData(uint8_t reg, uint8_t *buf, uint8_t bufSize);
%define! Parreg
%define! Parbuf
%define! ParbufSize
%include Common\nRF24L01WriteRegisterData.Inc

%endif %- WriteRegisterData
%-BW_METHOD_END WriteRegisterData
%-************************************************************************************************************
%-BW_METHOD_BEGIN WriteRead
%ifdef WriteRead
uint8_t %'ModuleName'%.%WriteRead(uint8_t val);
%define! Parval
%define! RetVal
%include Common\nRF24L01WriteRead.Inc

%endif %- WriteRead
%-BW_METHOD_END WriteRead
%-************************************************************************************************************
%-BW_METHOD_BEGIN Write
%ifdef Write
void %'ModuleName'%.%Write(uint8_t val);
%define! Parval
%include Common\nRF24L01Write.Inc

%endif %- Write
%-BW_METHOD_END Write
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetStatus
%ifdef GetStatus
uint8_t %'ModuleName'%.%GetStatus(void);
%define! RetVal
%include Common\nRF24L01GetStatus.Inc

%endif %- GetStatus
%-BW_METHOD_END GetStatus
%-************************************************************************************************************
%-BW_METHOD_BEGIN ResetStatusIRQ
%ifdef ResetStatusIRQ
void %'ModuleName'%.%ResetStatusIRQ(uint8_t flags);
%define! Parflags
%include Common\nRF24L01ResetStatusIRQ.Inc

%endif %- ResetStatusIRQ
%-BW_METHOD_END ResetStatusIRQ
%-************************************************************************************************************
%-BW_METHOD_BEGIN TxPayload
%ifdef TxPayload
void %'ModuleName'%.%TxPayload(uint8_t *payload, uint8_t payloadSize);
%define! Parpayload
%define! ParpayloadSize
%include Common\nRF24L01TxPayload.Inc

%endif %- TxPayload
%-BW_METHOD_END TxPayload
%-************************************************************************************************************
%-BW_METHOD_BEGIN RxPayload
%ifdef RxPayload
void %'ModuleName'%.%RxPayload(uint8_t *payload, uint8_t payloadSize);
%define! Parpayload
%define! ParpayloadSize
%include Common\nRF24L01RxPayload.Inc

%endif %- RxPayload
%-BW_METHOD_END RxPayload
%-************************************************************************************************************
%-BW_METHOD_BEGIN StopRxTx
%ifdef StopRxTx
void %'ModuleName'%.%StopRxTx(void);
%include Common\nRF24L01StopRxTx.Inc

%endif %- StopRxTx
%-BW_METHOD_END StopRxTx
%-************************************************************************************************************
%-BW_METHOD_BEGIN StartRxTx
%ifdef StartRxTx
void %'ModuleName'%.%StartRxTx(void);
%include Common\nRF24L01StartRxTx.Inc

%endif %- StartRxTx
%-BW_METHOD_END StartRxTx
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetChannel
%ifdef SetChannel
uint8_t %'ModuleName'%.%SetChannel(uint8_t channel);
%define! Parchannel
%define! RetVal
%include Common\nRF24L01SetChannel.Inc

%endif %- SetChannel
%-BW_METHOD_END SetChannel
%-************************************************************************************************************
%-BW_METHOD_BEGIN EnableAutoAck
%ifdef EnableAutoAck
uint8_t %'ModuleName'%.%EnableAutoAck(uint8_t pipes);
%define! Parpipes
%define! RetVal
%include Common\nRF24L01EnableAutoAck.Inc

%endif %- EnableAutoAck
%-BW_METHOD_END EnableAutoAck
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadNofRxPayload
%ifdef ReadNofRxPayload
uint8_t %'ModuleName'%.%ReadNofRxPayload(uint8_t *nof);
%define! Parnof
%define! RetVal
%include Common\nRF24L01ReadNofRxPayload.Inc

%endif %- ReadNofRxPayload
%-BW_METHOD_END ReadNofRxPayload
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetStaticPipePayload
%ifdef SetStaticPipePayload
uint8_t %'ModuleName'%.%SetStaticPipePayload(uint8_t pipe, uint8_t payloadBytes);
%define! Parpipe
%define! ParpayloadBytes
%define! RetVal
%include Common\nRF24L01SetStaticPipePayload.Inc

%endif %- SetStaticPipePayload
%-BW_METHOD_END SetStaticPipePayload
%-************************************************************************************************************
%-BW_METHOD_BEGIN EnableDynamicPayloadLength
%ifdef EnableDynamicPayloadLength
uint8_t %'ModuleName'%.%EnableDynamicPayloadLength(uint8_t pipeMask);
%define! ParpipeMask
%define! RetVal
%include Common\nRF24L01EnableDynamicPayloadLength.Inc

%endif %- EnableDynamicPayloadLength
%-BW_METHOD_END EnableDynamicPayloadLength
%-************************************************************************************************************
%-BW_METHOD_BEGIN WriteFeature
%ifdef WriteFeature
uint8_t %'ModuleName'%.%WriteFeature(uint8_t featureMask);
%define! ParfeatureMask
%define! RetVal
%include Common\nRF24L01WriteFeature.Inc

%endif %- WriteFeature
%-BW_METHOD_END WriteFeature
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadFeature
%ifdef ReadFeature
uint8_t %'ModuleName'%.%ReadFeature(uint8_t *featureMask);
%define! ParfeatureMask
%define! RetVal
%include Common\nRF24L01ReadFeature.Inc

%endif %- ReadFeature
%-BW_METHOD_END ReadFeature
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadObserveTxRegister
%ifdef ReadObserveTxRegister
uint8_t %'ModuleName'%.%ReadObserveTxRegister(uint8_t *nofLoss, uint8_t *nofRetransmitted);
%define! ParnofRetransmitted
%define! ParnofLoss
%define! RetVal
%include Common\nRF24L01ReadObserveTxRegister.Inc

%endif %- ReadObserveTxRegister
%-BW_METHOD_END ReadObserveTxRegister
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadReceivedPowerDetector
%ifdef ReadReceivedPowerDetector
uint8_t %'ModuleName'%.%ReadReceivedPowerDetector(uint8_t *rpd);
%define! Parrpd
%define! RetVal
%include Common\nRF24L01ReadReceivedPowerDetector.Inc

%endif %- ReadReceivedPowerDetector
%-BW_METHOD_END ReadReceivedPowerDetector
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetChannel
%ifdef GetChannel
uint8_t %'ModuleName'%.%GetChannel(uint8_t *channel);
%define! Parchannel
%define! RetVal
%include Common\nRF24L01GetChannel.Inc

%endif %- GetChannel
%-BW_METHOD_END GetChannel
%-************************************************************************************************************
%-BW_METHOD_BEGIN ConstantCarrierWave
%ifdef ConstantCarrierWave
uint8_t %'ModuleName'%.%ConstantCarrierWave(bool turnOn);
%define! ParturnOn
%define! RetVal
%include Common\nRF24L01ConstantCarrierWave.Inc

%endif %- ConstantCarrierWave
%-BW_METHOD_END ConstantCarrierWave
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetOutputPower
%ifdef SetOutputPower
uint8_t %'ModuleName'%.%SetOutputPower(int8_t power);
%define! Parpower
%define! RetVal
%include Common\nRF24L01SetOutputPower.Inc

%endif %- SetOutputPower
%-BW_METHOD_END SetOutputPower
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetOutputPower
%ifdef GetOutputPower
uint8_t %'ModuleName'%.%GetOutputPower(int8_t *power);
%define! Parpower
%define! RetVal
%include Common\nRF24L01GetOutputPower.Inc

%endif %- GetOutputPower
%-BW_METHOD_END GetOutputPower
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetStatusClrIRQ
%ifdef GetStatusClrIRQ
uint8_t %'ModuleName'%.%GetStatusClrIRQ(void);
%define! RetVal
%include Common\nRF24L01GetStatusClrIRQ.Inc

%endif %- GetStatusClrIRQ
%-BW_METHOD_END GetStatusClrIRQ
%-************************************************************************************************************
%-BW_METHOD_BEGIN PollInterrupt
%ifdef PollInterrupt
bool %'ModuleName'%.%PollInterrupt(void);
%define! RetVal
%include Common\nRF24L01PollInterrupt.Inc

%endif %- PollInterrupt
%-BW_METHOD_END PollInterrupt
%-************************************************************************************************************
%-BW_METHOD_BEGIN Deinit
%ifdef Deinit
void %'ModuleName'%.%Deinit(void);
%include Common\nRF24L01Deinit.Inc

%endif %- Deinit
%-BW_METHOD_END Deinit
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetDataRate
%ifdef SetDataRate
uint8_t %'ModuleName'%.%SetDataRate(uint16_t rate);
%define! Parrate
%define! RetVal
%include Common\nRF24L01SetDataRate.Inc

%endif %- SetDataRate
%-BW_METHOD_END SetDataRate
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetDataRate
%ifdef GetDataRate
uint8_t %'ModuleName'%.%GetDataRate(uint16_t *rate);
%define! Parrate
%define! RetVal
%include Common\nRF24L01GetDataRate.Inc

%endif %- GetDataRate
%-BW_METHOD_END GetDataRate
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetFifoStatus
%ifdef GetFifoStatus
uint8_t %'ModuleName'%.%GetFifoStatus(uint8_t *status);
%define! Parstatus
%define! RetVal
%include Common\nRF24L01GetFifoStatus.Inc

%endif %- GetFifoStatus
%-BW_METHOD_END GetFifoStatus
%-************************************************************************************************************
%-BW_METHOD_BEGIN ConfigureSPI
%ifdef ConfigureSPI
void %'ModuleName'%.%ConfigureSPI(void);
%include Common\nRF24L01ConfigureSPI.Inc

%endif %- ConfigureSPI
%-BW_METHOD_END ConfigureSPI
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetAddressWidth
%ifdef SetAddressWidth
uint8_t %'ModuleName'%.%SetAddressWidth(uint8_t width);
%define! Parwidth
%define! RetVal
%include Common\nRF24L01SetAddressWidth.Inc

%endif %- SetAddressWidth
%-BW_METHOD_END SetAddressWidth
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetAddressWidth
%ifdef GetAddressWidth
uint8_t %'ModuleName'%.%GetAddressWidth(uint8_t *pAddrWidth);
%define! ParpAddrWidth
%define! RetVal
%include Common\nRF24L01GetAddressWidth.Inc

%endif %- GetAddressWidth
%-BW_METHOD_END GetAddressWidth
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetTxAddress
%ifdef SetTxAddress
uint8_t %'ModuleName'%.%SetTxAddress(uint8_t *address, uint8_t nofAddressBytes);
%define! Paraddress
%define! ParnofAddressBytes
%define! RetVal
%include Common\nRF24L01SetTxAddress.Inc

%endif %- SetTxAddress
%-BW_METHOD_END SetTxAddress
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetTxAddress
%ifdef GetTxAddress
uint8_t %'ModuleName'%.%GetTxAddress(uint8_t *address, uint8_t nofAddressBytes);
%define! Paraddress
%define! ParnofAddressBytes
%define! RetVal
%include Common\nRF24L01GetTxAddress.Inc

%endif %- GetTxAddress
%-BW_METHOD_END GetTxAddress
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetRxAddress
%ifdef SetRxAddress
uint8_t %'ModuleName'%.%SetRxAddress(uint8_t pipe, uint8_t *address, uint8_t nofAddressBytes);
%define! Paraddress
%define! ParnofAddressBytes
%define! Parpipe
%define! RetVal
%include Common\nRF24L01SetRxAddress.Inc

%endif %- SetRxAddress
%-BW_METHOD_END SetRxAddress
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetRxAddress
%ifdef GetRxAddress
uint8_t %'ModuleName'%.%GetRxAddress(uint8_t pipe, uint8_t *address, uint8_t nofAddressBytes);
%define! Paraddress
%define! ParnofAddressBytes
%define! Parpipe
%define! RetVal
%include Common\nRF24L01GetRxAddress.Inc

%endif %- GetRxAddress
%-BW_METHOD_END GetRxAddress
%-BW_DEFINITION_END
/* END %ModuleName. */

#endif
/* ifndef __%'ModuleName'_H */
%include Common\Header.End
%-
%-BW_EVENT_DEFINITION_START
%-BW_METHOD_BEGIN OnInterrupt
%ifdef OnInterrupt
%INTERFACE OnInterrupt
void %OnInterrupt(void);
%include Common\nRF24L01OnInterrupt.Inc

%endif %- OnInterrupt
%-BW_METHOD_END OnInterrupt
%-BW_METHOD_BEGIN OnActivate
%ifdef OnActivate
%INTERFACE OnActivate
void %OnActivate(void);
%include Common\nRF24L01OnActivate.Inc

%endif %- OnActivate
%-BW_METHOD_END OnActivate
%-BW_METHOD_BEGIN OnDeactivate
%ifdef OnDeactivate
%INTERFACE OnDeactivate
void %OnDeactivate(void);
%include Common\nRF24L01OnDeactivate.Inc

%endif %- OnDeactivate
%-BW_METHOD_END OnDeactivate
%-BW_EVENT_DEFINITION_END
%IMPLEMENTATION
%define! Settings Common\nRF24L01Settings.Inc
%define! Abstract Common\nRF24L01Abstract.Inc
%include Common\Header.C

/* MODULE %ModuleName. */

#include "%'ModuleName'.h"
%-BW_CUSTOM_INCLUDE_START_M
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%-BW_CUSTOM_INCLUDE_END_M

%-BW_CUSTOM_VARIABLE_START
%- Write your static variables here
%-   Example:
%-     static int counter1;
%-     int %'ModuleName'%.counter2;
/* Macros to hide low level functionality */
#define %'ModuleName'%.WAIT_US(x)  %@Wait@'ModuleName'%.Waitus(x)%>50/* wait for the given number of micro-seconds */
#define %'ModuleName'%.WAIT_MS(x)  %@Wait@'ModuleName'%.Waitms(x)%>50/* wait for the given number of milli-seconds */
#define %'ModuleName'%.CE_LOW()    %@CE@'ModuleName'%.ClrVal()   %>50/* put CE LOW */
#define %'ModuleName'%.CE_HIGH()   %@CE@'ModuleName'%.SetVal()   %>50/* put CE HIGH */
#define %'ModuleName'%.CSN_LOW()   %@CSN@'ModuleName'%.ClrVal()  %>50/* put CSN LOW, activate bus */
#define %'ModuleName'%.CSN_HIGH()  %@CSN@'ModuleName'%.SetVal()  %>50/* put CSN HIGH, deactivate bus */

#define %'ModuleName'%.USE_SPI_BLOCK_MODE   0                    %>50/* using SPI block read/write */

%ifdef SWSPI
/* SW SPI */
#define %'ModuleName'%.SPI_Enable()                   %@SWSPI@'ModuleName'%.Enable()
#define %'ModuleName'%.SPI_Disable()                  %@SWSPI@'ModuleName'%.Disable()
#define %'ModuleName'%.SPI_SetFastMode()              %@SWSPI@'ModuleName'%.SetFastMode()
#define %'ModuleName'%.SPI_SetSlowMode()              %@SWSPI@'ModuleName'%.SetSlowMode()
#define %'ModuleName'%.SPI_SetShiftClockPolarity(val) (void)%@SWSPI@'ModuleName'%.SetShiftClockPolarity(val)
#define %'ModuleName'%.SPI_SetIdleClockPolarity(val)  (void)%@SWSPI@'ModuleName'%.SetIdleClockPolarity(val)
#define %'ModuleName'%.SPI_GetCharsInTxBuf()          %@SWSPI@'ModuleName'%.CharsInTxBuf()
#define %'ModuleName'%.SPI_GetCharsInRxBuf()          %@SWSPI@'ModuleName'%.CharsInRxBuf()
#define %'ModuleName'%.SPI_SendChar(ch)               %@SWSPI@'ModuleName'%.SendChar(ch)
#define %'ModuleName'%.SPI_RecvChar(p)                %@SWSPI@'ModuleName'%.RecvChar(p)
#define %'ModuleName'%.SPI_SetBaudRateMode(m)         %@SWSPI@'ModuleName'%.SetBaudRateMode(m)
%endif
%-
%ifdef SPI
/* HW SPI */
#define %'ModuleName'%.SPI_Enable()                   %@SPI@'ModuleName'%.Enable()
#define %'ModuleName'%.SPI_Disable()                  %@SPI@'ModuleName'%.Disable()
#define %'ModuleName'%.SPI_SetFastMode()              %@SPI@'ModuleName'%.SetFastMode()
#define %'ModuleName'%.SPI_SetSlowMode()              %@SPI@'ModuleName'%.SetSlowMode()
#define %'ModuleName'%.SPI_SetShiftClockPolarity(val) (void)%@SPI@'ModuleName'%.SetShiftClockPolarity(val)
#define %'ModuleName'%.SPI_SetIdleClockPolarity(val)  (void)%@SPI@'ModuleName'%.SetIdleClockPolarity(val)
#define %'ModuleName'%.SPI_GetCharsInTxBuf()          %@SPI@'ModuleName'%.GetCharsInTxBuf()
#define %'ModuleName'%.SPI_GetCharsInRxBuf()          %@SPI@'ModuleName'%.GetCharsInRxBuf()
#define %'ModuleName'%.SPI_SendChar(ch)               %@SPI@'ModuleName'%.SendChar(ch)
#define %'ModuleName'%.SPI_RecvChar(p)                %@SPI@'ModuleName'%.RecvChar(p)
#define %'ModuleName'%.SPI_SetBaudRateMode(m)         %@SPI@'ModuleName'%.SetBaudRateMode(m)
%endif

#if %'ModuleName'%.CONFIG_USE_MUTEX
  #include "FreeRTOS.h"
  #include "semphr.h"

  static SemaphoreHandle_t %'ModuleName'%.Mutex = NULL; /* Mutex to allow mutual exclusive access to the bus */
#endif
%-
%-BW_CUSTOM_VARIABLE_END
%-BW_INTERN_METHOD_DECL_START
%- List of internal methods headers
%-UNLOCKED
/* Internal method prototypes */
%-INTERNAL_LOC_METHOD_BEG SPIWriteRead
static uint8_t SPIWriteRead(uint8_t val);
%-INTERNAL_LOC_METHOD_END SPIWriteRead
%-INTERNAL_LOC_METHOD_BEG SPIWriteReadBuffer
static void SPIWriteReadBuffer(uint8_t *bufOut, uint8_t *bufIn, uint8_t bufSize);
%-INTERNAL_LOC_METHOD_END SPIWriteReadBuffer
%-INTERNAL_LOC_METHOD_BEG SPIWriteBuffer
static void SPIWriteBuffer(uint8_t *bufOut, uint8_t bufSize);
%-INTERNAL_LOC_METHOD_END SPIWriteBuffer
%-

%-BW_INTERN_METHOD_DECL_END
%-BW_IMPLEMENT_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN ConfigureSPI
%ifdef ConfigureSPI
%include Common\nRF24L01ConfigureSPI.Inc
void %'ModuleName'%.%ConfigureSPI(void)
{
#if %'ModuleName'%.SWITCH_BUS
  (void)%'ModuleName'%.SPI_Disable();
  (void)%'ModuleName'%.SPI_SetShiftClockPolarity(0); /* falling edge */
  (void)%'ModuleName'%.SPI_SetIdleClockPolarity(0); /* low idle clock polarity */
  (void)%'ModuleName'%.SPI_SetBaudRateMode(%'ModuleName'%.BAUD_RATE_MODE); /* set bus speed */
  (void)%'ModuleName'%.SPI_Enable();
#endif
}

%endif %- ConfigureSPI
%-BW_METHOD_END ConfigureSPI
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG SPIWriteRead
%define! Parval
%define! RetVal
%include Common\GeneralInternalGlobal.inc (SPIWriteRead)
static uint8_t SPIWriteRead(uint8_t val)
{
  uint8_t ch;

  while(%'ModuleName'%.SPI_GetCharsInTxBuf()!=0) {} /* wait until tx is empty */
  while(%'ModuleName'%.SPI_SendChar(val)!=ERR_OK) {} /* send character */
  while(%'ModuleName'%.SPI_GetCharsInTxBuf()!=0) {} /* wait until data has been sent */
  while(%'ModuleName'%.SPI_GetCharsInRxBuf()==0) {} /* wait until we receive data */
  while(%'ModuleName'%.SPI_RecvChar(&ch)!=ERR_OK) {} /* get data */
  return ch;
}

%-INTERNAL_METHOD_END SPIWriteRead
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG SPIWriteReadBuffer
%define! ParbufOut
%define! ParbufIn
%define! ParbufSize
%include Common\GeneralInternalGlobal.inc (SPIWriteReadBuffer)
static void SPIWriteReadBuffer(uint8_t *bufOut, uint8_t *bufIn, uint8_t bufSize)
{
#if %'ModuleName'%.USE_SPI_BLOCK_MODE
  uint16_t snt, rcvd;

  while(%'ModuleName'%.SPI_GetCharsInTxBuf()!=0) {} /* wait until tx is empty */
  while(SPI_SendBlock(bufOut, bufSize, &snt)!=ERR_OK) {
    /* send buffer */
  }
  while(%'ModuleName'%.SPI_GetCharsInTxBuf()!=0) {} /* wait until data has been sent */
  while(%'ModuleName'%.SPI_GetCharsInRxBuf()==0) {} /* wait until we receive data */
  while(SPI_RecvBlock(bufIn, bufSize, &rcvd)!=ERR_OK) {
    /* get data */
  }
#else
  uint8_t i;

  for(i=0;i<bufSize;i++) {
    bufIn[i] = SPIWriteRead(bufOut[i]);
  }
#endif
}

%-INTERNAL_METHOD_END SPIWriteReadBuffer
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG SPIWriteBuffer
%define! ParbufOut
%define! ParbufSize
%include Common\GeneralInternalGlobal.inc (SPIWriteBuffer)
static void SPIWriteBuffer(uint8_t *bufOut, uint8_t bufSize)
{
#if %'ModuleName'%.USE_SPI_BLOCK_MODE
  uint16_t snt, rcvd;
  static uint8_t dummyBuf[SPI_INP_BUF_SIZE];

  if (bufSize>SPI_INP_BUF_SIZE) { /* not enough dummy buffer */
    uint8_t i;

    for(i=0;i<bufSize;i++) {
      (void)SPIWriteRead(bufOut[i]);
    }
  } else {
    while(%'ModuleName'%.SPI_GetCharsInTxBuf()!=0) {} /* wait until tx is empty */
    while(SPI_SendBlock(bufOut, bufSize, &snt)!=ERR_OK) {
      /* send buffer */
    }
    while(%'ModuleName'%.SPI_GetCharsInTxBuf()!=0) {} /* wait until data has been sent */
    while(%'ModuleName'%.SPI_GetCharsInRxBuf()==0) {} /* wait until we receive data */
    while(SPI_SPI.RecvBlock(dummyBuf, bufSize, &rcvd)!=ERR_OK) {
      /* get data */
    }
  }
#else
  uint8_t i;

  for(i=0;i<bufSize;i++) {
    (void)SPIWriteRead(bufOut[i]);
  }
#endif
}

%-INTERNAL_METHOD_END SPIWriteBuffer
%-************************************************************************************************************
%-BW_METHOD_BEGIN Deinit
%ifdef Deinit
%include Common\nRF24L01Deinit.Inc
void %'ModuleName'%.%Deinit(void)
{
#if %'ModuleName'%.CONFIG_USE_MUTEX
  vQueueUnregisterQueue(%'ModuleName'%.Mutex);
  vSemaphoreDelete(%'ModuleName'%.Mutex);
  %'ModuleName'%.Mutex = NULL;
#endif
}

%endif %- Deinit
%-BW_METHOD_END Deinit
%-************************************************************************************************************
%-BW_METHOD_BEGIN Init
%ifdef Init
%include Common\nRF24L01Init.Inc
void %'ModuleName'%.%Init(void)
{
#if %'ModuleName'%.CONFIG_USE_MUTEX
  #if configSUPPORT_STATIC_ALLOCATION
  static StaticSemaphore_t xMutexBuffer;
  #endif

  #if configSUPPORT_STATIC_ALLOCATION
  %'ModuleName'%.Mutex = xSemaphoreCreateRecursiveMutexStatic(&xMutexBuffer);
  #else
  %'ModuleName'%.Mutex = xSemaphoreCreateRecursiveMutex();
  #endif
  if (%'ModuleName'%.Mutex==NULL) { /* semaphore creation failed */
    for(;;) {} /* error, not enough memory? */
  }
  vQueueAddToRegistry(%'ModuleName'%.Mutex, "%'ModuleName'%.Mutex");
#endif
  %'ModuleName'%.CE_LOW();   /* CE high: do not send or receive data */
  %'ModuleName'%.CSN_HIGH(); /* CSN low: not sending commands to the device */
  %'ModuleName'%.%ConfigureSPI(); /* set up SPI bus */
}

%endif %- Init
%-BW_METHOD_END Init
%-************************************************************************************************************
%-INHERITED_EVENT_BEGIN IRQ OnInterrupt
%if defined(IRQ) & defined(@IRQ@OnInterrupt)
%include Common\GeneralInternal.inc (OnInterrupt)
void %@IRQ@OnInterrupt(void)
{
  /*lint -save -e522 function lacks side effect  */
%if AppEventHandler <> "" %- not empty
  extern void %AppEventHandler(void); /* prototype */

%endif
  %'ModuleName'%.CE_LOW(); /* pull CE Low to disable transceiver */
%if AppEventHandler <> "" %- not empty
  %AppEventHandler();
%endif
%if defined(OnInterrupt)
  %OnInterrupt(); /* call user event (if enabled)... */
%endif
  /*lint -restore  */
}

%endif %- @IRQ@OnInterrupt
%-INHERITED_EVENT_END IRQ OnInterrupt
%-************************************************************************************************************
%-BW_METHOD_BEGIN WriteRegister
%ifdef WriteRegister
%define! Parreg
%define! Parval
%include Common\nRF24L01WriteRegister.Inc
void %'ModuleName'%.%WriteRegister(uint8_t reg, uint8_t val)
{
#if %'ModuleName'%.CONFIG_USE_MUTEX
  (void)xSemaphoreTakeRecursive(%'ModuleName'%.Mutex, portMAX_DELAY);
#endif
  %'ModuleName'%.CONFIG_ON_ACTIVATE_CALLBACK(); /* call user event */
#if %'ModuleName'%.SWITCH_BUS
  %'ModuleName'%.ConfigureSPI(); /* change bus speed */
#endif
  %'ModuleName'%.CSN_LOW(); /* initiate command sequence */
  (void)SPIWriteRead(%'ModuleName'%.W_REGISTER|reg); /* write register command */
  (void)SPIWriteRead(val); /* write value */
  %'ModuleName'%.CSN_HIGH(); /* end command sequence */
  %'ModuleName'%.CONFIG_ON_DEACTIVATE_CALLBACK(); /* call user event */
#if %'ModuleName'%.CONFIG_USE_MUTEX
  (void)xSemaphoreGiveRecursive(%'ModuleName'%.Mutex);
#endif
  /*lint -save -e522 function lacks side-effects */
  %'ModuleName'%.WAIT_US(10); /* insert a delay until next command */
  /*lint -restore */
}

%endif %- WriteRegister
%-BW_METHOD_END WriteRegister
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadRegister
%ifdef ReadRegister
%define! Parreg
%define! RetVal
%include Common\nRF24L01ReadRegister.Inc
uint8_t %'ModuleName'%.%ReadRegister(uint8_t reg)
{
  uint8_t val;

#if %'ModuleName'%.CONFIG_USE_MUTEX
  (void)xSemaphoreTakeRecursive(%'ModuleName'%.Mutex, portMAX_DELAY);
#endif
  %'ModuleName'%.CONFIG_ON_ACTIVATE_CALLBACK(); /* call user event */
#if %'ModuleName'%.SWITCH_BUS
  %'ModuleName'%.ConfigureSPI(); /* change bus speed */
#endif
  %'ModuleName'%.CSN_LOW();
  (void)SPIWriteRead(reg);
  val = SPIWriteRead(0); /* write dummy */
  %'ModuleName'%.CSN_HIGH();
  %'ModuleName'%.CONFIG_ON_DEACTIVATE_CALLBACK(); /* call user event */
#if %'ModuleName'%.CONFIG_USE_MUTEX
  (void)xSemaphoreGiveRecursive(%'ModuleName'%.Mutex);
#endif
  /*lint -save -e522 function lacks side-effects */
  %'ModuleName'%.WAIT_US(10);
  /*lint -restore */
  return val;
}

%endif %- ReadRegister
%-BW_METHOD_END ReadRegister
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadRegisterData
%ifdef ReadRegisterData
%define! Parreg
%define! Parbuf
%define! ParbufSize
%include Common\nRF24L01ReadRegisterData.Inc
void %'ModuleName'%.%ReadRegisterData(uint8_t reg, uint8_t *buf, uint8_t bufSize)
{
#if %'ModuleName'%.CONFIG_USE_MUTEX
  (void)xSemaphoreTakeRecursive(%'ModuleName'%.Mutex, portMAX_DELAY);
#endif
  %'ModuleName'%.CONFIG_ON_ACTIVATE_CALLBACK(); /* call user event */
#if %'ModuleName'%.SWITCH_BUS
  %'ModuleName'%.ConfigureSPI(); /* change bus speed */
#endif
  %'ModuleName'%.CSN_LOW();
  (void)SPIWriteRead(%'ModuleName'%.R_REGISTER|reg);
  SPIWriteReadBuffer(buf, buf, bufSize);
  %'ModuleName'%.CSN_HIGH();
  %'ModuleName'%.CONFIG_ON_DEACTIVATE_CALLBACK(); /* call user event */
#if %'ModuleName'%.CONFIG_USE_MUTEX
  (void)xSemaphoreGiveRecursive(%'ModuleName'%.Mutex);
#endif
  /*lint -save -e522 function lacks side-effects */
  %'ModuleName'%.WAIT_US(10);
  /*lint -restore */
}

%endif %- ReadRegisterData
%-BW_METHOD_END ReadRegisterData
%-************************************************************************************************************
%-BW_METHOD_BEGIN WriteRegisterData
%ifdef WriteRegisterData
%define! Parreg
%define! Parbuf
%define! ParbufSize
%include Common\nRF24L01WriteRegisterData.Inc
void %'ModuleName'%.%WriteRegisterData(uint8_t reg, uint8_t *buf, uint8_t bufSize)
{
#if %'ModuleName'%.CONFIG_USE_MUTEX
  (void)xSemaphoreTakeRecursive(%'ModuleName'%.Mutex, portMAX_DELAY);
#endif
  %'ModuleName'%.CONFIG_ON_ACTIVATE_CALLBACK(); /* call user event */
#if %'ModuleName'%.SWITCH_BUS
  %'ModuleName'%.ConfigureSPI(); /* change bus speed */
#endif
  %'ModuleName'%.CSN_LOW();
  (void)SPIWriteRead(%'ModuleName'%.W_REGISTER|reg); /* not masking registers as it would conflict with %'ModuleName'%.W_TX_PAYLOAD */
  SPIWriteBuffer(buf, bufSize);
  %'ModuleName'%.CSN_HIGH();
  %'ModuleName'%.CONFIG_ON_DEACTIVATE_CALLBACK(); /* call user event */
#if %'ModuleName'%.CONFIG_USE_MUTEX
  (void)xSemaphoreGiveRecursive(%'ModuleName'%.Mutex);
#endif
  /*lint -save -e522 function lacks side-effects */
  %'ModuleName'%.WAIT_US(10);
  /*lint -restore */
}

%endif %- WriteRegisterData
%-BW_METHOD_END WriteRegisterData
%-************************************************************************************************************
%-BW_METHOD_BEGIN WriteRead
%ifdef WriteRead
%define! Parval
%define! RetVal
%include Common\nRF24L01WriteRead.Inc
uint8_t %'ModuleName'%.%WriteRead(uint8_t val)
{
#if %'ModuleName'%.CONFIG_USE_MUTEX
  (void)xSemaphoreTakeRecursive(%'ModuleName'%.Mutex, portMAX_DELAY);
#endif
  %'ModuleName'%.CONFIG_ON_ACTIVATE_CALLBACK(); /* call user event */
#if %'ModuleName'%.SWITCH_BUS
  %'ModuleName'%.ConfigureSPI(); /* change bus speed */
#endif
  %'ModuleName'%.CSN_LOW();
  val = SPIWriteRead(val);
  %'ModuleName'%.CSN_HIGH();
  %'ModuleName'%.CONFIG_ON_DEACTIVATE_CALLBACK(); /* call user event */
#if %'ModuleName'%.CONFIG_USE_MUTEX
  (void)xSemaphoreGiveRecursive(%'ModuleName'%.Mutex);
#endif
  /*lint -save -e522 function lacks side-effects */
  %'ModuleName'%.WAIT_US(10);
  /*lint -restore */
  return val;
}

%endif %- WriteRead
%-BW_METHOD_END WriteRead
%-************************************************************************************************************
%-BW_METHOD_BEGIN Write
%ifdef Write
%define! Parval
%include Common\nRF24L01Write.Inc
void %'ModuleName'%.%Write(uint8_t val)
{
#if %'ModuleName'%.CONFIG_USE_MUTEX
  (void)xSemaphoreTakeRecursive(%'ModuleName'%.Mutex, portMAX_DELAY);
#endif
  %'ModuleName'%.CONFIG_ON_ACTIVATE_CALLBACK(); /* call user event */
#if %'ModuleName'%.SWITCH_BUS
  %'ModuleName'%.ConfigureSPI(); /* change bus speed */
#endif
  %'ModuleName'%.CSN_LOW();
  (void)SPIWriteRead(val);
  %'ModuleName'%.CSN_HIGH();
  %'ModuleName'%.CONFIG_ON_DEACTIVATE_CALLBACK(); /* call user event */
#if %'ModuleName'%.CONFIG_USE_MUTEX
  (void)xSemaphoreGiveRecursive(%'ModuleName'%.Mutex);
#endif
  /*lint -save -e522 function lacks side-effects */
  %'ModuleName'%.WAIT_US(10);
  /*lint -restore */
}

%endif %- Write
%-BW_METHOD_END Write
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetStatus
%ifdef GetStatus
%define! RetVal
%include Common\nRF24L01GetStatus.Inc
uint8_t %'ModuleName'%.%GetStatus(void)
{
  return %'ModuleName'%.%WriteRead(%'ModuleName'%.NOP);
}

%endif %- GetStatus
%-BW_METHOD_END GetStatus
%-************************************************************************************************************
%-BW_METHOD_BEGIN ResetStatusIRQ
%ifdef ResetStatusIRQ
%define! Parflags
%include Common\nRF24L01ResetStatusIRQ.Inc
void %'ModuleName'%.%ResetStatusIRQ(uint8_t flags)
{
  %'ModuleName'%.%WriteRegister(%'ModuleName'%.STATUS, flags); /* reset all IRQ in status register */
}

%endif %- ResetStatusIRQ
%-BW_METHOD_END ResetStatusIRQ
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetStatusClrIRQ
%ifdef GetStatusClrIRQ
%define! RetVal
%include Common\nRF24L01GetStatusClrIRQ.Inc
uint8_t %'ModuleName'%.%GetStatusClrIRQ(void)
{
  uint8_t status;

#if %'ModuleName'%.CONFIG_USE_MUTEX
  (void)xSemaphoreTakeRecursive(%'ModuleName'%.Mutex, portMAX_DELAY);
#endif
  %'ModuleName'%.CONFIG_ON_ACTIVATE_CALLBACK(); /* call user event */
#if %'ModuleName'%.SWITCH_BUS
  %'ModuleName'%.ConfigureSPI(); /* change bus speed */
#endif
  %'ModuleName'%.CSN_LOW(); /* initiate command sequence */
  status = SPIWriteRead(%'ModuleName'%.W_REGISTER|%'ModuleName'%.STATUS); /* get status */
  (void)SPIWriteRead(status&(%'ModuleName'%.STATUS_RX_DR|%'ModuleName'%.STATUS_TX_DS|%'ModuleName'%.STATUS_MAX_RT)); /* reset IRQ Bits */
  %'ModuleName'%.CSN_HIGH(); /* end command sequence */
  %'ModuleName'%.CONFIG_ON_DEACTIVATE_CALLBACK(); /* call user event */
#if %'ModuleName'%.CONFIG_USE_MUTEX
  (void)xSemaphoreGiveRecursive(%'ModuleName'%.Mutex);
#endif
  /*lint -save -e522 function lacks side-effects */
  %'ModuleName'%.WAIT_US(10); /* insert a delay until next command */
  /*lint -restore */
  return status;
}

%endif %- GetStatusClrIRQ
%-BW_METHOD_END GetStatusClrIRQ
%-************************************************************************************************************
%-BW_METHOD_BEGIN TxPayload
%ifdef TxPayload
%define! Parpayload
%define! ParpayloadSize
%include Common\nRF24L01TxPayload.Inc
void %'ModuleName'%.%TxPayload(uint8_t *payload, uint8_t payloadSize)
{
  %'ModuleName'%.%Write(%'ModuleName'%.FLUSH_TX); /* flush old data */
  %'ModuleName'%.%WriteRegisterData(%'ModuleName'%.W_TX_PAYLOAD, payload, payloadSize); /* write payload */
  %'ModuleName'%.CE_HIGH(); /* start transmission */
  /*lint -save -e522 function lacks side effect  */
  %'ModuleName'%.WAIT_US(15); /* keep signal high for 15 micro-seconds */
  /*lint -restore */
  %'ModuleName'%.CE_LOW();  /* back to normal */
}

%endif %- TxPayload
%-BW_METHOD_END TxPayload
%-************************************************************************************************************
%-BW_METHOD_BEGIN RxPayload
%ifdef RxPayload
%define! Parpayload
%define! ParpayloadSize
%include Common\nRF24L01RxPayload.Inc
void %'ModuleName'%.%RxPayload(uint8_t *payload, uint8_t payloadSize)
{
  %'ModuleName'%.CE_LOW(); /* need to disable rx mode during reading RX data */
  %'ModuleName'%.%ReadRegisterData(%'ModuleName'%.R_RX_PAYLOAD, payload, payloadSize); /* rx payload */
  %'ModuleName'%.CE_HIGH(); /* re-enable rx mode */
}

%endif %- RxPayload
%-BW_METHOD_END RxPayload
%-************************************************************************************************************
%-BW_METHOD_BEGIN StopRxTx
%ifdef StopRxTx
%include Common\nRF24L01StopRxTx.Inc
void %'ModuleName'%.%StopRxTx(void)
{
  %'ModuleName'%.CE_LOW(); /* disable RX or TX with pulling CE LOW */
}

%endif %- StopRxTx
%-BW_METHOD_END StopRxTx
%-************************************************************************************************************
%-BW_METHOD_BEGIN StartRxTx
%ifdef StartRxTx
%include Common\nRF24L01StartRxTx.Inc
void %'ModuleName'%.%StartRxTx(void)
{
  %'ModuleName'%.CE_HIGH(); /* enabling RX or TX with pulling CE HIGH */
}

%endif %- StartRxTx
%-BW_METHOD_END StartRxTx
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetChannel
%ifdef SetChannel
%define! Parchannel
%define! RetVal
%include Common\nRF24L01SetChannel.Inc
uint8_t %'ModuleName'%.%SetChannel(uint8_t channel)
{
  %'ModuleName'%.WriteRegister(%'ModuleName'%.RF_CH, channel&0x7F); /* set channel */
  /* need to flush data after channel change */
  %'ModuleName'%.%Write(%'ModuleName'%.FLUSH_RX); /* flush old data */
  %'ModuleName'%.%Write(%'ModuleName'%.FLUSH_TX); /* flush old data */
  return ERR_OK;
}

%endif %- SetChannel
%-BW_METHOD_END SetChannel
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetChannel
%ifdef GetChannel
%define! Parchannel
%define! RetVal
%include Common\nRF24L01GetChannel.Inc
uint8_t %'ModuleName'%.%GetChannel(uint8_t *channel)
{
  *channel = %'ModuleName'%.ReadRegister(%'ModuleName'%.RF_CH); /* read channel */
  return ERR_OK;
}

%endif %- GetChannel
%-BW_METHOD_END GetChannel
%-************************************************************************************************************
%-BW_METHOD_BEGIN EnableAutoAck
%ifdef EnableAutoAck
%define! Parpipes
%define! RetVal
%include Common\nRF24L01EnableAutoAck.Inc
uint8_t %'ModuleName'%.%EnableAutoAck(uint8_t pipes)
{
  %'ModuleName'%.WriteRegister(%'ModuleName'%.EN_AA, pipes&%'ModuleName'%.EN_AA_ENAA_ALL); /* enable auto acknowledge for the given pipes */
  return ERR_OK;
}

%endif %- EnableAutoAck
%-BW_METHOD_END EnableAutoAck
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadNofRxPayload
%ifdef ReadNofRxPayload
%define! Parnof
%define! RetVal
%include Common\nRF24L01ReadNofRxPayload.Inc
uint8_t %'ModuleName'%.%ReadNofRxPayload(uint8_t *nof)
{
  *nof = %'ModuleName'%.ReadRegister(%'ModuleName'%.R_RX_PL_WID); /* read number of RX payload for pipe */
  return ERR_OK;
}

%endif %- ReadNofRxPayload
%-BW_METHOD_END ReadNofRxPayload
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetStaticPipePayload
%ifdef SetStaticPipePayload
%define! Parpipe
%define! ParpayloadBytes
%define! RetVal
%include Common\nRF24L01SetStaticPipePayload.Inc
uint8_t %'ModuleName'%.%SetStaticPipePayload(uint8_t pipe, uint8_t payloadBytes)
{
  if (pipe > 5) {
    return ERR_FAULT; /* only pipe 0 to 5 allowed */
  }
  if (payloadBytes>32) {
    return ERR_FAULT;
  }
  %'ModuleName'%.WriteRegister(%'ModuleName'%.RX_PW_P0+pipe, payloadBytes); /* write number of RX payload for pipe */
  return ERR_OK;
}

%endif %- SetStaticPipePayload
%-BW_METHOD_END SetStaticPipePayload
%-************************************************************************************************************
%-BW_METHOD_BEGIN EnableDynamicPayloadLength
%ifdef EnableDynamicPayloadLength
%define! ParpipeMask
%define! RetVal
%include Common\nRF24L01EnableDynamicPayloadLength.Inc
uint8_t %'ModuleName'%.%EnableDynamicPayloadLength(uint8_t pipeMask)
{
  /* note: dynamic payload requires EN_DPL and ENAA_Px set for the pipe */
  if (pipeMask>0x3F) {
    return ERR_FAULT; /* only pipe 0 to 5 allowed */
  }
  %'ModuleName'%.WriteRegister(%'ModuleName'%.DYNPD, pipeMask); /* write number of RX payload for pipe */
  return ERR_OK;
}

%endif %- EnableDynamicPayloadLength
%-BW_METHOD_END EnableDynamicPayloadLength
%-************************************************************************************************************
%-BW_METHOD_BEGIN WriteFeature
%ifdef WriteFeature
%define! ParfeatureMask
%define! RetVal
%include Common\nRF24L01WriteFeature.Inc
uint8_t %'ModuleName'%.%WriteFeature(uint8_t featureMask)
{
  if (featureMask>(%'ModuleName'%.FEATURE_EN_DPL|%'ModuleName'%.FEATURE_EN_ACK_PAY|%'ModuleName'%.FEATURE_EN_DYN_PAY)) {
    return ERR_FAULT; /* mismatch of feature mask */
  }
  %'ModuleName'%.WriteRegister(%'ModuleName'%.FEATURE, featureMask); /* write number of RX payload for pipe */
  return ERR_OK;
}

%endif %- WriteFeature
%-BW_METHOD_END WriteFeature
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadFeature
%ifdef ReadFeature
%define! ParfeatureMask
%define! RetVal
%include Common\nRF24L01ReadFeature.Inc
uint8_t %'ModuleName'%.%ReadFeature(uint8_t *featureMask)
{
  *featureMask = %'ModuleName'%.ReadRegister(%'ModuleName'%.FEATURE); /* read FEATURE register */
  return ERR_OK;
}

%endif %- ReadFeature
%-BW_METHOD_END ReadFeature
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadObserveTxRegister
%ifdef ReadObserveTxRegister
%define! ParnofRetransmitted
%define! ParnofLoss
%define! RetVal
%include Common\nRF24L01ReadObserveTxRegister.Inc
uint8_t %'ModuleName'%.%ReadObserveTxRegister(uint8_t *nofLoss, uint8_t *nofRetransmitted)
{
  uint8_t val;

  val = %'ModuleName'%.ReadRegister(%'ModuleName'%.OBSERVE_TX); /* read OBSERVE_TX register */
  *nofLoss = (uint8_t)((val&0xF0)>>4); /* high nibble */
  *nofRetransmitted = (uint8_t)(val&0x0F); /* high nibble */
  return ERR_OK;
}

%endif %- ReadObserveTxRegister
%-BW_METHOD_END ReadObserveTxRegister
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadReceivedPowerDetector
%ifdef ReadReceivedPowerDetector
%define! Parrpd
%define! RetVal
%include Common\nRF24L01ReadReceivedPowerDetector.Inc
uint8_t %'ModuleName'%.%ReadReceivedPowerDetector(uint8_t *rpd)
{
  *rpd = %'ModuleName'%.ReadRegister(%'ModuleName'%.RPD); /* read RPD register */
  return ERR_OK;
}

%endif %- ReadReceivedPowerDetector
%-BW_METHOD_END ReadReceivedPowerDetector
%-************************************************************************************************************
%-BW_METHOD_BEGIN ConstantCarrierWave
%ifdef ConstantCarrierWave
%define! ParturnOn
%define! RetVal
%include Common\nRF24L01ConstantCarrierWave.Inc
uint8_t %'ModuleName'%.%ConstantCarrierWave(bool turnOn)
{
  /* note: RF channel, output power should be set independently */
  uint8_t val;

  if (turnOn) {
    /* Set PWR_UP = 1 and PRIM_RX = 0 in the CONFIG register. */
    %'ModuleName'%.WriteRegister(%'ModuleName'%.CONFIG, %'ModuleName'%.PWR_UP|%'ModuleName'%.PRIM_TX);
    /*lint -save -e522 function lacks side effect  */
    %'ModuleName'%.WAIT_US(1500); /* Wait 1.5ms PWR_UP->standby */
    /*lint -restore */
    /* In the RF register set:
       - CONT_WAVE = 1.
       - PLL_LOCK = 1.
       - RF_PWR (is set independently)
    */
    val = %'ModuleName'%.ReadRegister(%'ModuleName'%.RF_SETUP); /* read RF_SETUP register */
    val |= %'ModuleName'%.RF_SETUP_CONT_WAVE|%'ModuleName'%.RF_SETUP_PLL_LOCK; /* set bits */
    %'ModuleName'%.WriteRegister(%'ModuleName'%.RF_SETUP, val);
    %'ModuleName'%.CE_HIGH(); /* CE is high for carrier transmission */
    /* CE is kept high as long the carrier is needed */
  } else {
    val = %'ModuleName'%.ReadRegister(%'ModuleName'%.RF_SETUP); /* read RF_SETUP register */
    val &= ~(%'ModuleName'%.RF_SETUP_CONT_WAVE|%'ModuleName'%.RF_SETUP_PLL_LOCK); /* clear bits */
    %'ModuleName'%.WriteRegister(%'ModuleName'%.RF_SETUP, val); /* write back value */
    %'ModuleName'%.CE_LOW(); /* pull CE Low to disable transceiver */
  }
  return ERR_OK;
}

%endif %- ConstantCarrierWave
%-BW_METHOD_END ConstantCarrierWave
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetOutputPower
%ifdef SetOutputPower
%define! Parpower
%define! RetVal
%include Common\nRF24L01SetOutputPower.Inc
uint8_t %'ModuleName'%.%SetOutputPower(int8_t power)
{
  uint8_t val;

  /* get current register value */
  val = %'ModuleName'%.ReadRegister(%'ModuleName'%.RF_SETUP); /* read RF_SETUP register */
  val &= ~%'ModuleName'%.RF_SETUP_RF_PWR_MASK; /* clear bits */
  if (power==-18) {
    val |= %'ModuleName'%.RF_SETUP_RF_PWR_18;
  } else if (power==-12) {
    val |= %'ModuleName'%.RF_SETUP_RF_PWR_12;
  } else if (power==-10) {
    val |= %'ModuleName'%.RF_SETUP_RF_PWR_10;
  } else if (power==0) {
    val |= %'ModuleName'%.RF_SETUP_RF_PWR_0;
  } else {
    return ERR_RANGE;
  }
  %'ModuleName'%.WriteRegister(%'ModuleName'%.RF_SETUP, val);
  return ERR_OK;
}

%endif %- SetOutputPower
%-BW_METHOD_END SetOutputPower
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetOutputPower
%ifdef GetOutputPower
%define! Parpower
%define! RetVal
%include Common\nRF24L01GetOutputPower.Inc
uint8_t %'ModuleName'%.%GetOutputPower(int8_t *power)
{
  uint8_t val;

  val = %'ModuleName'%.ReadRegister(%'ModuleName'%.RF_SETUP); /* read RF_SETUP register */
  if ((val&%'ModuleName'%.RF_SETUP_RF_PWR_MASK)==%'ModuleName'%.RF_SETUP_RF_PWR_18) {
    *power = -18;
  } else if ((val&%'ModuleName'%.RF_SETUP_RF_PWR_MASK)==%'ModuleName'%.RF_SETUP_RF_PWR_12) {
    *power = -12;
  } else if ((val&%'ModuleName'%.RF_SETUP_RF_PWR_MASK)==%'ModuleName'%.RF_SETUP_RF_PWR_10) {
    *power = -10;
  } else if ((val&%'ModuleName'%.RF_SETUP_RF_PWR_MASK)==%'ModuleName'%.RF_SETUP_RF_PWR_0) {
    *power = 0;
  } else {
    return ERR_RANGE;
  }
  return ERR_OK;
}

%endif %- GetOutputPower
%-BW_METHOD_END GetOutputPower
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetDataRate
%ifdef SetDataRate
%define! Parrate
%define! RetVal
%include Common\nRF24L01SetDataRate.Inc
uint8_t %'ModuleName'%.%SetDataRate(uint16_t rate)
{
  uint8_t val;

  /* get current register value */
  val = %'ModuleName'%.ReadRegister(%'ModuleName'%.RF_SETUP); /* read RF_SETUP register */
  val &= ~%'ModuleName'%.RF_SETUP_RF_DR_MASK; /* clear bits */
  if (rate==250) {
    val |= %'ModuleName'%.RF_SETUP_RF_DR_250;
  } else if (rate==1000) {
    val |= %'ModuleName'%.RF_SETUP_RF_DR_1000;
  } else if (rate==2000) {
    val |= %'ModuleName'%.RF_SETUP_RF_DR_2000;
  } else { /* illegal parameter */
    return ERR_RANGE;
  }
  %'ModuleName'%.WriteRegister(%'ModuleName'%.RF_SETUP, val);
  return ERR_OK;
}

%endif %- SetDataRate
%-BW_METHOD_END SetDataRate
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetDataRate
%ifdef GetDataRate
%define! Parrate
%define! RetVal
%include Common\nRF24L01GetDataRate.Inc
uint8_t %'ModuleName'%.%GetDataRate(uint16_t *rate)
{
  uint8_t val;

  val = %'ModuleName'%.ReadRegister(%'ModuleName'%.RF_SETUP); /* read RF_SETUP register */
  if ((val&%'ModuleName'%.RF_SETUP_RF_DR_MASK)==%'ModuleName'%.RF_SETUP_RF_DR_250) {
    *rate = 250;
  } else if ((val&%'ModuleName'%.RF_SETUP_RF_DR_MASK)==%'ModuleName'%.RF_SETUP_RF_DR_1000) {
    *rate = 1000;
  } else if ((val&%'ModuleName'%.RF_SETUP_RF_DR_MASK)==%'ModuleName'%.RF_SETUP_RF_DR_2000) {
    *rate = 2000;
  } else {
    return ERR_RANGE;
  }
  return ERR_OK;
}

%endif %- GetDataRate
%-BW_METHOD_END GetDataRate
%-************************************************************************************************************
%-BW_METHOD_BEGIN PollInterrupt
%ifdef PollInterrupt
%define! RetVal
%include Common\nRF24L01PollInterrupt.Inc
bool %'ModuleName'%.%PollInterrupt(void)
{
  /*lint -save -e522 function lacks side effect  */
  uint8_t status;
  bool interrupt = false;
%if defined(AppEventHandler) & AppEventHandler<>"" %- not empty
  extern void %AppEventHandler(void); /* prototype */
%endif

  status = %'ModuleName'%.%GetStatus();
  if (status&(%'ModuleName'%.STATUS_RX_DR|%'ModuleName'%.STATUS_TX_DS|%'ModuleName'%.STATUS_MAX_RT)) {
    %'ModuleName'%.CE_LOW(); /* pull CE Low to disable transceiver */
%if defined(AppEventHandler) & AppEventHandler<>"" %- not empty
    %AppEventHandler();
%endif
%if defined(OnInterrupt)
    %OnInterrupt(); /* call user event (if enabled)... */
%endif
    interrupt = true;
  }
  return interrupt;
  /*lint -restore */
}

%endif %- PollInterrupt
%-BW_METHOD_END PollInterrupt
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetFifoStatus
%ifdef GetFifoStatus
%define! Parstatus
%define! RetVal
%include Common\nRF24L01GetFifoStatus.Inc
uint8_t %'ModuleName'%.%GetFifoStatus(uint8_t *status)
{
  *status = %'ModuleName'%.ReadRegister(%'ModuleName'%.FIFO_STATUS); /* read FIFO_STATUS register */
  return ERR_OK;
}

%endif %- GetFifoStatus
%-BW_METHOD_END GetFifoStatus
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetAddressWidth
%ifdef SetAddressWidth
%define! Parwidth
%define! RetVal
%include Common\nRF24L01SetAddressWidth.Inc
uint8_t %'ModuleName'%.%SetAddressWidth(uint8_t width)
{
  if (width==3) {
    %'ModuleName'%.WriteRegister(%'ModuleName'%.SETUP_AW, %'ModuleName'%.SETUP_AW_3BYTES);
  } else if (width==4) {
    %'ModuleName'%.WriteRegister(%'ModuleName'%.SETUP_AW, %'ModuleName'%.SETUP_AW_4BYTES);
  } else if (width==5) {
    %'ModuleName'%.WriteRegister(%'ModuleName'%.SETUP_AW, %'ModuleName'%.SETUP_AW_5BYTES);
  } else {
    return ERR_FAILED; /* only 3, 4 or 5 allowed */
  }
  return ERR_OK;
}

%endif %- SetAddressWidth
%-BW_METHOD_END SetAddressWidth
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetAddressWidth
%ifdef GetAddressWidth
%define! ParpAddrWidth
%define! RetVal
%include Common\nRF24L01GetAddressWidth.Inc
uint8_t %'ModuleName'%.%GetAddressWidth(uint8_t *pAddrWidth)
{
  uint8_t val;

  val = %'ModuleName'%.ReadRegister(%'ModuleName'%.SETUP_AW); /* read RF_SETUP_AW register */
  if (val==%'ModuleName'%.SETUP_AW_3BYTES) {
    *pAddrWidth = 3;
    return ERR_OK;
  } else if (val==%'ModuleName'%.SETUP_AW_4BYTES) {
    *pAddrWidth = 4;
    return ERR_OK;
  } else if (val==%'ModuleName'%.SETUP_AW_5BYTES) {
    *pAddrWidth = 5;
    return ERR_OK;
  } else {
    /* failure */
    *pAddrWidth = 0; /* illegal value */
    return ERR_FAILED;
  }
}

%endif %- GetAddressWidth
%-BW_METHOD_END GetAddressWidth
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetTxAddress
%ifdef SetTxAddress
%define! Paraddress
%define! ParnofAddressBytes
%define! RetVal
%include Common\nRF24L01SetTxAddress.Inc
uint8_t %'ModuleName'%.%SetTxAddress(uint8_t *address, uint8_t nofAddressBytes)
{
  int i, j;
  uint8_t swap[5]; /* address is max 5 bytes */

  if (nofAddressBytes>=3 && nofAddressBytes<=5) {
    for(j=0,i=nofAddressBytes-1; i>=0 && j<(int)sizeof(swap); i--,j++) { /* need to send LSB first */
      swap[j] = address[i];
    }
    %'ModuleName'%.WriteRegisterData(%'ModuleName'%.TX_ADDR, &swap[0], nofAddressBytes);
    return ERR_OK;
  } else {
    return ERR_FAILED; /* only 3, 4 or 5 address bytes allowed */
  }
}

%endif %- SetTxAddress
%-BW_METHOD_END SetTxAddress
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetTxAddress
%ifdef GetTxAddress
%define! Paraddress
%define! ParnofAddressBytes
%define! RetVal
%include Common\nRF24L01GetTxAddress.Inc
uint8_t %'ModuleName'%.%GetTxAddress(uint8_t *address, uint8_t nofAddressBytes)
{
  int i, j;
  uint8_t swap[5]; /* address is max 5 bytes */

  if (nofAddressBytes>=3 && nofAddressBytes<=5) {
    %'ModuleName'%.ReadRegisterData(%'ModuleName'%.TX_ADDR, swap, nofAddressBytes);
    for(j=0,i=nofAddressBytes-1; i>=0 && j<nofAddressBytes; i--,j++) {
      address[j] = swap[i];
    }
    return ERR_OK;
  } else {
    return ERR_FAILED; /* only 3, 4 or 5 address bytes allowed */
  }
}

%endif %- GetTxAddress
%-BW_METHOD_END GetTxAddress
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetRxAddress
%ifdef SetRxAddress
%define! Paraddress
%define! ParnofAddressBytes
%define! Parpipe
%define! RetVal
%include Common\nRF24L01SetRxAddress.Inc
uint8_t %'ModuleName'%.%SetRxAddress(uint8_t pipe, uint8_t *address, uint8_t nofAddressBytes)
{
  uint8_t swap[5]; /* address is max 5 bytes */
  int i, j;

  if (pipe>5) {
    return ERR_FAILED; /* only pipe 0 to 5 allowed */
  }
  if (!(nofAddressBytes>=3 && nofAddressBytes<=5)) {
    return ERR_FAILED; /* only 3, 4 or 5 allowed */
  }
  if (pipe==0 || pipe==1) { /* full number of address bytes */
    for(j=0,i=nofAddressBytes-1; i>=0 && j<(int)sizeof(swap); i--,j++) { /* need to send LSB first */
      swap[j] = address[i];
    }
    %'ModuleName'%.WriteRegisterData(%'ModuleName'%.RX_ADDR_P0+pipe, &swap[0], nofAddressBytes);
  } else { /* P2-P5: only last byte */
    %'ModuleName'%.WriteRegisterData(%'ModuleName'%.RX_ADDR_P0+pipe, &address[nofAddressBytes-1], 1);
  }
  return ERR_OK;
}

%endif %- SetRxAddress
%-BW_METHOD_END SetRxAddress
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetRxAddress
%ifdef GetRxAddress
%define! Paraddress
%define! ParnofAddressBytes
%define! Parpipe
%define! RetVal
%include Common\nRF24L01GetRxAddress.Inc
uint8_t %'ModuleName'%.%GetRxAddress(uint8_t pipe, uint8_t *address, uint8_t nofAddressBytes)
{
  int i, j;
  uint8_t swap[5]; /* address is max 5 bytes */

  if (pipe>5) {
    return ERR_FAILED; /* only pipe 0 to 5 allowed */
  }
  if (!(nofAddressBytes>=3 && nofAddressBytes<=5)) {
    return ERR_FAILED; /* only 3, 4 or 5 allowed */
  }
  for(i=0; i<nofAddressBytes; i++) {
    swap[i] = 0; /* init */
  }
  if (pipe==0 || pipe==1) { /* full number of address bytes */
    %'ModuleName'%.ReadRegisterData(%'ModuleName'%.RX_ADDR_P0+pipe, swap, nofAddressBytes);
  } else if (pipe>=2 && pipe<=5) {
    %'ModuleName'%.ReadRegisterData(%'ModuleName'%.RX_ADDR_P1, swap, nofAddressBytes); /* read base address from P1 */
    %'ModuleName'%.ReadRegisterData(%'ModuleName'%.RX_ADDR_P0+pipe, &swap[0], 1); /* pipe 2-5 only have one address byte */
  }
  /* swap back into correct order */
  for(j=0,i=nofAddressBytes-1; i>=0 && j<(int)nofAddressBytes; i--,j++) {
    address[j] = swap[i];
  }
  return ERR_OK;
}

%endif %- GetRxAddress
%-BW_METHOD_END GetRxAddress
%-BW_IMPLEMENT_END
/* END %ModuleName. */

%include Common\Header.End
%-
%-
%-BW_EVENT_IMPLEMENT_START
%-BW_METHOD_BEGIN OnInterrupt
%ifdef OnInterrupt
%IMPLEMENTATION OnInterrupt
%include Common\nRF24L01OnInterrupt.Inc
void %OnInterrupt(void)
{
  /* write your code here */
}

%endif %- OnInterrupt
%-BW_METHOD_END OnInterrupt
%-BW_METHOD_BEGIN OnActivate
%ifdef OnActivate
%IMPLEMENTATION OnActivate
%include Common\nRF24L01OnActivate.Inc
void %OnActivate(void)
{
  /* Write your code here ... */
}

%endif %- OnActivate
%-BW_METHOD_END OnActivate
%-BW_METHOD_BEGIN OnDeactivate
%ifdef OnDeactivate
%IMPLEMENTATION OnDeactivate
%include Common\nRF24L01OnDeactivate.Inc
void %OnDeactivate(void)
{
  /* Write your code here ... */
}

%endif %- OnDeactivate
%-BW_METHOD_END OnDeactivate
%-BW_EVENT_IMPLEMENT_END
%CODE_BEGIN
%if (CPUfamily = "S32K")
#ifdef CPU_INIT_MCUONECLIPSE_DRIVERS
%endif
#if %'ModuleName'%.CONFIG_INITIALIZE_DURING_STARTUP
  %'ModuleName'%.%Init(); /* ### %DeviceType "%DeviceName" init code ... */
#endif
%if (CPUfamily = "S32K")
#endif
%endif
%CODE_END
%-
%ENABLE
%CODE_BEGIN
%CODE_END
%-
%else %- Language (& Compiler)
  %error^ This component is not implemented in selected language & compiler !
%endif %- Language (& Compiler)
%DEBUG
%ALL_SYMBOLS
%-
%-----------------------------------------------------------------------------------------
%if defined(sdk) & %@sdk@ConfigFilesFolderName <> ""
  %define  ConfigSrcDirFolder %%@sdk@ConfigFilesFolderName/
%else
  %define  ConfigSrcDirFolder
%endif
%----------------------------
%FILE %'DirRel_Code'%'ConfigSrcDirFolder'%'ModuleName'config.h
/**
 * \file
 * \brief Configuration header file for Nordic Semiconductor nRF24L01+ transceiver
 *
 * This header file is used to configure settings of the nRF24L01 module.
 */

#ifndef __%'ModuleName'_CONFIG_H
#define __%'ModuleName'_CONFIG_H

#ifndef %'ModuleName'%.CONFIG_IRQ_PIN_ENABLED
%if defined(IRQPinEnabled) & %IRQPinEnabled='yes'
  void %@IRQ@OnInterrupt(void); /* prototype for interrupt handler */
  #define %'ModuleName'%.CONFIG_IRQ_PIN_ENABLED  1
%else
  void RF1_OnInterrupt(void); /* prototype for interrupt handler */
  #define %'ModuleName'%.CONFIG_IRQ_PIN_ENABLED  0
%endif
    /*!< 1: IRQ pin is enabled, 0: No IRQ pin available */
#endif

#ifndef %'ModuleName'%.CONFIG_ON_ACTIVATE_CALLBACK
%if defined(OnActivate)
  void %OnActivate(void); /* prototype */
  #define %'ModuleName'%.CONFIG_ON_ACTIVATE_CALLBACK()  %OnActivate()
%else
  void RF1_OnActivate(void); /* prototype */
  #define %'ModuleName'%.CONFIG_ON_ACTIVATE_CALLBACK()  /* RF1_OnActivate() */
%endif
    /*!< User callback called before using device */
#endif

#ifndef %'ModuleName'%.CONFIG_ON_DEACTIVATE_CALLBACK
%if defined(OnDeactivate)
  void %OnDeactivate(void); /* prototype */
  #define %'ModuleName'%.CONFIG_ON_DEACTIVATE_CALLBACK()  %OnDeactivate()
%else
  void RF1_Deactivate(void); /* prototype */
  #define %'ModuleName'%.CONFIG_ON_DEACTIVATE_CALLBACK()  /* RF1_OnDeactivate() */
%endif
    /*!< User callback called after using device */
#endif

#ifndef %'ModuleName'%.CONFIG_USE_MUTEX
%if defined(OperatingSystemId) & OperatingSystemId = 'FreeRTOS' & %UseMutex='yes'
  #define %'ModuleName'%.CONFIG_USE_MUTEX  1
%else
  #define %'ModuleName'%.CONFIG_USE_MUTEX  0
%endif
    /*!< 1: Use FreeRTOS Mutex, 0: Do not use FreeRTOS mutex */
#endif

#ifndef %'ModuleName'%.CONFIG_INITIALIZE_DURING_STARTUP
%if defined(InitDuringStartup) & InitDuringStartup = 'yes'
  #define %'ModuleName'%.CONFIG_INITIALIZE_DURING_STARTUP  1
%else
  #define %'ModuleName'%.CONFIG_INITIALIZE_DURING_STARTUP  0
%endif
    /*!< 1: Call Init() during startup, 0: Do not call Init() */
#endif

#endif /* __%'ModuleName'_CONFIG_H */
%-----------------------------------------------------------------------------------------
