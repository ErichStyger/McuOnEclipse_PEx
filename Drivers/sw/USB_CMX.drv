%-Driver generated by the Bean Wizard
%-
%- WARNING !
%-
%- Do not make changes to these lines (if you make some changes, you damage this driver)
%- which begins with:
%-
%-  %-STARTUSERTYPES
%-  %-ENDUSRTYPES
%-  /* END %ModuleName. */
%-  /* MODULE %ModuleName. */
%-  %-INTERNAL_METHOD_BEG
%-  %-INTERNAL_METHOD_END
%-  %-INHERITED_EVENT_BEGIN
%-  %-INHERITED_EVENT_END
%-  %-BW_METHOD_BEGIN
%-  %-BW_METHOD_END
%-  %-BW_DEFINITION_START
%-  %-BW_DEFINITION_END
%-  %-BW_IMPLEMENT_START
%-  %-BW_IMPLEMENT_END
%-  %-BW_EVENT_DEFINITION_START
%-  %-BW_EVENT_DEFINITION_END
%-  %-BW_EVENT_IMPLEMENT_START
%-  %-BW_EVENT_IMPLEMENT_END
%-  %-BW_METHOD_MACROS_START
%-  %-BW_METHOD_MACROS_END
%-  %-BW_SECTIONS_INSERT
%-  %-BW_INTERN_COMMENTS_START
%-  %-BW_INTERN_COMMENTS_END
%-  %-BW_BEAN_CONSTANTS_START
%-  %-BW_BEAN_CONSTANTS_END
%-
%-
%- These lines are not comments, but they are necessary for Bean Wizard
%- If you change these lines, Bean Wizard will not be responsible for loosing or damaging your code!
%-
%-
%- readyCPU ...
%- readyDEVICE ...
%-
%define DriverAuthor  Author
%define DriverVersion 01.00
%define DriverDate    07.01.2009
%-
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END
%-
%-BW_INTERN_COMMENTS_START
%- List of descriptions of internal methods
%-BW_INTERN_COMMENTS_END
%-
%-BW_SECTIONS_INSERT
%if Language='ANSIC'
%-
%-
%INTERFACE
%define! Settings Common\USB_CMXSettings.Inc
%define! Abstract Common\USB_CMXAbstract.Inc
%include Common\Header.h

#ifndef __%'ModuleName'_H
#define __%'ModuleName'_H

/* MODULE %ModuleName. */

%ifdef SharedModules
/* Include shared modules, which are used for whole project */
  %for var from IncludeSharedModules
#include "%'var'.h"
  %endfor
%endif
/* Include inherited beans */
%ifdef InhrSymbolList
  %for var from InhrSymbolList
#include "%@%var@ModuleName.h"
  %endfor
%endif
%-BW_CUSTOM_INCLUDE_START_H
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%-BW_CUSTOM_INCLUDE_END_H
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END

#include "%ProcessorModule.h"

%-STARTUSERTYPES - Do not make changes between lines (included this lines) marked with %-STARTUSERTYPES and %-ENDUSRTYPES

%-ENDUSRTYPES
%-BW_BEAN_CONSTANTS_START  - Do not make changes between lines (included this lines) marked with %-BW_BEAN_CONSTANTS_START and %-BW_BEAN_CONSTANTS_END
%- No constants defined in the BeanWizard for this bean
%-BW_BEAN_CONSTANTS_END
%-BW_CUSTOM_USERTYPE_START
%- Write your own types here ...
%-  Example:
%-    typedef int TMyInteger;
%-
%-BW_CUSTOM_USERTYPE_END

/****************************************************************************
 *
 *            Copyright (c) 2006-2007 by CMX Systems, Inc.
 *
 * This software is copyrighted by and is the sole property of
 * CMX.  All rights, title, ownership, or other interests
 * in the software remain the property of CMX.  This
 * software may only be used in accordance with the corresponding
 * license agreement.  Any unauthorized use, duplication, transmission,
 * distribution, or disclosure of this software is expressly forbidden.
 *
 * This Copyright notice may not be removed or modified without prior
 * written consent of CMX.
 *
 * CMX reserves the right to modify this software without notice.
 *
 * CMX Systems, Inc.
 * 12276 San Jose Blvd. #511
 * Jacksonville, FL 32223
 * USA
 *
 * Tel:  (904) 880-1840
 * Fax:  (904) 880-1632
 * http: www.cmx.com
 * email: cmx@cmx.com
 *
 ***************************************************************************/
//#ifndef _USB_H_
//#define _USB_H_
#include "hcc_types.h"
//#include "../usb-drv/usb_config.h"
#include "mcf51xx_reg.h"
#define USB_DRIVER_VERSION  0x0004
/******************************************************************************
 ************************ Type definitions ************************************
 *****************************************************************************/
 /* Return values for callback functions. */
typedef enum {
  clbst_ok,       /* Callback executed ok. */
  clbst_in,       /* Start IN transfer. */
  clbst_out,      /* Start out transfer. */
  clbst_error,    /* Error encountered, stop endpoint. */
  clbst_not_ready /* No buffer avaiable, pause endpoint. */
} callback_state_t;

typedef callback_state_t (*usb_callback_t)(void);
/******************************************************************************
 ************************ Exported functions **********************************
 *****************************************************************************/
void usb_stop(void);
extern void usb_it_handler(void);

extern hcc_u8 usb_ep_is_busy(hcc_u8 ep);
extern hcc_u8 usb_ep_error(hcc_u8 ep);
extern hcc_u32 usb_get_done(hcc_u8 ep);
extern void usb_abort_ep(hcc_u8 ep);
extern void usb_send(hcc_u8 ep, usb_callback_t f, hcc_u8* data, hcc_u32 tr_length, hcc_u32 req_length);
extern void usb_receive(hcc_u8 ep, usb_callback_t f, hcc_u8* data, hcc_u32 tr_length);
extern hcc_u8 usb_get_state(void);

hcc_u16 usb_get_rx_plength(hcc_u8 ep);
hcc_u8 *usb_get_rx_pptr(hcc_u8 ep);
extern hcc_u16 usb_get_rx_plength(hcc_u8 ep);
extern void usb_stop_ep_rx(hcc_u8 ep);
extern void usb_stop_ep_tx(hcc_u8 ep);

/******************************************************************************
 ************************ Imported functions **********************************
 *****************************************************************************/
/* Event callbacks. */
void usb_bus_error_event(void);
void usb_wakeup_event(void);
void usb_suspend_event(void);
void usb_reset_event(void);
callback_state_t usb_ep0_callback(void);

/* Configuration callbacks. */
void* get_device_descriptor();
hcc_u8 is_cfgd_index(hcc_u16 cndx);
void *get_cfg_descriptor(hcc_u8 cndx);
hcc_u8 is_str_index(hcc_u8 sndx);
void *get_str_descriptor(hcc_u8 sndx);
hcc_u8 is_ifc_ndx(hcc_u8 cndx, hcc_u8 indx, hcc_u8 iset);
hcc_u8 is_ep_ndx(hcc_u8 cndx, hcc_u8 indx, hcc_u8 iset, hcc_u8 endx);
void *get_ep_descriptor(hcc_u8 cndx, hcc_u8 indx, hcc_u8 iset, hcc_u8 endx);
void *get_ep_rx_buffer(hcc_u8 ep, hcc_u8 buf);

/******************************************************************************
 ************************ Macro definitions ***********************************
 *****************************************************************************/
/* This 16 bit counter is increased each mS while the USB is connected and not
   in sleep state. */
#define usb_get_frame_ctr() ((hcc_u16)(MCF_USB_FRM_NUML | (MCF_USB_FRM_NUML << 8)))

/* These macros access fileds of a setup packet. */
#define STP_REQU_TYPE(a)        (((hcc_u8*)(a))[0])
#define STP_REQUEST(a)      (((hcc_u8*)(a))[1])
#define STP_VALUE(a)        RD_LE16(&(((hcc_u8*)(a))[2]))
#define STP_VALUE_LO(a)     (((hcc_u8*)(a))[2])
#define STP_VALUE_HI(a)     (((hcc_u8*)(a))[3])
#define STP_INDEX(a)        RD_LE16(&(((hcc_u8*)(a))[4]))
#define STP_INDEX_LO(a)     (((hcc_u8*)(a))[4])
#define STP_INDEX_HI(a)     (((hcc_u8*)(a))[5])
#define STP_LENGTH(a)       RD_LE16(&(((hcc_u8*)(a))[6]))
#define STP_LENGTH_LO(a)    (((hcc_u8*)(a))[6])
#define STP_LENGTH_HI(a)    (((hcc_u8*)(a))[7])

/* Handled standard USB request. (bmRequest values). */
#define USBRQ_GET_STATUS         0u
#define USBRQ_CLEAR_FEATURE      1u
#define USBRQ_SET_FEATURE        3u
#define USBRQ_SET_ADDRESS        5u
#define USBRQ_GET_DESCRIPTOR     6u
#define USBRQ_SET_DESCRIPTOR     7u
#define USBRQ_GET_CONFIGURATION  8u
#define USBRQ_SET_CONFIGURATION  9u
#define USBRQ_GET_INTERFACE      10u
#define USBRQ_SET_INTERFACE      11u
#define USBRQ_SYNCH_FRAME        12u

/* Standard USB descriptor type vaules. */
#define STDD_DEVICE         1u
#define STDD_CONFIG         2u
#define STDD_STRING         3u
#define STDD_INTERFACE      4u
#define STDD_ENDPOINT       5u

/* Endpoint type vaues. */
#define EP_TYPE_CONTROL 0u
#define EP_TYPE_ISO     1u
#define EP_TYPE_BULK    2u
#define EP_TYPE_IT      3u
#define EP_TYPE_DISABLE 4u

/* Driver states. */
#define USBST_DISABLED    (1u<<0)
#define USBST_DEFAULT     (1u<<1) /* Only standard requests are handled on
                                     then default pipe. */
#define USBST_ADDRESSED   (1u<<2) /* USB has a unique address, but no
                                     configuration is active. */
#define USBST_CONFIGURED  (1u<<3) /* Device is configured, and fully
                                     functional. */

/* Error flags returned by usb_ep_error(). */
#define USBEPERR_NONE             (0) /* No error. */
#define USBEPERR_TO_MANY_DATA     (BIT0) /* To many data received. */
#define USBEPERR_PROTOCOL_ERROR   (BIT1) /* Protocol error. */
#define USBEPERR_USER_ABORT       (BIT2) /* Transfer was aborted by the
                                             application. */
#define USBEPERR_HOST_ABORT       (BIT3) /* Host aborted the transfer. */

/* This macro will evaluate to an array inicializer list with values of a
   device descriptor. */
#define USB_FILL_DEV_DESC(usb_ver, dclass, dsubclass, dproto, psize, vid,\
                          pid, relno, mstr, pstr, sstr, ncfg) \
  (hcc_u8)0x12u, STDD_DEVICE, (hcc_u8)(usb_ver), (hcc_u8)((usb_ver) >> 8)\
  , (hcc_u8)(dclass), (hcc_u8)(dsubclass), (hcc_u8)(dproto), (hcc_u8)(psize)\
  , (hcc_u8)(vid), (hcc_u8)((vid) >> 8), (hcc_u8)(pid), (hcc_u8)((pid) >> 8)\
  , (hcc_u8)(relno), (hcc_u8)((relno) >> 8), (hcc_u8)(mstr), (hcc_u8)(pstr)\
  , (hcc_u8)(sstr), (hcc_u8)(ncfg)

/* This macro will evaluate to an array inicializer list with values of a
   configuration descriptor. */
#define USB_FILL_CFG_DESC(size, nifc, cfg_id, str_ndx, attrib, pow) \
  (hcc_u8)0x09u, STDD_CONFIG, (hcc_u8)(size), (hcc_u8)((size) >> 8)\
  , (hcc_u8)(nifc), (hcc_u8)(cfg_id), (hcc_u8)(str_ndx), (hcc_u8)(attrib), (hcc_u8)(pow)
/* Values for the attrib field of the configuration descriptor. */
/* Devide ic BUS powered. */
#define CFGD_ATTR_BUS_PWR  (1u<<7)
/* Device is self powered. */
#define CFGD_ATTR_SELF_PWR (1u<<6)
/* Device can wake up the BUS. */
#define CFGD_ATTR_RWAKEUP  (1u<<5)


/* This macro will evaluate to an array inicializer list with values of an
   interface association descriptor. */
#define FILL_IFC_ASSOC_DESC(first_ifc, nifc, fclass, fsubclass, fproto, strndx)\
  (hcc_u8)0x08u, (hcc_u8)0x0bu, (hcc_u8) first_ifc, (hcc_u8) nifc\
  , (hcc_u8)(fclass), (hcc_u8)(fsubclass), (hcc_u8)(fproto), (hcc_u8)(strndx)

/* This macro will evaluate to an array inicializer list with values of a
   interface descriptor. */
#define USB_FILL_IFC_DESC(ifc_id, alt_set, no_ep, iclass, isubclass, iproto, strndx) \
  (hcc_u8)0x09u, STDD_INTERFACE, (hcc_u8)(ifc_id), (hcc_u8)(alt_set), (hcc_u8)(no_ep)\
  , (hcc_u8)(iclass), (hcc_u8)(isubclass), (hcc_u8)(iproto), (hcc_u8)(strndx)

/* This macro will evaluate to an array inicializer list with values of a
   endpoint descriptor. */
#define USB_FILL_EP_DESC(addr, dir, attrib, psize, interval) \
  (hcc_u8)0x07u, STDD_ENDPOINT, (hcc_u8)((addr)&0x7f) | (((hcc_u8)(dir))<<0x7)\
  , (hcc_u8)(attrib), (hcc_u8)((psize) & 0xff), (hcc_u8)(((psize) >> 8) & 0xff)\
  , (interval)

/* IN endpoint (device to host) */
#define EPD_DIR_TX                1
/* Out endpoint (host todevice) */
#define EPD_DIR_RX                0

/* Control endpoint */
#define EPD_ATTR_CTRL             0
/* Isochronous endpoint. */
#define EPD_ATTR_ISO              1
/* Bulk endpoint. */
#define EPD_ATTR_BULK             2
/* Interrupt endpoint. */
#define EPD_ATTR_INT              3
/* Iso endpoint synchronisation type: none */
#define EPD_ATTR_ISO_SYNC_NONE    (0 << 2)
/* Iso endpoint synchronisation type: asynchronous */
#define EPD_ATTR_ISO_SYNC_ASYNC   (1 << 2)
/* Iso endpoint synchronisation type: adaptive */
#define EPD_ATTR_ISO_SYNC_ADAPT   (2 << 2)
/* Iso endpoint synchronisation type: synchronous */
#define EPD_ATTR_ISO_SYNC_SYNC    (3 << 2)
/* Iso endpoint usage type: data endpoint */
#define EPD_ATTR_ISO_USAGE_DATA   (0 << 4)
/* Iso endpoint usage type: feedback endpoint */
#define EPD_ATTR_ISO_USAGE_FEEDB  (1 << 4)
/* Iso endpoint usage type: explicite feedback endpoint */
#define EPD_ATTR_ISO_USAGE_EFEEDB (2 << 4)

//#endif
/****************************** END OF FILE **********************************/


%-BW_DEFINITION_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN Init
%ifdef Init
byte %'ModuleName'%.%Init(void);
%define! RetVal
%include Common\USB_CMXInit.Inc

%endif %- Init
%-BW_METHOD_END Init
%-************************************************************************************************************
%-BW_METHOD_BEGIN stack_init
%ifdef stack_init
void %'ModuleName'%.%stack_init(byte pattern);
%define! Parpattern
%include Common\USB_CMXstack_init.Inc

%endif %- stack_init
%-BW_METHOD_END stack_init
%-************************************************************************************************************
%-BW_METHOD_BEGIN stack_size
%ifdef stack_size
long %'ModuleName'%.%stack_size(byte pattern);
%define! Parpattern
%define! RetVal
%include Common\USB_CMXstack_size.Inc

%endif %- stack_size
%-BW_METHOD_END stack_size
%-************************************************************************************************************
%-BW_METHOD_BEGIN hw_init
%ifdef hw_init
void %'ModuleName'%.%hw_init(void);
%include Common\USB_CMXhw_init.Inc

%endif %- hw_init
%-BW_METHOD_END hw_init
%-BW_DEFINITION_END
/* END %ModuleName. */

#endif
/* ifndef __%'ModuleName'_H */
%include Common\Header.End
%-
%-BW_EVENT_DEFINITION_START
%-BW_EVENT_DEFINITION_END
%IMPLEMENTATION
%define! Settings Common\USB_CMXSettings.Inc
%define! Abstract Common\USB_CMXAbstract.Inc
%include Common\Header.C

/* MODULE %ModuleName. */

%for var from EventModules
#include "%var.h"
%endfor
#include "%'ModuleName'.h"
%-BW_CUSTOM_INCLUDE_START_M
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%-BW_CUSTOM_INCLUDE_END_M

%-BW_CUSTOM_VARIABLE_START
%- Write your static variables here
%-   Example:
%-     static int counter1;
%-     int %'ModuleName'%.counter2;
%-
/***************************************************************************
 *
 *            Copyright (c) 2006-2007 by CMX Systems, Inc.
 *
 * This software is copyrighted by and is the sole property of
 * CMX.  All rights, title, ownership, or other interests
 * in the software remain the property of CMX.  This
 * software may only be used in accordance with the corresponding
 * license agreement.  Any unauthorized use, duplication, transmission,
 * distribution, or disclosure of this software is expressly forbidden.
 *
 * This Copyright notice may not be removed or modified without prior
 * written consent of CMX.
 *
 * CMX reserves the right to modify this software without notice.
 *
 * CMX Systems, Inc.
 * 12276 San Jose Blvd. #511
 * Jacksonville, FL 32223
 * USA
 *
 * Tel:  (904) 880-1840
 * Fax:  (904) 880-1632
 * http: www.cmx.com
 * email: cmx@cmx.com
 *
 ***************************************************************************/
#include <hidef.h>
#include "mcf51xx_reg.h"

static void init_clock(void)
{
 /* Assume 12MHz external clock source connected. */

  /* In order to use the USB we need to enter PEE mode and MCGOUT set to 48 MHz.
     Out of reset MCG is in FEI mode. */

  /**** Moving from FEI (FLL engaged internal) to PEE (PLL engaged external) mode. */
  /* switch from FEI to FBE (FLL bypassed external) */
    /* enable external clock source */
  MCGC2 = MCGC2_HGO_MASK       /* oscillator in high gain mode */
          | MCGC2_EREFS_MASK   /* because crystal is being used */
          | MCGC2_RANGE_MASK   /* 12 MHz is in high freq range */
          | MCGC2_ERCLKEN_MASK;     /* activate external reference clock */
  while (MCGSC_OSCINIT == 0)
    ;
    /* select clock mode */
  MCGC1 = (2<<6)         /* CLKS = 10 -> external reference clock. */
          | (3<<3);      /* RDIV = 3 -> 12MHz/8=1.5 MHz */

    /* wait for mode change to be done */
  while (MCGSC_IREFST != 0)
    ;
  while (MCGSC_CLKST != 2)
    ;

  /* switch from FBE to PBE (PLL bypassed internal) mode */
  MCGC3=MCGC3_PLLS_MASK
        | (8<<0);     /* VDIV=6 -> multiply by 32 -> 1.5MHz * 32 = 48MHz */
  while(MCGSC_PLLST != 1)
    ;
  while(MCGSC_LOCK != 1)
    ;
  /* finally switch from PBE to PEE (PLL enabled external mode) */
  MCGC1 = (0<<6)         /* CLKS = 0 -> PLL or FLL output clock. */
          | (3<<3);      /* RDIV = 3 -> 12MHz/8=1.5 MHz */
  while(MCGSC_CLKST!=3)
    ;

  /* Now MCGOUT=48MHz, BUS_CLOCK=24MHz */
}

extern hcc_imask asm_set_ipl(hcc_imask ip);

static void _irq_restore (hcc_imask ip)
{
    asm_set_ipl(ip);
}

static hcc_imask _irq_disable (void)
{
    return((hcc_imask)asm_set_ipl(7));
}

static void Usb_Vbus_On(void)
{
  PTHD_PTHD4 = 0;   /* turn AMD (Vbus) switch on */
}

static void Usb_Vbus_Off(void)
{
  PTHD_PTHD4 = 1;  /* turn AMD (Vbus) switch onff */
}

static int Usb_Vbus_Stat(void)
{
  return((PTGD_PTGD0 & 0x4)>>2);
}



/****************************************************************************
 *
 *            Copyright (c) 2006-2007 by CMX Systems, Inc.
 *
 * This software is copyrighted by and is the sole property of
 * CMX.  All rights, title, ownership, or other interests
 * in the software remain the property of CMX.  This
 * software may only be used in accordance with the corresponding
 * license agreement.  Any unauthorized use, duplication, transmission,
 * distribution, or disclosure of this software is expressly forbidden.
 *
 * This Copyright notice may not be removed or modified without prior
 * written consent of CMX.
 *
 * CMX reserves the right to modify this software without notice.
 *
 * CMX Systems, Inc.
 * 12276 San Jose Blvd. #511
 * Jacksonville, FL 32223
 * USA
 *
 * Tel:  (904) 880-1840
 * Fax:  (904) 880-1632
 * http: www.cmx.com
 * email: cmx@cmx.com
 *
 ***************************************************************************/
//#include "hcc_types.h"
#include "mcf51xx_reg.h"
//#include "target.h"

/*****************************************************************************
 * Local types.
 *****************************************************************************/
typedef struct {
  volatile hcc_u32 tlength;
  volatile hcc_u32 maxlength;
  void * volatile address;
  volatile usb_callback_t data_func;
  hcc_u16 psize;
  hcc_u32 data0_tx;
  hcc_u32 data0_rx;
  volatile hcc_u8 state;
  volatile hcc_u8 flags;
  volatile hcc_u8 error;
  hcc_u8 next_rx;
  hcc_u8 next_tx;
} ep_info_t;

/*****************************************************************************
 * Macro definitions.
 *****************************************************************************/
#define DIR_TX             BIT7

#define SOF_PID_VALUE                0xd
/* Note: BIT3 shows if the data packet is data0 or data1. */
#define DATA_PID_VALUE      0x3
#define DATA0_PID_VALUE     0x3
#define DATA1_PID_VALUE     0xb

#define MCF_USB_ENDPT(ep)  (((hcc_u8*)&MCF_USB_ENDPT0)[ep<<2])
#define MCF_USB_ENDPT_EP_HSHK      BIT0
#define MCF_USB_ENDPT_EP_STALL     BIT1
#define MCF_USB_ENDPT_EP_TX_EN     BIT2
#define MCF_USB_ENDPT_EP_RX_EN     BIT3
#define MCF_USB_ENDPT_EP_CTL_DIS   BIT4
#define MCF_USB_ENDPT_RETRY_DIS    BIT6
#define MCF_USB_ENDPT_HOST_WO_HUB  BIT7

#define MIN(a,b)     ((a) < (b) ? (a) : (b))

/* Control endpoint state machine state values. */
#define EPST_IDLE             0x0
#define EPST_DATA_TX          0x1
#define EPST_DATA_TX_LAST     0x2
#define EPST_DATA_RX          0x3
#define EPST_STATUS_TX        0x4
#define EPST_STATUS_RX        0x5
#define EPST_TX_STOP          0x6
#define EPST_ABORT_TX         0x7
#define EPST_DATA_TX_WAIT_DB  0x8
#define EPST_DATA_TX_EMPTY_DB 0x9

/* Standard USB feature selector values. */
#define FEAT_ENDPOINT_HALT        0u
#define FEAT_DEVICE_REMOTE_WAKEUP 1u

/* Endpoint flag bits. */
#define EPFL_ERROR    (hcc_u8)BIT0  /* There was an error during the ongoing
                               transfer. */
#define EPFL_ZPACKET  (hcc_u8)BIT1  /* After the last data packet an additional zero
                               length packet needs to be transmitted to close
                               the transfer. */

/* This macro shall evaluate to a uint32 pointer to the start address of the
   buffer descriptor table (BDT). The BDT has 32 bytes for each endpoint.
   The BDT shall be alignet to 512 byte boundary! */
#if 0
extern hcc_u32 _BDT_BASE[];
#else
#define _BDT_BASE ((hcc_u32*)0x%#l%BDTBase) /* 512 bytes, aligned at 512 byte boundaries */
#endif
#define BDT_BASE              ((hcc_u32*)(_BDT_BASE))
#define BDT_CTL_RX(ep, b)     (BDT_BASE[((ep)<<3)+((b)<<1)+0])
#define BDT_ADR_RX(ep, b)     (BDT_BASE[((ep)<<3)+((b)<<1)+1])
#define BDT_CTL_TX(ep, b)     (BDT_BASE[((ep)<<3)+((b)<<1)+4])
#define BDT_ADR_TX(ep, b)     (BDT_BASE[((ep)<<3)+((b)<<1)+5])

#define BDT_CTL_STALL BIT2
#define BDT_CTL_DTS   BIT3
#define BDT_CTL_DATA  BIT6
#define BDT_CTL_OWN   BIT7

/*****************************************************************************
 * Global variables.
 *****************************************************************************/
/* N/A */

/*****************************************************************************
 * Module variables.
 *****************************************************************************/
static volatile hcc_u8 usb_current_config;
static volatile hcc_u8 usb_state;
static volatile hcc_u8 new_address;
static ep_info_t ep_info[16];

/*****************************************************************************
 * Function predefinitions.
 *****************************************************************************/
static void enter_default_state(void);
static void disable_ep_rx(hcc_u8);
static void disable_ep_tx(hcc_u8);
static void ready_ep_rx(hcc_u8, hcc_u8);
static void ready_ep_tx(hcc_u8, hcc_u8);
static hcc_u8 select_tx_buf(hcc_u8 ep);
static void send_zero_packet(hcc_u8 ep);
static void _usb_send(hcc_u8 ep);
static void _usb_receive(hcc_u8 ep);
static callback_state_t cb_set_address(void);
static callback_state_t usb_stm_ctrl0(void);
static hcc_u8 usb_setup_ep(hcc_u8 addr, hcc_u8 type, hcc_u8 ep, hcc_u16 psize);

/*****************************************************************************
 * Name:
 *   usb_get_rx_pptr
 * In:
 *   ep: number of endpoint.
 * Out:
 *   Pointer to the packet buffer containing data of the last received packet.
 *
 * Description:
 *   Returns te number of bytes that are left of the transfer. If
 *   usb_ep_is_busy returns false, then the transfer was aborted either
 *   by the host or by the application.
 *****************************************************************************/
hcc_u8* usb_get_rx_pptr(hcc_u8 ep)
{
  hcc_u8 cur_buf=(hcc_u8)(MCF_USB_STAT & MCF_USB_STAT_ODD ? 1 : 0);
  return((hcc_u8 *)(RD_LE32(&BDT_ADR_RX(ep, cur_buf))));
}

/*****************************************************************************
 * Name:
 *   select_tx_buf
 * In:
 *   ep: number of endpoint.
 * Out:
 *   The index of the next tx buffer.
 *
 * Description:
 *   Returns te number of bytes that are left of the transfer. If
 *   usb_ep_is_busy returns false, then the transfer was aborted either
 *   by the host or by the application.
 *****************************************************************************/
static hcc_u8 select_tx_buf(hcc_u8 ep)
{
/* SHALL ONLY BE CALLED WITH USB INTERRUPTS DISABLED. */
  hcc_u8 buf;
  hcc_u32 ctl;
  /* Find out which buffer shall be used. */
  ctl=(RD_LE32(&BDT_CTL_TX(ep, 0)) & BDT_CTL_OWN)
      | (RD_LE32(&BDT_CTL_TX(ep, 1)) & BDT_CTL_OWN) << 1;

  switch(ctl)
  {
  case 0:  /* No buffer is used by the USB module. Fill the one
           we think is the next. */
    buf=ep_info[ep].next_tx;
    ep_info[ep].next_tx ^= 0x1;
    break;
  case BDT_CTL_OWN: /* Buffer 0 is used by the USB. */
    buf=1;
    ep_info[ep].next_tx=0;
    break;
  case BDT_CTL_OWN<<1: /* Buffer 1 is used by the USB. */
    buf=0;
    ep_info[ep].next_tx=1;
    break;
  default: /* Both buffers are used by the usb. This is
              an error. */
    CMX_ASSERT(0);
  }
  return(buf);
}

/*****************************************************************************
 * Name:
 *   usb_get_done
 * In:
 *   ep: number of endpoint.
 * Out:
 *   The number of bytes the endpoint tansferred.
 *
 * Description:
 *   Returns te number of bytes that were transferred.
 *****************************************************************************/
hcc_u32 usb_get_done(hcc_u8 ep)
{
  return(ep_info[ep].maxlength-ep_info[ep].tlength);
}

/*****************************************************************************
 * Name:
 *    usb_ep_is_busy
 * In:
 *   ep: number of endpoint.
 * Out:
 *   nonzero if endpoint is buys (a transfer is ongoing).
 *
 * Description:
 *
 *****************************************************************************/
hcc_u8 usb_ep_is_busy(hcc_u8 ep)
{
  return (hcc_u8)(ep_info[ep].state != EPST_IDLE ? (hcc_u8)1 : (hcc_u8)0);
}

/*****************************************************************************
 * Name:
 *    usb_get_state
 * In:
 *   N/A
 * Out:
 *   Current USB state. See USBST_xxx in usb.h
 *
 * Description:
 *
 *****************************************************************************/
hcc_u8 usb_get_state(void)
{
  return(usb_state);
}

/*****************************************************************************
 * Name:
 *    usb_ep_error
 * In:
 *   ep: number fo endpoint
 * Out:
 *   Endpoint specific error code. (See USBEPERR_xx macro definitions in usb.h)
 *
 * Description:
 *
 *****************************************************************************/
hcc_u8 usb_ep_error(hcc_u8 ep)
{
  hcc_u8 tmp=ep_info[ep].error;
  ep_info[ep].error=USBEPERR_NONE;
  return(tmp);
}

/*****************************************************************************
 * Name:
 *    send_zero_packet
 * In:
 *    N/A
 * Out:
 *    N/A
 *
 * Description:
 *    Will send a zero length data packet.
 *
 * Assumptions:
 *    ep is the index of a TX endpoint.
 *****************************************************************************/
static void send_zero_packet(hcc_u8 ep)
{
  hcc_u8 buf;

  buf=select_tx_buf(ep);
  /* Write packet length. */
  WR_LE32(&BDT_CTL_TX(ep, buf), 0);

  /* Make buffer ready for transmission. */
  ready_ep_tx(ep, buf);
}

/*****************************************************************************
 * Name:
 *    usb_stop
 * In:
 *   n/a
 * Out:
 *   n/a
 *
 * Description:
 *   Stops USB driver.
 *****************************************************************************/
void usb_stop(void)
{
  /* Disable all USB interrupts. */
  MCF_USB_INT_ENB = 0x0;
  /* Disable all OTG interupts. */
  MCF_USB_OTG_INT_EN = 0x0;
  /* Disable all USB error interrupts. */
  MCF_USB_ERR_ENB = 0x0;

  /* Clear any pending OTG interupts. */
  MCF_USB_OTG_INT_STAT = 0xff;
  /* Clear any pending USB interrupts.*/
  MCF_USB_INT_STAT = 0xff;
  /* Clear any pending USB error interrupt. */
  MCF_USB_ERR_STAT = 0xff;

  MCF_USB_USB_CTRL=0;
  /* Disable USB module. */
  MCF_USB_CTL = 0;

  enter_default_state();
  usb_setup_ep(0, EP_TYPE_DISABLE, 0, 0);
  usb_state=USBST_DISABLED;
}

/*****************************************************************************
 * Name:
 *    usb_setup_ep
 * In:
 *    addr  - endpoint address
 *    type  - endpoint type (control, bulk, interrupt, iso). This is the value
 *            of the endpoint type filed of the endpoint descriptor.
 *    ep    - number of endpoint
 *    psize - maximum packet size allowed for this endpoint.
 *    db    - nonzer of endpoint shall be double buffered. Note: only iso and
 *            bulk endpoints can be double buffered (this is hardware
 *            specific).
 * Out:
 *    0  - all ok
 *    !0 - initialisation failed
 *
 * Description:
 *    Configures the spcified endpoint.
 *****************************************************************************/
static hcc_u8 usb_setup_ep(hcc_u8 addr, hcc_u8 type, hcc_u8 ep, hcc_u16 psize)
{
  hcc_u8 endpt;
   /* Disable endpoint. */
  disable_ep_tx(ep);
  disable_ep_rx(ep);

  if (ep_info[ep].state!=EPST_IDLE)
  {
    ep_info[ep].error=USBEPERR_HOST_ABORT;
  }
  else
  {
    ep_info[ep].error=USBEPERR_NONE;
  }

  ep_info[ep].state=EPST_IDLE;
  ep_info[ep].flags=0;
  ep_info[ep].data_func=(void*)0;
  ep_info[ep].address=0;
  ep_info[ep].tlength=0;
  ep_info[ep].maxlength=0;
  ep_info[ep].psize=psize;
  ep_info[ep].data0_tx=0;
  ep_info[ep].data0_rx=0;
  if (type == EP_TYPE_DISABLE)
  {
    return(0);
  }

  endpt =0;

  /* if RX side of the endpoint needs to be configured */
  if (!(addr & DIR_TX) || type == EP_TYPE_CONTROL)
  {
    endpt |=MCF_USB_ENDPT_EP_RX_EN;

    /* Set BDT_CTL to default value. Set packet size, buffer is owned by the CPU,
       enable data toggle synchronisation, expect data0 packet. Note: data0/1
       will be set when the buffer is given to the USB. */
        WR_LE32(&BDT_CTL_RX(ep, 0), (hcc_u32)((psize << 16) | BDT_CTL_DTS));
    /* Set BDT_CTL to default value. */
    WR_LE32(&BDT_CTL_RX(ep, 1), (hcc_u32)((psize << 16) | BDT_CTL_DTS));

    /* Set RX buffer address. */
    WR_LE32(&BDT_ADR_RX(ep, 0), (hcc_u32)get_ep_rx_buffer(ep, 0));
    WR_LE32(&BDT_ADR_RX(ep, 1), (hcc_u32)get_ep_rx_buffer(ep, 1));
  }
  if ((addr & DIR_TX) || type == EP_TYPE_CONTROL)
  {
    endpt |= MCF_USB_ENDPT_EP_TX_EN;
    /* Set BDT_CTL to default value. Set buffer owned by the CPU. Value of other
       fileds is not important. Those will get a correct value when the buffer is
       made ready for transmission. */
    WR_LE32(&BDT_CTL_TX(ep, 0), 0);
    /* Set BDT_CTL to default value. */
        WR_LE32(&BDT_CTL_TX(ep, 1), 0);
    /* Set TX buffer address. */
  }

  if (type != EP_TYPE_ISO)
  { /* Non ISO endpoints need handhaking. */
    endpt |= MCF_USB_ENDPT_EP_HSHK;
  }
  else
  { /* ISO endpoints do not need handshaking, and retry. */
    endpt |= MCF_USB_ENDPT_RETRY_DIS;
  }

  /* If a non control endpoint uses both directions (e.g. two endpoint is
    implemented in the same hardware slot), then CTL_DIS shall be set. */
  if (type != EP_TYPE_CONTROL)
  {
    endpt |= MCF_USB_ENDPT_EP_CTL_DIS;
  }
  else
  { /* Reception on control endpoints shall be enabled by default. */
    /* Set maximum packet size. */
    WR_LE32(&BDT_CTL_RX(ep, ep_info[ep].next_rx), (hcc_u32)ep_info[ep].psize<<16u);
    ready_ep_rx(ep, ep_info[ep].next_rx);
  }

  MCF_USB_ENDPT(ep)=endpt;

  return(0);
}

/*****************************************************************************
 * Name:
 *    set_config
 * In:
 *    cfg_ndx - index of the configuration to be activated. The value shall
 *              shall equal to one defined in a configuration descriptor.
 * Out:
 *    N/A
 *
 * Description:
 *    Configures the USB module according to the specifyed configuration.
 * Assumptions:
 *    the spefified configuration exists.
 *    the first interface descriptor is for the default alternate setting.
 *    interfaces must be numbered from 0 increasing continously (0,1,2,3...)
 *    configurations must be numbered from 0 increasing continously
 *****************************************************************************/
static void set_config(hcc_u8 cfg_ndx)
{
  hcc_u8 cfg_ep=0;

  usb_current_config=cfg_ndx;

  /* All endpoint shall use buffer 0 now. */
  if (cfg_ndx != 0)
  {
    /* For all interfaces in this configuration. */
    hcc_u8 ifc=0;
    while(is_ifc_ndx(cfg_ndx, ifc, 0))
    { /* Emdpoint descriptor index in configuration descriptor. */
      hcc_u8 ifc_ep=0;
      while(is_ep_ndx(cfg_ndx, ifc, 0, ifc_ep))
      {
        const hcc_u8 *epd=get_ep_descriptor(cfg_ndx, ifc, 0, ifc_ep);
        /* Endpoint index and address is the same. */
        usb_setup_ep(epd[2], epd[3], (hcc_u8)(epd[2] & 0x7fu), RD_LE16(&epd[4]));
        ifc_ep++;
        cfg_ep++;
      }
      ifc++;
    }
    usb_state = USBST_CONFIGURED;
  }
  else
  {
    usb_state=USBST_ADDRESSED;
    /* No endpoints to configure. The loop below will disable all except 0. */
  }

  cfg_ep++;

  while(cfg_ep < 16)
  {
    usb_setup_ep(0, EP_TYPE_DISABLE, cfg_ep++, 0);
  }
}

/*****************************************************************************
 * Name:
 *    enter_default_state
 * In:
 *    N/A
 * Out:
 *    N/A
 *
 * Description:
 *    Configure USB driver to reflect the default state. In this state only
 *    standard requests on the default pipe are answered, all other endpoints
 *    are disabled.
 *****************************************************************************/
static void enter_default_state(void)
{
  int ep;
  /* In this state the USB module responds to the default address.
     Only EP0 is configured. */

  MCF_USB_CTL |= MCF_USB_CTL_ODD_RST;

  for(ep=0; ep<sizeof(ep_info)/sizeof(ep_info[0]); ep++)
  {
    ep_info[ep].next_rx=0;
    ep_info[ep].next_tx=0;
  }
  MCF_USB_CTL &= ~MCF_USB_CTL_ODD_RST;

  /* Configure ep 0. */
  usb_setup_ep(0, EP_TYPE_CONTROL, 0, EP0_PACKET_SIZE);
  /* Disable all other endpoints. */
  set_config(0);

  /* Set address to default address. */
  MCF_USB_ADDR = 0;

  usb_state=USBST_DEFAULT;
  new_address=0;
}


/*****************************************************************************
 * Name:
 *    usb_stop_ep_tx
 * In:
 *    ep - endpoint number
 * Out:
 *    N/A
 * Description:
 *    Will stall a tx endpoint (endpoint will not transmit any more packages,
 *    all IN request from the host will be denyed with error handsake).
 *****************************************************************************/
void usb_stop_ep_tx(hcc_u8 ep)
{
  /* This cal needs to be protected againt USB interrupts, to
     make BDT_CTL assecc atomic. */
  hcc_imask im=_irq_disable();

  /* To enforce stall handshake, we stop both buffers. */
  WR_LE32(&BDT_CTL_TX(ep, 0), BDT_CTL_OWN | BDT_CTL_STALL);
  WR_LE32(&BDT_CTL_TX(ep, 1), BDT_CTL_OWN | BDT_CTL_STALL);

  _irq_restore(im);
}

/*****************************************************************************
 * Name:
 *    usb_stop_ep_rx
 * In:
 *    ep - endpoint number
 * Out:
 *    N/A
 * Description:
 *    Will stall a rx endpoint (endpoint will not treceive any more packages,
 *    all OUT request from the host will be denyed with error handsake).
 *****************************************************************************/
void usb_stop_ep_rx(hcc_u8 ep)
{
  /* This cal needs to be protected againt USB interrupts, to
     make BDT_CTL assecc atomic. */
  hcc_imask im=_irq_disable();

  /* To enforce stall handshake, we stop both buffers. */
  WR_LE32(&BDT_CTL_RX(ep, 0), BDT_CTL_OWN | BDT_CTL_STALL);
  WR_LE32(&BDT_CTL_RX(ep, 1), BDT_CTL_OWN | BDT_CTL_STALL);

  _irq_restore(im);
}

/*****************************************************************************
 * Name:
 *    ready_ep_tx
 * In:
 *    ep - endpoint number
 * Out:
 *    N/A
 * Description:
 *    Make tx endpoint ready for transmission.
 *****************************************************************************/
static void ready_ep_tx(hcc_u8 ep, hcc_u8 buf)
{ /* Simply give buffer to USB. */
  hcc_u32 ctl;

  /* Give buffer to USB, set correct data0/1 flag, configure if data toggle
     synchronisation shall be used or not. */
  ctl=RD_LE32(&BDT_CTL_TX(ep, buf)) & ~0xff;
  ctl |= BDT_CTL_OWN | ep_info[ep].data0_tx | BDT_CTL_DTS;
  WR_LE32(&BDT_CTL_TX(ep, buf), ctl);
}

/*****************************************************************************
 * Name:
 *    ready_ep_rx
 * In:
 *    ep - endpoint number
 * Out:
 *    N/A
 * Description:
 *    Make rx endpoint ready for reception.
 *****************************************************************************/
static void ready_ep_rx(hcc_u8 ep, hcc_u8 buf)
{ /* Simply give buffer to USB. */
  hcc_u32 ctl;

  /* Give buffer to USB, set correct data0/1 flag, configure if data toggle
     synchronisation shall be used or not. */
  ctl = (ep_info[ep].psize << 16) | BDT_CTL_OWN | ep_info[ep].data0_rx | BDT_CTL_DTS;

  ep_info[ep].data0_rx ^= BDT_CTL_DATA;

  WR_LE32(&BDT_CTL_RX(ep, buf), ctl);
}

/*****************************************************************************
 * Name:
 *    disable_ep_tx
 * In:
 *    ep - endpoint number
 * Out:
 *    N/A
 * Description:
 *    Disable TX endpoint. Endpoint behaves as it would not exist (it will not
 *    affect the USB and will not generate any events).
 *****************************************************************************/
static void disable_ep_tx(hcc_u8 ep)
{
  MCF_USB_ENDPT(ep) &= ~MCF_USB_ENDPT_EP_TX_EN;
  while(MCF_USB_ENDPT(ep) & MCF_USB_ENDPT_EP_TX_EN)
    ;
  WR_LE32(&BDT_CTL_TX(ep, 0), 0);
  WR_LE32(&BDT_CTL_TX(ep, 1), 0);
}


/*****************************************************************************
 * Name:
 *    disable_ep_rx
 * In:
 *    ep - endpoint number
 * Out:
 *    N/A
 * Description:
 *    Disable RX endpoint. Endpoint behaves as it would not exist (it will not
 *    affect the USB and will not generate any events).
 *****************************************************************************/
static void disable_ep_rx(hcc_u8 ep)
{
  MCF_USB_ENDPT(ep) &= ~MCF_USB_ENDPT_EP_RX_EN;
}

/*****************************************************************************
 * Name:
 *    _usb_send
 * In:
 *    ep - endpoint number
 * Out:
 *    N/A
 * Description:
 *    This fucntion inmplements the basic state machine for transmit (IN)
 *    endpoints. It will
 *        - call user callback functions if neccessary,
 *        - set endpoint specific error codes
 *        - split data to be sent to packet sized pieces
 *    Note: it is called from the interrupt handler routine and from "user
 *          space" too. The function needs to be reentrant!
 *****************************************************************************/
static void _usb_send(hcc_u8 ep)
{
  hcc_u32 l;
  hcc_u8 buf;
  hcc_u32 length;

  switch (ep_info[ep].state)
  {
  case EPST_DATA_TX:
    l=MIN(ep_info[ep].tlength, ep_info[ep].psize);
    CMX_ASSERT(l == ep_info[ep].psize || l==ep_info[ep].tlength);

    /* Select next ep buffer. */
    buf=select_tx_buf(ep);
    /* Set-up UBS module to directly send from applications buffer. */
    WR_LE32(&BDT_ADR_TX(ep, buf), (hcc_u32)ep_info[ep].address);

    /* Set tx packet length. */
    length=MIN(ep_info[ep].psize, ep_info[ep].tlength);
    WR_LE32(&BDT_CTL_TX(ep, buf), (hcc_u32)(length<<16u));

    /* Make buffer ready for transmission. */
    ready_ep_tx(ep, buf);
    /* Invert the data toggle bit. */
    ep_info[ep].data0_tx ^= BDT_CTL_DATA;

    /* Calculate transfer status. */
    ep_info[ep].tlength -= l;
    ep_info[ep].address = (hcc_u8*)ep_info[ep].address + l;

    /* Is the just created packet the last one? */
    if (ep_info[ep].tlength == 0)
    { /* Do we need to send a zero length packet to terminate the transmission? */
      if ((l == ep_info[ep].psize) && (ep_info[ep].flags & EPFL_ZPACKET))
      {
        ep_info[ep].state=EPST_TX_STOP;
      }
      else
      {
        ep_info[ep].state=EPST_DATA_TX_LAST;
      }
      /* Warning: when getting there, an additional interrupt is needed to advance the
         state succesfully. */
      break;
    }
    break;
  case EPST_DATA_TX_WAIT_DB:
    /* Let second buffer get empty while waiting for a new buffer. */
    ep_info[ep].state=EPST_DATA_TX_EMPTY_DB;
    break;
  case EPST_TX_STOP:
    /* Send a sort packet. */
    ep_info[ep].state=EPST_DATA_TX_LAST;
    send_zero_packet(ep);
    break;
  case EPST_DATA_TX_LAST:
    /* In this state we may have one or two packets in the packet buffers.
       We shall wait till both packets are sent, and both buffers are empty. */

    /* Check if both buffers are empty. */
    if ((RD_LE32(&BDT_CTL_TX(ep, 0)) & BDT_CTL_OWN) == 0
       && (RD_LE32(&BDT_CTL_TX(ep, 1)) & BDT_CTL_OWN) == 0)
    {
      /* Enter IDLE state. */
      ep_info[ep].state=EPST_IDLE;
    }
    break;
  default:
    CMX_ASSERT(0);

  }
}

/*****************************************************************************
 * Name:
 *    usb_send
 * In:
 *    ep          - endpoint number
 *    f           - pointer to user callback function. A callback will bemade
 *                  if:  - the buffer is empty and more data needs to be sent
 *                       - all transmission is finished
 *                       - in case of an error
 *    data        - pointer to data buffer
 *    buffer_size - size of data buffer
 *    tr_length   - number of bytes to be transferred.
 *    req_length  - the number of bytes the host wants to receive.
 *
 *    Note: since all packes transmission on USB are started by the host, it
 *          needs to know how many bytes shall be transferred during a
 *          transfer. Because of this the host will always tell the device
 *          how many bytes it can receive (req_length). On the other hand, the
 *          the device may have less data ready (tr_length).
 * Out:
 *    N/A
 * Description:
 *    Using this function an TX (IN) transfer can be enabled.
 *****************************************************************************/
void usb_send(hcc_u8 ep, usb_callback_t f, hcc_u8* data, hcc_u32 tr_length, hcc_u32 req_length)
{
  hcc_imask itst;

  ep_info[ep].tlength=tr_length <= req_length ? tr_length : req_length;
  ep_info[ep].maxlength=ep_info[ep].tlength;
  ep_info[ep].data_func=f;
  ep_info[ep].address=data;
  ep_info[ep].flags=(hcc_u8)(req_length > tr_length ?   (hcc_u8)EPFL_ZPACKET : (hcc_u8)0);
  ep_info[ep].error = USBEPERR_NONE;
  ep_info[ep].state=EPST_DATA_TX;

  itst=_irq_disable();
  _usb_send(ep);
  _irq_restore(itst);
}

/*****************************************************************************
 * Name:
 *    _usb_receive
 * In:
 *    ep - endpoint number
 * Out:
 *    N/A
 * Description:
 *    This fucntion inmplements the basic state machine for receive (OUT)
 *    endpoints. It will
 *        - call user callback functions if neccessary,
 *        - set endpoint specific error codes
 *        - reassemble packets into the specified buffer
 *    Note: it is called from the interrupt handler routine and from "user
 *          space" too. The function needs to be reentrant!
 *****************************************************************************/
void _usb_receive(hcc_u8 ep)
{
  hcc_u8 loops=0;
  hcc_u8* buf;
  int x;

  /* Copy data to USER space, or call callback if no buffer is available. */
  do
  {
    hcc_u8 this_buf=(hcc_u8)((MCF_USB_STAT & MCF_USB_STAT_ODD) ? 1 : 0);
    hcc_u16 plength=(hcc_u16)(RD_LE32(&BDT_CTL_RX(ep, this_buf)) >> 16);

    /* Check if amount of received data is ok. */
    if (ep_info[ep].tlength < plength)
    { /* Host sent too many data! This is a protocol error. */
      usb_stop_ep_rx(ep);
      ep_info[ep].error = USBEPERR_TO_MANY_DATA;
      return;
    }

    /* Copy data to the user buffer. */

    /* Copy packet data to destination address. */
    /* Get next RX buffer address. */
    buf=(hcc_u8*)RD_LE32(&BDT_ADR_RX(ep, (MCF_USB_STAT & MCF_USB_STAT_ODD) ? 1 : 0));

    for(x=0; x < plength; x++)
    {
      ((hcc_u8*)(ep_info[ep].address))[x]=buf[x];
    }

    ep_info[ep].tlength -= plength;
    ep_info[ep].address = ((hcc_u8 *)ep_info[ep].address) + plength;

    /* Was this the last data packet? */
    if ((ep_info[ep].tlength == 0) || (ep_info[ep].psize != plength))
    {
      /* Uuuupps: at this point there sall be no RX buffer enabled. But
         if the hosts terminates the transfer early (by sending a short
         packet) then one buffer may remain enabled. So we may have an
         unexpected interrupt and an unexpected packet.
         We try to disable the buffer, but this is not safe. There is a
         race. If the host already sent additional data to this endpoint,
         then the first transfer will be dropped as a spurious packet.
         Note: control endpoints are not affected because befor enabling RX
         these don't need to know how much data will be transfered (setup
         transfer will tell this).
         Note1: we don't know if "aborting" the reception was succesfull or
         not. */
      WR_LE32(&BDT_CTL_RX(ep, ep_info[ep].next_rx ? 0 : 1), 0);
      ep_info[ep].state=EPST_IDLE;
      /* Control endpoints will execute the callback after the status stage. */
      /* Check if control endpoint. (Note: both ENDPT registers will have
         the same content, so we check reg0. )*/
      if (! MCF_USB_ENDPT(ep) & MCF_USB_ENDPT_EP_CTL_DIS)
      {
        /* Tell application transfer ended. */
        if (ep_info[ep].data_func != (void *) 0)
        {
          /* We don't care about the return valus since the transfer is already
             finished and we can do nothing in case of an error. */
          (void)(*ep_info[ep].data_func)();
        }
        /* Disable callbacks. */
        ep_info[ep].data_func = (void *)0;
      }
    }
    else
    {
          /* Make buffer ready for reception if two buffers can be filled by the
             USB module. */
      if (ep_info[ep].tlength > ep_info[ep].psize)
      {
        ready_ep_rx(ep, this_buf);
      }
    }
  }while(loops);
}

/*****************************************************************************
 * Name:
 *    usb_receive
 * In:
 *    ep          - endpoint number
 *    f           - pointer to user callback function. A callback will bemade
 *                  if:  - the buffer is empty and more data needs to be sent
 *                       - all transmission is finished
 *                       - in case of an error
 *    data        - pointer to data buffer
 *    buffer_size - size of data buffer
 *    tr_length   - number of bytes to be transferred. (This shal be the same
 *                  amount that the host wants to send).
 *
 * Out:
 *    N/A
 * Description:
 *    Using this function an RX (OUT) transfer can be enabled.
 *****************************************************************************/
void usb_receive(hcc_u8 ep, usb_callback_t f, hcc_u8* data, hcc_u32 tr_length)
{
  ep_info[ep].tlength=tr_length;
  ep_info[ep].maxlength=ep_info[ep].tlength;
  ep_info[ep].data_func=f;
  ep_info[ep].address=data;
  ep_info[ep].state=EPST_DATA_RX;
  ep_info[ep].error=USBEPERR_NONE;
  ep_info[ep].flags=0;

  /* Enable next rx buffer. */
  ready_ep_rx(ep, ep_info[ep].next_rx);

  if (ep_info[ep].tlength > ep_info[ep].psize)
  {
    ready_ep_rx(ep, (hcc_u8)(ep_info[ep].next_rx ^ 0x1));
  }
}

/*****************************************************************************
 * Name:
 *    usb_abort_ep
 * In:
 *    ep          - endpoint number
 *
 * Out:
 *    N/A
 * Description:
 *    A call to this function will stop the ongoing transfer on the selected
 *    endpoint (early stop). Early stop is only possible if there is some
 *    penging date left in the buffer. If not, then transfer willstop anyway.
 *****************************************************************************/
void usb_abort_ep(hcc_u8 ep)
{
  /* Get endpoint into a fixed state. */
  hcc_imask itst=_irq_disable();
  /* If the endpoint is busy. */
  switch(ep_info[ep].state)
  {
  case EPST_IDLE:
    /* If endpoint is idle, we can not stop it. */
    break;
    /* In these cases is is too late for an early stop since the transfer
       is already going to end. */
  case EPST_DATA_TX_LAST:
  case EPST_STATUS_TX:
  case EPST_STATUS_RX:
    break;

  case EPST_DATA_RX:
    ep_info[ep].error=USBEPERR_USER_ABORT;
    ep_info[ep].flags |= EPFL_ERROR;

    /* Disable following calbacks in case of an error. */
    ep_info[ep].data_func=(void *) 0;
    /* Stall endpoint. */
    usb_stop_ep_rx(ep);
    break;
  default:
    /* UPS! invalid or unknown state... */
    CMX_ASSERT(0);
  }
  _irq_restore(itst);
}

/*****************************************************************************
 * Name:
 *    cb_set_address
 * In:
 *    N/A
 *
 * Out:
 *    N/A
 *
 * Description:
 *    This callback is used by the state machine that handles the standard
 *    requests on the default pipe to set the device address after the
 *    status stage of the "set address" request.
 *****************************************************************************/
static callback_state_t cb_set_address()
{
  if (new_address != 0)
  {
    usb_state=USBST_ADDRESSED;
  }
  else
  {
    enter_default_state();
  }
  MCF_USB_ADDR = new_address;
  new_address = 0;
  return(clbst_ok);
}

/*****************************************************************************
 * Name:
 *    usb_stm_ctrl0
 * In:
 *    N/A
 * Out:
 *    status of callback execution
 *
 * Description:
 *    Will decode and handle setup packets on the default endpoint.
 * Assumptions:
 *    Is only called if a setup packet is received.
 *****************************************************************************/
static callback_state_t usb_stm_ctrl0()
{
  hcc_u8 *pdata=(hcc_u8 *)usb_get_rx_pptr(0);

  /* The return value shall reflect the direction of the transfer. */
  callback_state_t r=(STP_REQU_TYPE(pdata) & 1u<<7) ? clbst_in: clbst_out;

  switch (STP_REQU_TYPE(pdata) & 0x7f)
  {
  case 0: /* Standard request for the device. */
    /* Determine what request this is. */
    switch (STP_REQUEST(pdata))
    {
    case USBRQ_SET_ADDRESS:
      new_address=(hcc_u8)(STP_VALUE(pdata) & ((1u << 7)-1u));
      ep_info[0].data_func=cb_set_address;
      break;
    case USBRQ_GET_DESCRIPTOR:
      switch(STP_VALUE(pdata) & 0xff00u)
      {
      case STDD_DEVICE << 8:
        {
          hcc_u8 *p=(hcc_u8*)get_device_descriptor();
          usb_send(0, (void *) 0, p, p[0], STP_LENGTH(pdata));
        }
        break;
      case STDD_CONFIG << 8:
        /* Do we have a CFG descriptor with the requested index? */
        {
          hcc_u8 cfg=(hcc_u8)(STP_VALUE(pdata) & 0xffu);
          /* For index 0 we return the first config descriptor. */
          if (cfg == 0)
          {
            cfg++;
          }
          if (is_cfgd_index(cfg))
          {
            const hcc_u8 *cd;
            cd=get_cfg_descriptor(cfg);
            usb_send(0, (void *) 0, (void*)cd, RD_LE16(&cd[2])
                     , STP_LENGTH(pdata));
            break;
          }
        }
        /* No such descriptor, report error. */
        r=clbst_error;
        break;

      case STDD_STRING << 8:
        /* See if te required descriptor exists. */
        if (is_str_index((hcc_u8)(STP_VALUE(pdata) & 0xffu)))
        {
          usb_send(0, (void *) 0, (void *)get_str_descriptor((hcc_u8)(STP_VALUE(pdata) & 0xffu))
                   , *(hcc_u8*)get_str_descriptor((hcc_u8)(STP_VALUE(pdata) & 0xffu))
                   , STP_LENGTH(pdata));
          break;
        }
        /* No such string descriptor. */
        r=clbst_error;
        break;

      default:
        /* Call user callback if avaiable. */
        goto call_usercb;
      }
      break;
    case USBRQ_GET_CONFIGURATION:
      usb_send(0, (void *) 0, (void *)&usb_current_config
                 , 1
                 , STP_LENGTH(pdata));
      break;
    case USBRQ_SET_CONFIGURATION:
      if (STP_VALUE(pdata) == 0)
      {
        set_config(0);
        break;
      }
      else if (is_cfgd_index(STP_VALUE(pdata)))
      {

        set_config((hcc_u8)STP_VALUE(pdata));
        break;
      }
      r=clbst_error;
      break;
    case USBRQ_SYNCH_FRAME:
    case USBRQ_SET_FEATURE:
    case USBRQ_CLEAR_FEATURE:
    case USBRQ_GET_STATUS:
    case USBRQ_SET_DESCRIPTOR:
    default: /* Unknown or not implemented request. */
      /* Call user callback if avaiable. */
      goto call_usercb;
    }
    break;
  case 1: /* Standard request for an interface. */
      /* Call user callback. */
      goto call_usercb;
  case 2: /* Standard request for an endpoint. */
    switch(STP_REQUEST(pdata))
    {
    case USBRQ_CLEAR_FEATURE:
      switch(STP_VALUE(pdata))
      {
      case FEAT_ENDPOINT_HALT:
        {
          /* Find the endpoint with the address specified int pdata->index.
          assumption: endpoints are allocated after each other. */
          hcc_u8 adr=(hcc_u8)(STP_INDEX(pdata) & 0x7f);

          if (STP_INDEX(pdata) & 0x80)
          {
            hcc_u32 bdt;
            ep_info[adr].data0_tx=0;
            bdt=RD_LE32(&BDT_CTL_TX(adr, 0));
            bdt &= ~BDT_CTL_STALL;
                  WR_LE32(&BDT_CTL_TX(adr, 0), bdt);
            bdt=RD_LE32(&BDT_CTL_TX(adr, 1));
            bdt &= ~BDT_CTL_STALL;
                  WR_LE32(&BDT_CTL_TX(adr, 1), bdt);
          }
          else
          {
            hcc_u32 bdt;
            ep_info[adr].data0_rx=0;
            bdt=RD_LE32(&BDT_CTL_RX(adr, 0));
            bdt &= ~BDT_CTL_STALL;
                  WR_LE32(&BDT_CTL_RX(adr, 0), bdt);
            bdt=RD_LE32(&BDT_CTL_RX(adr, 1));
            bdt &= ~BDT_CTL_STALL;
                  WR_LE32(&BDT_CTL_RX(adr, 1), bdt);
          }
        }
        break;
      default:
        goto call_usercb;
      }
      break;
    default:
      /* Call user callback if avaiable. */
      goto call_usercb;
    }
    break;
  default:
  call_usercb:
    r=usb_ep0_callback();
  }

  return(r);
}

/*****************************************************************************
 * Name:
 *    usb_it_handler
 * In:
 *    N/A
 * Out:
 *    N/A
 *
 * Description:
 *    Low priority interrupt handler.
 *
 * Assumptions:
 *
 *****************************************************************************/
//#ifdef __GNUC__
/* __declspec(interrupt) is not supported by GNUC. Remove it with a macro. */
//void usb_it_handler1(void)
//#else
//#pragma interrupt  on
//#pragma TRAP_PROC
interrupt
/* VectorNumber_Vusb */
void usb_it_handler(void)
//#endif
{
  hcc_u8 istr;

  /* Save irq USB status. */
  istr=MCF_USB_INT_STAT;
  if(istr & ~MCF_USB_INT_STAT_TOK_DNE)
  {
    if (istr & MCF_USB_INT_STAT_USB_RST)
    {
      /* Clear IT flag. */
      MCF_USB_INT_STAT = MCF_USB_INT_STAT_USB_RST;
      /* Enter default state. */
      enter_default_state();
      usb_reset_event();
      goto it_exit;
    }

    if (istr & MCF_USB_INT_STAT_ERROR)
    {
      MCF_USB_INT_STAT = MCF_USB_INT_STAT_ERROR;
      usb_bus_error_event();
    }
    if (istr & MCF_USB_INT_STAT_RESUME)
    {
      MCF_USB_INT_ENB &= ~MCF_USB_INT_ENB_RESUME;

      MCF_USB_INT_STAT = MCF_USB_INT_STAT_SLEEP;
      MCF_USB_INT_ENB |= MCF_USB_INT_ENB_SLEEP;
      usb_wakeup_event();
    }
    if (istr & MCF_USB_INT_STAT_SLEEP)
    {
      MCF_USB_INT_ENB &= ~MCF_USB_INT_ENB_SLEEP;

      MCF_USB_INT_STAT = MCF_USB_INT_STAT_RESUME;
      MCF_USB_INT_ENB |= MCF_USB_INT_ENB_RESUME;
      usb_suspend_event();
    }

    /* Stall was sent. */
    if (istr & MCF_USB_INT_STAT_STALL)
    {
      hcc_u8 ep=(hcc_u8)(MCF_USB_STAT >> 4);
      MCF_USB_INT_STAT = MCF_USB_INT_STAT_STALL;
      /* Remove stall for control endpoints. ??*/
      if ((MCF_USB_ENDPT(ep) & MCF_USB_ENDPT_EP_CTL_DIS) == 0)
      {
        WR_LE32(&BDT_CTL_RX(ep, 0), 0);
        WR_LE32(&BDT_CTL_RX(ep, 1), 0);
        WR_LE32(&BDT_CTL_TX(ep, 0), 0);
        WR_LE32(&BDT_CTL_TX(ep, 1), 0);
        ready_ep_rx(ep, ep_info[ep].next_rx);
      }
    }
  }

  if (istr & MCF_USB_INT_STAT_TOK_DNE)
  {
    hcc_u8 ep=(hcc_u8)(MCF_USB_STAT >> 4);
    int is_rx;
    int is_stp;
    hcc_u8 this_buf=(hcc_u8)(MCF_USB_STAT & MCF_USB_STAT_ODD ? 1 : 0);

    if (MCF_USB_STAT & MCF_USB_STAT_TX)
    {
      is_rx=0;
      is_stp=0;

      WR_LE32(&BDT_CTL_TX(ep, this_buf),
               RD_LE32(&BDT_CTL_TX(ep, this_buf)) & ~(BDT_CTL_STALL|BDT_CTL_OWN));
      ep_info[ep].next_tx = (hcc_u8)(this_buf ? 0u : 1u);
    }
    else
    {/* This is an RX packet.*/
      is_rx=1;
      ep_info[ep].next_rx=(hcc_u8)(this_buf ^ 0x1u);
      is_stp=(hcc_u8)(RD_LE32(&BDT_CTL_RX(ep, this_buf)) & 0x3f) == (SOF_PID_VALUE<<2) ? 1 : 0;

      WR_LE32(&BDT_CTL_RX(ep, this_buf),
               RD_LE32(&BDT_CTL_RX(ep, this_buf)) & ~(BDT_CTL_STALL|BDT_CTL_OWN));
    }

    /* is this a control endpoint? */
    if ((MCF_USB_ENDPT(ep) & MCF_USB_ENDPT_EP_CTL_DIS) == 0)
    {/* then use a special state machine. */
      switch(ep_info[ep].state)
      {
      default:
        CMX_ASSERT(0);
        break;
      case EPST_IDLE:
      idle:
        if (is_stp)
        {
          callback_state_t r;
          /* Reset the endpoint state. */

          /* Since TOKBUSY is still set, this is a safe point to disable
             packet buffers (NAK in and out direction). */
          WR_LE32(&BDT_CTL_TX(ep, 0), 0);
          WR_LE32(&BDT_CTL_TX(ep, 1), 0);
          WR_LE32(&BDT_CTL_RX(ep, 0), 0);
          WR_LE32(&BDT_CTL_RX(ep, 1), 0);


          /* Dnager: if a setup frame will be received not in idle
             state, then the TOKBUSY will not be cleared,
             and the whole USB will not answer any more.*/

          /* This flag shall be cleared after each setup packet. Note:
             it seems it shall be cleared before trying to use endpoint
             buffers. */
          MCF_USB_CTL &= ~MCF_USB_CTL_TXDSUSPEND_TOKBUSY;

             /* remove any callback */
          ep_info[ep].data_func = (void*)0;
             /* clear flags*/
          ep_info[ep].flags=0;
             /* clear user error indicator */
          ep_info[ep].error=USBEPERR_NONE;
          /* After a setup packet the next packet is always a data1. */
          ep_info[ep].data0_tx = BDT_CTL_DATA;
          ep_info[ep].data0_rx = BDT_CTL_DATA;
          /* Remove stall condition. */

          if (ep == 0)
          {
            r=usb_stm_ctrl0();
          }
          else
          {
            /* Only one control channel is supported. */
            r=clbst_error;
          }
          switch(r)
          {
            case clbst_error:
              usb_stop_ep_tx(ep);
              usb_stop_ep_rx(ep);
              ep_info[ep].state = EPST_IDLE;
              ep_info[ep].error = USBEPERR_USER_ABORT;
              break;
            case clbst_not_ready:
              /* Nothing to do. */
              break;
            case clbst_in:
              ready_ep_rx(ep, ep_info[ep].next_rx);
              break;
            case clbst_out:
              if (ep_info[ep].state == EPST_IDLE)
              {
                goto send_status;
              }
              break;
            default:
              break;
          }
        }
        else
        {/* This is not a setup packet, and we encountered a protocol error.
            Possible reasons:
               -spurious package on the bus (not our fault)
               -we ended the transfer before the host.
                  - host and device transfer length was not the same
                  - driver error miscounted packages
          */
          /* Stall endpoint to make error visible to the host. */
          ep_info[ep].error = USBEPERR_TO_MANY_DATA;

          usb_stop_ep_rx(ep);
          usb_stop_ep_tx(ep);
        }
        break;
      case EPST_DATA_TX:
      case EPST_DATA_TX_LAST:
      case EPST_TX_STOP:

        /* If there is an RX interrupt pending , stop transmission. */
        if (is_rx)
        {
          /* Inform application about transfer end. */
          ep_info[ep].state=EPST_IDLE;
          if (ep_info[ep].data_func != (void *)0)
          {
            (void)(*ep_info[ep].data_func)();
          }
          /* Go to EPST_IDLE and handle the packet as it would be the start
             of a new transfer.  */
          goto idle;
        }
        _usb_send(ep);

        /* If transfer is ended, then we shall receive a handshake from the host. */
        if (ep_info[ep].state == EPST_IDLE)
        {
          ep_info[ep].state=EPST_STATUS_TX;
        }

        break;
      case EPST_STATUS_TX:
        /* We may have some TX interrupt events on the USB module event stack. These
           events are already handled, but wi may get dome dummy interrupts.
           So simply dropp such events to keep the state machine synchron to the USB. */
        if (!is_rx)
        {
          break;
        }
        /* In the IN transfer status stage we received a 0 byte long DATA 1 packet. */
        ep_info[ep].state=EPST_IDLE;
        /* Tell application transfer ended. */
        if (ep_info[ep].data_func != (void *) 0)
        {
          /* We don't care about the return value at this point, since we already
             sent the status, and the transfer is already ended. */
          (void)(*ep_info[ep].data_func)();
          /* Disable callbacks. */
          ep_info[ep].data_func = (void *)0;
        }
        ready_ep_rx(ep, ep_info[ep].next_rx);
        break;
      case EPST_DATA_RX:
        _usb_receive(ep);
        /* Was this the last packet to receive? */
        send_status:
        if(ep_info[ep].state == EPST_IDLE)
        {
          /* If there was an error, stall the status stage. */
          if (ep_info[ep].flags & EPFL_ERROR)
          {
            usb_stop_ep_tx(ep);
          }
          else
          {
            /* Handshake is allways a data 1 packet. */
            ep_info[ep].data0_tx = BDT_CTL_DATA;
            /* If all ok send handshake. */
            ep_info[ep].state=EPST_STATUS_RX;
            /* Send a 0 byte long data1 packet as response.*/
            send_zero_packet(ep);
          }
        }
        break;
      case EPST_STATUS_RX:
        /* In the OUT transfer status stage we sent a 0 byte long DATA 0 packet. */
        ep_info[ep].state=EPST_IDLE;
        /* Tell application transfer ended. */
        if (ep_info[ep].data_func != (void *) 0)
        {
          /* We don't care about the return value at this point, since we already
             sent the status, and the transfer is already ended. */
          (void)(*ep_info[ep].data_func)();
          /* Disable callbacks. */
          ep_info[ep].data_func = (void *)0;
        }
        ready_ep_rx(ep, ep_info[ep].next_rx);
        break;
      }
    }
    else
    {
      /* Is this an OUT (rx) endpoint? */
      if(is_rx)
      {
        /* Handle reception. */
        _usb_receive(ep);
      }
      else
      { /* This is an IN endpoint (TX) */
        _usb_send(ep);
        if (ep_info[ep].state==EPST_IDLE)
        {
          /* Inform user application. */
          if (ep_info[ep].data_func != (void *)0)
          {
            (*ep_info[ep].data_func)();
            /* Disable futher callbacks. */
            ep_info[ep].data_func = (void *)0;
          }
        }
      }
    }
        /* Clear interrupt flag. */
    MCF_USB_INT_STAT=MCF_USB_INT_STAT_TOK_DNE;

  }
  it_exit:
          ;
}

/****************************** END OF FILE **********************************/





%-BW_CUSTOM_VARIABLE_END
%-BW_INTERN_METHOD_DECL_START
%- List of internal methods headers
%-BW_INTERN_METHOD_DECL_END
%-BW_IMPLEMENT_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN Init
%ifdef Init
%define! RetVal
%include Common\USB_CMXInit.Inc
byte %'ModuleName'%.%Init(void)
{
/*****************************************************************************
 * Name:
 *    usb_init
 * In:
 *   None
 * Out:
 *   0  - if all ok
 *   !0 - if failed
 *
 * Description:
 *   Initialises the usb driver. Will set the interrupt level.
 *   Note: clock source is the system clock (48MHz).
 *****************************************************************************/
  /* Reset USB module first. */
  USBTRC0_USBRESET = 1;
  while (USBTRC0_USBRESET){}

  /* exit suspend and select USB clock source
   * If you program CLK_SRC bits as 2b11 in the USB_CTRL register then MCGPLLSCK is connected to the USB 48 Mhz clock.
   * If you program CLK_SRC bits to 2b00 then the usb_alt_clk input pin to the chip is used as the USB 48 Mhz clock . This is the PTG0 pad. (Pin number 32 for 80LQFP)
   * Plz ignore programmation 2b01,2b10 for CLK_SRC bit. They are reserved.
   */
  MCF_USB_USB_CTRL = MCF_USB_USB_CTRL_CLKSRC_SYS;

  /* Disable all USB interrupts. */
  MCF_USB_INT_ENB = 0x0;
  /* Disable all OTG interupts. */
  MCF_USB_OTG_INT_EN = 0x0;
  /* Disable all USB error interrupts. */
  MCF_USB_ERR_ENB = 0x0;

  /* Put USB to default state. */
  enter_default_state();

  /* Clear any pending OTG interupts. */
  MCF_USB_OTG_INT_STAT = 0xff;
  /* Clear any pending USB interrupts.*/
  MCF_USB_INT_STAT = 0xff;
  /* Clear any pending USB error interrupt. */
  MCF_USB_ERR_STAT = 0xff;

  /* Enable USB interrupts. */
  MCF_USB_INT_ENB = MCF_USB_INT_ENB_SLEEP | MCF_USB_INT_ENB_TOK_DNE
                    | MCF_USB_INT_ENB_ERROR | MCF_USB_INT_ENB_USB_RST
                    | MCF_USB_INT_ENB_STALL;

  /* Set BDT address. */
  MCF_USB_BDT_PAGE_01 = (hcc_u8)(((hcc_u32)BDT_BASE) >> 8);
  MCF_USB_BDT_PAGE_02 = (hcc_u8)(((hcc_u32)BDT_BASE) >> 16);
  MCF_USB_BDT_PAGE_03 = (hcc_u8)(((hcc_u32)BDT_BASE) >> 24);


   /* Enable USB PHY before enabling USB module. */
  USBTRC0 = USBTRC0_USBVREN_MASK; /* initialize register */
  %@USBConfig@'ModuleName'%.enable_voltage_regulator();
  %@USBConfig@'ModuleName'%.enable_usb_pull_up();

   /* Enable USB functionality*/
  MCF_USB_CTL = MCF_USB_CTL_USB_EN_SOF_EN;

  return(0);
}

%endif %- Init
%-BW_METHOD_END Init
%-************************************************************************************************************
%-BW_METHOD_BEGIN stack_init
%ifdef stack_init
%define! Parpattern
%include Common\USB_CMXstack_init.Inc
void %'ModuleName'%.%stack_init(byte pattern)
{
  extern unsigned long far __SP_END;
  byte far * stackEnd  = (byte far*)&__SP_END;
  byte far * stackPointer;
  asm {
    move.l A7,stackPointer
  }
  stackPointer -= 4;
  for (;stackPointer >= stackEnd;)
  {
    *stackPointer-- = pattern;
  }
}

%endif %- stack_init
%-BW_METHOD_END stack_init
%-************************************************************************************************************
%-BW_METHOD_BEGIN stack_size
%ifdef stack_size
%define! Parpattern
%define! RetVal
%include Common\USB_CMXstack_size.Inc
long %'ModuleName'%.%stack_size(byte pattern)
{
  extern unsigned long far __SP_END;
  extern unsigned long far __SP_INIT;
  byte far * stackEnd  = (byte far*)&__SP_END;
  byte far * stackBegin = (byte far*)&__SP_INIT;
  byte far * stackPointer;
  byte far *tempStackPointer = stackEnd;
  long stackSize = 0;

  asm{
   move.l A7,stackPointer
  }

  // Search the stack for pattern
  for(;tempStackPointer <= (stackPointer);tempStackPointer++)
  {
    if(*tempStackPointer != pattern)
    {
       break;
    }
    stackSize++;
  }
  return (stackBegin-stackEnd+1-stackSize);
}

%endif %- stack_size
%-BW_METHOD_END stack_size
%-************************************************************************************************************
%-BW_METHOD_BEGIN hw_init
%ifdef hw_init
%include Common\USB_CMXhw_init.Inc
void %'ModuleName'%.%hw_init(void)
{
  /* Disable watchdog. */
  SOPT1_COPT=0;
#ifdef LITTLE_ENDIAN_MODE
  SOPT2  &= ~(1<<5); /* MUST clear bit 5 to use little endian for memory access */
#endif
  init_clock();
  EnableInterrupts;
}

%endif %- hw_init
%-BW_METHOD_END hw_init
%-BW_IMPLEMENT_END
/* END %ModuleName. */

%include Common\Header.End
%-
%-
%-BW_EVENT_IMPLEMENT_START
%-BW_EVENT_IMPLEMENT_END
%INITIALIZATION
  /* ### %DeviceType "%DeviceName" init code ... */
%CODE_BEGIN
  /* Write code here ... */
%CODE_END
%-
%ENABLE
%CODE_BEGIN
%CODE_END
%-
%else %- Language (& Compiler)
  %error^ This bean is not implemented in selected language & compiler !
%endif %- Language (& Compiler)
%DEBUG
%ALL_SYMBOLS
%-
%-=======================================================================================
%FILE CODE\mcf5xxx_Io.s
/*
 * File:    mcf5xxx.s
 * Purpose: Lowest level routines for all ColdFire processors.
 *
 * Notes:
 *
 */


    .global asm_set_ipl
    .global _asm_set_ipl
    .global _mcf5xxx_byterev

    .text
/********************************************************************/
/*
 * This routines changes the IPL to the value passed into the routine.
 * It also returns the old IPL value back.
 * Calling convention from C:
 *   old_ipl = asm_set_ipl(new_ipl);
 * For the Diab Data C compiler, it passes return value thru D0.
 * Note that only the least significant three bits of the passed
 * value are used.
 */

asm_set_ipl:
_asm_set_ipl:
    link    A6,#-12
    movem.l D6-D7,(SP)

    move.w  SR,D7       /* current sr    */

    move.l  D7,D6       /* prepare return value  */
    andi.l  #0x0700,D6  /* mask out IPL  */
    lsr.l   #8,D6       /* IPL   */


    andi.l  #0x07,D0        /* least significant three bits  */
    lsl.l   #8,D0           /* move over to make mask    */

    andi.l  #0x0000F8FF,D7  /* zero out current IPL  */
    or.l    D0,D7           /* place new IPL in sr   */
    move.w  D7,SR

    move.w  d6,d0
    movem.l (SP),D6-D7
    lea     8(SP),SP
    unlk    A6
    rts


_mcf5xxx_byterev:
    .short   0x02c0      /* byterev.l, D0   */
    rts


/********************************************************************/
    .end
%-===========================================================================
%FILE CODE\hcc_types.h
/****************************************************************************
 *
 *            Copyright (c) 2006-2007 by CMX Systems, Inc.
 *
 * This software is copyrighted by and is the sole property of
 * CMX.  All rights, title, ownership, or other interests
 * in the software remain the property of CMX.  This
 * software may only be used in accordance with the corresponding
 * license agreement.  Any unauthorized use, duplication, transmission,
 * distribution, or disclosure of this software is expressly forbidden.
 *
 * This Copyright notice may not be removed or modified without prior
 * written consent of CMX.
 *
 * CMX reserves the right to modify this software without notice.
 *
 * CMX Systems, Inc.
 * 12276 San Jose Blvd. #511
 * Jacksonville, FL 32223
 * USA
 *
 * Tel:  (904) 880-1840
 * Fax:  (904) 880-1632
 * http: www.cmx.com
 * email: cmx@cmx.com
 *
 ***************************************************************************/
#ifndef _CMX_TYPES_H_
#define _CMX_TYPES_H_
#include  "cpu.h"

/* Type definitions */
typedef unsigned char hcc_u8;
typedef unsigned short hcc_u16;
typedef unsigned long int hcc_u32;

typedef volatile hcc_u8 hcc_reg8;
typedef volatile hcc_u16 hcc_reg16;
typedef volatile hcc_u32 hcc_reg32;

typedef hcc_u32 hcc_imask;

#ifdef NDEBUG
#define CMX_ASSERT(c) (void)0
#else
#define CMX_ASSERT(c)\
do {\
  if(!(c))\
  {\
    int a=1;\
    while(a)\
      ;\
  }\
}while(0)
#endif

extern hcc_u32 mcf5xxx_byterev(hcc_u32 val);


#define WR_LE32(a, v) ((*(hcc_u32*)(a))= mcf5xxx_byterev(v))
#define WR_LE16(a, v) ((*(hcc_u16*)(a))=(hcc_u16)(mcf5xxx_byterev(v) >> 16))
#define WR_LE16(a, v) ((*(hcc_u16*)(a))=(hcc_u16)(mcf5xxx_byterev(v) >> 16))
#define RD_LE32(a)    (mcf5xxx_byterev(*(hcc_u32*)(a)))
#define RD_LE16(a)    ((hcc_u16)(mcf5xxx_byterev((hcc_u32)*(hcc_u16*)(a))>>16))

/* Read 16 bit big endian value from address. */
#define RD_BE16(a) (*(hcc_u16*)(a))
/* Write 16bit value in v to address a in big endian order. */
#define WR_BE16(a, v) (*(hcc_u16*)(a) = (hcc_u16)(v))
/* Read 32 bit little endian value from address. */
#define RD_BE32(a) (*(hcc_u32*)(a))
/* Write 32bit value in v to address a in big endian order. */
#define WR_BE32(a, v) (*(hcc_u32*)(a) = (hcc_u32)(v))


#endif /*_CMX_TYPES_H_*/

/****************************** END OF FILE **********************************/
%-===========================================================================
%FILE CODE\mcf51xx_reg.h
/***************************************************************************
 *
 *            Copyright (c) 2006-2007 by CMX Systems, Inc.
 *
 * This software is copyrighted by and is the sole property of
 * CMX.  All rights, title, ownership, or other interests
 * in the software remain the property of CMX.  This
 * software may only be used in accordance with the corresponding
 * license agreement.  Any unauthorized use, duplication, transmission,
 * distribution, or disclosure of this software is expressly forbidden.
 *
 * This Copyright notice may not be removed or modified without prior
 * written consent of CMX.
 *
 * CMX reserves the right to modify this software without notice.
 *
 * CMX Systems, Inc.
 * 12276 San Jose Blvd. #511
 * Jacksonville, FL 32223
 * USA
 *
 * Tel:  (904) 880-1840
 * Fax:  (904) 880-1632
 * http: www.cmx.com
 * email: cmx@cmx.com
 *
 ***************************************************************************/
 /*
  * Author: William Jiang
  * Change History:
  *       version 1, Oct.31, 2007 --- initial version
  */
#ifndef _MCF51XX_REGS_H_
#define _MCF51XX_REGS_H_

#include "cpu.h"

#define LITTLE_ENDIAN_MODE

#define nop()       asm( nop)

/*
 * Memory map definitions from linker command files
 */
#if 0
extern volatile byte  const _IPSBAR[];
#else
  #define _IPSBAR ((char*)0xFFFF8000)
#endif
/*
 * Memory Map Info
 */

#define BITX(x) (1U<<(x))
#define BIT0        BITX(0)
#define BIT1        BITX(1)
#define BIT2        BITX(2)
#define BIT3        BITX(3)
#define BIT4        BITX(4)
#define BIT5        BITX(5)
#define BIT6        BITX(6)
#define BIT7         BITX(7)
#define BIT8        BITX(8)
#define BIT9        BITX(9)
#define BIT10   BITX(10)
#define BIT11        BITX(11)
#define BIT12   BITX(12)
#define BIT13        BITX(13)
#define BIT14   BITX(14)
#define BIT15        BITX(15)
#define BIT16   BITX(16)
#define BIT17        BITX(17)
#define BIT18   BITX(18)
#define BIT19        BITX(19)
#define BIT20   BITX(20)
#define BIT21        BITX(21)
#define BIT22   BITX(22)
#define BIT23        BITX(23)
#define BIT24   BITX(24)
#define BIT25        BITX(25)
#define BIT26   BITX(26)
#define BIT27        BITX(27)
#define BIT28   BITX(28)
#define BIT29        BITX(29)
#define BIT30   BITX(30)
#define BIT31        BITX(31)


/*********************************************************************
*
* Core register bit definitions
*
*********************************************************************/
/* Status Register */
#define MCF5XXX_SR_T        (0x8000)
#define MCF5XXX_SR_S        (0x2000)
#define MCF5XXX_SR_M        (0x1000)
#define MCF5XXX_SR_IPL      (0x0700)
#define MCF5XXX_SR_IPL_0    (0x0000)
#define MCF5XXX_SR_IPL_1    (0x0100)
#define MCF5XXX_SR_IPL_2    (0x0200)
#define MCF5XXX_SR_IPL_3    (0x0300)
#define MCF5XXX_SR_IPL_4    (0x0400)
#define MCF5XXX_SR_IPL_5    (0x0500)
#define MCF5XXX_SR_IPL_6    (0x0600)
#define MCF5XXX_SR_IPL_7    (0x0700)
#define MCF5XXX_SR_X        (0x0010)
#define MCF5XXX_SR_N        (0x0008)
#define MCF5XXX_SR_Z        (0x0004)
#define MCF5XXX_SR_V        (0x0002)
#define MCF5XXX_SR_C        (0x0001)


/*********************************************************************
*
* Universal Serial Bus (USB)
*
*********************************************************************/

/* Register read/write macros */
#define MCF_USB_PER_ID                       (*(hcc_reg8 *)(&_IPSBAR[0x1A00]))
#define MCF_USB_IP_COMP                      (*(hcc_reg8 *)(&_IPSBAR[0x1A04]))
#define MCF_USB_REV                          (*(hcc_reg8 *)(&_IPSBAR[0x1A08]))
#define MCF_USB_ADD_INFO                     (*(hcc_reg8 *)(&_IPSBAR[0x1A0C]))
#define MCF_USB_OTG_INT_STAT                 (*(hcc_reg8 *)(&_IPSBAR[0x1A10]))
#define MCF_USB_OTG_INT_EN                   (*(hcc_reg8 *)(&_IPSBAR[0x1A14]))
#define MCF_USB_OTG_STATUS                   (*(hcc_reg8 *)(&_IPSBAR[0x1A18]))
#define MCF_USB_OTG_CTRL                     (*(hcc_reg8 *)(&_IPSBAR[0x1A1C]))
#define MCF_USB_INT_STAT                     (*(hcc_reg8 *)(&_IPSBAR[0x1A80]))
#define MCF_USB_INT_ENB                      (*(hcc_reg8 *)(&_IPSBAR[0x1A84]))
#define MCF_USB_ERR_STAT                     (*(hcc_reg8 *)(&_IPSBAR[0x1A88]))
#define MCF_USB_ERR_ENB                      (*(hcc_reg8 *)(&_IPSBAR[0x1A8C]))
#define MCF_USB_STAT                         (*(hcc_reg8 *)(&_IPSBAR[0x1A90]))
#define MCF_USB_CTL                          (*(hcc_reg8 *)(&_IPSBAR[0x1A94]))
#define MCF_USB_ADDR                         (*(hcc_reg8 *)(&_IPSBAR[0x1A98]))
#define MCF_USB_BDT_PAGE_01                  (*(hcc_reg8 *)(&_IPSBAR[0x1A9C]))
#define MCF_USB_FRM_NUML                     (*(hcc_reg8 *)(&_IPSBAR[0x1AA0]))
#define MCF_USB_FRM_NUMH                     (*(hcc_reg8 *)(&_IPSBAR[0x1AA4]))
#define MCF_USB_FRM_NUM       (MCF_USB_INT_STAT=MCF_USB_INT_STAT_SOF_TOK ,MCF_USB_FRM_NUML | (((hcc_u16)MCF_USB_FRM_NUMH)<<8))
#define MCF_USB_TOKEN                        (*(hcc_reg8 *)(&_IPSBAR[0x1AA8]))
#define MCF_USB_SOF_THLDL                    (*(hcc_reg8 *)(&_IPSBAR[0x1AAC]))
#define MCF_USB_BDT_PAGE_02                  (*(hcc_reg8 *)(&_IPSBAR[0x1AB0]))
#define MCF_USB_BDT_PAGE_03                  (*(hcc_reg8 *)(&_IPSBAR[0x1AB4]))
#define MCF_USB_ENDPT0                       (*(hcc_reg8 *)(&_IPSBAR[0x1AC0]))
#define MCF_USB_ENDPT1                       (*(hcc_reg8 *)(&_IPSBAR[0x1AC4]))
#define MCF_USB_ENDPT2                       (*(hcc_reg8 *)(&_IPSBAR[0x1AC8]))
#define MCF_USB_ENDPT3                       (*(hcc_reg8 *)(&_IPSBAR[0x1ACC]))
#define MCF_USB_ENDPT4                       (*(hcc_reg8 *)(&_IPSBAR[0x1AD0]))
#define MCF_USB_ENDPT5                       (*(hcc_reg8 *)(&_IPSBAR[0x1AD4]))
#define MCF_USB_ENDPT6                       (*(hcc_reg8 *)(&_IPSBAR[0x1AD8]))
#define MCF_USB_ENDPT7                       (*(hcc_reg8 *)(&_IPSBAR[0x1ADC]))
#define MCF_USB_ENDPT8                       (*(hcc_reg8 *)(&_IPSBAR[0x1AE0]))
#define MCF_USB_ENDPT9                       (*(hcc_reg8 *)(&_IPSBAR[0x1AE4]))
#define MCF_USB_ENDPT10                      (*(hcc_reg8 *)(&_IPSBAR[0x1AE8]))
#define MCF_USB_ENDPT11                      (*(hcc_reg8 *)(&_IPSBAR[0x1AEC]))
#define MCF_USB_ENDPT12                      (*(hcc_reg8 *)(&_IPSBAR[0x1AF0]))
#define MCF_USB_ENDPT13                      (*(hcc_reg8 *)(&_IPSBAR[0x1AF4]))
#define MCF_USB_ENDPT14                      (*(hcc_reg8 *)(&_IPSBAR[0x1AF8]))
#define MCF_USB_ENDPT15                      (*(hcc_reg8 *)(&_IPSBAR[0x1AFC]))
#define MCF_USB_USB_CTRL                     (*(hcc_reg8 *)(&_IPSBAR[0x1B00]))
#define MCF_USB_USB_OTG_OBSERVE              (*(hcc_reg8 *)(&_IPSBAR[0x1B04]))
#define MCF_USB_USB_OTG_CONTROL              (*(hcc_reg8 *)(&_IPSBAR[0x1B08]))

/* two new added registers for V1 */
#define MCF_USB_USBTRC0                                         (*(hcc_reg8 *)(&_IPSBAR[0x1B0C]))
#define MCF_USB_OTGPIN                                         (*(hcc_reg8 *)(&_IPSBAR[0x1B10]))

/* Bit definitions and macros for MCF_USB_USBTRC0 */
#define MCF_USB_USBTRC0_USB_RESUME_INT                (0x01)
#define MCF_USB_USBTRC0_USBVREN                        (0x04)
#define MCF_USB_USBTRC0_USBRESMEN                (0x20)
#define MCF_USB_USBTRC0_USBPU                        (0x40)
#define MCF_USB_USBTRC0_USBRESET                (0x80)

/* Bit definitions and macros for MCF_USB_OTGPIN */
#define MCF_USB_OTGPIN_SESSVLD                        (0x01)
#define MCF_USB_OTGPIN_SESSEND                        (0x02)
#define MCF_USB_OTGPIN_VBUSVLD                        (0x04)
#define MCF_USB_OTGPIN_PULLUP                        (0x08)
#define MCF_USB_OTGPIN_DPDOWN                        (0x10)
#define MCF_USB_OTGPIN_DMDOWN                        (0x20)
#define MCF_USB_OTGPIN_USBID                        (0x40)


/* Bit definitions and macros for MCF_USB_PER_ID */
#define MCF_USB_PER_ID_ID(x)                 (((x)&0x3F)<<0)

/* Bit definitions and macros for MCF_USB_IP_COMP */
#define MCF_USB_IP_COMP_NID(x)               (((x)&0x3F)<<0)

/* Bit definitions and macros for MCF_USB_REV */
#define MCF_USB_REV_REV(x)                   (((x)&0xFF)<<0)

/* Bit definitions and macros for MCF_USB_ADD_INFO */
#define MCF_USB_ADD_INFO_HOST                (0x01)
#define MCF_USB_ADD_INFO_IRQ_NUM(x)          (((x)&0x1F)<<3)

/* Bit definitions and macros for MCF_USB_OTG_INT_STAT */
#define MCF_USB_OTG_INT_STAT_A_VBUS_VLD_CHG  (0x01)
#define MCF_USB_OTG_INT_STAT_B_SESS_END_CHG  (0x04)
#define MCF_USB_OTG_INT_STAT_SESS_VLD_CHG    (0x08)
#define MCF_USB_OTG_INT_STAT_LINE_STATE      (0x20)
#define MCF_USB_OTG_INT_STAT_1_MSEC          (0x40)
#define MCF_USB_OTG_INT_STAT_ID_CHG          (0x80)

/* Bit definitions and macros for MCF_USB_OTG_INT_EN */
#define MCF_USB_OTG_INT_EN_A_VBUS_VLD_EN     (0x01)
#define MCF_USB_OTG_INT_EN_B_SESS_END_EN     (0x04)
#define MCF_USB_OTG_INT_EN_SESS_VLD_EN       (0x08)
#define MCF_USB_OTG_INT_EN_LINE_STATE        (0x20)
#define MCF_USB_OTG_INT_EN_1_MSEC_EN         (0x40)
#define MCF_USB_OTG_INT_EN_ID_EN             (0x80)

/* Bit definitions and macros for MCF_USB_OTG_STATUS */
#define MCF_USB_OTG_STATUS_A_VBUS_VLD        (0x01)
#define MCF_USB_OTG_STATUS_B_SESS_END        (0x04)
#define MCF_USB_OTG_STATUS_SESS_VLD          (0x08)
#define MCF_USB_OTG_STATUS_LINE_STATE        (0x20)
#define MCF_USB_OTG_STATUS_1_MSEC            (0x40)
#define MCF_USB_OTG_STATUS_ID                (0x80)

/* Bit definitions and macros for MCF_USB_OTG_CTRL */
#define MCF_USB_OTG_CTRL_VBUS_DSCHG          (0x01)
#define MCF_USB_OTG_CTRL_VBUS_CHG            (0x02)
#define MCF_USB_OTG_CTRL_OTG_EN              (0x04)
#define MCF_USB_OTG_CTRL_VBUS_ON             (0x08)
#define MCF_USB_OTG_CTRL_DM_LOW              (0x10)
#define MCF_USB_OTG_CTRL_DP_LOW              (0x20)
#define MCF_USB_OTG_CTRL_DM_HIGH             (0x40)
#define MCF_USB_OTG_CTRL_DP_HIGH             (0x80)

/* Bit definitions and macros for MCF_USB_INT_STAT */
#define MCF_USB_INT_STAT_USB_RST             (0x01)
#define MCF_USB_INT_STAT_ERROR               (0x02)
#define MCF_USB_INT_STAT_SOF_TOK             (0x04)
#define MCF_USB_INT_STAT_TOK_DNE             (0x08)
#define MCF_USB_INT_STAT_SLEEP               (0x10)
#define MCF_USB_INT_STAT_RESUME              (0x20)
#define MCF_USB_INT_STAT_ATTACH              (0x40)
#define MCF_USB_INT_STAT_STALL               (0x80)

/* Bit definitions and macros for MCF_USB_INT_ENB */
#define MCF_USB_INT_ENB_USB_RST              (0x01)
#define MCF_USB_INT_ENB_ERROR                (0x02)
#define MCF_USB_INT_ENB_SOF_TOK              (0x04)
#define MCF_USB_INT_ENB_TOK_DNE              (0x08)
#define MCF_USB_INT_ENB_SLEEP                (0x10)
#define MCF_USB_INT_ENB_RESUME               (0x20)
#define MCF_USB_INT_ENB_ATTACH               (0x40)
#define MCF_USB_INT_ENB_STALL                (0x80)

/* Bit definitions and macros for MCF_USB_ERR_STAT */
#define MCF_USB_ERR_STAT_PID_ERR             (0x01)
#define MCF_USB_ERR_STAT_CRC5_EOF            (0x02)
#define MCF_USB_ERR_STAT_CRC16               (0x04)
#define MCF_USB_ERR_STAT_DFN8                (0x08)
#define MCF_USB_ERR_STAT_BTO_ERR             (0x10)
#define MCF_USB_ERR_STAT_DMA_ERR             (0x20)
#define MCF_USB_ERR_STAT_BTS_ERR             (0x80)

/* Bit definitions and macros for MCF_USB_ERR_ENB */
#define MCF_USB_ERR_ENB_PID_ERR              (0x01)
#define MCF_USB_ERR_ENB_CRC5_EOF             (0x02)
#define MCF_USB_ERR_ENB_CRC16                (0x04)
#define MCF_USB_ERR_ENB_DFN8                 (0x08)
#define MCF_USB_ERR_ENB_BTO_ERR              (0x10)
#define MCF_USB_ERR_ENB_DMA_ERR              (0x20)
#define MCF_USB_ERR_ENB_BTS_ERR              (0x80)

/* Bit definitions and macros for MCF_USB_STAT */
#define MCF_USB_STAT_ODD                     (0x04)
#define MCF_USB_STAT_TX                      (0x08)
#define MCF_USB_STAT_ENDP(x)                 (((x)&0x0F)<<4)

/* Bit definitions and macros for MCF_USB_CTL */
#define MCF_USB_CTL_USB_EN_SOF_EN            (0x01)
#define MCF_USB_CTL_ODD_RST                  (0x02)
#define MCF_USB_CTL_RESUME                   (0x04)
#define MCF_USB_CTL_HOST_MODE_EN             (0x08)
#define MCF_USB_CTL_RESET                    (0x10)
#define MCF_USB_CTL_TXDSUSPEND_TOKBUSY       (0x20)
#define MCF_USB_CTL_SE0                      (0x40)
#define MCF_USB_CTL_JSTATE                   (0x80)

/* Bit definitions and macros for MCF_USB_ADDR */
#define MCF_USB_ADDR_ADDR(x)                 (((x)&0x7F)<<0)
#define MCF_USB_ADDR_LS_EN                   (0x80)

/* Bit definitions and macros for MCF_USB_BDT_PAGE_01 */
#define MCF_USB_BDT_PAGE_01_BDT_BA9          (0x02)
#define MCF_USB_BDT_PAGE_01_BDT_BA10         (0x04)
#define MCF_USB_BDT_PAGE_01_BDT_BA11         (0x08)
#define MCF_USB_BDT_PAGE_01_BDT_BA12         (0x10)
#define MCF_USB_BDT_PAGE_01_BDT_BA13         (0x20)
#define MCF_USB_BDT_PAGE_01_BDT_BA14         (0x40)
#define MCF_USB_BDT_PAGE_01_BDT_BA15         (0x80)

/* Bit definitions and macros for MCF_USB_FRM_NUM */
#define MCF_USB_FRM_NUM_FRM(x)               (((x)&0xFFFF)<<0)

/* Bit definitions and macros for MCF_USB_FRM_NUML */
#define MCF_USB_FRM_NUML_FRM0                (0x01)
#define MCF_USB_FRM_NUML_FRM1                (0x02)
#define MCF_USB_FRM_NUML_FRM2                (0x04)
#define MCF_USB_FRM_NUML_FRM3                (0x08)
#define MCF_USB_FRM_NUML_FRM4                (0x10)
#define MCF_USB_FRM_NUML_FRM5                (0x20)
#define MCF_USB_FRM_NUML_FRM6                (0x40)
#define MCF_USB_FRM_NUML_FRM7                (0x80)

/* Bit definitions and macros for MCF_USB_FRM_NUMH */
#define MCF_USB_FRM_NUMH_FRM8                (0x01)
#define MCF_USB_FRM_NUMH_FRM9                (0x02)
#define MCF_USB_FRM_NUMH_FRM10               (0x04)
#define MCF_USB_FRM_NUMH_FRM11               (0x08)
#define MCF_USB_FRM_NUMH_FRM12               (0x10)
#define MCF_USB_FRM_NUMH_FRM13               (0x20)
#define MCF_USB_FRM_NUMH_FRM14               (0x40)
#define MCF_USB_FRM_NUMH_FRM15               (0x80)

/* Bit definitions and macros for MCF_USB_TOKEN */
#define MCF_USB_TOKEN_TOKEN_ENDPT(x)         (((x)&0x0F)<<0)
#define MCF_USB_TOKEN_TOKEN_PID(x)           (((x)&0x0F)<<4)

/* Bit definitions and macros for MCF_USB_SOF_THLDL */
#define MCF_USB_SOF_THLDL_CNT(x)             (((x)&0xFF)<<0)

/* Bit definitions and macros for MCF_USB_BDT_PAGE_02 */
#define MCF_USB_BDT_PAGE_02_BDT_BA16         (0x01)
#define MCF_USB_BDT_PAGE_02_BDT_BA17         (0x02)
#define MCF_USB_BDT_PAGE_02_BDT_BA18         (0x04)
#define MCF_USB_BDT_PAGE_02_BDT_BA19         (0x08)
#define MCF_USB_BDT_PAGE_02_BDT_BA20         (0x10)
#define MCF_USB_BDT_PAGE_02_BDT_BA21         (0x20)
#define MCF_USB_BDT_PAGE_02_BDT_BA22         (0x40)
#define MCF_USB_BDT_PAGE_02_BDT_BA23         (0x80)

/* Bit definitions and macros for MCF_USB_BDT_PAGE_03 */
#define MCF_USB_BDT_PAGE_03_BDT_BA24         (0x01)
#define MCF_USB_BDT_PAGE_03_BDT_BA25         (0x02)
#define MCF_USB_BDT_PAGE_03_BDT_BA26         (0x04)
#define MCF_USB_BDT_PAGE_03_BDT_BA27         (0x08)
#define MCF_USB_BDT_PAGE_03_BDT_BA28         (0x10)
#define MCF_USB_BDT_PAGE_03_BDT_BA29         (0x20)
#define MCF_USB_BDT_PAGE_03_BDT_BA30         (0x40)
#define MCF_USB_BDT_PAGE_03_BDT_BA31         (0x80)

/* Bit definitions and macros for MCF_USB_ENDPT0 */
#define MCF_USB_ENDPT0_EP_HSHK               (0x01)
#define MCF_USB_ENDPT0_EP_STALL              (0x02)
#define MCF_USB_ENDPT0_EP_EN_TX              (0x04)
#define MCF_USB_ENDPT0_EP_EN_RX              (0x08)
#define MCF_USB_ENDPT0_EP_CTL_DIS            (0x10)
#define MCF_USB_ENDPT0_RETRY_DIS             (0x40)
#define MCF_USB_ENDPT0_HOST_WO_HUB           (0x80)

/* Bit definitions and macros for MCF_USB_ENDPT1 */
#define MCF_USB_ENDPT1_EP_HSHK               (0x01)
#define MCF_USB_ENDPT1_EP_STALL              (0x02)
#define MCF_USB_ENDPT1_EP_EN_TX              (0x04)
#define MCF_USB_ENDPT1_EP_EN_RX              (0x08)
#define MCF_USB_ENDPT1_EP_CTL_DIS            (0x10)
#define MCF_USB_ENDPT1_RETRY_DIS             (0x40)
#define MCF_USB_ENDPT1_HOST_WO_HUB           (0x80)

/* Bit definitions and macros for MCF_USB_ENDPT2 */
#define MCF_USB_ENDPT2_EP_HSHK               (0x01)
#define MCF_USB_ENDPT2_EP_STALL              (0x02)
#define MCF_USB_ENDPT2_EP_EN_TX              (0x04)
#define MCF_USB_ENDPT2_EP_EN_RX              (0x08)
#define MCF_USB_ENDPT2_EP_CTL_DIS            (0x10)
#define MCF_USB_ENDPT2_RETRY_DIS             (0x40)
#define MCF_USB_ENDPT2_HOST_WO_HUB           (0x80)

/* Bit definitions and macros for MCF_USB_ENDPT3 */
#define MCF_USB_ENDPT3_EP_HSHK               (0x01)
#define MCF_USB_ENDPT3_EP_STALL              (0x02)
#define MCF_USB_ENDPT3_EP_EN_TX              (0x04)
#define MCF_USB_ENDPT3_EP_EN_RX              (0x08)
#define MCF_USB_ENDPT3_EP_CTL_DIS            (0x10)
#define MCF_USB_ENDPT3_RETRY_DIS             (0x40)
#define MCF_USB_ENDPT3_HOST_WO_HUB           (0x80)

/* Bit definitions and macros for MCF_USB_ENDPT4 */
#define MCF_USB_ENDPT4_EP_HSHK               (0x01)
#define MCF_USB_ENDPT4_EP_STALL              (0x02)
#define MCF_USB_ENDPT4_EP_EN_TX              (0x04)
#define MCF_USB_ENDPT4_EP_EN_RX              (0x08)
#define MCF_USB_ENDPT4_EP_CTL_DIS            (0x10)
#define MCF_USB_ENDPT4_RETRY_DIS             (0x40)
#define MCF_USB_ENDPT4_HOST_WO_HUB           (0x80)

/* Bit definitions and macros for MCF_USB_ENDPT5 */
#define MCF_USB_ENDPT5_EP_HSHK               (0x01)
#define MCF_USB_ENDPT5_EP_STALL              (0x02)
#define MCF_USB_ENDPT5_EP_EN_TX              (0x04)
#define MCF_USB_ENDPT5_EP_EN_RX              (0x08)
#define MCF_USB_ENDPT5_EP_CTL_DIS            (0x10)
#define MCF_USB_ENDPT5_RETRY_DIS             (0x40)
#define MCF_USB_ENDPT5_HOST_WO_HUB           (0x80)

/* Bit definitions and macros for MCF_USB_ENDPT6 */
#define MCF_USB_ENDPT6_EP_HSHK               (0x01)
#define MCF_USB_ENDPT6_EP_STALL              (0x02)
#define MCF_USB_ENDPT6_EP_EN_TX              (0x04)
#define MCF_USB_ENDPT6_EP_EN_RX              (0x08)
#define MCF_USB_ENDPT6_EP_CTL_DIS            (0x10)
#define MCF_USB_ENDPT6_RETRY_DIS             (0x40)
#define MCF_USB_ENDPT6_HOST_WO_HUB           (0x80)

/* Bit definitions and macros for MCF_USB_ENDPT7 */
#define MCF_USB_ENDPT7_EP_HSHK               (0x01)
#define MCF_USB_ENDPT7_EP_STALL              (0x02)
#define MCF_USB_ENDPT7_EP_EN_TX              (0x04)
#define MCF_USB_ENDPT7_EP_EN_RX              (0x08)
#define MCF_USB_ENDPT7_EP_CTL_DIS            (0x10)
#define MCF_USB_ENDPT7_RETRY_DIS             (0x40)
#define MCF_USB_ENDPT7_HOST_WO_HUB           (0x80)

/* Bit definitions and macros for MCF_USB_ENDPT8 */
#define MCF_USB_ENDPT8_EP_HSHK               (0x01)
#define MCF_USB_ENDPT8_EP_STALL              (0x02)
#define MCF_USB_ENDPT8_EP_EN_TX              (0x04)
#define MCF_USB_ENDPT8_EP_EN_RX              (0x08)
#define MCF_USB_ENDPT8_EP_CTL_DIS            (0x10)
#define MCF_USB_ENDPT8_RETRY_DIS             (0x40)
#define MCF_USB_ENDPT8_HOST_WO_HUB           (0x80)

/* Bit definitions and macros for MCF_USB_ENDPT9 */
#define MCF_USB_ENDPT9_EP_HSHK               (0x01)
#define MCF_USB_ENDPT9_EP_STALL              (0x02)
#define MCF_USB_ENDPT9_EP_EN_TX              (0x04)
#define MCF_USB_ENDPT9_EP_EN_RX              (0x08)
#define MCF_USB_ENDPT9_EP_CTL_DIS            (0x10)
#define MCF_USB_ENDPT9_RETRY_DIS             (0x40)
#define MCF_USB_ENDPT9_HOST_WO_HUB           (0x80)

/* Bit definitions and macros for MCF_USB_ENDPT10 */
#define MCF_USB_ENDPT10_EP_HSHK              (0x01)
#define MCF_USB_ENDPT10_EP_STALL             (0x02)
#define MCF_USB_ENDPT10_EP_EN_TX             (0x04)
#define MCF_USB_ENDPT10_EP_EN_RX             (0x08)
#define MCF_USB_ENDPT10_EP_CTL_DIS           (0x10)
#define MCF_USB_ENDPT10_RETRY_DIS            (0x40)
#define MCF_USB_ENDPT10_HOST_WO_HUB          (0x80)

/* Bit definitions and macros for MCF_USB_ENDPT11 */
#define MCF_USB_ENDPT11_EP_HSHK              (0x01)
#define MCF_USB_ENDPT11_EP_STALL             (0x02)
#define MCF_USB_ENDPT11_EP_EN_TX             (0x04)
#define MCF_USB_ENDPT11_EP_EN_RX             (0x08)
#define MCF_USB_ENDPT11_EP_CTL_DIS           (0x10)
#define MCF_USB_ENDPT11_RETRY_DIS            (0x40)
#define MCF_USB_ENDPT11_HOST_WO_HUB          (0x80)

/* Bit definitions and macros for MCF_USB_ENDPT12 */
#define MCF_USB_ENDPT12_EP_HSHK              (0x01)
#define MCF_USB_ENDPT12_EP_STALL             (0x02)
#define MCF_USB_ENDPT12_EP_EN_TX             (0x04)
#define MCF_USB_ENDPT12_EP_EN_RX             (0x08)
#define MCF_USB_ENDPT12_EP_CTL_DIS           (0x10)
#define MCF_USB_ENDPT12_RETRY_DIS            (0x40)
#define MCF_USB_ENDPT12_HOST_WO_HUB          (0x80)

/* Bit definitions and macros for MCF_USB_ENDPT13 */
#define MCF_USB_ENDPT13_EP_HSHK              (0x01)
#define MCF_USB_ENDPT13_EP_STALL             (0x02)
#define MCF_USB_ENDPT13_EP_EN_TX             (0x04)
#define MCF_USB_ENDPT13_EP_EN_RX             (0x08)
#define MCF_USB_ENDPT13_EP_CTL_DIS           (0x10)
#define MCF_USB_ENDPT13_RETRY_DIS            (0x40)
#define MCF_USB_ENDPT13_HOST_WO_HUB          (0x80)

/* Bit definitions and macros for MCF_USB_ENDPT14 */
#define MCF_USB_ENDPT14_EP_HSHK              (0x01)
#define MCF_USB_ENDPT14_EP_STALL             (0x02)
#define MCF_USB_ENDPT14_EP_EN_TX             (0x04)
#define MCF_USB_ENDPT14_EP_EN_RX             (0x08)
#define MCF_USB_ENDPT14_EP_CTL_DIS           (0x10)
#define MCF_USB_ENDPT14_RETRY_DIS            (0x40)
#define MCF_USB_ENDPT14_HOST_WO_HUB          (0x80)

/* Bit definitions and macros for MCF_USB_ENDPT15 */
#define MCF_USB_ENDPT15_EP_HSHK              (0x01)
#define MCF_USB_ENDPT15_EP_STALL             (0x02)
#define MCF_USB_ENDPT15_EP_EN_TX             (0x04)
#define MCF_USB_ENDPT15_EP_EN_RX             (0x08)
#define MCF_USB_ENDPT15_EP_CTL_DIS           (0x10)
#define MCF_USB_ENDPT15_RETRY_DIS            (0x40)
#define MCF_USB_ENDPT15_HOST_WO_HUB          (0x80)

/* Bit definitions and macros for MCF_USB_USB_CTRL */
#define MCF_USB_USB_CTRL_SUSP                (1<<7)
#define MCF_USB_USB_CTRL_PDE                 (1<<6)
#define MCF_USB_USB_CTRL_CLKSRC_ALT          (0<<0)
//#define MCF_USB_USB_CTRL_CLKSRC_OSC          (1<<0)
#define MCF_USB_USB_CTRL_CLKSRC_SYS          (3<<0)



/*********************************************************************
*
* I2C Module (I2C)
*
*********************************************************************/

/* Register read/write macros */
#define MCF_I2C_I2AR          (*(hcc_reg8 *)(&_IPSBAR[0x001838]))
#define MCF_I2C_I2FDR         (*(hcc_reg8 *)(&_IPSBAR[0x001839]))
#define MCF_I2C_I2CR          (*(hcc_reg8 *)(&_IPSBAR[0x00183A]))
#define MCF_I2C_I2SR          (*(hcc_reg8 *)(&_IPSBAR[0x00183B]))
#define MCF_I2C_I2DR          (*(hcc_reg8 *)(&_IPSBAR[0x00183C]))
#define MCF_I2C_I2CR2         (*(hcc_reg8 *)(&_IPSBAR[0x00183D]))

/* Bit definitions and macros for MCF_I2C_I2AR */
#define MCF_I2C_I2AR_ADR(x)   (((x)&0x7F)<<1)

/* Bit definitions and macros for MCF_I2C_I2FDR */
#define MCF_I2C_I2FDR_IC(x)   (((x)&0x3F)<<0)

/* Bit definitions and macros for MCF_I2C_I2CR */
#define MCF_I2C_I2CR_RSTA     (0x04)
#define MCF_I2C_I2CR_TXAK     (0x08)
#define MCF_I2C_I2CR_MTX      (0x10)
#define MCF_I2C_I2CR_MSTA     (0x20)
#define MCF_I2C_I2CR_IIEN     (0x40)
#define MCF_I2C_I2CR_IEN      (0x80)

/* Bit definitions and macros for MCF_I2C_I2SR */
#define MCF_I2C_I2SR_RXAK     (0x01)
#define MCF_I2C_I2SR_IIF      (0x02)
#define MCF_I2C_I2SR_SRW      (0x04)
#define MCF_I2C_I2SR_IAL      (0x10)
#define MCF_I2C_I2SR_IBB      (0x20)
#define MCF_I2C_I2SR_IAAS     (0x40)
#define MCF_I2C_I2SR_ICF      (0x80)

/* Bit definitions and macros for MCF_I2C_I2DR */
#define MCF_I2C_I2DR_DATA(x)  (((x)&0xFF)<<0)


/*---------- William ------------------------------------------*/
/* SCI1 */
#define MCF_SCI1BDH_REG                (*(hcc_reg8*)(&_IPSBAR[0x38]))
#define MCF_SCI1BDL_REG                (*(hcc_reg8*)(&_IPSBAR[0x39]))
#define MCF_SCI1C1_REG                (*(hcc_reg8*)(&_IPSBAR[0x3A]))
#define MCF_SCI1C2_REG                (*(hcc_reg8*)(&_IPSBAR[0x3B]))
#define MCF_SCI1S1_REG                (*(hcc_reg8*)(&_IPSBAR[0x3C]))
#define MCF_SCI1S2_REG                (*(hcc_reg8*)(&_IPSBAR[0x3D]))
#define MCF_SCI1C3_REG                (*(hcc_reg8*)(&_IPSBAR[0x3E]))
#define MCF_SCI1D_REG                  (*(hcc_reg8*)(&_IPSBAR[0x3F]))
#define MCF_SCI1BD_REG    (*(hcc_reg16*)(&_IPSBAR[0x38]))


/* SCI2 */
#define MCF_SCI2BDH_REG                (*(hcc_reg8*)(&_IPSBAR[0x40]))
#define MCF_SCI2BDL_REG                (*(hcc_reg8*)(&_IPSBAR[0x41]))
#define MCF_SCI2C1_REG                (*(hcc_reg8*)(&_IPSBAR[0x42]))
#define MCF_SCI2C2_REG                (*(hcc_reg8*)(&_IPSBAR[0x43]))
#define MCF_SCI2S1_REG                (*(hcc_reg8*)(&_IPSBAR[0x44]))
#define MCF_SCI2S2_REG                (*(hcc_reg8*)(&_IPSBAR[0x45]))
#define MCF_SCI2C3_REG                (*(hcc_reg8*)(&_IPSBAR[0x46]))
#define MCF_SCI2D_REG                  (*(hcc_reg8*)(&_IPSBAR[0x47]))
#define MCF_SCI2BD_REG    (*(hcc_reg16*)(&_IPSBAR[0x40]))


#define MCF_SCIBDH_REG(portno) (*(hcc_reg8*)(&_IPSBAR[0x38+(portno*8)]))
#define MCF_SCIBDL_REG(portno) (*(hcc_reg8*)(&_IPSBAR[0x39+(portno*8)]))
#define MCF_SCIC1_REG(portno)  (*(hcc_reg8*)(&_IPSBAR[0x3A+(portno*8)]))
#define MCF_SCIC2_REG(portno)  (*(hcc_reg8*)(&_IPSBAR[0x3B+(portno*8)]))
#define MCF_SCIS1_REG(portno)         (*(hcc_reg8*)(&_IPSBAR[0x3C+(portno*8)]))
#define MCF_SCIS2_REG(portno)         (*(hcc_reg8*)(&_IPSBAR[0x3D+(portno*8)]))
#define MCF_SCIC3_REG(portno)  (*(hcc_reg8*)(&_IPSBAR[0x3E+(portno*8)]))
#define MCF_SCID_REG(portno)         (*(hcc_reg8*)(&_IPSBAR[0x3F+(portno*8)]))
#define MCF_SCIBD_REG(portno)  (*(hcc_reg16*)(&_IPSBAR[0x38+(portno*8)]))
#define SCI_NO 0
#if  (SCI_NO==0)
#define MCF_SCIBDH              MCF_SCI1BDH_REG
#define MCF_SCIBDL              MCF_SCI1BDL_REG
#define MCF_SCIC1               MCF_SCI1C1_REG
#define MCF_SCIC2               MCF_SCI1C2_REG
#define MCF_SCIS1               MCF_SCI1S1_REG
#define MCF_SCIS2               MCF_SCI1S2_REG
#define MCF_SCID                MCF_SCI1D_REG
#define MCF_SCIBD               MCF_SCI1BD_REG
#else
#define MCF_SCIBDH              MCF_SCI2BDH_REG
#define MCF_SCIBDL              MCF_SCI2BDL_REG
#define MCF_SCIC1               MCF_SCI2C1_REG
#define MCF_SCIC2               MCF_SCI2C2_REG
#define MCF_SCIS1               MCF_SCI2S1_REG
#define MCF_SCIS2               MCF_SCI2S2_REG
#define MCF_SCID                MCF_SCI2D_REG
#define MCF_SCIBD               MCF_SCI2BD_REG
#endif

/* Bit definition for SCIBDH register */
#define MCF_SCIBDH_REG_LBKDIE_BIT   (1<<7)
#define MCF_SCIBDH_REG_RXEDGIE_BIT  (1<<6)

/* Bit definition for SCIC1 register */
#define MCF_SCIC1_REG_LOOPS_BIT     (1<<7)
#define MCF_SCIC1_REG_SCISWAI_BIT   (1<<6)
#define MCF_SCIC1_REG_RSRC_BIT      (1<<5)
#define MCF_SCIC1_REG_M_BIT         (1<<4)
#define MCF_SCIC1_REG_WAKE_BIT      (1<<3)
#define MCF_SCIC1_REG_ILT_BIT       (1<<2)
#define MCF_SCIC1_REG_PE_BIT        (1<<1)
#define MCF_SCIC1_REG_PT_BIT        (1<<0)

/* Bit definition for SCIC2 register */
#define MCF_SCIC2_REG_TIE_BIT       (1<<7)
#define MCF_SCIC2_REG_TCIE_BIT      (1<<6)
#define MCF_SCIC2_REG_RIE_BIT       (1<<5)
#define MCF_SCIC2_REG_ILIE_BIT      (1<<4)
#define MCF_SCIC2_REG_TE_BIT        (1<<3)
#define MCF_SCIC2_REG_RE_BIT        (1<<2)
#define MCF_SCIC2_REG_RWU_BIT       (1<<1)
#define MCF_SCIC2_REG_SBK_BIT       (1<<0)

/* Bit definition for SCIC3 register */
#define MCF_SCIC3_REG_R8_BIT        (1<<7)
#define MCF_SCIC3_REG_T8_BIT        (1<<6)
#define MCF_SCIC3_REG_TXDIR_BIT     (1<<5)
#define MCF_SCIC3_REG_TXINV_BIT     (1<<4)
#define MCF_SCIC3_REG_ORIE_BIT      (1<<3)
#define MCF_SCIC3_REG_NEIE_BIT      (1<<2)
#define MCF_SCIC3_REG_FEIE_BIT      (1<<1)
#define MCF_SCIC3_REG_PEIE_BIT      (1<<0)


/* Bit definition for SCIS1 register */
#define MCF_SCIS1_REG_TDRE_BIT      (1<<7)
#define MCF_SCIS1_REG_TC_BIT        (1<<6)
#define MCF_SCIS1_REG_RDRF_BIT      (1<<5)
#define MCF_SCIS1_REG_IDLE_BIT      (1<<4)
#define MCF_SCIS1_REG_OR_BIT        (1<<3)
#define MCF_SCIS1_REG_NF_BIT        (1<<2)
#define MCF_SCIS1_REG_FE_BIT        (1<<1)
#define MCF_SCIS1_REG_PE_BIT        (1<<0)


/* Bit definition for SCIS2 register */
#define MCF_SCIS2_REG_LBKDIF_BIT    (1<<7)
#define MCF_SCIS2_REG_RXEDGIF_BIT   (1<<6)
#define MCF_SCIS2_REG_RXINV_BIT     (1<<4)
#define MCF_SCIS2_REG_RWUID_BIT     (1<<3)
#define MCF_SCIS2_REG_BRK13_BIT     (1<<2)
#define MCF_SCIS2_REG_LBKDE_BIT     (1<<1)
#define MCF_SCIS2_REG_RAF_BIT       (1<<0)


/* MCG */
#define MCF_MCGC1_REG     (*(hcc_reg8*)(&_IPSBAR[0x48]))
#define MCF_MCGC2_REG     (*(hcc_reg8*)(&_IPSBAR[0x49]))
#define MCF_MCGTRM_REG     (*(hcc_reg8*)(&_IPSBAR[0x4A]))
#define MCF_MCGSC_REG     (*(hcc_reg8*)(&_IPSBAR[0x4B]))
#define MCF_MCGC3_REG     (*(hcc_reg8*)(&_IPSBAR[0x4C]))
#define MCF_MCGT_REG     (*(hcc_reg8*)(&_IPSBAR[0x4D]))

/* Bit defintions for MCGC1 register */
#define MCF_MCGC1_REG_CLKS_BIT    (3<<6)
#define MCF_MCGC1_REG_RDIV_BIT    (7<<3)
#define MCF_MCGC1_REG_IREFS_BIT   (1<<2)
#define MCF_MCGC1_REG_IRCLKEN_BIT (1<<1)
#define MCF_MCGC1_REG_IREFSTEN_BIT    (1)


/* Bit defintions for MCGC2 register */
#define MCF_MCGC2_REG_BDIV_BIT    (2<<6)
#define MCF_MCGC2_REG_RANGE_BIT   (1<<5)
#define MCF_MCGC2_REG_HGO_BIT     (1<<4)
#define MCF_MCGC2_REG_LP_BIT      (1<<3)
#define MCF_MCGC2_REG_EREFS_BIT   (1<<2)
#define MCF_MCGC2_REG_ERCLKEN_BIT (1<<1)
#define MCF_MCGC2_REG_EREFSTEN_BIT    (1)


/* Bit defintions for MCGC3 register */
#define MCF_MCGC3_REG_LOLIE_BIT   (1<<7)
#define MCF_MCGC3_REG_PLLS_BIT    (1<<6)
#define MCF_MCGC3_REG_CME_BIT     (1<<5)
#define MCF_MCGC3_REG_DIV32_BIT   (1<<4)
#define MCF_MCGC3_REG_VDIV_BIT    (1)


/* Bit defintions for MCGSC register */
#define MCF_MCGSC_REG_LOLS_BIT    (1<<7)
#define MCF_MCGSC_REG_LOCK_BIT    (1<<6)
#define MCF_MCGSC_REG_PLLST_BIT   (1<<5)
#define MCF_MCGSC_REG_IREFST_BIT  (1<<4)
#define MCF_MCGSC_REG_CLKST_BIT   (3<<2)
#define MCF_MCGSC_REG_OSCINIT_BIT (1<<1)
#define MCF_MCGSC_REG_FTRIM_BIT   (1)


/* Real Time Clock */
#define MCF_RTCSC_REG                  (*(hcc_reg8*)(&_IPSBAR[0x6C]))
#define MCF_RTCCNT_REG                (*(hcc_reg8*)(&_IPSBAR[0x6D]))
#define MCF_RTCMOD_REG                (*(hcc_reg8*)(&_IPSBAR[0x6E]))

/* Bit definitions for RTC */
#define MCF_RTCSC_REG_RTIE_BIT  (1<<4)
#define MCF_RTCSC_REG_RTIF_BIT  (1<<7)

/* Bit values for RTC */
#define MCF_RTC_SOURCE_LPO   0
#define MCF_RTC_SOURCE_EXT   1
#define MCF_RTC_SOURCE_INT   2


/* Timer/PWM */
#define MCF_TPM1SC_REG        (*(hcc_reg8*)(&_IPSBAR[0x20]))
#define MCF_TPM1CNTH_REG      (*(hcc_reg8*)(&_IPSBAR[0x21]))
#define MCF_TPM1CNTL_REG      (*(hcc_reg8*)(&_IPSBAR[0x22]))
#define MCF_TPM1MODH_REG      (*(hcc_reg8*)(&_IPSBAR[0x23]))
#define MCF_TPM1MODL_REG      (*(hcc_reg8*)(&_IPSBAR[0x24]))
#define MCF_TPM1C0SC_REG      (*(hcc_reg8*)(&_IPSBAR[0x25]))
#define MCF_TPM1C0VH_REG      (*(hcc_reg8*)(&_IPSBAR[0x26]))
#define MCF_TPM1C0VL_REG      (*(hcc_reg8*)(&_IPSBAR[0x27]))
#define MCF_TPM1C1SC_REG      (*(hcc_reg8*)(&_IPSBAR[0x28]))
#define MCF_TPM1C1VH_REG      (*(hcc_reg8*)(&_IPSBAR[0x29]))
#define MCF_TPM1C1VL_REG      (*(hcc_reg8*)(&_IPSBAR[0x2A]))
#define MCF_TPM1C2SC_REG      (*(hcc_reg8*)(&_IPSBAR[0x2B]))
#define MCF_TPM1C2VH_REG      (*(hcc_reg8*)(&_IPSBAR[0x2C]))
#define MCF_TPM1C2VL_REG      (*(hcc_reg8*)(&_IPSBAR[0x2D]))
#define MCF_TPM1C3SC_REG      (*(hcc_reg8*)(&_IPSBAR[0x2E]))
#define MCF_TPM1C3VH_REG      (*(hcc_reg8*)(&_IPSBAR[0x2F]))
#define MCF_TPM1C3VL_REG      (*(hcc_reg8*)(&_IPSBAR[0x30]))

/* Timer/PWM word type registers */
#define MCF_TPM1CNT_REG      (*(hcc_reg16*)(&_IPSBAR[0x21]))  /* this may be problem because it is not aligned to word boundary.*/
#define MCF_TPM1MOD_REG      (*(hcc_reg16*)(&_IPSBAR[0x23]))  /* same boundary issue as above */
#define MCF_TPM1C0V_REG      (*(hcc_reg16*)(&_IPSBAR[0x26]))
#define MCF_TPM1C1V_REG      (*(hcc_reg16*)(&_IPSBAR[0x29]))
#define MCF_TPM1C2V_REG      (*(hcc_reg16*)(&_IPSBAR[0x2C]))
#define MCF_TPM1C3V_REG      (*(hcc_reg16*)(&_IPSBAR[0x2F]))

#define MCF_TPMxSC_REG        MCF_TPM1SC_REG
#define MCF_TPMxCNT_REG       MCF_TPM1CNT_REG
#define MCF_TPMxMOD_REG       MCF_TPM1MOD_REG
#define MCF_TPMxMODH_REG      MCF_TPM1MODH_REG
#define MCF_TPMxMODL_REG      MCF_TPM1MODL_REG
#define MCF_TPMxCnSC_REG      MCF_TPM1C0SC_REG
#define MCF_TPMxCnV_REG       MCF_TPM1C0V_REG


/* Bit/Bit mask definitions for TPMxSC register */
#define MCF_TPMSC_REG_TOF_BIT   (1<<7)
#define MCF_TPMSC_REG_TOIE_BIT  (1<<6)
#define MCF_TPMSC_REG_CPWMS_BIT (1<<5)
#define MCF_TPMSC_REG_CLKS_BIT  (3<<3)
#define MCF_TPMSC_REG_CLKS_BIT_POS  (3)
#define MCF_TPMSC_REG_PS_BIT    (7)

/* TPM Prescaler */
#define MCF_TPM_CLK_PRESCALOR_1   0
#define MCF_TPM_CLK_PRESCALOR_2   1
#define MCF_TPM_CLK_PRESCALOR_4   2
#define MCF_TPM_CLK_PRESCALOR_8   3
#define MCF_TPM_CLK_PRESCALOR_16  4
#define MCF_TPM_CLK_PRESCALOR_32  5
#define MCF_TPM_CLK_PRESCALOR_64  6
#define MCF_TPM_CLK_PRESCALOR_128 7


/* Bit/Bit mask definitions for TPMxCnSC register */
#define MCF_TPMCnSC_REG_CHnF_BIT   (1<<7)
#define MCF_TPMCnSC_REG_CHnIE_BIT  (1<<6)
#define MCF_TPMCnSC_REG_MSnBA_BIT_POS 4
#define MCF_TPMCnSC_REG_MSnBA_BIT  (3<<MCF_TPMCnSC_REG_MSnBA_BIT_POS)
#define MCF_TPMCnSC_REG_ELSn_BIT_POS  2
#define MCF_TPMCnSC_REG_ELSn_BIT   (2<<MCF_TPMCnSC_REG_ELSn_BIT_POS)

/* Mode, edge and level selection */
#define MCF_TPM_MODE_INPUT_CAPTURE  0    /* CPWMS = 0 in TPMSC register */
#define MCF_TPM_MODE_OUTPUT_COMPARE (1 << MCF_TPMCnSC_REG_MSnBA_BIT_POS)    /* CPWMS = 0 in TPMSC register */
#define MCF_TPM_MODE_PWM_EDGE       (2 << MCF_TPMCnSC_REG_MSnBA_BIT_POS)    /* CPWMS = 0 in TPMSC register */
#define MCF_TPM_MODE_PWM_CENTER     MCF_TPMSC_REG_CPWMS_BIT    /* CPWMS = 1 in TPMSC register */

#define MCF_TPM_EDGE_RISING         (1 << MCF_TPMCnSC_REG_ELSn_BIT_POS)
#define MCF_TPM_EDGE_FALLING        (2 << MCF_TPMCnSC_REG_ELSn_BIT_POS)
#define MCF_TPM_EDGE_BOTH           (3 << MCF_TPMCnSC_REG_ELSn_BIT_POS)

#define MCF_TPM_OUTPUT_SW           0
#define MCF_TPM_OUTPUT_TOGGLE       (1 << MCF_TPMCnSC_REG_ELSn_BIT_POS)
#define MCF_TPM_OUTPUT_CLEAR        (2 << MCF_TPMCnSC_REG_ELSn_BIT_POS)
#define MCF_TPM_OUTPUT_SET          (3 << MCF_TPMCnSC_REG_ELSn_BIT_POS)

#define MCF_TPM_PWM_OUTPUT_HIGH       MCF_TPM_OUTPUT_CLEAR
#define MCF_TPM_PWM_OUTPUT_LOW        MCF_TPM_OUTPUT_SET

/* Input capture macros */
#define MCF_TPM_MODE_INPUT_CAPTURE_RISING_EDGE  ( MCF_TPM_MODE_INPUT_CAPTURE |  MCF_TPM_EDGE_RISING)
#define MCF_TPM_MODE_INPUT_CAPTURE_FALLING_EDGE  ( MCF_TPM_MODE_INPUT_CAPTURE |  MCF_TPM_EDGE_FALLING)
#define MCF_TPM_MODE_INPUT_CAPTURE_BOTH_EDGE  ( MCF_TPM_MODE_INPUT_CAPTURE |  MCF_TPM_EDGE_BOTH)

/* Output compare macros */
#define MCF_TPM_MODE_OUTPUT_COMPARE_SW        (MCF_TPM_MODE_OUTPUT_COMPARE |  MCF_TPM_OUTPUT_SW)
#define MCF_TPM_MODE_OUTPUT_COMPARE_TOGGLE    (MCF_TPM_MODE_OUTPUT_COMPARE |  MCF_TPM_OUTPUT_TOGGLE)
#define MCF_TPM_MODE_OUTPUT_COMPARE_CLEAR     (MCF_TPM_MODE_OUTPUT_COMPARE |  MCF_TPM_OUTPUT_CLEAR)
#define MCF_TPM_MODE_OUTPUT_COMPARE_SET       (MCF_TPM_MODE_OUTPUT_COMPARE |  MCF_TPM_OUTPUT_SET)

/* Clock source selection */
#define MCF_TPM_CLK_SRC_NO          0
#define MCF_TPM_CLK_SRC_BUS_CLK     (1<<MCF_TPMSC_REG_CLKS_BIT_POS)
#define MCF_TPM_CLK_SRC_FIX_CLK     (2<<MCF_TPMSC_REG_CLKS_BIT_POS)
#define MCF_TPM_CLK_SRC_EXT_CLK     (3<<MCF_TPMSC_REG_CLKS_BIT_POS)

/* Port D register definitions */
#define  MCF_PTDD_REG         (*(hcc_reg8*)(&_IPSBAR[0x6]))
#define  MCF_PTDDD_REG        (*(hcc_reg8*)(&_IPSBAR[0x7]))
#define   MCF_PTDPE_REG        (*(hcc_reg8*)(&_IPSBAR[0x184C]))
#define   MCF_PTDSE_REG        (*(hcc_reg8*)(&_IPSBAR[0x184D]))
#define   MCF_PTDDS_REG        (*(hcc_reg8*)(&_IPSBAR[0x184E]))
#define   MCF_PTDIFE_REG       (*(hcc_reg8*)(&_IPSBAR[0x184F]))


/* System Integration Module (Refer to Chapter 5 of Soc Guide) */
#define MCF_SIMOPT1_REG       (*(hcc_reg8*)(&_IPSBAR[0x1802]))
#define MCF_SIMOPT2_REG       (*(hcc_reg8*)(&_IPSBAR[0x1803]))

#define MCF_SIMOPT1_REG_COPT_BIT  (3<<6)


/* Flash */
#define MCF_FCDIV_REG       (*(hcc_reg8*)(&_IPSBAR[0x1820]))
#define MCF_FOPT_REG        (*(hcc_reg8*)(&_IPSBAR[0x1821]))
#define MCF_FRSV0_REG       (*(hcc_reg8*)(&_IPSBAR[0x1822]))
#define MCF_FCNFG_REG       (*(hcc_reg8*)(&_IPSBAR[0x1823]))
#define MCF_FPROT_REG       (*(hcc_reg8*)(&_IPSBAR[0x1824]))
#define MCF_FSTAT_REG       (*(hcc_reg8*)(&_IPSBAR[0x1825]))
#define MCF_FCMD_REG        (*(hcc_reg8*)(&_IPSBAR[0x1826]))
#define MCF_FRSV1_REG       (*(hcc_reg8*)(&_IPSBAR[0x1827]))
#define MCF_FADDRHI_REG     (*(hcc_reg8*)(&_IPSBAR[0x1828]))
#define MCF_FADDRLO_REG     (*(hcc_reg8*)(&_IPSBAR[0x1829]))
#define MCF_FRSV2_REG       (*(hcc_reg8*)(&_IPSBAR[0x182A]))
#define MCF_FRSV3_REG       (*(hcc_reg8*)(&_IPSBAR[0x182B]))
#define MCF_FDATAHI1_REG    (*(hcc_reg8*)(&_IPSBAR[0x182C]))
#define MCF_FDATALO1_REG       (*(hcc_reg8*)(&_IPSBAR[0x182D]))
#define MCF_FDATAHI0_REG       (*(hcc_reg8*)(&_IPSBAR[0x182E]))
#define MCF_FDATALO0_REG       (*(hcc_reg8*)(&_IPSBAR[0x182F]))




/* Interrupt No. */
#define VectorNumber_VRTC     VectorNumber_Vrtc //29
#define VectorNumber_TPM1Ovf    VectorNumber_Vtpm1ovf
#define VectorNumber_TPM1CH0F    VectorNumber_Vtpm1ch0

#define VectorNumber_TICK1ms  VectorNumber_TPM1CH0F //VectorNumber_TPM1

#endif
/****************************** END OF FILE **********************************/


