%-Driver generated by the Component Wizard
%-
%- WARNING !
%-
%- Do not make changes to these lines (if you make some changes, you damage this driver)
%- which begins with:
%-
%-  %-STARTUSERTYPES
%-  %-ENDUSRTYPES
%-  /* END %ModuleName. */
%-  /* MODULE %ModuleName. */
%-  %-INTERNAL_METHOD_BEG
%-  %-INTERNAL_METHOD_END
%-  %-INHERITED_EVENT_BEGIN
%-  %-INHERITED_EVENT_END
%-  %-BW_METHOD_BEGIN
%-  %-BW_METHOD_END
%-  %-BW_DEFINITION_START
%-  %-BW_DEFINITION_END
%-  %-BW_IMPLEMENT_START
%-  %-BW_IMPLEMENT_END
%-  %-BW_EVENT_DEFINITION_START
%-  %-BW_EVENT_DEFINITION_END
%-  %-BW_EVENT_IMPLEMENT_START
%-  %-BW_EVENT_IMPLEMENT_END
%-  %-BW_METHOD_MACROS_START
%-  %-BW_METHOD_MACROS_END
%-  %-BW_SECTIONS_INSERT
%-  %-BW_INTERN_COMMENTS_START
%-  %-BW_INTERN_COMMENTS_END
%-  %-BW_BEAN_CONSTANTS_START
%-  %-BW_BEAN_CONSTANTS_END
%-
%-
%- These lines are not comments, but they are necessary for Component Wizard
%- If you change these lines, Component Wizard will not be responsible for loosing or damaging your code!
%-
%-
%- readyCPU ...
%- readyDEVICE ...
%-
%define DriverAuthor  Author
%define DriverVersion 01.00
%define DriverDate    30.09.2010
%-
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END
%-
%-BW_INTERN_COMMENTS_START
%- List of descriptions of internal methods
%define! Description_printfPutChar Helper routine for printf
%define! Description_SendSeparatedStrings Prints a string using an I/O function, formated for the 'help' command
%-BW_INTERN_COMMENTS_END
%-
%-BW_SECTIONS_INSERT
%if Language='ANSIC'
%-
%-
%INTERFACE
%define! Settings Common\ShellSettings.Inc
%define! Abstract Common\ShellAbstract.Inc
%include Common\Header.h

%if (CPUfamily = "Kinetis")
%if (defined(PEversionDecimal) && (PEversionDecimal <=0 '1283'))
%- MCU10.3 is 1283
#include "PE_LDD.h" /* hack for Processor Expert (e.g. in MCU10.3) and LDD: PE_LDD.h includes at the end all shared modules, causing a recursive header file include conflict */
/* PE version is %PEversionDecimal */
%endif
%endif

#ifndef __%'ModuleName'_H
#define __%'ModuleName'_H

/* MODULE %ModuleName. */
#include "%@sdk@ModuleName.h" /* SDK and API used */
#include "%'ModuleName'config.h" /* configuration */
#include <stdint.h>
#include <stdbool.h>

%-STARTUSERTYPES - Do not make changes between lines (included this lines) marked with %-STARTUSERTYPES and %-ENDUSRTYPES

#ifndef __BWUserType_%'ModuleName'_StdIO_OutErr_FctType
#define __BWUserType_%'ModuleName'_StdIO_OutErr_FctType
  typedef void (*%'ModuleName'%.StdIO_OutErr_FctType)(uint8_t);  %>40/* Callback for an output or error I/O function */
#endif
#ifndef __BWUserType_%'ModuleName'_StdIO_In_FctType
#define __BWUserType_%'ModuleName'_StdIO_In_FctType
  typedef void (*%'ModuleName'%.StdIO_In_FctType)(uint8_t *);    %>40/* Callback for an I/O input function. */
#endif
#ifndef __BWUserType_%'ModuleName'_StdIO_KeyPressed_FctType
#define __BWUserType_%'ModuleName'_StdIO_KeyPressed_FctType
  typedef bool (*%'ModuleName'%.StdIO_KeyPressed_FctType)(void); %>40/* Callback which returns true if a key has been pressed */
#endif
#ifndef __BWUserType_%'ModuleName'_StdIOType
#define __BWUserType_%'ModuleName'_StdIOType
  typedef struct {                                               %>40/* Record containing input, output and error callback (stdin, stdout, stderr). */
    %'ModuleName'_StdIO_In_FctType stdIn;                        %>40/* standard input */
    %'ModuleName'_StdIO_OutErr_FctType stdOut;                   %>40/* standard output */
    %'ModuleName'_StdIO_OutErr_FctType stdErr;                   %>40/* standard error */
    %'ModuleName'_StdIO_KeyPressed_FctType keyPressed;           %>40/* key pressed callback */
  #if %'ModuleName'%.CONFIG_ECHO_ENABLED
    bool echoEnabled;                                            %>40/* true if I/O shall echo characters */
  #endif
  } %'ModuleName'_StdIOType;
#endif
#ifndef __BWUserType_%'ModuleName'_ConstStdIOType
#define __BWUserType_%'ModuleName'_ConstStdIOType
  typedef const %'ModuleName'%.StdIOType %'ModuleName'%.ConstStdIOType;%>40/* constant StdIOType */
#endif
#ifndef __BWUserType_%'ModuleName'_ParseCommandCallback
#define __BWUserType_%'ModuleName'_ParseCommandCallback
  typedef uint8_t (*%'ModuleName'%.ParseCommandCallback)(const uint8_t *cmd, bool *handled, const %'ModuleName'%.StdIOType *io);%>40/* Callback for parsing a shell command */
#endif
#ifndef __BWUserType_%'ModuleName'_ConstStdIOTypePtr
#define __BWUserType_%'ModuleName'_ConstStdIOTypePtr
  typedef const %'ModuleName'%.ConstStdIOType *%'ModuleName'%.ConstStdIOTypePtr;%>40/* Pointer to constant standard I/O descriptor */
#endif
#ifndef __BWUserType_%'ModuleName'_ConstParseCommandCallback
#define __BWUserType_%'ModuleName'_ConstParseCommandCallback
  typedef const %'ModuleName'%.ParseCommandCallback %'ModuleName'%.ConstParseCommandCallback;%>40/* Callback for parsing a shell command */
#endif

%-ENDUSRTYPES
%-BW_BEAN_CONSTANTS_START  - Do not make changes between lines (included this lines) marked with %-BW_BEAN_CONSTANTS_START and %-BW_BEAN_CONSTANTS_END
%- No constants defined in the BeanWizard for this bean
%-BW_BEAN_CONSTANTS_END
%-BW_CUSTOM_USERTYPE_START
%-BW_CUSTOM_INCLUDE_START_H
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%-BW_CUSTOM_INCLUDE_END_H
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END
#define %'ModuleName'%.DEFAULT_SHELL_BUFFER_SIZE  %'ModuleName'%.CONFIG_DEFAULT_SHELL_BUFFER_SIZE  /* default buffer size for shell command parsing */

/* Include inherited components */
%- %ifdef InhrSymbolList
%-   %for var from InhrSymbolList
%- #include "%@%var@ModuleName.h"
%-  %endfor
%- %endif

/* other includes needed */
#include <stddef.h> /* for size_t */

%- Write your own types here ...
%-  Example:
%-    typedef int TMyInteger;
%-

/* VTxxx control and color codes which can be used in terminals supporting color. See https://en.wikipedia.org/wiki/ANSI_escape_code */
/* general control */
#define %'ModuleName'%.ANSI_CONTROL_RESET                "\033[0m"        /* reset to defaults */
#define %'ModuleName'%.ANSI_CONTROL_CLEAR                "\033[2J"        /* clear terminal */
/* text colors: */
#define %'ModuleName'%.ANSI_COLOR_TEXT_BLACK           "\033[2;30m"
#define %'ModuleName'%.ANSI_COLOR_TEXT_RED             "\033[2;31m"
#define %'ModuleName'%.ANSI_COLOR_TEXT_GREEN           "\033[2;32m"
#define %'ModuleName'%.ANSI_COLOR_TEXT_YELLOW          "\033[2;33m"
#define %'ModuleName'%.ANSI_COLOR_TEXT_BLUE            "\033[2;34m"
#define %'ModuleName'%.ANSI_COLOR_TEXT_MAGENTA         "\033[2;35m"
#define %'ModuleName'%.ANSI_COLOR_TEXT_CYAN            "\033[2;36m"
#define %'ModuleName'%.ANSI_COLOR_TEXT_WHITE           "\033[2;37m"
#define %'ModuleName'%.ANSI_COLOR_TEXT_BRIGHT_BLACK    "\033[1;30m"
#define %'ModuleName'%.ANSI_COLOR_TEXT_BRIGHT_RED      "\033[1;31m"
#define %'ModuleName'%.ANSI_COLOR_TEXT_BRIGHT_GREEN    "\033[1;32m"
#define %'ModuleName'%.ANSI_COLOR_TEXT_BRIGHT_YELLOW   "\033[1;33m"
#define %'ModuleName'%.ANSI_COLOR_TEXT_BRIGHT_BLUE     "\033[1;34m"
#define %'ModuleName'%.ANSI_COLOR_TEXT_BRIGHT_MAGENTA  "\033[1;35m"
#define %'ModuleName'%.ANSI_COLOR_TEXT_BRIGHT_CYAN     "\033[1;36m"
#define %'ModuleName'%.ANSI_COLOR_TEXT_BRIGHT_WHITE    "\033[1;37m"
/* text background colors */
#define %'ModuleName'%.ANSI_COLOR_BG_BLACK             "\033[24;40m"
#define %'ModuleName'%.ANSI_COLOR_BG_RED               "\033[24;41m"
#define %'ModuleName'%.ANSI_COLOR_BG_GREEN             "\033[24;42m"
#define %'ModuleName'%.ANSI_COLOR_BG_YELLOW            "\033[24;43m"
#define %'ModuleName'%.ANSI_COLOR_BG_BLUE              "\033[24;44m"
#define %'ModuleName'%.ANSI_COLOR_BG_MAGENTA           "\033[24;45m"
#define %'ModuleName'%.ANSI_COLOR_BG_CYAN              "\033[24;46m"
#define %'ModuleName'%.ANSI_COLOR_BG_WHITE             "\033[24;47m"
#define %'ModuleName'%.ANSI_COLOR_BG_BRIGHT_BLACK      "\033[4;40m"
#define %'ModuleName'%.ANSI_COLOR_BG_BRIGHT_RED        "\033[4;41m"
#define %'ModuleName'%.ANSI_COLOR_BG_BRIGHT_GREEN      "\033[4;42m"
#define %'ModuleName'%.ANSI_COLOR_BG_BRIGHT_YELLOW     "\033[4;43m"
#define %'ModuleName'%.ANSI_COLOR_BRIGHT_BLUE          "\033[4;44m"
#define %'ModuleName'%.ANSI_COLOR_BRIGHT_MAGENTA       "\033[4;45m"
#define %'ModuleName'%.ANSI_COLOR_BRIGHT_CYAN          "\033[4;46m"
#define %'ModuleName'%.ANSI_COLOR_BRIGHT_WHITE         "\033[4;47m"

/* settings for silent prefix char */
#define %'ModuleName'%.NO_SILENT_PREFIX_CHAR ' '                 %>40/* used for no silent prefix char */
#define %'ModuleName'%.SILENT_PREFIX_CHAR_ENABLED (%'ModuleName'%.CONFIG_SILENT_PREFIX_CHAR != %'ModuleName'%.NO_SILENT_PREFIX_CHAR)

#define %'ModuleName'%.DEFAULT_SERIAL  %'ModuleName'%.CONFIG_DEFAULT_SERIAL /* If set to 1, then the shell implements its own StdIO which is returned by %'ModuleName'%.%GetStdio(); */

extern uint8_t %'ModuleName'%.DefaultShellBuffer[%'ModuleName'%.DEFAULT_SHELL_BUFFER_SIZE]; /* default buffer which can be used by the application */

#if %'ModuleName'%.DEFAULT_SERIAL
  extern %'ModuleName'_ConstStdIOType %'ModuleName'%.stdio; /* default standard I/O */
#endif

#define %'ModuleName'%.DASH_LINE "--------------------------------------------------------------"
/* predefined commands */
#define %'ModuleName'%.CMD_HELP   "help"
#define %'ModuleName'%.CMD_STATUS "status"
%-BW_CUSTOM_USERTYPE_END

#ifdef __cplusplus
extern "C" {
#endif

%-BW_DEFINITION_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendStr
%ifdef SendStr
void %'ModuleName'%.%SendStr(const uint8_t *str, %'ModuleName'_StdIO_OutErr_FctType io);
%define! Parstr
%define! Pario
%include Common\ShellSendStr.Inc

%endif %- SendStr
%-BW_METHOD_END SendStr
%-************************************************************************************************************
%-BW_METHOD_BEGIN ParseCommand
%ifdef ParseCommand
uint8_t %'ModuleName'%.%ParseCommand(const uint8_t *cmd, bool *handled, %'ModuleName'_ConstStdIOType *io);
%define! Pario
%define! Parcmd
%define! Parhandled
%define! RetVal
%include Common\ShellParseCommand.Inc

%endif %- ParseCommand
%-BW_METHOD_END ParseCommand
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendNum32s
%ifdef SendNum32s
void %'ModuleName'%.%SendNum32s(int32_t val, %'ModuleName'_StdIO_OutErr_FctType io);
%define! Parval
%define! Pario
%include Common\ShellSendNum32s.Inc

%endif %- SendNum32s
%-BW_METHOD_END SendNum32s
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendNum16s
%ifdef SendNum16s
void %'ModuleName'%.%SendNum16s(int16_t val, %'ModuleName'_StdIO_OutErr_FctType io);
%define! Parval
%define! Pario
%include Common\ShellSendNum16s.Inc

%endif %- SendNum16s
%-BW_METHOD_END SendNum16s
%-************************************************************************************************************
%-BW_METHOD_BEGIN PrintPrompt
%ifdef PrintPrompt
void %'ModuleName'%.%PrintPrompt(%'ModuleName'_ConstStdIOType *io);
%define! Pario
%include Common\ShellPrintPrompt.Inc

%endif %- PrintPrompt
%-BW_METHOD_END PrintPrompt
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadLine
%ifdef ReadLine
bool %'ModuleName'%.%ReadLine(uint8_t *bufStart, uint8_t *buf, size_t bufSize, %'ModuleName'_ConstStdIOType *io);
%define! ParbufStart
%define! Parbuf
%define! ParbufSize
%define! Pario
%define! RetVal
%include Common\ShellReadLine.Inc

%endif %- ReadLine
%-BW_METHOD_END ReadLine
%-************************************************************************************************************
%-BW_METHOD_BEGIN PrintStatus
%ifdef PrintStatus
uint8_t %'ModuleName'%.%PrintStatus(%'ModuleName'_ConstStdIOType *io);
%define! Pario
%define! RetVal
%include Common\ShellPrintStatus.Inc

%endif %- PrintStatus
%-BW_METHOD_END PrintStatus
%-************************************************************************************************************
%-BW_METHOD_BEGIN PrintCommandFailed
%ifdef PrintCommandFailed
void %'ModuleName'%.%PrintCommandFailed(const uint8_t *cmd, %'ModuleName'_ConstStdIOType *io);
%define! Pario
%define! Parcmd
%include Common\ShellPrintCommandFailed.Inc

%endif %- PrintCommandFailed
%-BW_METHOD_END PrintCommandFailed
%-************************************************************************************************************
%-BW_METHOD_BEGIN ParseWithCommandTable
%ifdef ParseWithCommandTable
uint8_t %'ModuleName'%.%ParseWithCommandTable(const uint8_t *cmd, %'ModuleName'_ConstStdIOType *io, %'ModuleName'_ConstParseCommandCallback *parseCallback);
%define! Parcmd
%define! Pario
%define! ParparseCallback
%define! RetVal
%include Common\ShellParseWithCommandTable.Inc

%endif %- ParseWithCommandTable
%-BW_METHOD_END ParseWithCommandTable
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetStdio
%ifdef GetStdio
%'ModuleName'_ConstStdIOTypePtr %'ModuleName'%.%GetStdio(void);
%define! RetVal
%include Common\ShellGetStdio.Inc

%endif %- GetStdio
%-BW_METHOD_END GetStdio
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendNum32u
%ifdef SendNum32u
void %'ModuleName'%.%SendNum32u(uint32_t val, %'ModuleName'_StdIO_OutErr_FctType io);
%define! Parval
%define! Pario
%include Common\ShellSendNum32u.Inc

%endif %- SendNum32u
%-BW_METHOD_END SendNum32u
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendNum16u
%ifdef SendNum16u
void %'ModuleName'%.%SendNum16u(uint16_t val, %'ModuleName'_StdIO_OutErr_FctType io);
%define! Parval
%define! Pario
%include Common\ShellSendNum16u.Inc

%endif %- SendNum16u
%-BW_METHOD_END SendNum16u
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendNum8u
%ifdef SendNum8u
void %'ModuleName'%.%SendNum8u(uint8_t val, %'ModuleName'_StdIO_OutErr_FctType io);
%define! Parval
%define! Pario
%include Common\ShellSendNum8u.Inc

%endif %- SendNum8u
%-BW_METHOD_END SendNum8u
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendNum8s
%ifdef SendNum8s
void %'ModuleName'%.%SendNum8s(int8_t val, %'ModuleName'_StdIO_OutErr_FctType io);
%define! Parval
%define! Pario
%include Common\ShellSendNum8s.Inc

%endif %- SendNum8s
%-BW_METHOD_END SendNum8s
%-************************************************************************************************************
%-BW_METHOD_BEGIN Init
%ifdef Init
void %'ModuleName'%.%Init(void);
%include Common\ShellInit.Inc

%endif %- Init
%-BW_METHOD_END Init
%-************************************************************************************************************
%-BW_METHOD_BEGIN RequestSerial
%ifdef RequestSerial
void %'ModuleName'%.%RequestSerial(void);
%include Common\ShellRequestSerial.Inc

%endif %- RequestSerial
%-BW_METHOD_END RequestSerial
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReleaseSerial
%ifdef ReleaseSerial
void %'ModuleName'%.%ReleaseSerial(void);
%include Common\ShellReleaseSerial.Inc

%endif %- ReleaseSerial
%-BW_METHOD_END ReleaseSerial
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendHelpStr
%ifdef SendHelpStr
void %'ModuleName'%.%SendHelpStr(const uint8_t *strCmd, const uint8_t *strHelp, %'ModuleName'_StdIO_OutErr_FctType io);
%define! ParstrCmd
%define! Pario
%define! ParstrHelp
%include Common\ShellSendHelpStr.Inc

%endif %- SendHelpStr
%-BW_METHOD_END SendHelpStr
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendStatusStr
%ifdef SendStatusStr
void %'ModuleName'%.%SendStatusStr(const uint8_t *strItem, const uint8_t *strStatus, %'ModuleName'_StdIO_OutErr_FctType io);
%define! ParstrItem
%define! ParstrStatus
%define! Pario
%include Common\ShellSendStatusStr.Inc

%endif %- SendStatusStr
%-BW_METHOD_END SendStatusStr
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadChar
%ifdef ReadChar
void %'ModuleName'%.%ReadChar(uint8_t *c);
%define! Parc
%include Common\ShellReadChar.Inc

%endif %- ReadChar
%-BW_METHOD_END ReadChar
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendChar
%ifdef SendChar
void %'ModuleName'%.%SendChar(uint8_t ch);
%define! Parch
%include Common\ShellSendChar.Inc

%endif %- SendChar
%-BW_METHOD_END SendChar
%-************************************************************************************************************
%-BW_METHOD_BEGIN KeyPressed
%ifdef KeyPressed
bool %'ModuleName'%.%KeyPressed(void);
%define! RetVal
%include Common\ShellKeyPressed.Inc

%endif %- KeyPressed
%-BW_METHOD_END KeyPressed
%-************************************************************************************************************
%-BW_METHOD_BEGIN Deinit
%ifdef Deinit
void %'ModuleName'%.%Deinit(void);
%include Common\ShellDeinit.Inc

%endif %- Deinit
%-BW_METHOD_END Deinit
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetSemaphore
%ifdef GetSemaphore
void* %'ModuleName'%.%GetSemaphore(void);
%define! RetVal
%include Common\ShellGetSemaphore.Inc

%endif %- GetSemaphore
%-BW_METHOD_END GetSemaphore
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadAndParseWithCommandTable
%ifdef ReadAndParseWithCommandTable
uint8_t %'ModuleName'%.%ReadAndParseWithCommandTable(uint8_t *cmdBuf, size_t cmdBufSize, %'ModuleName'_ConstStdIOType *io, %'ModuleName'_ConstParseCommandCallback *parseCallback);
%define! ParcmdBuf
%define! ParcmdBufSize
%define! Pario
%define! ParparseCallback
%define! RetVal
%include Common\ShellReadAndParseWithCommandTable.Inc

%endif %- ReadAndParseWithCommandTable
%-BW_METHOD_END ReadAndParseWithCommandTable
%-************************************************************************************************************
%-BW_METHOD_BEGIN IterateTable
%ifdef IterateTable
uint8_t %'ModuleName'%.%IterateTable(const uint8_t *cmd, bool *handled, %'ModuleName'_ConstStdIOType *io, %'ModuleName'_ConstParseCommandCallback *parserTable);
%define! Parcmd
%define! Pario
%define! Parhandled
%define! ParparserTable
%define! RetVal
%include Common\ShellIterateTable.Inc

%endif %- IterateTable
%-BW_METHOD_END IterateTable
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetStdio
%ifdef SetStdio
uint8_t %'ModuleName'%.%SetStdio(%'ModuleName'_ConstStdIOTypePtr stdio);
%define! Parstdio
%define! RetVal
%include Common\ShellSetStdio.Inc

%endif %- SetStdio
%-BW_METHOD_END SetStdio
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendData
%ifdef SendData
void %'ModuleName'%.%SendData(const uint8_t *data, uint16_t dataSize, %'ModuleName'_StdIO_OutErr_FctType io);
%define! Pardata
%define! PardataSize
%define! Pario
%include Common\ShellSendData.Inc

%endif %- SendData
%-BW_METHOD_END SendData
%-************************************************************************************************************
%-BW_METHOD_BEGIN IsHistoryCharacter
%ifdef IsHistoryCharacter
bool %'ModuleName'%.%IsHistoryCharacter(uint8_t ch, uint8_t *cmdBuf, size_t cmdBufIdx, bool *isPrev);
%define! ParcmdBuf
%define! ParcmdBufIdx
%define! ParisPrev
%define! Parch
%define! RetVal
%include Common\ShellIsHistoryCharacter.Inc

%endif %- IsHistoryCharacter
%-BW_METHOD_END IsHistoryCharacter
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendCh
%ifdef SendCh
void %'ModuleName'%.%SendCh(uint8_t ch, %'ModuleName'_StdIO_OutErr_FctType io);
%define! Parch
%define! Pario
%include Common\ShellSendCh.Inc

%endif %- SendCh
%-BW_METHOD_END SendCh
%-************************************************************************************************************
%-BW_METHOD_BEGIN printf
%ifdef printf
unsigned %'ModuleName'%.%printf(const char *fmt, ...);
%define! Parfmt
%define! RetVal
%include Common\Shellprintf.Inc

%endif %- printf
%-BW_METHOD_END printf
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG printfPutChar
void %'ModuleName'%.printfPutChar(void *arg, char c);
%define! Pararg
%define! Parc
%include Common\GeneralInternal.inc (printfPutChar)

%-INTERNAL_METHOD_END printfPutChar
%-************************************************************************************************************
%-BW_METHOD_BEGIN printfIO
%ifdef printfIO
unsigned %'ModuleName'%.%printfIO(%'ModuleName'_ConstStdIOType *io, const char *fmt, ...);
%define! Parfmt
%define! Pario
%define! RetVal
%include Common\ShellprintfIO.Inc

%endif %- printfIO
%-BW_METHOD_END printfIO
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendCharFct
%ifdef SendCharFct
void %'ModuleName'%.%SendCharFct(uint8_t ch, uint8_t (*fct)(uint8_t ch));
%define! Parch
%define! Parfct
%include Common\ShellSendCharFct.Inc

%endif %- SendCharFct
%-BW_METHOD_END SendCharFct
%-************************************************************************************************************
%-BW_METHOD_BEGIN PrintMemory
%ifdef PrintMemory
uint8_t %'ModuleName'%.%PrintMemory(void *hndl, uint32_t startAddr, uint32_t endAddr, uint8_t addrSize, uint8_t bytesPerLine, uint8_t (*readfp)(void *, uint32_t, uint8_t*, size_t), %'ModuleName'_ConstStdIOType *io);
%define! ParstartAddr
%define! ParendAddr
%define! ParaddrSize
%define! ParbytesPerLine
%define! Parreadfp
%define! Pario
%define! Parhndl
%define! RetVal
%include Common\ShellPrintMemory.Inc

%endif %- PrintMemory
%-BW_METHOD_END PrintMemory
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadAndParseWithCommandTableExt
%ifdef ReadAndParseWithCommandTableExt
uint8_t %'ModuleName'%.%ReadAndParseWithCommandTableExt(uint8_t *cmdBuf, size_t cmdBufSize, %'ModuleName'_ConstStdIOType *io, %'ModuleName'_ConstParseCommandCallback *parseCallback, bool silent);
%define! ParcmdBuf
%define! ParcmdBufSize
%define! Pario
%define! ParparseCallback
%define! Parsilent
%define! RetVal
%include Common\ShellReadAndParseWithCommandTableExt.Inc

%endif %- ReadAndParseWithCommandTableExt
%-BW_METHOD_END ReadAndParseWithCommandTableExt
%-************************************************************************************************************
%-BW_METHOD_BEGIN ParseWithCommandTableExt
%ifdef ParseWithCommandTableExt
uint8_t %'ModuleName'%.%ParseWithCommandTableExt(const uint8_t *cmd, %'ModuleName'_ConstStdIOType *io, %'ModuleName'_ConstParseCommandCallback *parseCallback, bool silent);
%define! Parcmd
%define! Pario
%define! ParparseCallback
%define! Parsilent
%define! RetVal
%include Common\ShellParseWithCommandTableExt.Inc

%endif %- ParseWithCommandTableExt
%-BW_METHOD_END ParseWithCommandTableExt
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadCommandLine
%ifdef ReadCommandLine
uint8_t %'ModuleName'%.%ReadCommandLine(uint8_t *cmdBuf, size_t cmdBufSize, %'ModuleName'_ConstStdIOType *io);
%define! ParcmdBuf
%define! ParcmdBufSize
%define! Pario
%define! RetVal
%include Common\ShellReadCommandLine.Inc

%endif %- ReadCommandLine
%-BW_METHOD_END ReadCommandLine
%-BW_DEFINITION_END
/* END %ModuleName. */

#ifdef __cplusplus
}  /* extern "C" */
#endif

#endif
/* ifndef __%'ModuleName'_H */
%include Common\Header.End
%-
%-BW_EVENT_DEFINITION_START
%-BW_METHOD_BEGIN OnBeforeIterateCmd
%ifdef OnBeforeIterateCmd
%INTERFACE OnBeforeIterateCmd
void %OnBeforeIterateCmd(const uint8_t *cmd);
%define! Parcmd
%include Common\ShellOnBeforeIterateCmd.Inc

%endif %- OnBeforeIterateCmd
%-BW_METHOD_END OnBeforeIterateCmd
%-BW_METHOD_BEGIN OnAfterIterateCmd
%ifdef OnAfterIterateCmd
%INTERFACE OnAfterIterateCmd
void %OnAfterIterateCmd(const uint8_t *cmd);
%define! Parcmd
%include Common\ShellOnAfterIterateCmd.Inc

%endif %- OnAfterIterateCmd
%-BW_METHOD_END OnAfterIterateCmd
%-BW_EVENT_DEFINITION_END
%IMPLEMENTATION
%define! Settings Common\ShellSettings.Inc
%define! Abstract Common\ShellAbstract.Inc
%include Common\Header.C

/* MODULE %ModuleName. */
#include <ctype.h> /* for isalnum*/

%for var from EventModules
#include "%var.h"
%endfor
#include "%'ModuleName'.h"
%if defined(XFormat)
#include "%@XFormat@ModuleName.h"
%else
#include "McuXFormat.h"
%endif
%if defined(Utility)
#include "%@Utility@ModuleName.h"
%else
#include "McuUtility.h"
%endif
%if defined(CriticalSection)
#include "%@CriticalSection@ModuleName.h"
%else
#include "McuCriticalSection.h"
%endif
%if defined(Wait)
#include "%@Wait@ModuleName.h"
%endif

#if %'ModuleName'%.DEFAULT_SERIAL
  #include %'ModuleName'%.CONFIG_DEFAULT_SERIAL_INCLUDE
#endif

%-BW_CUSTOM_INCLUDE_START_M
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%-BW_CUSTOM_INCLUDE_END_M

%-BW_CUSTOM_VARIABLE_START
%- Write your static variables here
%-   Example:
%-     static int counter1;
%-     int %'ModuleName'%.counter2;
uint8_t %'ModuleName'%.DefaultShellBuffer[%'ModuleName'%.DEFAULT_SHELL_BUFFER_SIZE]; /* default buffer which can be used by the application */
#if %'ModuleName'%.CONFIG_HISTORY_ENABLED
  static uint8_t %'ModuleName'_history[%'ModuleName'%.CONFIG_HISTORY_NOF_ITEMS][%'ModuleName'%.CONFIG_HISTORY_ITEM_LENGTH];%>40/* History buffers */
  static uint8_t %'ModuleName'_history_index = 0;                %>40/* Selected command */
#endif
#if %'ModuleName'%.CONFIG_ECHO_ENABLED
  static bool %'ModuleName'_EchoEnabled = TRUE;
#endif

#if %'ModuleName'%.CONFIG_USE_MUTEX
  #include "FreeRTOS.h"
  #include "task.h"
  #include "semphr.h"
#endif

#ifdef __HC08__
  #pragma MESSAGE DISABLE C3303 /* implicit concatenation of strings */
#endif
#if %'ModuleName'%.CONFIG_USE_MUTEX
  static SemaphoreHandle_t ShellSem = NULL; /* Semaphore to protect shell SCI access */
#endif

#if %'ModuleName'%.DEFAULT_SERIAL
  %'ModuleName'_ConstStdIOType %'ModuleName'%.stdio =
  {
    (%'ModuleName'_StdIO_In_FctType)%'ModuleName'_ReadChar, /* stdin */
    (%'ModuleName'_StdIO_OutErr_FctType)%'ModuleName'_SendChar, /* stdout */
    (%'ModuleName'_StdIO_OutErr_FctType)%'ModuleName'_SendChar, /* stderr */
    %'ModuleName'_KeyPressed /* if input is not empty */
  };
  static %'ModuleName'_ConstStdIOType *%'ModuleName'%.currStdIO = &%'ModuleName'%.stdio;
#else
  static %'ModuleName'_ConstStdIOType *%'ModuleName'%.currStdIO = NULL; /* needs to be set through %'ModuleName'%.%SetStdio(); */
#endif
%-
%-BW_CUSTOM_VARIABLE_END
%-BW_INTERN_METHOD_DECL_START
%- List of internal methods headers
%-UNLOCKED
/* Internal method prototypes */
%-INTERNAL_LOC_METHOD_BEG SendSeparatedStrings
static void SendSeparatedStrings(const uint8_t *strA, const uint8_t *strB, uint8_t tabChar, uint8_t tabPos, %'ModuleName'_StdIO_OutErr_FctType io);
%-INTERNAL_LOC_METHOD_END SendSeparatedStrings
%-

%-BW_INTERN_METHOD_DECL_END
%-BW_IMPLEMENT_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendCh
%ifdef SendCh
%define! Parch
%define! Pario
%include Common\ShellSendCh.Inc
void %'ModuleName'%.%SendCh(uint8_t ch, %'ModuleName'_StdIO_OutErr_FctType io)
{
  if (io==NULL) {
    return;
  }
  io(ch);
}

%endif %- SendCh
%-BW_METHOD_END SendCh
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendStr
%ifdef SendStr
%define! Parstr
%define! Pario
%include Common\ShellSendStr.Inc
/*!
 * \brief Prints a string using I/O callbacks
 * \param[in] str String (zero terminated) to be printed
 * \param[in] io I/O function to be used for printing
 */
void %'ModuleName'%.%SendStr(const uint8_t *str, %'ModuleName'_StdIO_OutErr_FctType io)
{
  if (io==NULL) {
    return;
  }
  while(*str!='\0') {
    io(*str++);
  }
}

%endif %- SendStr
%-BW_METHOD_END SendStr
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendNum32s
%ifdef SendNum32s
%define! Parval
%define! Pario
%include Common\ShellSendNum32s.Inc
void %'ModuleName'%.%SendNum32s(int32_t val, %'ModuleName'_StdIO_OutErr_FctType io)
{
  unsigned char buf[sizeof("-1234567890")];

  %@Utility@'ModuleName'%.Num32sToStr(buf, sizeof(buf), val);
  %'ModuleName'%.%SendStr(buf, io);
}

%endif %- SendNum32s
%-BW_METHOD_END SendNum32s
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendNum32u
%ifdef SendNum32u
%define! Parval
%define! Pario
%include Common\ShellSendNum32u.Inc
void %'ModuleName'%.%SendNum32u(uint32_t val, %'ModuleName'_StdIO_OutErr_FctType io)
{
  unsigned char buf[sizeof("1234567890")];

  %@Utility@'ModuleName'%.Num32uToStr(buf, sizeof(buf), val);
  %'ModuleName'%.%SendStr(buf, io);
}

%endif %- SendNum32u
%-BW_METHOD_END SendNum32u
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendNum16s
%ifdef SendNum16s
%define! Parval
%define! Pario
%include Common\ShellSendNum16s.Inc
void %'ModuleName'%.%SendNum16s(int16_t val, %'ModuleName'_StdIO_OutErr_FctType io)
{
  unsigned char buf[sizeof("-12345")];

  %@Utility@'ModuleName'%.Num16sToStr(buf, sizeof(buf), val);
  %'ModuleName'%.%SendStr(buf, io);
}

%endif %- SendNum16s
%-BW_METHOD_END SendNum16s
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendNum16u
%ifdef SendNum16u
%define! Parval
%define! Pario
%include Common\ShellSendNum16u.Inc
void %'ModuleName'%.%SendNum16u(uint16_t val, %'ModuleName'_StdIO_OutErr_FctType io)
{
  unsigned char buf[sizeof("12345")];

  %@Utility@'ModuleName'%.Num16uToStr(buf, sizeof(buf), val);
  %'ModuleName'%.%SendStr(buf, io);
}

%endif %- SendNum16u
%-BW_METHOD_END SendNum16u
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendNum8u
%ifdef SendNum8u
%define! Parval
%define! Pario
%include Common\ShellSendNum8u.Inc
void %'ModuleName'%.%SendNum8u(uint8_t val, %'ModuleName'_StdIO_OutErr_FctType io)
{
  unsigned char buf[sizeof("123")];

  %@Utility@'ModuleName'%.Num8uToStr(buf, sizeof(buf), val);
  %'ModuleName'%.%SendStr(buf, io);
}

%endif %- SendNum8u
%-BW_METHOD_END SendNum8u
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendNum8s
%ifdef SendNum8s
%define! Parval
%define! Pario
%include Common\ShellSendNum8s.Inc
void %'ModuleName'%.%SendNum8s(int8_t val, %'ModuleName'_StdIO_OutErr_FctType io)
{
  unsigned char buf[sizeof("-123")];

  %@Utility@'ModuleName'%.Num8sToStr(buf, sizeof(buf), val);
  %'ModuleName'%.%SendStr(buf, io);
}

%endif %- SendNum8s
%-BW_METHOD_END SendNum8s
%-************************************************************************************************************
%-BW_METHOD_BEGIN ParseCommand
%ifdef ParseCommand
%define! Pario
%define! Parcmd
%define! Parhandled
%define! RetVal
%include Common\ShellParseCommand.Inc
uint8_t %'ModuleName'%.%ParseCommand(const uint8_t *cmd, bool *handled, %'ModuleName'_ConstStdIOType *io)
{
  if (%@Utility@'ModuleName'%.strcmp((char*)cmd, %'ModuleName'%.CMD_HELP)==0 || %@Utility@'ModuleName'%.strcmp((char*)cmd, "%'ModuleName' help")==0) {
    %'ModuleName'%.%SendStr((unsigned char*)"\r\n", io->stdOut);
    %'ModuleName'%.%SendStr((unsigned char*)%'ModuleName'%.DASH_LINE, io->stdOut);
    %'ModuleName'%.%SendStr((unsigned char*)"\r\n", io->stdOut);
    %'ModuleName'%.%SendStr((unsigned char*)%'ModuleName'%.CONFIG_PROJECT_NAME_STRING, io->stdOut);
    %'ModuleName'%.%SendStr((unsigned char*)"\r\n", io->stdOut);
    %'ModuleName'%.%SendStr((unsigned char*)%'ModuleName'%.DASH_LINE, io->stdOut);
    %'ModuleName'%.%SendStr((unsigned char*)"\r\n", io->stdOut);
    %'ModuleName'%.%SendHelpStr((unsigned char*)"%'ModuleName'", (const unsigned char*)"Group of %'ModuleName' commands\r\n", io->stdOut);
%if defined(PrintStatus)
    %'ModuleName'%.%SendHelpStr((unsigned char*)"  help|status", (const unsigned char*)"Print help or status information\r\n", io->stdOut);
%else %- only help
    %'ModuleName'%.%SendHelpStr((unsigned char*)"  help", (const unsigned char*)"Prints help\r\n", io->stdOut);
%endif
#if %'ModuleName'%.CONFIG_ECHO_ENABLED
    %'ModuleName'%.%SendHelpStr((unsigned char*)"  echo (on|off)", (const unsigned char*)"Turn echo on or off\r\n", io->stdOut);
#endif
    *handled = TRUE;
    return ERR_OK;
#if %'ModuleName'%.CONFIG_ECHO_ENABLED
  } else if ((%@Utility@'ModuleName'%.strcmp((char*)cmd, "%'ModuleName' echo on")==0)) {
    *handled = TRUE;
    %'ModuleName'%.EchoEnabled = TRUE;
    return ERR_OK;
  } else if ((%@Utility@'ModuleName'%.strcmp((char*)cmd, "%'ModuleName' echo off")==0)) {
    *handled = TRUE;
    %'ModuleName'%.EchoEnabled = FALSE;
    return ERR_OK;
#endif
%if defined(PrintStatus)
  } else if ((%@Utility@'ModuleName'%.strcmp((char*)cmd, %'ModuleName'%.CMD_STATUS)==0) || (%@Utility@'ModuleName'%.strcmp((char*)cmd, "%'ModuleName' status")==0)) {
    *handled = TRUE;
    return %'ModuleName'%.%PrintStatus(io);
%endif
  }
  return ERR_OK; /* no error */
}

%endif %- ParseCommand
%-BW_METHOD_END ParseCommand
%-************************************************************************************************************
%-BW_METHOD_BEGIN PrintPrompt
%ifdef PrintPrompt
%define! Pario
%include Common\ShellPrintPrompt.Inc
void %'ModuleName'%.%PrintPrompt(%'ModuleName'_ConstStdIOType *io)
{
  %'ModuleName'%.%SendStr((unsigned char*)"\r\n", io->stdOut); /* ensure that there is a new line */
  %'ModuleName'%.%SendStr((unsigned char*)%'ModuleName'%.CONFIG_PROMPT_STRING, io->stdOut);
}

%endif %- PrintPrompt
%-BW_METHOD_END PrintPrompt
%-************************************************************************************************************
%-BW_METHOD_BEGIN IsHistoryCharacter
%ifdef IsHistoryCharacter
%define! ParcmdBuf
%define! ParcmdBufIdx
%define! ParisPrev
%define! Parch
%define! RetVal
%include Common\ShellIsHistoryCharacter.Inc
bool %'ModuleName'%.%IsHistoryCharacter(uint8_t ch, uint8_t *cmdBuf, size_t cmdBufIdx, bool *isPrev)
{
  *isPrev = FALSE;
#if %'ModuleName'%.CONFIG_HISTORY_ENABLED
  if (   cmdBufIdx==0 /* first character on command line */
      || (%@Utility@'ModuleName'%.strcmp((const char*)cmdBuf, (const char*)%'ModuleName'%.history[%'ModuleName'%.history_index])==0) /* pressing prev/next character on previous history element */
      )
  {
    if (ch==%'ModuleName'%.CONFIG_HISTORY_CHAR_PREV) {
      *isPrev = TRUE;
      return TRUE;
    } else if (ch==%'ModuleName'%.CONFIG_HISTORY_CHAR_NEXT) {
      *isPrev = FALSE;
      return TRUE;
    }
  }
#if 0
  if (cmdBufIdx==0 || cmdBufIdx==2) { /* accept only first character or sequence as history sequence */
    if (cmdBufIdx==2 && cmdBuf[0]==0x1b && cmdBuf[1]==0x5b) {
      /* up:    0x27 0x5b 0x41
       * down:  0x27 0x5b 0x42
       * right: 0x27 0x5b 0x43
       * left:  0x27 0x5b 0x44
       */
      if (cmdBuf[2]==0x41 /* up */ || cmdBuf[2]==0x44 /* left */) {
        *isPrev = TRUE;
        return TRUE;
      } else if (cmdBuf[2]==0x42 /* down */ || cmdBuf[2]==0x43 /* right */) {
        *isPrev = FALSE;
        return TRUE;
      }
    }
    /* NYI: handle TAB and SHIFT-TAB */
  }
#endif
#else
  (void)ch; /* not used */
  (void)cmdBuf; /* not used */
  (void)cmdBufIdx; /* not used */
#endif
  return FALSE;
}

%endif %- IsHistoryCharacter
%-BW_METHOD_END IsHistoryCharacter
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadLine
%ifdef ReadLine
%define! ParbufStart
%define! Parbuf
%define! ParbufSize
%define! Pario
%define! RetVal
%include Common\ShellReadLine.Inc
bool %'ModuleName'%.%ReadLine(uint8_t *bufStart, uint8_t *buf, size_t bufSize, %'ModuleName'_ConstStdIOType *io)
{
  uint8_t c;
  bool isBackwardHistory;

  if (io->keyPressed()) {
    for(;;) {                                                    %>40/* while not '\r' or '\n' */
      c = '\0';                                                  %>40/* initialize character */
      io->stdIn(&c);                                             %>40/* read character */
      if (c=='\0') { /* nothing in rx buffer? Something is wrong... */
        break; /* get out of loop */
      }
      if (c=='\b' || c=='\177') {                                %>40/* check for backspace */
        if (buf > bufStart) {                                    %>40/* Avoid buffer underflow */
#if %'ModuleName'%.CONFIG_ECHO_ENABLED
           if (%'ModuleName'_EchoEnabled && io->echoEnabled) {
             io->stdOut('\b');                                   %>40/* delete character on terminal */
             io->stdOut(' ');
             io->stdOut('\b');
           }
#endif
           buf--;                                                %>40/* delete last character in buffer */
           *buf = '\0';
           bufSize++;
        }
      } else if (%'ModuleName'%.%IsHistoryCharacter(c, bufStart, (size_t)(buf-bufStart), &isBackwardHistory)) {
#if %'ModuleName'%.CONFIG_HISTORY_ENABLED
        uint8_t cBuf[3]={'\0','\0','\0'}, cBufIdx = 0;
        bool prevInHistory;
#endif

        while (c!='\0') {                                        %>40/* empty the rx buffer (escape sequence) */
#if %'ModuleName'%.CONFIG_HISTORY_ENABLED
           cBuf[cBufIdx] = c;
           cBufIdx++;
           if (cBufIdx==sizeof(cBuf)) {
             cBufIdx = 0; /* ring buffer */
           }
#endif
           c = '\0';                                             %>40/* initialize character */
           io->stdIn(&c);                                        %>40/* read character */
        }
#if %'ModuleName'%.CONFIG_HISTORY_ENABLED
        /* if not an alphanumeric switch to history  */
        prevInHistory = cBufIdx==0 && cBuf[0]==0x1b && cBuf[1]==0x5b && (cBuf[2]==0x41 /*up*/ || cBuf[2]==0x44 /*left*/);
        /* up:    0x27 0x5b 0x41
         * down:  0x27 0x5b 0x42
         * right: 0x27 0x5b 0x43
         * left:  0x27 0x5b 0x44
         */
        if (prevInHistory) {
          %@Utility@'ModuleName'%.strcpy(bufStart, %'ModuleName'%.CONFIG_HISTORY_ITEM_LENGTH, %'ModuleName'_history[%'ModuleName'_history_index]);
          %'ModuleName'_history_index++;                         %>40/* update the index */
          if (%'ModuleName'_history_index==%'ModuleName'%.CONFIG_HISTORY_NOF_ITEMS) {
            %'ModuleName'_history_index = 0;
          }
        } else {
          if (%'ModuleName'_history_index==0) {
            %'ModuleName'_history_index = (%'ModuleName'%.CONFIG_HISTORY_NOF_ITEMS-1);
          } else {
            %'ModuleName'_history_index--;
          }
          %@Utility@'ModuleName'%.strcpy(bufStart, %'ModuleName'%.CONFIG_HISTORY_ITEM_LENGTH, %'ModuleName'_history[%'ModuleName'_history_index]);
        }
        bufSize = bufSize + buf - bufStart - %@Utility@'ModuleName'%.strlen((const char*)bufStart);%>40/* update the buffer */
        buf = bufStart + %@Utility@'ModuleName'%.strlen((const char*)bufStart);
#endif
#if %'ModuleName'%.CONFIG_ECHO_ENABLED
        if (%'ModuleName'_EchoEnabled && io->echoEnabled) {
          %'ModuleName'%.%SendStr((unsigned char*)"\r\n", io->stdOut);
          %'ModuleName'%.%PrintPrompt(io);
          %'ModuleName'%.%SendStr(bufStart, io->stdOut);
        }
#endif
      } else {
#if %'ModuleName'%.CONFIG_ECHO_ENABLED
        if (%'ModuleName'_EchoEnabled && io->echoEnabled) {
  #if %@sdk@'ModuleName'%.CONFIG_CPU_IS_ESP32
          if (c=='\r') { /* idf.py monitor uses '\r' for '\n'? */
            c = '\n';
          }
  #endif
          io->stdOut(c);                                         %>40/* echo character */
        }
#endif
        *buf = (uint8_t)c;                                       %>40/* append character to the string */
        buf++;
        bufSize--;
        if ((c=='\r') || (c=='\n')) {
#if %'ModuleName'%.CONFIG_ECHO_ENABLED
          if (%'ModuleName'_EchoEnabled && io->echoEnabled) {
            #if McuLib_CONFIG_CPU_IS_ESP32
            %'ModuleName'%.%SendStr((unsigned char*)" \n", io->stdOut); /* for ESP32 idf.py monitor it uses '\r' at the end, plus we need a space */
            #else
            %'ModuleName'%.%SendStr((unsigned char*)"\n", io->stdOut);
            #endif
          }
#endif
#if %'ModuleName'%.CONFIG_HISTORY_ENABLED
          if ((bufStart[0] != '\0') && (bufStart[0] != '\r') && (bufStart[0] != '\n')) {
            int i;

            for(i=%'ModuleName'%.CONFIG_HISTORY_NOF_ITEMS-1; i>0;i--) {
              %@Utility@'ModuleName'%.strcpy(%'ModuleName'_history[i], %'ModuleName'%.CONFIG_HISTORY_ITEM_LENGTH, %'ModuleName'_history[i-1]);%>40/* move previous commands */
            }
            %'ModuleName'_history_index = 0;                     %>40/* update the history with the current command */
            %@Utility@'ModuleName'%.strcpy(%'ModuleName'_history[0], %'ModuleName'%.CONFIG_HISTORY_ITEM_LENGTH, bufStart);%>40/* add the current command to the history */
            if (buf-bufStart <= %'ModuleName'%.CONFIG_HISTORY_ITEM_LENGTH) {%>40/* size check */
              %'ModuleName'_history[0][buf-bufStart-1] = '\0';
            } else {
              %'ModuleName'_history[0][%'ModuleName'%.CONFIG_HISTORY_ITEM_LENGTH-1] = '\0';
            }
          }
#endif
          break;
        }
        if (bufSize <= 1) {                                      %>40/* buffer full */
          break;
        }
      }
    } /* for */
    *buf = '\0';                                                 %>40/* zero terminate string */
    return TRUE;
  } else {
    return FALSE;
  }
}

%endif %- ReadLine
%-BW_METHOD_END ReadLine
%-************************************************************************************************************
%-BW_METHOD_BEGIN PrintStatus
%ifdef PrintStatus
%define! Pario
%define! RetVal
%include Common\ShellPrintStatus.Inc
uint8_t %'ModuleName'%.%PrintStatus(%'ModuleName'_ConstStdIOType *io)
{
  unsigned char buf[32];

  %'ModuleName'%.%SendStatusStr((const unsigned char*)"%'ModuleName'", (const unsigned char*)"Commandline shell status\r\n", io->stdOut);
  %'ModuleName'%.%SendStatusStr((const unsigned char*)"  Build", (const unsigned char*)__DATE__, io->stdOut);
  %'ModuleName'%.%SendStr((unsigned char*)" ", io->stdOut);
  %'ModuleName'%.%SendStr((unsigned char*)__TIME__, io->stdOut);
  %'ModuleName'%.%SendStr((unsigned char*)"\r\n", io->stdOut);
#if %'ModuleName'%.CONFIG_ECHO_ENABLED
  %'ModuleName'%.%SendStatusStr((const unsigned char*)"  echo", %'ModuleName'_EchoEnabled?(const unsigned char*)"On\r\n":(const unsigned char*)"Off\r\n", io->stdOut);
#endif

  buf[0] = '\0';
  if (%'ModuleName'%.CONFIG_SILENT_PREFIX_CHAR!=%'ModuleName'%.NO_SILENT_PREFIX_CHAR) {
    %@Utility@'ModuleName'%.chcat(buf, sizeof(buf), %'ModuleName'%.CONFIG_SILENT_PREFIX_CHAR);
    %@Utility@'ModuleName'%.strcat(buf, sizeof(buf), (unsigned char*)"\r\n");
  } else {
    %@Utility@'ModuleName'%.strcat(buf, sizeof(buf), (unsigned char*)"none\r\n");
  }
  %'ModuleName'%.%SendStatusStr((const unsigned char*)"  silent", buf, io->stdOut);
#if McuShell_CONFIG_MULTI_CMD_ENABLED
  %@Utility@'ModuleName'%.strcpy(buf, sizeof(buf), (unsigned char*)"yes: '");
  %@Utility@'ModuleName'%.chcat(buf, sizeof(buf), %'ModuleName'%.CONFIG_MULTI_CMD_CHAR);
  %@Utility@'ModuleName'%.strcat(buf, sizeof(buf), (unsigned char*)"', size: ");
  %@Utility@'ModuleName'%.strcatNum32u(buf, sizeof(buf), %'ModuleName'%.CONFIG_MULTI_CMD_SIZE);
  %@Utility@'ModuleName'%.strcat(buf, sizeof(buf), (unsigned char*)"\r\n");
  %'ModuleName'%.%SendStatusStr((const unsigned char*)"  multiCmd", buf, io->stdOut);
#else
  %'ModuleName'%.%SendStatusStr((const unsigned char*)"  multiCmd", (unsigned char*)"no\r\n", io->stdOut);
#endif

  %@Utility@'ModuleName'%.Num32uToStr(buf, sizeof(buf), %'ModuleName'%.CONFIG_DEFAULT_SHELL_BUFFER_SIZE);
  %@Utility@'ModuleName'%.strcat(buf, sizeof(buf), (unsigned char*)" bytes default size\r\n");
  %'ModuleName'%.%SendStatusStr((const unsigned char*)"  size", buf, io->stdOut);

  return ERR_OK;
}

%endif %- PrintStatus
%-BW_METHOD_END PrintStatus
%-************************************************************************************************************
%-BW_METHOD_BEGIN PrintCommandFailed
%ifdef PrintCommandFailed
%define! Pario
%define! Parcmd
%include Common\ShellPrintCommandFailed.Inc
void %'ModuleName'%.%PrintCommandFailed(const uint8_t *cmd, %'ModuleName'_ConstStdIOType *io)
{
  %'ModuleName'%.%SendStr((unsigned char*)"*** Failed or unknown command: ", io->stdErr);
  %'ModuleName'%.%SendStr(cmd, io->stdErr);
  %'ModuleName'%.%SendStr((unsigned char*)"\r\n", io->stdErr);
  %'ModuleName'%.%SendStr((unsigned char*)"*** Type ", io->stdErr);
  %'ModuleName'%.%SendStr((unsigned char*)%'ModuleName'%.CMD_HELP, io->stdErr);
  %'ModuleName'%.%SendStr((unsigned char*)" to get a list of available commands\r\n", io->stdErr);
}

%endif %- PrintCommandFailed
%-BW_METHOD_END PrintCommandFailed
%-************************************************************************************************************
%-BW_METHOD_BEGIN IterateTable
%ifdef IterateTable
%define! Parcmd
%define! Pario
%define! Parhandled
%define! ParparserTable
%define! RetVal
%include Common\ShellIterateTable.Inc
uint8_t %'ModuleName'%.%IterateTable(const uint8_t *cmd, bool *handled, %'ModuleName'_ConstStdIOType *io, %'ModuleName'_ConstParseCommandCallback *parserTable)
{
  uint8_t res = ERR_OK;

  if (parserTable==NULL) { /* no table??? */
    return ERR_FAILED;
  }
  if (io==NULL) { /* no IO handler??? */
    return ERR_FAILED;
  }
  /* iterate through all parser functions in table */
  while(*parserTable!=NULL) {
  %if defined(OnBeforeIterateCmd)
    %OnBeforeIterateCmd(cmd);
  %endif
    if ((*parserTable)(cmd, handled, io)!=ERR_OK) {
      res = ERR_FAILED;
    }
  %if defined(OnAfterIterateCmd)
    %OnAfterIterateCmd(cmd);
  %endif
    parserTable++;
  }
  return res;
}

%endif %- IterateTable
%-BW_METHOD_END IterateTable
%-************************************************************************************************************
%-BW_METHOD_BEGIN ParseWithCommandTableExt
%ifdef ParseWithCommandTableExt
%define! Parcmd
%define! Pario
%define! ParparseCallback
%define! Parsilent
%define! RetVal
%include Common\ShellParseWithCommandTableExt.Inc
uint8_t %'ModuleName'%.%ParseWithCommandTableExt(const uint8_t *cmd, %'ModuleName'_ConstStdIOType *io, %'ModuleName'_ConstParseCommandCallback *parseCallback, bool silent)
{
  uint8_t res = ERR_OK;
  bool handled;
#if %'ModuleName'%.SILENT_PREFIX_CHAR_ENABLED
  bool silentPrefix = FALSE;
#endif
#if %'ModuleName'%.CONFIG_MULTI_CMD_ENABLED
  uint8_t buf[%'ModuleName'%.CONFIG_MULTI_CMD_SIZE];
  uint8_t i;
  bool parseBuffer, finished;
  bool insideDoubleQuotes = FALSE; /* with multi-commands: allow the McuShell_CONFIG_MULTI_CMD_CHAR inside double quoted strings */
#endif

  if (io==NULL) { /* no I/O handler? */
    return ERR_FAILED;
  }
  if (*cmd=='\0') { /* empty command */
    return ERR_OK;
  }
#if %'ModuleName'%.CONFIG_MULTI_CMD_ENABLED
  parseBuffer = FALSE;
  finished = FALSE;
  i = 0;
  for(;;) { /* breaks */
    if (i>sizeof(buf)-2) {
      res = ERR_FAILED;
      %'ModuleName'%.PrintCommandFailed(buf, io);
      break; /* buffer overflow */
    }
    buf[i] = *cmd;
    if (buf[i]=='"') {
      if (insideDoubleQuotes) { /* already had a double quote? */
        insideDoubleQuotes = FALSE; /* note: we do not support nested double quotes */
      } else {
        insideDoubleQuotes = TRUE; /* mark that we are inside double quotes */
      }
    }
    cmd++; i++;
  #if %'ModuleName'%.SILENT_PREFIX_CHAR_ENABLED
    if (i==1 && buf[0]==%'ModuleName'%.CONFIG_SILENT_PREFIX_CHAR) { /* first character is silent character */
      silentPrefix |= (bool)(buf[0]==%'ModuleName'%.CONFIG_SILENT_PREFIX_CHAR);
      buf[0] = *cmd; /* skip silent character */
      cmd++;
    }
  #endif
    if (!insideDoubleQuotes && buf[i-1] == %'ModuleName'%.CONFIG_MULTI_CMD_CHAR) { /* found separator, but not inside double quoted string */
      buf[i-1] = '\0';
      parseBuffer = TRUE;
    } else if (buf[i-1]=='\0') {
      parseBuffer = TRUE;
      finished = TRUE;
    }
    if (parseBuffer) {
      handled = FALSE;
      res = %'ModuleName'%.IterateTable(buf, &handled, io, parseCallback); /* iterate through all parser functions in table */
      if (!handled || res!=ERR_OK) { /* no handler has handled the command, or error? */
        %'ModuleName'%.PrintCommandFailed(buf, io);
        res = ERR_FAILED;
      }
      parseBuffer = FALSE;
      i = 0; /* restart */
    }
    if (finished) {
      break; /* get out of loop */
    }
  } /* for */
#else
  #if %'ModuleName'%.SILENT_PREFIX_CHAR_ENABLED
  silentPrefix = (bool)(*cmd==%'ModuleName'%.CONFIG_SILENT_PREFIX_CHAR);
  if (silentPrefix) {
    cmd++; /* skip silent character */
  }
  #endif
  handled = FALSE;
  res = %'ModuleName'%.IterateTable(cmd, &handled, io, parseCallback); /* iterate through all parser functions in table */
  if (!handled || res!=ERR_OK) { /* no handler has handled the command? */
    %'ModuleName'%.PrintCommandFailed(cmd, io);
    res = ERR_FAILED;
  }
#endif
#if %'ModuleName'%.SILENT_PREFIX_CHAR_ENABLED
  if (!silentPrefix && !silent) {
    %'ModuleName'%.PrintPrompt(io);
  }
#else
  if (!silent) {
    %'ModuleName'%.PrintPrompt(io);
  }
#endif
  return res;
}

%endif %- ParseWithCommandTableExt
%-BW_METHOD_END ParseWithCommandTableExt
%-************************************************************************************************************
%-BW_METHOD_BEGIN ParseWithCommandTable
%ifdef ParseWithCommandTable
%define! Parcmd
%define! Pario
%define! ParparseCallback
%define! RetVal
%include Common\ShellParseWithCommandTable.Inc
uint8_t %'ModuleName'%.%ParseWithCommandTable(const uint8_t *cmd, %'ModuleName'_ConstStdIOType *io, %'ModuleName'_ConstParseCommandCallback *parseCallback)
{
  return %'ModuleName'%.%ParseWithCommandTableExt(cmd, io, parseCallback, FALSE);
}

%endif %- ParseWithCommandTable
%-BW_METHOD_END ParseWithCommandTable
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetStdio
%ifdef SetStdio
%define! Parstdio
%define! RetVal
%include Common\ShellSetStdio.Inc
uint8_t %'ModuleName'%.%SetStdio(%'ModuleName'_ConstStdIOTypePtr stdio)
{
  %'ModuleName'%.currStdIO = stdio;
  return ERR_OK;
}

%endif %- SetStdio
%-BW_METHOD_END SetStdio
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetStdio
%ifdef GetStdio
%define! RetVal
%include Common\ShellGetStdio.Inc
%'ModuleName'_ConstStdIOTypePtr %'ModuleName'%.%GetStdio(void)
{
  return %'ModuleName'%.currStdIO;
}

%endif %- GetStdio
%-BW_METHOD_END GetStdio
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadAndParseWithCommandTableExt
%ifdef ReadAndParseWithCommandTableExt
%define! ParcmdBuf
%define! ParcmdBufSize
%define! Pario
%define! ParparseCallback
%define! Parsilent
%define! RetVal
%include Common\ShellReadAndParseWithCommandTableExt.Inc
uint8_t %'ModuleName'%.%ReadAndParseWithCommandTableExt(uint8_t *cmdBuf, size_t cmdBufSize, %'ModuleName'_ConstStdIOType *io, %'ModuleName'_ConstParseCommandCallback *parseCallback, bool silent)
{
  /* IMPORTANT NOTE: this function *appends* to the buffer, so the buffer needs to be initialized first! */
  uint8_t res = ERR_OK;
  size_t len;

  if (io==NULL) { /* no I/O handler? */
    return ERR_FAILED;
  }
  len = %@Utility@'ModuleName'%.strlen((const char*)cmdBuf);
  if (%'ModuleName'%.ReadLine(cmdBuf, cmdBuf+len, cmdBufSize-len, io)) {
    len = %@Utility@'ModuleName'%.strlen((const char*)cmdBuf);   %>40/* length of buffer string */
    if (len==0) { /* error case */
      return ERR_FAILED;
    } else if (len==1 && (cmdBuf[0]=='\n' || cmdBuf[0]=='\r')) { %>40/* eat preceding newline characters */
      cmdBuf[0] = '\0';
    }
    if (len>=cmdBufSize-1) {                                     %>40/* buffer overflow? Parse what we have, will be likely return an error */
      (void)%'ModuleName'%.%ParseWithCommandTableExt(cmdBuf, io, parseCallback, silent);
      cmdBuf[0] = '\0'; /* start again */
      res = ERR_OVERFLOW;
    } else if (cmdBuf[len-1]=='\n' || cmdBuf[len-1]=='\r') {     %>40/* line end: parse command */
      cmdBuf[len-1] = '\0';                                      %>40/* remove line end character for parser */
      res = %'ModuleName'%.%ParseWithCommandTableExt(cmdBuf, io, parseCallback, silent);
      cmdBuf[0] = '\0';                                          %>40/* start again */
    } else {
      /* continue to append to buffer */
    }
  }
  return res;
}

%endif %- ReadAndParseWithCommandTableExt
%-BW_METHOD_END ReadAndParseWithCommandTableExt
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadCommandLine
%ifdef ReadCommandLine
%define! ParcmdBuf
%define! ParcmdBufSize
%define! Pario
%define! RetVal
%include Common\ShellReadCommandLine.Inc
uint8_t %'ModuleName'%.%ReadCommandLine(uint8_t *cmdBuf, size_t cmdBufSize, %'ModuleName'_ConstStdIOType *io)
{
  /* IMPORTANT NOTE: this function *appends* to the buffer, so the buffer needs to be initialized first! */
  size_t len;

  if (io==NULL) { /* no I/O handler? */
    return ERR_FAILED;
  }
  len = %@Utility@'ModuleName'%.strlen((const char*)cmdBuf);
  if (%'ModuleName'%.%ReadLine(cmdBuf, cmdBuf+len, cmdBufSize-len, io)) {
    len = %@Utility@'ModuleName'%.strlen((const char*)cmdBuf); /* length of buffer string */
    if (len==0) { /* error case */
      return ERR_FAILED;
    } else if (len==1 && (cmdBuf[0]=='\n' || cmdBuf[0]=='\r')) { /* eat preceding newline characters */
      cmdBuf[0] = '\0';
    }
    if (len>=cmdBufSize-1) {           /* buffer overflow? Parse what we have, will be likely return an error */
      cmdBuf[0] = '\0'; /* start again */
      return ERR_OVERFLOW;
    } else if (cmdBuf[len-1]=='\n' || cmdBuf[len-1]=='\r') { /* line end: parse command */
      cmdBuf[len-1] = '\0';            /* remove line end character for parser */
      return ERR_OK;
    } else {
      /* continue to append to buffer */
    }
  }
  return ERR_BUSY;
}

%endif %- ReadCommandLine
%-BW_METHOD_END ReadCommandLine
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadAndParseWithCommandTable
%ifdef ReadAndParseWithCommandTable
%define! ParcmdBuf
%define! ParcmdBufSize
%define! Pario
%define! ParparseCallback
%define! RetVal
%include Common\ShellReadAndParseWithCommandTable.Inc
uint8_t %'ModuleName'%.%ReadAndParseWithCommandTable(uint8_t *cmdBuf, size_t cmdBufSize, %'ModuleName'_ConstStdIOType *io, %'ModuleName'_ConstParseCommandCallback *parseCallback)
{
  return %'ModuleName'%.%ReadAndParseWithCommandTableExt(cmdBuf, cmdBufSize, io, parseCallback, FALSE);
}

%endif %- ReadAndParseWithCommandTable
%-BW_METHOD_END ReadAndParseWithCommandTable
%-************************************************************************************************************
%-BW_METHOD_BEGIN RequestSerial
%ifdef RequestSerial
%include Common\ShellRequestSerial.Inc
void %'ModuleName'%.%RequestSerial(void)
{
#if %'ModuleName'%.CONFIG_USE_MUTEX
  (void)xSemaphoreTakeRecursive(ShellSem, portMAX_DELAY);
#endif
}

%endif %- RequestSerial
%-BW_METHOD_END RequestSerial
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReleaseSerial
%ifdef ReleaseSerial
%include Common\ShellReleaseSerial.Inc
void %'ModuleName'%.%ReleaseSerial(void)
{
#if %'ModuleName'%.CONFIG_USE_MUTEX
  (void)xSemaphoreGiveRecursive(ShellSem);
#endif
}

%endif %- ReleaseSerial
%-BW_METHOD_END ReleaseSerial
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetSemaphore
%ifdef GetSemaphore
%define! RetVal
%include Common\ShellGetSemaphore.Inc
void* %'ModuleName'%.%GetSemaphore(void)
{
#if %'ModuleName'%.CONFIG_USE_MUTEX
  return ShellSem;
#else
  return NULL;
#endif
}

%endif %- GetSemaphore
%-BW_METHOD_END GetSemaphore
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG SendSeparatedStrings
%define! ParstrA
%define! ParstrB
%define! PartabChar
%define! PartabPos
%define! Pario
%include Common\GeneralInternalGlobal.inc (SendSeparatedStrings)
static void SendSeparatedStrings(const uint8_t *strA, const uint8_t *strB, uint8_t tabChar, uint8_t tabPos, %'ModuleName'_StdIO_OutErr_FctType io)
{
  /* write command part */
  if (strA!=NULL) {
    while(*strA!='\0' && tabPos>0) {
      io(*strA++);
      tabPos--;
    }
  }
  /* fill up until ';' */
  while(tabPos>0) {
    io(' ');
    tabPos--;
  }
  /* write separator */
  io(tabChar);
  io(' ');
  if (strB!=NULL) {
    /* write help text */
    %'ModuleName'%.%SendStr(strB, io);
  }
}

%-INTERNAL_METHOD_END SendSeparatedStrings
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendHelpStr
%ifdef SendHelpStr
%define! ParstrCmd
%define! Pario
%define! ParstrHelp
%include Common\ShellSendHelpStr.Inc
void %'ModuleName'%.%SendHelpStr(const uint8_t *strCmd, const uint8_t *strHelp, %'ModuleName'_StdIO_OutErr_FctType io)
{
  SendSeparatedStrings(strCmd, strHelp, ';', %'ModuleName'%.CONFIG_HELP_SEMICOLON_POS, io);
}

%endif %- SendHelpStr
%-BW_METHOD_END SendHelpStr
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendStatusStr
%ifdef SendStatusStr
%define! ParstrItem
%define! ParstrStatus
%define! Pario
%include Common\ShellSendStatusStr.Inc
void %'ModuleName'%.%SendStatusStr(const uint8_t *strItem, const uint8_t *strStatus, %'ModuleName'_StdIO_OutErr_FctType io)
{
  SendSeparatedStrings(strItem, strStatus, ':', %'ModuleName'%.CONFIG_STATUS_COLON_POS, io);
}

%endif %- SendStatusStr
%-BW_METHOD_END SendStatusStr
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadChar
%ifdef ReadChar
%define! Parc
%include Common\ShellReadChar.Inc
void %'ModuleName'%.%ReadChar(uint8_t *c)
{
#if %'ModuleName'%.CONFIG_DEFAULT_SERIAL
  uint8_t res;

#if %'ModuleName'%.CONFIG_USE_MUTEX
  (void)xSemaphoreTakeRecursive(ShellSem, portMAX_DELAY);
#endif
  res = %'ModuleName'%.CONFIG_DEFAULT_SERIAL_RECEIVE_FCT_NAME((uint8_t*)c);
  if (res==ERR_RXEMPTY) {
    /* no character in buffer */
    *c = '\0';
  }
#if %'ModuleName'%.CONFIG_USE_MUTEX
  (void)xSemaphoreGiveRecursive(ShellSem);
#endif
#else
  *c = '\0';
  return; /* no serial component set up in properties */
#endif
}

%endif %- ReadChar
%-BW_METHOD_END ReadChar
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendChar
%ifdef SendChar
%define! Parch
%include Common\ShellSendChar.Inc
void %'ModuleName'%.%SendChar(uint8_t ch)
{
#if %'ModuleName'%.CONFIG_DEFAULT_SERIAL
  %'ModuleName'%.%SendCharFct(ch, %'ModuleName'%.CONFIG_DEFAULT_SERIAL_SEND_FCT_NAME);
#else
  (void)ch;                                                      %>40/* avoid compiler warning about unused argument */
#endif
}

%endif %- SendChar
%-BW_METHOD_END SendChar
%-************************************************************************************************************
%-BW_METHOD_BEGIN KeyPressed
%ifdef KeyPressed
%define! RetVal
%include Common\ShellKeyPressed.Inc
bool %'ModuleName'%.%KeyPressed(void)
{
#if %'ModuleName'%.CONFIG_DEFAULT_SERIAL
  bool res;

#if %'ModuleName'%.CONFIG_USE_MUTEX
  (void)xSemaphoreTakeRecursive(ShellSem, portMAX_DELAY);
#endif
#if %'ModuleName'%.CONFIG_DEFAULT_SERIAL
  res = (bool)((%'ModuleName'%.CONFIG_DEFAULT_SERIAL_RXAVAIL_FCT_NAME()==0U) ? FALSE : TRUE); /* true if there are characters in receive buffer */
#endif
#if %'ModuleName'%.CONFIG_USE_MUTEX
  (void)xSemaphoreGiveRecursive(ShellSem);
#endif
  return res;
#else
  return FALSE; /* no serial component set up in properties */
#endif
}

%endif %- KeyPressed
%-BW_METHOD_END KeyPressed
%-************************************************************************************************************
%-BW_METHOD_BEGIN Init
%ifdef Init
%include Common\ShellInit.Inc
void %'ModuleName'%.%Init(void)
{
#if %'ModuleName'%.CONFIG_USE_MUTEX
#if configSUPPORT_STATIC_ALLOCATION
  static StaticSemaphore_t xMutexBuffer;
#endif
  bool schedulerStarted;
  %@CriticalSection@'ModuleName'%.CriticalVariable();

  schedulerStarted = (bool)(xTaskGetSchedulerState()!=taskSCHEDULER_NOT_STARTED);
  if (!schedulerStarted) { /* FreeRTOS not started yet. We are called in PE_low_level_init(), and interrupts are disabled */
    %@CriticalSection@'ModuleName'%.EnterCritical();
  }
#if configSUPPORT_STATIC_ALLOCATION
  ShellSem = xSemaphoreCreateRecursiveMutexStatic(&xMutexBuffer);
#else
  ShellSem = xSemaphoreCreateRecursiveMutex();
#endif
  if (!schedulerStarted) { /* above RTOS call might have enabled interrupts! Make sure we restore the state */
    %@CriticalSection@'ModuleName'%.ExitCritical();
  }
  if (ShellSem==NULL) { /* semaphore creation failed */
    for(;;) {} /* error, not enough memory? */
  }
  vQueueAddToRegistry(ShellSem, "%'ModuleName'%.Sem");
#endif
#if %'ModuleName'%.CONFIG_HISTORY_ENABLED
  {
    int i;

    %'ModuleName'_history_index = 0;
    for(i=0; i<%'ModuleName'%.CONFIG_HISTORY_NOF_ITEMS;i++) {
      %'ModuleName'_history[i][0] = '\0';
    }
  }
#endif
#if %'ModuleName'%.CONFIG_ECHO_ENABLED
  %'ModuleName'_EchoEnabled = TRUE;
#endif
}

%endif %- Init
%-BW_METHOD_END Init
%-************************************************************************************************************
%-BW_METHOD_BEGIN Deinit
%ifdef Deinit
%include Common\ShellDeinit.Inc
void %'ModuleName'%.%Deinit(void)
{
#if %'ModuleName'%.CONFIG_USE_MUTEX
  vQueueUnregisterQueue(ShellSem);
  vSemaphoreDelete(ShellSem);
  ShellSem = NULL;
#endif
}

%endif %- Deinit
%-BW_METHOD_END Deinit
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendData
%ifdef SendData
%define! Pardata
%define! PardataSize
%define! Pario
%include Common\ShellSendData.Inc
/*!
 * \brief Sends data using I/O callbacks
 * \param[in] data Pointer to data to be sent
 * \param[in] io I/O function to be used for sending
 */
void %'ModuleName'%.%SendData(const uint8_t *data, uint16_t dataSize, %'ModuleName'_StdIO_OutErr_FctType io)
{
  while(dataSize>0) {
    io(*data++);
    dataSize--;
  }
}

%endif %- SendData
%-BW_METHOD_END SendData
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG printfPutChar
%define! Pararg
%define! Parc
%include Common\GeneralInternal.inc (printfPutChar)
void %'ModuleName'%.printfPutChar(void *arg, char c)
{
  %'ModuleName'%.StdIO_OutErr_FctType fct = (%'ModuleName'%.StdIO_OutErr_FctType)arg;

  fct(c); /* print character */
}

%-INTERNAL_METHOD_END printfPutChar
%-************************************************************************************************************
%-BW_METHOD_BEGIN printfIO
%ifdef printfIO
%define! Parfmt
%define! Pario
%define! RetVal
%include Common\ShellprintfIO.Inc
unsigned %'ModuleName'%.%printfIO(%'ModuleName'_ConstStdIOType *io, const char *fmt, ...)
{
  va_list args;
  unsigned int count = 0;

  va_start(args,fmt);
  count = %@XFormat@'ModuleName'%.xvformat(%'ModuleName'%.printfPutChar, (void*)io->stdOut, fmt, args);
  va_end(args);
  return count;
}

%endif %- printfIO
%-BW_METHOD_END printfIO
%-************************************************************************************************************
%-BW_METHOD_BEGIN printf
%ifdef printf
%define! Parfmt
%define! RetVal
%include Common\Shellprintf.Inc
unsigned %'ModuleName'%.%printf(const char *fmt, ...)
{
  va_list args;
  unsigned int count = 0;

  va_start(args,fmt);
  count = %@XFormat@'ModuleName'%.xvformat(%'ModuleName'%.printfPutChar, (void*)%'ModuleName'%.%GetStdio()->stdOut, fmt, args);
  va_end(args);
  return count;
}

%endif %- printf
%-BW_METHOD_END printf
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendCharFct
%ifdef SendCharFct
%define! Parch
%define! Parfct
%include Common\ShellSendCharFct.Inc
void %'ModuleName'%.%SendCharFct(uint8_t ch, uint8_t (*fct)(uint8_t ch))
{
#if %'ModuleName'%.CONFIG_BLOCKING_SEND_ENABLED
  uint8_t res;
  #if %'ModuleName'%.CONFIG_BLOCKING_SEND_TIMEOUT_MS>0
  int timeoutMs = %'ModuleName'%.CONFIG_BLOCKING_SEND_TIMEOUT_MS;
  #endif
#endif

#if %'ModuleName'%.CONFIG_USE_MUTEX
  (void)xSemaphoreTakeRecursive(ShellSem, portMAX_DELAY);
#endif
#if %'ModuleName'%.CONFIG_BLOCKING_SEND_ENABLED
  do {
    res = fct((uint8_t)ch);                                      %>40/* Send char, returns error code */
  #if %'ModuleName'%.CONFIG_BLOCKING_SEND_TIMEOUT_MS>0
    if (res==ERR_TXFULL) {
    #if %'ModuleName'%.CONFIG_BLOCKING_SEND_RTOS_WAIT
    %if defined(Wait)
      %@Wait@'ModuleName'%.WaitOSms(%'ModuleName'%.CONFIG_BLOCKING_SEND_TIMEOUT_WAIT_MS);
    %else
      McuWait_WaitOSms(%'ModuleName'%.CONFIG_BLOCKING_SEND_TIMEOUT_WAIT_MS);
    %endif
    #else
    %if defined(Wait)
      %@Wait@'ModuleName'%.Waitms(%'ModuleName'%.CONFIG_BLOCKING_SEND_TIMEOUT_WAIT_MS);
    %else
      MCUWait_Waitms(%'ModuleName'%.CONFIG_BLOCKING_SEND_TIMEOUT_WAIT_MS);
    %endif
    #endif
    }
  #endif
  #if %'ModuleName'%.CONFIG_BLOCKING_SEND_TIMEOUT_MS>0
    if(timeoutMs<=0) {
      break; /* timeout */
    }
    timeoutMs -= %'ModuleName'%.CONFIG_BLOCKING_SEND_TIMEOUT_WAIT_MS;
  #endif
  } while(res==ERR_TXFULL);
#else
  (void)fct((uint8_t)ch);                                        %>40/* non blocking send */
#endif
#if %'ModuleName'%.CONFIG_USE_MUTEX
  (void)xSemaphoreGiveRecursive(ShellSem);
#endif
}

%endif %- SendCharFct
%-BW_METHOD_END SendCharFct
%-************************************************************************************************************
%-BW_METHOD_BEGIN PrintMemory
%ifdef PrintMemory
%define! ParstartAddr
%define! ParendAddr
%define! ParaddrSize
%define! ParbytesPerLine
%define! Parreadfp
%define! Pario
%define! Parhndl
%define! RetVal
%include Common\ShellPrintMemory.Inc
uint8_t %'ModuleName'%.%PrintMemory(void *hndl, uint32_t startAddr, uint32_t endAddr, uint8_t addrSize, uint8_t bytesPerLine, uint8_t (*readfp)(void *, uint32_t, uint8_t*, size_t), %'ModuleName'_ConstStdIOType *io)
{
  #define NOF_BYTES_PER_LINE 32 /* how many bytes are shown on a line. This defines as well the chunk size we read from memory */
  #define MAX_NOF_BYTES_PER_LINE 32
  uint8_t buf[MAX_NOF_BYTES_PER_LINE]; /* this is the chunk of data we get (per line in output) */
  uint8_t str[3*MAX_NOF_BYTES_PER_LINE+((MAX_NOF_BYTES_PER_LINE+1)/8)+1]; /* maximum string for output:
                                              - '3*' because each byte is 2 hex digits plus a space
                                              - '(NOF_BYTES_PER_LINE+1)/8' because we add a space between every 8 byte block
                                              - '+1' for the final zero byte */
  uint32_t addr;
  uint8_t res=0, j, bufSize;
  uint8_t ch;

  if (endAddr<startAddr) {
    %'ModuleName'%.%SendStr((unsigned char*)"\r\n*** End address must be larger or equal than start address\r\n", io->stdErr);
    return ERR_RANGE;
  }
  for(addr=startAddr; addr<=endAddr; /* nothing */ ) {
    if (endAddr-addr+1 >= bytesPerLine) { /* read only part of buffer */
      bufSize = bytesPerLine; /* read full buffer */
    } else {
      bufSize = (uint8_t)(endAddr-addr+1);
    }
    if (readfp(hndl, addr, buf, bufSize)!=ERR_OK) {
      %'ModuleName'%.%SendStr((unsigned char*)"\r\n*** Read failed!\r\n", io->stdErr);
      return ERR_FAILED;
    }
    if (res != ERR_OK) {
      %'ModuleName'%.%SendStr((unsigned char*)"\r\n*** Failure reading memory block!\r\n", io->stdErr);
      return ERR_FAULT;
    }
    /* write address */
    %@Utility@'ModuleName'%.strcpy(str, sizeof(str), (unsigned char*)"0x");
    %@Utility@'ModuleName'%.strcatNumHex(str, sizeof(str), addr, addrSize);
    %@Utility@'ModuleName'%.chcat(str, sizeof(str), ':');
    %'ModuleName'%.%SendStr((unsigned char*)str, io->stdOut);
    /* write data in hex */
    str[0] = '\0';
    for (j=0; j<bufSize; j++) {
      if ((j%8)==0) {
        %@Utility@'ModuleName'%.chcat(str, sizeof(str), ' ');
      }
      %@Utility@'ModuleName'%.strcatNum8Hex(str, sizeof(str), buf[j]);
      %@Utility@'ModuleName'%.chcat(str, sizeof(str), ' ');
    }
    for (/*empty*/; j<bytesPerLine; j++) { /* fill up line */
      %@Utility@'ModuleName'%.strcat(str, sizeof(str), (unsigned char*)"-- ");
    }
    %'ModuleName'%.%SendStr((unsigned char*)str, io->stdOut);
    /* write in ASCII */
    io->stdOut(' ');
    for (j=0; j<bufSize; j++) {
      ch = buf[j];
      if (ch >= ' ' && ch <= 0x7f) {
        io->stdOut(ch);
      } else {
        io->stdOut('.'); /* place holder */
      }
    }
    for (/*empty*/; j<bytesPerLine; j++) { /* fill up line */
      %@Utility@'ModuleName'%.strcat(str, sizeof(str), (unsigned char*)"-- ");
    }
    %'ModuleName'%.%SendStr((unsigned char*)"\r\n", io->stdOut);
    addr += bytesPerLine;
  }
  return ERR_OK;
}

%endif %- PrintMemory
%-BW_METHOD_END PrintMemory
%-************************************************************************************************************
%-BW_IMPLEMENT_END
/* END %ModuleName. */

%include Common\Header.End
%-
%-
%-BW_EVENT_IMPLEMENT_START
%-BW_METHOD_BEGIN OnBeforeIterateCmd
%ifdef OnBeforeIterateCmd
%IMPLEMENTATION OnBeforeIterateCmd
%define! Parcmd
%include Common\ShellOnBeforeIterateCmd.Inc
void %OnBeforeIterateCmd(const uint8_t *cmd)
{
  /* Write your code here ... */
}

%endif %- OnBeforeIterateCmd
%-BW_METHOD_END OnBeforeIterateCmd
%-BW_METHOD_BEGIN OnAfterIterateCmd
%ifdef OnAfterIterateCmd
%IMPLEMENTATION OnAfterIterateCmd
%define! Parcmd
%include Common\ShellOnAfterIterateCmd.Inc
void %OnAfterIterateCmd(const uint8_t *cmd)
{
  /* Write your code here ... */
}

%endif %- OnAfterIterateCmd
%-BW_METHOD_END OnAfterIterateCmd
%-BW_EVENT_IMPLEMENT_END
%INITIALIZATION
%CODE_BEGIN
%if (CPUfamily = "S32K")
#ifdef CPU_INIT_MCUONECLIPSE_DRIVERS
%endif
  %'ModuleName'%.%Init(); /* ### %DeviceType "%DeviceName" init code ... */
%if (CPUfamily = "S32K")
#endif
%endif
%CODE_END
%-
%ENABLE
%CODE_BEGIN
%CODE_END
%-
%ENABLE
%CODE_BEGIN
%CODE_END
%-
%else %- Language (& Compiler)
  %error^ This component is not implemented in selected language & compiler !
%endif %- Language (& Compiler)
%DEBUG
%ALL_SYMBOLS
%-
%-----------------------------------------------------------------------------------------
%if defined(sdk) & %@sdk@ConfigFilesFolderName <> ""
  %define  ConfigSrcDirFolder %%@sdk@ConfigFilesFolderName/
%else
  %define  ConfigSrcDirFolder
%endif
%----------------------------
%FILE %'DirRel_Code'%'ConfigSrcDirFolder'%'ModuleName'config.h
/**
 * \file
 * \brief Configuration header file for Shell
 * Copyright (c) 2020, Erich Styger
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * This header file is used to configure settings of the Shell module.
 */

#ifndef __%'ModuleName'_CONFIG_H
#define __%'ModuleName'_CONFIG_H

#ifndef %'ModuleName'%.CONFIG_BLOCKING_SEND_ENABLED
%if defined(BlockingSend) & %BlockingSend='yes'
  #define %'ModuleName'%.CONFIG_BLOCKING_SEND_ENABLED            %>60(1)
%else
  #define %'ModuleName'%.CONFIG_BLOCKING_SEND_ENABLED            %>60(0)
%endif
    /*!< 1: Sending is blocking (with an optional timeout); 0: Do not block on sending */
#endif

#ifndef %'ModuleName'%.CONFIG_BLOCKING_SEND_TIMEOUT_MS
%if defined(ShellBlockingSendTimeoutMs)
  #define %'ModuleName'%.CONFIG_BLOCKING_SEND_TIMEOUT_MS         %>60(%ShellBlockingSendTimeoutMs)
%else
  #define %'ModuleName'%.CONFIG_BLOCKING_SEND_TIMEOUT_MS         %>60(0)
%endif
    /*!< Total blocking time (timeout) in milliseconds, uses 0 for blocking without a timeout */
#endif

#ifndef %'ModuleName'%.CONFIG_BLOCKING_SEND_TIMEOUT_WAIT_MS
%if defined(WaitTimeMs)
  #define %'ModuleName'%.CONFIG_BLOCKING_SEND_TIMEOUT_WAIT_MS    %>60(%WaitTimeMs)
%else
  #define %'ModuleName'%.CONFIG_BLOCKING_SEND_TIMEOUT_WAIT_MS    %>60(0)
%endif
    /*!< waiting time during blocking, use 0 (zero) for polling */
#endif

#ifndef %'ModuleName'%.CONFIG_BLOCKING_SEND_RTOS_WAIT
%if defined(BlockingSend) & %BlockingSend='yes'
  #define %'ModuleName'%.CONFIG_BLOCKING_SEND_RTOS_WAIT          %>60(1)
%else
  #define %'ModuleName'%.CONFIG_BLOCKING_SEND_RTOS_WAIT          %>60(0)
%endif
    /*!< 1: Use WaitmsOS() instead of Waitms(); 0: Use Waitms() instead of WaitOSms() */
#endif

#ifndef %'ModuleName'%.CONFIG_USE_MUTEX
%if defined(ConsoleSempahore) & %ConsoleSempahore='yes'
  #define %'ModuleName'%.CONFIG_USE_MUTEX                        %>60(1)
%else
  #define %'ModuleName'%.CONFIG_USE_MUTEX                        %>60(0)
%endif
    /*!< 1: use RTOS mutex; 0: do not use RTOS mutex */
#endif

#ifndef %'ModuleName'%.CONFIG_DEFAULT_SHELL_BUFFER_SIZE
%if defined(ShellDefaultBufferSize)
  #define %'ModuleName'%.CONFIG_DEFAULT_SHELL_BUFFER_SIZE        %>60(%ShellDefaultBufferSize)
%else
  #define %'ModuleName'%.CONFIG_DEFAULT_SHELL_BUFFER_SIZE        %>60(0)
%endif
    /*!< default buffer size for shell command parsing */
#endif

#ifndef %'ModuleName'%.CONFIG_DEFAULT_SERIAL
%if defined(Serial)
  #define %'ModuleName'%.CONFIG_DEFAULT_SERIAL                   %>60(1)
%else
  #define %'ModuleName'%.CONFIG_DEFAULT_SERIAL                   %>60(0)
%endif
    /*!< 1: the shell implements its own StdIO which is returned by GetStdio(); 0: The shell does not implement its own standard I/O */
#endif

#if %'ModuleName'%.CONFIG_DEFAULT_SERIAL
  #ifndef %'ModuleName'%.CONFIG_DEFAULT_SERIAL_INCLUDE
  %if defined(Serial)
    #define %'ModuleName'%.CONFIG_DEFAULT_SERIAL_INCLUDE         %>60"%@Serial@'ModuleName'.h"
  %else
    #define %'ModuleName'%.CONFIG_DEFAULT_SERIAL_INCLUDE         %>60"McuSerial.h"
  %endif
      /*!< Include for the functions below */
  #endif

  #ifndef %'ModuleName'%.CONFIG_DEFAULT_SERIAL_RECEIVE_FCT_NAME
  %if defined(Serial)
    #define %'ModuleName'%.CONFIG_DEFAULT_SERIAL_RECEIVE_FCT_NAME%>60%@Serial@'ModuleName'%.RecvChar
  %else
    #define %'ModuleName'%.CONFIG_DEFAULT_SERIAL_RECEIVE_FCT_NAME%>60McuSerial_RecvChar
  %endif
      /*!< Function name to read a character and returning ERR_OK if it was successful */
  #endif

  #ifndef %'ModuleName'%.CONFIG_DEFAULT_SERIAL_SEND_FCT_NAME
  %if defined(Serial)
    #define %'ModuleName'%.CONFIG_DEFAULT_SERIAL_SEND_FCT_NAME   %>60%@Serial@'ModuleName'%.SendChar
  %else
    #define %'ModuleName'%.CONFIG_DEFAULT_SERIAL_SEND_FCT_NAME   %>60McuSerial_SendChar
  %endif
      /*!< Function name to send a character and returning ERR_OK if it was successful */
  #endif

  #ifndef %'ModuleName'%.CONFIG_DEFAULT_SERIAL_RXAVAIL_FCT_NAME
  %if defined(Serial)
    #define %'ModuleName'%.CONFIG_DEFAULT_SERIAL_RXAVAIL_FCT_NAME%>60%@Serial@'ModuleName'%.GetCharsInRxBuf
  %else
    #define %'ModuleName'%.CONFIG_DEFAULT_SERIAL_RXAVAIL_FCT_NAME%>60McuSerial_GetCharsInRxBuf
  %endif
    /*!< Function name to check if there is anything available to receive and returns TRUE, otherwise FALSE */
  #endif
#endif

#ifndef %'ModuleName'%.CONFIG_PROMPT_STRING
%if defined(Prompt)
  #define %'ModuleName'%.CONFIG_PROMPT_STRING                    %>60%Prompt
%else
  #define %'ModuleName'%.CONFIG_PROMPT_STRING                    %>60"CMD>"
%endif
#endif

#ifndef %'ModuleName'%.CONFIG_PROJECT_NAME_STRING
%if defined(ProjectNameStr)
  #define %'ModuleName'%.CONFIG_PROJECT_NAME_STRING              %>60"%ProjectNameStr"
%else
  #define %'ModuleName'%.CONFIG_PROJECT_NAME_STRING              %>60"My Project"
%endif
#endif

#ifndef %'ModuleName'%.CONFIG_MULTI_CMD_ENABLED
%if %MultiCommandEnabled='yes'
  #define %'ModuleName'%.CONFIG_MULTI_CMD_ENABLED                %>60(1) /* 1: enabled, 0: disabled */
%else
  #define %'ModuleName'%.CONFIG_MULTI_CMD_ENABLED                %>60(0) /* 1: enabled, 0: disabled */
%endif
#endif

#ifndef %'ModuleName'%.CONFIG_MULTI_CMD_SIZE
%if defined(MaxSubCommandStringSize)
  #define %'ModuleName'%.CONFIG_MULTI_CMD_SIZE                   %>60(%MaxSubCommandStringSize) /* max size of each command */
%else
  #define %'ModuleName'%.CONFIG_MULTI_CMD_SIZE                   %>60(32) /* max size of each command */
%endif
#endif

#ifndef %'ModuleName'%.CONFIG_MULTI_CMD_CHAR
%if defined(MultiCmdSeparationChar)
  #define %'ModuleName'%.CONFIG_MULTI_CMD_CHAR                   %>60'%MultiCmdSeparationChar' /* separation character */
%else
  #define %'ModuleName'%.CONFIG_MULTI_CMD_CHAR                   %>60';' /* separation character */
%endif
#endif

#ifndef %'ModuleName'%.CONFIG_HISTORY_ENABLED
%if defined(HistoryEnabled) & %HistoryEnabled='yes'
  #define %'ModuleName'%.CONFIG_HISTORY_ENABLED                  %>60(1)
%else
  #define %'ModuleName'%.CONFIG_HISTORY_ENABLED                  %>60(0)
%endif
    /*!< 1: history enabled with <cursor-up> and <cursor-down>; 0: no history functionality */
#endif

#ifndef %'ModuleName'%.CONFIG_HISTORY_NOF_ITEMS
%if defined(NofHistoryItems)
  #define %'ModuleName'%.CONFIG_HISTORY_NOF_ITEMS                %>60(%NofHistoryItems)
%else
  #define %'ModuleName'%.CONFIG_HISTORY_NOF_ITEMS                %>60(5)
%endif
    /*!< number of items in the history */
#endif

#ifndef %'ModuleName'%.CONFIG_HISTORY_ITEM_LENGTH
%if defined(HistLength)
  #define %'ModuleName'%.CONFIG_HISTORY_ITEM_LENGTH              %>60(%HistLength)
%else
  #define %'ModuleName'%.CONFIG_HISTORY_ITEM_LENGTH              %>60(32)
%endif
    /*!< length of a history item */
#endif

#ifndef %'ModuleName'%.CONFIG_HISTORY_CHAR_PREV
%if defined(PrevHistoryChar)
  #define %'ModuleName'%.CONFIG_HISTORY_CHAR_PREV                %>60'%PrevHistoryChar'
%else
  #define %'ModuleName'%.CONFIG_HISTORY_CHAR_PREV                %>60'\e'
%endif
    /*!< character to go to previous item in history */
#endif

#ifndef %'ModuleName'%.CONFIG_HISTORY_CHAR_NEXT
%if defined(NextHistoryChar)
  #define %'ModuleName'%.CONFIG_HISTORY_CHAR_NEXT                %>60'%NextHistoryChar'
%else
  #define %'ModuleName'%.CONFIG_HISTORY_CHAR_NEXT                %>60'\t'
%endif
    /*!< character to go to next item in history */
#endif

#ifndef %'ModuleName'%.CONFIG_ECHO_ENABLED
%if defined(EchoEnabled) & %EchoEnabled='yes'
  #define %'ModuleName'%.CONFIG_ECHO_ENABLED                     %>60(1)
%else
  #define %'ModuleName'%.CONFIG_ECHO_ENABLED                     %>60(0)
%endif
    /*!< 1: shell implements local echo; 0: no echo functionality
     Note that echo needs to be enabled in each I/O too (io->echoEnabled) */
#endif

#ifndef %'ModuleName'%.CONFIG_STATUS_COLON_POS
%if defined(StatusColonPos)
  #define %'ModuleName'%.CONFIG_STATUS_COLON_POS                 %>60(%StatusColonPos)
%else
  #define %'ModuleName'%.CONFIG_STATUS_COLON_POS                 %>60(13)
%endif
   /*!< position of the ':' after the item string for the 'status' command */
#endif

#ifndef %'ModuleName'%.CONFIG_HELP_SEMICOLON_POS
%if defined(HelpSemicolonPos)
  #define %'ModuleName'%.CONFIG_HELP_SEMICOLON_POS               %>60(%HelpSemicolonPos)
%else
  #define %'ModuleName'%.CONFIG_HELP_SEMICOLON_POS               %>60(26)
%endif
 /*!< position of the ';' after the command string for the 'help' command */
#endif

#ifndef %'ModuleName'%.CONFIG_SILENT_PREFIX_CHAR
%if %SilentModePrefixChar='' %- empty property
  #define %'ModuleName'%.CONFIG_SILENT_PREFIX_CHAR               %>60' '
%else
  #define %'ModuleName'%.CONFIG_SILENT_PREFIX_CHAR               %>60'%SilentModePrefixChar'
%endif
    /*!< With this char as first character in the cmd, printing is silent. Use a space to disable it */
#endif

#endif /* __%'ModuleName'_CONFIG_H */
%-----------------------------------------------------------------------------------------
