%-Driver generated by the Component Wizard
%-
%- WARNING !
%-
%- Do not make changes to these lines (if you make some changes, you damage this driver)
%- which begins with:
%-
%-  %-STARTUSERTYPES
%-  %-ENDUSRTYPES
%-  /* END %ModuleName. */
%-  /* MODULE %ModuleName. */
%-  %-INTERNAL_METHOD_BEG
%-  %-INTERNAL_METHOD_END
%-  %-INHERITED_EVENT_BEGIN
%-  %-INHERITED_EVENT_END
%-  %-BW_METHOD_BEGIN
%-  %-BW_METHOD_END
%-  %-BW_DEFINITION_START
%-  %-BW_DEFINITION_END
%-  %-BW_IMPLEMENT_START
%-  %-BW_IMPLEMENT_END
%-  %-BW_EVENT_DEFINITION_START
%-  %-BW_EVENT_DEFINITION_END
%-  %-BW_EVENT_IMPLEMENT_START
%-  %-BW_EVENT_IMPLEMENT_END
%-  %-BW_METHOD_MACROS_START
%-  %-BW_METHOD_MACROS_END
%-  %-BW_SECTIONS_INSERT
%-  %-BW_INTERN_COMMENTS_START
%-  %-BW_INTERN_COMMENTS_END
%-  %-BW_BEAN_CONSTANTS_START
%-  %-BW_BEAN_CONSTANTS_END
%-
%-
%- These lines are not comments, but they are necessary for Component Wizard
%- If you change these lines, Component Wizard will not be responsible for loosing or damaging your code!
%-
%-
%- readyCPU ...
%- readyDEVICE ...
%-
%define DriverAuthor  Author
%define DriverVersion 01.00
%define DriverDate    30.09.2010
%-
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END
%-
%-BW_INTERN_COMMENTS_START
%- List of descriptions of internal methods
%define! Description_SendSeparatedStrings Prints a string using an I/O function, formated for the 'help' command
%-BW_INTERN_COMMENTS_END
%-
%-BW_SECTIONS_INSERT
%if Language='ANSIC'
%-
%-
%INTERFACE
%define! Settings Common\ShellSettings.Inc
%define! Abstract Common\ShellAbstract.Inc
%include Common\Header.h

%if (CPUfamily = "Kinetis")
%if (defined(PEversionDecimal) && (PEversionDecimal <=0 '1283'))
%- MCU10.3 is 1283
#include "PE_LDD.h" /* hack for Processor Expert (e.g. in MCU10.3) and LDD: PE_LDD.h includes at the end all shared modules, causing a recursive header file include conflict */
/* PE version is %PEversionDecimal */
%endif
%endif

#ifndef __%'ModuleName'_H
#define __%'ModuleName'_H

/* MODULE %ModuleName. */
#include <stdint.h>
#include <stdbool.h>

#ifndef bool
  #include "PE_Types.h"
#endif

%-STARTUSERTYPES - Do not make changes between lines (included this lines) marked with %-STARTUSERTYPES and %-ENDUSRTYPES

#ifndef __BWUserType_%'ModuleName'_StdIO_OutErr_FctType
#define __BWUserType_%'ModuleName'_StdIO_OutErr_FctType
  typedef void (*%'ModuleName'%.StdIO_OutErr_FctType)(uint8_t);  %>40/* Callback for an output or error I/O function */
#endif
#ifndef __BWUserType_%'ModuleName'_StdIO_In_FctType
#define __BWUserType_%'ModuleName'_StdIO_In_FctType
  typedef void (*%'ModuleName'%.StdIO_In_FctType)(uint8_t *);    %>40/* Callback for an I/O input function. */
#endif
#ifndef __BWUserType_%'ModuleName'_StdIO_KeyPressed_FctType
#define __BWUserType_%'ModuleName'_StdIO_KeyPressed_FctType
  typedef bool (*%'ModuleName'%.StdIO_KeyPressed_FctType)(void); %>40/* Callback which returns true if a key has been pressed */
#endif
#ifndef __BWUserType_%'ModuleName'_StdIOType
#define __BWUserType_%'ModuleName'_StdIOType
  typedef struct {                                               %>40/* Record containing input, output and error callback (stdin, stdout, stderr). */
    %'ModuleName'_StdIO_In_FctType stdIn;                        %>40/* standard input */
    %'ModuleName'_StdIO_OutErr_FctType stdOut;                   %>40/* standard output */
    %'ModuleName'_StdIO_OutErr_FctType stdErr;                   %>40/* standard error */
    %'ModuleName'_StdIO_KeyPressed_FctType keyPressed;           %>40/* key pressed callback */
  } %'ModuleName'_StdIOType;
#endif
#ifndef __BWUserType_%'ModuleName'_ConstStdIOType
#define __BWUserType_%'ModuleName'_ConstStdIOType
  typedef const %'ModuleName'%.StdIOType %'ModuleName'%.ConstStdIOType;%>40/* constant StdIOType */
#endif
#ifndef __BWUserType_%'ModuleName'_ParseCommandCallback
#define __BWUserType_%'ModuleName'_ParseCommandCallback
  typedef uint8_t (*%'ModuleName'%.ParseCommandCallback)(const uint8_t *cmd, bool *handled, const %'ModuleName'%.StdIOType *io);%>40/* Callback for parsing a shell command */
#endif
#ifndef __BWUserType_%'ModuleName'_ConstStdIOTypePtr
#define __BWUserType_%'ModuleName'_ConstStdIOTypePtr
  typedef const %'ModuleName'%.ConstStdIOType *%'ModuleName'%.ConstStdIOTypePtr;%>40/* Pointer to constant standard I/O descriptor */
#endif
#ifndef __BWUserType_%'ModuleName'_ConstParseCommandCallback
#define __BWUserType_%'ModuleName'_ConstParseCommandCallback
  typedef const %'ModuleName'%.ParseCommandCallback %'ModuleName'%.ConstParseCommandCallback;%>40/* Callback for parsing a shell command */
#endif

%-ENDUSRTYPES


%-BW_BEAN_CONSTANTS_START  - Do not make changes between lines (included this lines) marked with %-BW_BEAN_CONSTANTS_START and %-BW_BEAN_CONSTANTS_END
%- No constants defined in the BeanWizard for this bean
%-BW_BEAN_CONSTANTS_END
%-BW_CUSTOM_USERTYPE_START

/* Include inherited components */
%ifdef InhrSymbolList
  %for var from InhrSymbolList
#include "%@%var@ModuleName.h"
  %endfor
%endif

#if %@sdk@'ModuleName'%.SDK_VERSION_USED == %@sdk@'ModuleName'%.SDK_VERSION_NONE
%ifdef SharedModules
/* Include shared modules, which are used for whole project */
  %for var from IncludeSharedModules
  #include "%'var'.h"
  %endfor
%endif
%-BW_CUSTOM_INCLUDE_START_H
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%-BW_CUSTOM_INCLUDE_END_H
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END
  #include "%ProcessorModule.h"
#endif
#include <stddef.h> /* for size_t */
%- Write your own types here ...
%-  Example:
%-    typedef int TMyInteger;
%-

/* settings for command line history */
%if %HistoryEnabled='yes'
#define %'ModuleName'%.HISTORY_ENABLED   1                       %>40/* 1: enabled, 0: disabled */
#define %'ModuleName'%.NOF_HISTORY       %NofHistoryItems        %>40/* number of items in history */
#define %'ModuleName'%.HIST_LEN          %HistLength             %>40/* history buffer size */
#define %'ModuleName'%.HISTORY_PREV_CHAR '%PrevHistoryChar'      %>40/* character for 'previous' in history */
#define %'ModuleName'%.HISTORY_NEXT_CHAR '%NextHistoryChar'      %>40/* character for 'next' in history */
%else
#define %'ModuleName'%.HISTORY_ENABLED  0                        %>40/* 1: enabled, 0: disabled */
#define %'ModuleName'%.NOF_HISTORY      0                        %>40/* number of items in history */
#define %'ModuleName'%.HIST_LEN         0                        %>40/* history buffer size */
%endif

/* settings for silent prefix char */
%if %SilentModePrefixChar='' %- empty property
#define %'ModuleName'%.SILENT_PREFIX_CHAR    ' '                 %>40/* with this char as first character in the cmd, printing is silent. Use a space to disable it */
%else
#define %'ModuleName'%.SILENT_PREFIX_CHAR    '%SilentModePrefixChar'%>40/* with this char as first character in the cmd, printing is silent. Use a space to disable it */
%endif
#define %'ModuleName'%.NO_SILENT_PREFIX_CHAR ' '                 %>40/* used for no silent prefix char */
#define %'ModuleName'%.SILENT_PREFIX_CHAR_ENABLED (%'ModuleName'%.SILENT_PREFIX_CHAR != %'ModuleName'%.NO_SILENT_PREFIX_CHAR)

/* multi command support */
%if %MultiCommandEnabled='yes'
#define %'ModuleName'%.MULTI_CMD_ENABLED   1 /* 1: enabled, 0: disabled */
#define %'ModuleName'%.MULTI_CMD_SIZE      %MaxSubCommandStringSize /* max size of each command */
#define %'ModuleName'%.MULTI_CMD_CHAR      '%MultiCmdSeparationChar' /* separation character */
%else
#define %'ModuleName'%.MULTI_CMD_ENABLED   0 /* 1: enabled, 0: disabled */
#define %'ModuleName'%.MULTI_CMD_SIZE      0 /* max size of each command */
#define %'ModuleName'%.MULTI_CMD_CHAR      ';' /* separation character */
%endif

/* settings for local echo */
%if %EchoEnabled='yes'
#define %'ModuleName'%.ECHO_ENABLED  1                           %>40/* 1: enabled, 0: disabled */
%else
#define %'ModuleName'%.ECHO_ENABLED  0                           %>40/* 1: enabled, 0: disabled */
%endif

%if defined(Serial)
#define %'ModuleName'%.DEFAULT_SERIAL  1 /* If set to 1, then the shell implements its own StdIO which is returned by %'ModuleName'%.%GetStdio(); */
%else
#define %'ModuleName'%.DEFAULT_SERIAL  0 /* If set to 1, then the shell implements its own StdIO which is returned by %'ModuleName'%.%GetStdio(); */
%endif

#define %'ModuleName'%.DASH_LINE "--------------------------------------------------------------"
/* predefined commands */
#define %'ModuleName'%.CMD_HELP   "help"
#define %'ModuleName'%.CMD_STATUS "status"
%-BW_CUSTOM_USERTYPE_END
%-BW_DEFINITION_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendStr
%ifdef SendStr
void %'ModuleName'%.%SendStr(const uint8_t *str, %'ModuleName'_StdIO_OutErr_FctType io);
%define! Parstr
%define! Pario
%include Common\ShellSendStr.Inc

%endif %- SendStr
%-BW_METHOD_END SendStr
%-************************************************************************************************************
%-BW_METHOD_BEGIN ParseCommand
%ifdef ParseCommand
uint8_t %'ModuleName'%.%ParseCommand(const uint8_t *cmd, bool *handled, %'ModuleName'_ConstStdIOType *io);
%define! Pario
%define! Parcmd
%define! Parhandled
%define! RetVal
%include Common\ShellParseCommand.Inc

%endif %- ParseCommand
%-BW_METHOD_END ParseCommand
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendNum32s
%ifdef SendNum32s
void %'ModuleName'%.%SendNum32s(int32_t val, %'ModuleName'_StdIO_OutErr_FctType io);
%define! Parval
%define! Pario
%include Common\ShellSendNum32s.Inc

%endif %- SendNum32s
%-BW_METHOD_END SendNum32s
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendNum16s
%ifdef SendNum16s
void %'ModuleName'%.%SendNum16s(int16_t val, %'ModuleName'_StdIO_OutErr_FctType io);
%define! Parval
%define! Pario
%include Common\ShellSendNum16s.Inc

%endif %- SendNum16s
%-BW_METHOD_END SendNum16s
%-************************************************************************************************************
%-BW_METHOD_BEGIN PrintPrompt
%ifdef PrintPrompt
void %'ModuleName'%.%PrintPrompt(%'ModuleName'_ConstStdIOType *io);
%define! Pario
%include Common\ShellPrintPrompt.Inc

%endif %- PrintPrompt
%-BW_METHOD_END PrintPrompt
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadLine
%ifdef ReadLine
bool %'ModuleName'%.%ReadLine(uint8_t *bufStart, uint8_t *buf, size_t bufSize, %'ModuleName'_ConstStdIOType *io);
%define! ParbufStart
%define! Parbuf
%define! ParbufSize
%define! Pario
%define! RetVal
%include Common\ShellReadLine.Inc

%endif %- ReadLine
%-BW_METHOD_END ReadLine
%-************************************************************************************************************
%-BW_METHOD_BEGIN PrintStatus
%ifdef PrintStatus
uint8_t %'ModuleName'%.%PrintStatus(%'ModuleName'_ConstStdIOType *io);
%define! Pario
%define! RetVal
%include Common\ShellPrintStatus.Inc

%endif %- PrintStatus
%-BW_METHOD_END PrintStatus
%-************************************************************************************************************
%-BW_METHOD_BEGIN PrintCommandFailed
%ifdef PrintCommandFailed
void %'ModuleName'%.%PrintCommandFailed(const uint8_t *cmd, %'ModuleName'_ConstStdIOType *io);
%define! Pario
%define! Parcmd
%include Common\ShellPrintCommandFailed.Inc

%endif %- PrintCommandFailed
%-BW_METHOD_END PrintCommandFailed
%-************************************************************************************************************
%-BW_METHOD_BEGIN ParseWithCommandTable
%ifdef ParseWithCommandTable
uint8_t %'ModuleName'%.%ParseWithCommandTable(const uint8_t *cmd, %'ModuleName'_ConstStdIOType *io, %'ModuleName'_ConstParseCommandCallback *parseCallback);
%define! Parcmd
%define! Pario
%define! ParparseCallback
%define! RetVal
%include Common\ShellParseWithCommandTable.Inc

%endif %- ParseWithCommandTable
%-BW_METHOD_END ParseWithCommandTable
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetStdio
%ifdef GetStdio
%'ModuleName'_ConstStdIOTypePtr %'ModuleName'%.%GetStdio(void);
%define! RetVal
%include Common\ShellGetStdio.Inc

%endif %- GetStdio
%-BW_METHOD_END GetStdio
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendNum32u
%ifdef SendNum32u
void %'ModuleName'%.%SendNum32u(uint32_t val, %'ModuleName'_StdIO_OutErr_FctType io);
%define! Parval
%define! Pario
%include Common\ShellSendNum32u.Inc

%endif %- SendNum32u
%-BW_METHOD_END SendNum32u
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendNum16u
%ifdef SendNum16u
void %'ModuleName'%.%SendNum16u(uint16_t val, %'ModuleName'_StdIO_OutErr_FctType io);
%define! Parval
%define! Pario
%include Common\ShellSendNum16u.Inc

%endif %- SendNum16u
%-BW_METHOD_END SendNum16u
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendNum8u
%ifdef SendNum8u
void %'ModuleName'%.%SendNum8u(uint8_t val, %'ModuleName'_StdIO_OutErr_FctType io);
%define! Parval
%define! Pario
%include Common\ShellSendNum8u.Inc

%endif %- SendNum8u
%-BW_METHOD_END SendNum8u
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendNum8s
%ifdef SendNum8s
void %'ModuleName'%.%SendNum8s(int8_t val, %'ModuleName'_StdIO_OutErr_FctType io);
%define! Parval
%define! Pario
%include Common\ShellSendNum8s.Inc

%endif %- SendNum8s
%-BW_METHOD_END SendNum8s
%-************************************************************************************************************
%-BW_METHOD_BEGIN Init
%ifdef Init
void %'ModuleName'%.%Init(void);
%include Common\ShellInit.Inc

%endif %- Init
%-BW_METHOD_END Init
%-************************************************************************************************************
%-BW_METHOD_BEGIN RequestSerial
%ifdef RequestSerial
void %'ModuleName'%.%RequestSerial(void);
%include Common\ShellRequestSerial.Inc

%endif %- RequestSerial
%-BW_METHOD_END RequestSerial
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReleaseSerial
%ifdef ReleaseSerial
void %'ModuleName'%.%ReleaseSerial(void);
%include Common\ShellReleaseSerial.Inc

%endif %- ReleaseSerial
%-BW_METHOD_END ReleaseSerial
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendHelpStr
%ifdef SendHelpStr
void %'ModuleName'%.%SendHelpStr(const uint8_t *strCmd, const uint8_t *strHelp, %'ModuleName'_StdIO_OutErr_FctType io);
%define! ParstrCmd
%define! Pario
%define! ParstrHelp
%include Common\ShellSendHelpStr.Inc

%endif %- SendHelpStr
%-BW_METHOD_END SendHelpStr
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendStatusStr
%ifdef SendStatusStr
void %'ModuleName'%.%SendStatusStr(const uint8_t *strItem, const uint8_t *strStatus, %'ModuleName'_StdIO_OutErr_FctType io);
%define! ParstrItem
%define! ParstrStatus
%define! Pario
%include Common\ShellSendStatusStr.Inc

%endif %- SendStatusStr
%-BW_METHOD_END SendStatusStr
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadChar
%ifdef ReadChar
void %'ModuleName'%.%ReadChar(uint8_t *c);
%define! Parc
%include Common\ShellReadChar.Inc

%endif %- ReadChar
%-BW_METHOD_END ReadChar
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendChar
%ifdef SendChar
void %'ModuleName'%.%SendChar(uint8_t ch);
%define! Parch
%include Common\ShellSendChar.Inc

%endif %- SendChar
%-BW_METHOD_END SendChar
%-************************************************************************************************************
%-BW_METHOD_BEGIN KeyPressed
%ifdef KeyPressed
bool %'ModuleName'%.%KeyPressed(void);
%define! RetVal
%include Common\ShellKeyPressed.Inc

%endif %- KeyPressed
%-BW_METHOD_END KeyPressed
%-************************************************************************************************************
%-BW_METHOD_BEGIN Deinit
%ifdef Deinit
void %'ModuleName'%.%Deinit(void);
%include Common\ShellDeinit.Inc

%endif %- Deinit
%-BW_METHOD_END Deinit
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetSemaphore
%ifdef GetSemaphore
void* %'ModuleName'%.%GetSemaphore(void);
%define! RetVal
%include Common\ShellGetSemaphore.Inc

%endif %- GetSemaphore
%-BW_METHOD_END GetSemaphore
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadAndParseWithCommandTable
%ifdef ReadAndParseWithCommandTable
uint8_t %'ModuleName'%.%ReadAndParseWithCommandTable(uint8_t *cmdBuf, size_t cmdBufSize, %'ModuleName'_ConstStdIOType *io, %'ModuleName'_ConstParseCommandCallback *parseCallback);
%define! ParcmdBuf
%define! ParcmdBufSize
%define! Pario
%define! ParparseCallback
%define! RetVal
%include Common\ShellReadAndParseWithCommandTable.Inc

%endif %- ReadAndParseWithCommandTable
%-BW_METHOD_END ReadAndParseWithCommandTable
%-************************************************************************************************************
%-BW_METHOD_BEGIN IterateTable
%ifdef IterateTable
uint8_t %'ModuleName'%.%IterateTable(const uint8_t *cmd, bool *handled, %'ModuleName'_ConstStdIOType *io, %'ModuleName'_ConstParseCommandCallback *parserTable);
%define! Parcmd
%define! Pario
%define! Parhandled
%define! ParparserTable
%define! RetVal
%include Common\ShellIterateTable.Inc

%endif %- IterateTable
%-BW_METHOD_END IterateTable
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetStdio
%ifdef SetStdio
uint8_t %'ModuleName'%.%SetStdio(%'ModuleName'_ConstStdIOTypePtr stdio);
%define! Parstdio
%define! RetVal
%include Common\ShellSetStdio.Inc

%endif %- SetStdio
%-BW_METHOD_END SetStdio
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendData
%ifdef SendData
void %'ModuleName'%.%SendData(const uint8_t *data, uint16_t dataSize, %'ModuleName'_StdIO_OutErr_FctType io);
%define! Pardata
%define! PardataSize
%define! Pario
%include Common\ShellSendData.Inc

%endif %- SendData
%-BW_METHOD_END SendData
%-************************************************************************************************************
%-BW_METHOD_BEGIN IsHistoryCharacter
%ifdef IsHistoryCharacter
bool %'ModuleName'%.%IsHistoryCharacter(uint8_t ch, uint8_t *cmdBuf, size_t cmdBufIdx, bool *isPrev);
%define! ParcmdBuf
%define! ParcmdBufIdx
%define! ParisPrev
%define! Parch
%define! RetVal
%include Common\ShellIsHistoryCharacter.Inc

%endif %- IsHistoryCharacter
%-BW_METHOD_END IsHistoryCharacter
%-BW_DEFINITION_END
/* END %ModuleName. */

#endif
/* ifndef __%'ModuleName'_H */
%include Common\Header.End
%-
%-BW_EVENT_DEFINITION_START
%-BW_METHOD_BEGIN OnBeforeIterateCmd
%ifdef OnBeforeIterateCmd
%INTERFACE OnBeforeIterateCmd
void %OnBeforeIterateCmd(const uint8_t *cmd);
%define! Parcmd
%include Common\ShellOnBeforeIterateCmd.Inc

%endif %- OnBeforeIterateCmd
%-BW_METHOD_END OnBeforeIterateCmd
%-BW_METHOD_BEGIN OnAfterIterateCmd
%ifdef OnAfterIterateCmd
%INTERFACE OnAfterIterateCmd
void %OnAfterIterateCmd(const uint8_t *cmd);
%define! Parcmd
%include Common\ShellOnAfterIterateCmd.Inc

%endif %- OnAfterIterateCmd
%-BW_METHOD_END OnAfterIterateCmd
%-BW_EVENT_DEFINITION_END
%IMPLEMENTATION
%define! Settings Common\ShellSettings.Inc
%define! Abstract Common\ShellAbstract.Inc
%include Common\Header.C

/* MODULE %ModuleName. */
#include <ctype.h> /* for isalnum*/

%for var from EventModules
#include "%var.h"
%endfor
#include "%'ModuleName'.h"
%-BW_CUSTOM_INCLUDE_START_M
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%-BW_CUSTOM_INCLUDE_END_M

%-BW_CUSTOM_VARIABLE_START
%- Write your static variables here
%-   Example:
%-     static int counter1;
%-     int %'ModuleName'%.counter2;
#if %'ModuleName'%.HISTORY_ENABLED
  static uint8_t %'ModuleName'_history[%'ModuleName'%.NOF_HISTORY][%'ModuleName'%.HIST_LEN];%>40/* History buffers */
  static uint8_t %'ModuleName'_history_index = 0;                %>40/* Selected command */
#endif
#if %'ModuleName'%.ECHO_ENABLED
  static bool %'ModuleName'_EchoEnabled = TRUE;
#endif

%if defined(OperatingSystemId) & OperatingSystemId = 'FreeRTOS' & defined(ConsoleSempahore) & %ConsoleSempahore='yes'
#include "FreeRTOS.h"
#include "semphr.h"

%endif
#ifdef __HC08__
  #pragma MESSAGE DISABLE C3303 /* implicit concatenation of strings */
#endif
%if defined(OperatingSystemId) & OperatingSystemId = 'FreeRTOS' & %ConsoleSempahore='yes'
static xSemaphoreHandle ShellSem = NULL; /* Semaphore to protect shell SCI access */
%endif

%if defined(Serial)
static %'ModuleName'_ConstStdIOType %'ModuleName'%.stdio =
{
  (%'ModuleName'_StdIO_In_FctType)%'ModuleName'_ReadChar, /* stdin */
  (%'ModuleName'_StdIO_OutErr_FctType)%'ModuleName'_SendChar, /* stdout */
  (%'ModuleName'_StdIO_OutErr_FctType)%'ModuleName'_SendChar, /* stderr */
  %'ModuleName'_KeyPressed /* if input is not empty */
};
static %'ModuleName'_ConstStdIOType *%'ModuleName'%.currStdIO = &%'ModuleName'%.stdio;
%else
static %'ModuleName'_ConstStdIOType *%'ModuleName'%.currStdIO = NULL; /* needs to be set through %'ModuleName'%.%SetStdio(); */
%endif
%-
%-BW_CUSTOM_VARIABLE_END
%-BW_INTERN_METHOD_DECL_START
%- List of internal methods headers
%-UNLOCKED
/* Internal method prototypes */
%-INTERNAL_LOC_METHOD_BEG SendSeparatedStrings
static void SendSeparatedStrings(const uint8_t *strA, const uint8_t *strB, uint8_t tabChar, uint8_t tabPos, %'ModuleName'_StdIO_OutErr_FctType io);
%-INTERNAL_LOC_METHOD_END SendSeparatedStrings
%-

%-BW_INTERN_METHOD_DECL_END
%-BW_IMPLEMENT_START
%-*****************************************************************************************************


%-************************************************************************************************************
%-BW_METHOD_BEGIN SendStr
%ifdef SendStr
%define! Parstr
%define! Pario
%include Common\ShellSendStr.Inc
/*!
 * \brief Prints a string using I/O callbacks
 * \param[in] str String (zero terminated) to be printed
 * \param[in] io I/O function to be used for printing
 */
void %'ModuleName'%.%SendStr(const uint8_t *str, %'ModuleName'_StdIO_OutErr_FctType io)
{
  while(*str!='\0') {
    io(*str++);
  }
}

%endif %- SendStr
%-BW_METHOD_END SendStr
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendNum32s
%ifdef SendNum32s
%define! Parval
%define! Pario
%include Common\ShellSendNum32s.Inc
void %'ModuleName'%.%SendNum32s(int32_t val, %'ModuleName'_StdIO_OutErr_FctType io)
{
  unsigned char buf[sizeof("-1234567890")];

  %@Utility@'ModuleName'%.Num32sToStr(buf, sizeof(buf), val);
  %'ModuleName'%.%SendStr(buf, io);
}

%endif %- SendNum32s
%-BW_METHOD_END SendNum32s
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendNum32u
%ifdef SendNum32u
%define! Parval
%define! Pario
%include Common\ShellSendNum32u.Inc
void %'ModuleName'%.%SendNum32u(uint32_t val, %'ModuleName'_StdIO_OutErr_FctType io)
{
  unsigned char buf[sizeof("1234567890")];

  %@Utility@'ModuleName'%.Num32uToStr(buf, sizeof(buf), val);
  %'ModuleName'%.%SendStr(buf, io);
}

%endif %- SendNum32u
%-BW_METHOD_END SendNum32u
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendNum16s
%ifdef SendNum16s
%define! Parval
%define! Pario
%include Common\ShellSendNum16s.Inc
void %'ModuleName'%.%SendNum16s(int16_t val, %'ModuleName'_StdIO_OutErr_FctType io)
{
  unsigned char buf[sizeof("-12345")];

  %@Utility@'ModuleName'%.Num16sToStr(buf, sizeof(buf), val);
  %'ModuleName'%.%SendStr(buf, io);
}

%endif %- SendNum16s
%-BW_METHOD_END SendNum16s
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendNum16u
%ifdef SendNum16u
%define! Parval
%define! Pario
%include Common\ShellSendNum16u.Inc
void %'ModuleName'%.%SendNum16u(uint16_t val, %'ModuleName'_StdIO_OutErr_FctType io)
{
  unsigned char buf[sizeof("12345")];

  %@Utility@'ModuleName'%.Num16uToStr(buf, sizeof(buf), val);
  %'ModuleName'%.%SendStr(buf, io);
}

%endif %- SendNum16u
%-BW_METHOD_END SendNum16u
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendNum8u
%ifdef SendNum8u
%define! Parval
%define! Pario
%include Common\ShellSendNum8u.Inc
void %'ModuleName'%.%SendNum8u(uint8_t val, %'ModuleName'_StdIO_OutErr_FctType io)
{
  unsigned char buf[sizeof("123")];

  %@Utility@'ModuleName'%.Num8uToStr(buf, sizeof(buf), val);
  %'ModuleName'%.%SendStr(buf, io);
}

%endif %- SendNum8u
%-BW_METHOD_END SendNum8u
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendNum8s
%ifdef SendNum8s
%define! Parval
%define! Pario
%include Common\ShellSendNum8s.Inc
void %'ModuleName'%.%SendNum8s(int8_t val, %'ModuleName'_StdIO_OutErr_FctType io)
{
  unsigned char buf[sizeof("-123")];

  %@Utility@'ModuleName'%.Num8sToStr(buf, sizeof(buf), val);
  %'ModuleName'%.%SendStr(buf, io);
}

%endif %- SendNum8s
%-BW_METHOD_END SendNum8s
%-************************************************************************************************************
%-BW_METHOD_BEGIN ParseCommand
%ifdef ParseCommand
%define! Pario
%define! Parcmd
%define! Parhandled
%define! RetVal
%include Common\ShellParseCommand.Inc
uint8_t %'ModuleName'%.%ParseCommand(const uint8_t *cmd, bool *handled, %'ModuleName'_ConstStdIOType *io)
{
  if (%@Utility@'ModuleName'%.strcmp((char*)cmd, %'ModuleName'%.CMD_HELP)==0 || %@Utility@'ModuleName'%.strcmp((char*)cmd, "%'ModuleName' help")==0) {
    %'ModuleName'%.%SendStr((unsigned char*)"\r\n", io->stdOut);
    %'ModuleName'%.%SendStr((unsigned char*)%'ModuleName'%.DASH_LINE, io->stdOut);
    %'ModuleName'%.%SendStr((unsigned char*)"\r\n", io->stdOut);
    %'ModuleName'%.%SendStr((unsigned char*)"%ProjectNameStr", io->stdOut);
    %'ModuleName'%.%SendStr((unsigned char*)"\r\n", io->stdOut);
    %'ModuleName'%.%SendStr((unsigned char*)%'ModuleName'%.DASH_LINE, io->stdOut);
    %'ModuleName'%.%SendStr((unsigned char*)"\r\n", io->stdOut);
    %'ModuleName'%.%SendHelpStr((unsigned char*)"%'ModuleName'", (const unsigned char*)"Group of %'ModuleName' commands\r\n", io->stdOut);
%if defined(PrintStatus)
    %'ModuleName'%.%SendHelpStr((unsigned char*)"  help|status", (const unsigned char*)"Print help or status information\r\n", io->stdOut);
%else %- only help
    %'ModuleName'%.%SendHelpStr((unsigned char*)"  help", (const unsigned char*)"Prints help\r\n", io->stdOut);
%endif
#if %'ModuleName'%.ECHO_ENABLED
    %'ModuleName'%.%SendHelpStr((unsigned char*)"  echo (on|off)", (const unsigned char*)"Turn echo on or off\r\n", io->stdOut);
#endif
    *handled = TRUE;
    return ERR_OK;
#if %'ModuleName'%.ECHO_ENABLED
  } else if ((%@Utility@'ModuleName'%.strcmp((char*)cmd, "%'ModuleName' echo on")==0)) {
    *handled = TRUE;
    %'ModuleName'%.EchoEnabled = TRUE;
    return ERR_OK;
  } else if ((%@Utility@'ModuleName'%.strcmp((char*)cmd, "%'ModuleName' echo off")==0)) {
    *handled = TRUE;
    %'ModuleName'%.EchoEnabled = FALSE;
    return ERR_OK;
#endif
%if defined(PrintStatus)
  } else if ((%@Utility@'ModuleName'%.strcmp((char*)cmd, %'ModuleName'%.CMD_STATUS)==0) || (%@Utility@'ModuleName'%.strcmp((char*)cmd, "%'ModuleName' status")==0)) {
    *handled = TRUE;
    return %'ModuleName'%.%PrintStatus(io);
%endif
  }
  return ERR_OK; /* no error */
}

%endif %- ParseCommand
%-BW_METHOD_END ParseCommand
%-************************************************************************************************************
%-BW_METHOD_BEGIN PrintPrompt
%ifdef PrintPrompt
%define! Pario
%include Common\ShellPrintPrompt.Inc
void %'ModuleName'%.%PrintPrompt(%'ModuleName'_ConstStdIOType *io)
{
  %'ModuleName'%.%SendStr((unsigned char*)%Prompt, io->stdOut);
}

%endif %- PrintPrompt
%-BW_METHOD_END PrintPrompt
%-************************************************************************************************************
%-BW_METHOD_BEGIN IsHistoryCharacter
%ifdef IsHistoryCharacter
%define! ParcmdBuf
%define! ParcmdBufIdx
%define! ParisPrev
%define! Parch
%define! RetVal
%include Common\ShellIsHistoryCharacter.Inc
bool %'ModuleName'%.%IsHistoryCharacter(uint8_t ch, uint8_t *cmdBuf, size_t cmdBufIdx, bool *isPrev)
{
  *isPrev = FALSE;
#if %'ModuleName'%.HISTORY_ENABLED
  if (   cmdBufIdx==0 /* first character on command line */
      || (%@Utility@'ModuleName'%.strcmp(cmdBuf, %'ModuleName'%.history[%'ModuleName'%.history_index])==0) /* pressing prev/next character on previous history element */
      )
  {
    if (ch==%'ModuleName'%.HISTORY_PREV_CHAR) {
      *isPrev = TRUE;
      return TRUE;
    } else if (ch==%'ModuleName'%.HISTORY_NEXT_CHAR) {
      *isPrev = FALSE;
      return TRUE;
    }
  }
#if 0
  if (cmdBufIdx==0 || cmdBufIdx==2) { /* accept only first character or sequence as history sequence */
    if (cmdBufIdx==2 && cmdBuf[0]==0x1b && cmdBuf[1]==0x5b) {
      /* up:    0x27 0x5b 0x41
       * down:  0x27 0x5b 0x42
       * right: 0x27 0x5b 0x43
       * left:  0x27 0x5b 0x44
       */
      if (cmdBuf[2]==0x41 /* up */ || cmdBuf[2]==0x44 /* left */) {
        *isPrev = TRUE;
        return TRUE;
      } else if (cmdBuf[2]==0x42 /* down */ || cmdBuf[2]==0x43 /* right */) {
        *isPrev = FALSE;
        return TRUE;
      }
    }
    /* \todo: handle TAB and SHIFT-TAB */
  }
#endif
#else
  (void)ch; /* not used */
  (void)cmdBuf; /* not used */
  (void)cmdBufIdx; /* not used */
#endif
  return FALSE;
}

%endif %- IsHistoryCharacter
%-BW_METHOD_END IsHistoryCharacter
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadLine
%ifdef ReadLine
%define! ParbufStart
%define! Parbuf
%define! ParbufSize
%define! Pario
%define! RetVal
%include Common\ShellReadLine.Inc
bool %'ModuleName'%.%ReadLine(uint8_t *bufStart, uint8_t *buf, size_t bufSize, %'ModuleName'_ConstStdIOType *io)
{
  uint8_t c;
  bool isBackwardHistory;

  if (io->keyPressed()) {
    for(;;) {                                                    %>40/* while not '\r' or '\n' */
      c = '\0';                                                  %>40/* initialize character */
      io->stdIn(&c);                                             %>40/* read character */
      if (c=='\0') { /* nothing in rx buffer? Something is wrong... */
        break; /* get out of loop */
      }
      if (c=='\b' || c=='\177') {                                %>40/* check for backspace */
        if (buf > bufStart) {                                    %>40/* Avoid buffer underflow */
#if %'ModuleName'%.ECHO_ENABLED
           if (%'ModuleName'_EchoEnabled) {
             io->stdOut('\b');                                   %>40/* delete character on terminal */
             io->stdOut(' ');
             io->stdOut('\b');
           }
#endif
           buf--;                                                %>40/* delete last character in buffer */
           *buf = '\0';
           bufSize++;
        }
      } else if (%'ModuleName'%.%IsHistoryCharacter(c, bufStart, buf-bufStart, &isBackwardHistory)) {
#if %'ModuleName'%.HISTORY_ENABLED
        uint8_t cBuf[3]={'\0','\0','\0'}, cBufIdx = 0;
        bool prevInHistory;
#endif

        while (c!='\0') {                                        %>40/* empty the rx buffer (escape sequence) */
#if %'ModuleName'%.HISTORY_ENABLED
           cBuf[cBufIdx] = c;
           cBufIdx++;
           if (cBufIdx==sizeof(cBuf)) {
             cBufIdx = 0; /* ring buffer */
           }
#endif
           c = '\0';                                             %>40/* initialize character */
           io->stdIn(&c);                                        %>40/* read character */
        }
#if %'ModuleName'%.HISTORY_ENABLED
        /* if not an alphanumeric switch to history  */
        prevInHistory = cBufIdx==0 && cBuf[0]==0x1b && cBuf[1]==0x5b && (cBuf[2]==0x41 /*up*/ || cBuf[2]==0x44 /*left*/);
        /* up:    0x27 0x5b 0x41
         * down:  0x27 0x5b 0x42
         * right: 0x27 0x5b 0x43
         * left:  0x27 0x5b 0x44
         */
        if (prevInHistory) {
          %@Utility@'ModuleName'%.strcpy(bufStart, %'ModuleName'%.HIST_LEN, %'ModuleName'_history[%'ModuleName'_history_index]);
          %'ModuleName'_history_index++;                         %>40/* update the index */
          if (%'ModuleName'_history_index==%'ModuleName'%.NOF_HISTORY) {
            %'ModuleName'_history_index = 0;
          }
        } else {
          if (%'ModuleName'_history_index==0) {
            %'ModuleName'_history_index = (%'ModuleName'%.NOF_HISTORY-1);
          } else {
            %'ModuleName'_history_index--;
          }
          %@Utility@'ModuleName'%.strcpy(bufStart, %'ModuleName'%.HIST_LEN, %'ModuleName'_history[%'ModuleName'_history_index]);
        }
        bufSize = bufSize + buf - bufStart - %@Utility@'ModuleName'%.strlen(bufStart);%>40/* update the buffer */
        buf = bufStart + %@Utility@'ModuleName'%.strlen(bufStart);
#endif
#if %'ModuleName'%.ECHO_ENABLED
        if (%'ModuleName'_EchoEnabled) {
          %'ModuleName'%.%SendStr((unsigned char*)"\r\n", io->stdOut);
          %'ModuleName'%.%PrintPrompt(io);
          %'ModuleName'%.%SendStr(bufStart, io->stdOut);
        }
#endif
      } else {
#if %'ModuleName'%.ECHO_ENABLED
        if (%'ModuleName'_EchoEnabled) {
          io->stdOut(c);                                         %>40/* echo character */
        }
#endif
        *buf = (uint8_t)c;                                       %>40/* append character to the string */
        buf++;
        bufSize--;
        if ((c=='\r') || (c=='\n')) {
#if %'ModuleName'%.ECHO_ENABLED
          if (%'ModuleName'_EchoEnabled) {
            %'ModuleName'%.%SendStr((unsigned char*)"\n", io->stdOut);
          }
#endif
#if %'ModuleName'%.HISTORY_ENABLED
          if ((bufStart[0] != '\0') && (bufStart[0] != '\r') && (bufStart[0] != '\n')) {
            int i;

            for(i=%'ModuleName'%.NOF_HISTORY-1; i>0;i--) {
              %@Utility@'ModuleName'%.strcpy(%'ModuleName'_history[i], %'ModuleName'%.HIST_LEN, %'ModuleName'_history[i-1]);%>40/* move previous commands */
            }
            %'ModuleName'_history_index = 0;                     %>40/* update the history with the current command */
            %@Utility@'ModuleName'%.strcpy(%'ModuleName'_history[0], %'ModuleName'%.HIST_LEN, bufStart);%>40/* add the current command to the history */
            if (buf-bufStart <= %'ModuleName'%.HIST_LEN) {       %>40/* size check */
              %'ModuleName'_history[0][buf-bufStart-1] = '\0';
            } else {
              %'ModuleName'_history[0][%'ModuleName'%.HIST_LEN-1] = '\0';
            }
          }
#endif
          break;
        }
        if (bufSize <= 1) {                                      %>40/* buffer full */
          break;
        }
      }
    } /* for */
    *buf = '\0';                                                 %>40/* zero terminate string */
    return TRUE;
  } else {
    return FALSE;
  }
}

%endif %- ReadLine
%-BW_METHOD_END ReadLine
%-************************************************************************************************************
%-BW_METHOD_BEGIN PrintStatus
%ifdef PrintStatus
%define! Pario
%define! RetVal
%include Common\ShellPrintStatus.Inc
uint8_t %'ModuleName'%.%PrintStatus(%'ModuleName'_ConstStdIOType *io)
{
  %'ModuleName'%.%SendStatusStr((const unsigned char*)"%'ModuleName'", (const unsigned char*)"\r\n", io->stdOut);
  %'ModuleName'%.%SendStatusStr((const unsigned char*)"  Build", (const unsigned char*)__DATE__, io->stdOut);
  %'ModuleName'%.%SendStr((unsigned char*)" ", io->stdOut);
  %'ModuleName'%.%SendStr((unsigned char*)__TIME__, io->stdOut);
  %'ModuleName'%.%SendStr((unsigned char*)"\r\n", io->stdOut);
#if %'ModuleName'%.ECHO_ENABLED
  %'ModuleName'%.%SendStatusStr((const unsigned char*)"  echo", %'ModuleName'_EchoEnabled?(const unsigned char*)"On\r\n":(const unsigned char*)"Off\r\n", io->stdOut);
#endif
  return ERR_OK;
}

%endif %- PrintStatus
%-BW_METHOD_END PrintStatus
%-************************************************************************************************************
%-BW_METHOD_BEGIN PrintCommandFailed
%ifdef PrintCommandFailed
%define! Pario
%define! Parcmd
%include Common\ShellPrintCommandFailed.Inc
void %'ModuleName'%.%PrintCommandFailed(const uint8_t *cmd, %'ModuleName'_ConstStdIOType *io)
{
  %'ModuleName'%.%SendStr((unsigned char*)"*** Failed or unknown command: ", io->stdErr);
  %'ModuleName'%.%SendStr(cmd, io->stdErr);
  %'ModuleName'%.%SendStr((unsigned char*)"\r\n", io->stdErr);
  %'ModuleName'%.%SendStr((unsigned char*)"*** Type ", io->stdErr);
  %'ModuleName'%.%SendStr((unsigned char*)%'ModuleName'%.CMD_HELP, io->stdErr);
  %'ModuleName'%.%SendStr((unsigned char*)" to get a list of available commands\r\n", io->stdErr);
}

%endif %- PrintCommandFailed
%-BW_METHOD_END PrintCommandFailed
%-************************************************************************************************************
%-BW_METHOD_BEGIN IterateTable
%ifdef IterateTable
%define! Parcmd
%define! Pario
%define! Parhandled
%define! ParparserTable
%define! RetVal
%include Common\ShellIterateTable.Inc
uint8_t %'ModuleName'%.%IterateTable(const uint8_t *cmd, bool *handled, %'ModuleName'_ConstStdIOType *io, %'ModuleName'_ConstParseCommandCallback *parserTable)
{
  uint8_t res = ERR_OK;

  if (parserTable==NULL) { /* no table??? */
    return ERR_FAILED;
  }
  if (io==NULL) { /* no IO handler??? */
    return ERR_FAILED;
  }
  /* iterate through all parser functions in table */
  while(*parserTable!=NULL) {
  %if defined(OnBeforeIterateCmd)
    %OnBeforeIterateCmd(cmd);
  %endif
    if ((*parserTable)(cmd, handled, io)!=ERR_OK) {
      res = ERR_FAILED;
    }
  %if defined(OnAfterIterateCmd)
    %OnAfterIterateCmd(cmd);
  %endif
    parserTable++;
  }
  return res;
}

%endif %- IterateTable
%-BW_METHOD_END IterateTable
%-************************************************************************************************************
%-BW_METHOD_BEGIN ParseWithCommandTable
%ifdef ParseWithCommandTable
%define! Parcmd
%define! Pario
%define! ParparseCallback
%define! RetVal
%include Common\ShellParseWithCommandTable.Inc
uint8_t %'ModuleName'%.%ParseWithCommandTable(const uint8_t *cmd, %'ModuleName'_ConstStdIOType *io, %'ModuleName'_ConstParseCommandCallback *parseCallback)
{
  uint8_t res = ERR_OK;
  bool handled;
#if %'ModuleName'%.SILENT_PREFIX_CHAR_ENABLED
  bool silent = FALSE;
#endif
#if %'ModuleName'%.MULTI_CMD_ENABLED
  uint8_t buf[%'ModuleName'%.MULTI_CMD_SIZE];
  uint8_t i;
  bool parseBuffer, finished;
#endif

  if (io==NULL) { /* no I/O handler? */
    return ERR_FAILED;
  }
  if (*cmd=='\0') { /* empty command */
    return ERR_OK;
  }
#if %'ModuleName'%.MULTI_CMD_ENABLED
  parseBuffer = FALSE;
  finished = FALSE;
  i = 0;
  for(;;) { /* breaks */
    if (i>sizeof(buf)-2) {
      res = ERR_FAILED;
      break; /* buffer overflow */
    }
    buf[i] = *cmd;
    cmd++; i++;
  #if %'ModuleName'%.SILENT_PREFIX_CHAR_ENABLED
    if (i==1 && buf[0]==%'ModuleName'%.SILENT_PREFIX_CHAR) { /* first character is silent character */
      silent |= (bool)(buf[0]==%'ModuleName'%.SILENT_PREFIX_CHAR);
      buf[0] = *cmd; /* skip silent character */
      cmd++;
    }
  #endif
    if (buf[i-1] == %'ModuleName'%.MULTI_CMD_CHAR) { /* found separator */
      buf[i-1] = '\0';
      parseBuffer = TRUE;
    } else if (buf[i-1]=='\0') {
      parseBuffer = TRUE;
      finished = TRUE;
    }
    if (parseBuffer) {
      handled = FALSE;
      res = %'ModuleName'%.IterateTable(buf, &handled, io, parseCallback); /* iterate through all parser functions in table */
      if (!handled || res!=ERR_OK) { /* no handler has handled the command, or error? */
        %'ModuleName'%.PrintCommandFailed(buf, io);
        res = ERR_FAILED;
      }
      parseBuffer = FALSE;
      i = 0; /* restart */
    }
    if (finished) {
      break; /* get out of loop */
    }
  } /* for */
#else
  #if %'ModuleName'%.SILENT_PREFIX_CHAR_ENABLED
  silent = (bool)(*cmd==%'ModuleName'%.SILENT_PREFIX_CHAR);
  if (silent) {
    cmd++; /* skip silent character */
  }
  #endif
  handled = FALSE;
  res = %'ModuleName'%.IterateTable(cmd, &handled, io, parseCallback); /* iterate through all parser functions in table */
  if (!handled || res!=ERR_OK) { /* no handler has handled the command? */
    %'ModuleName'%.PrintCommandFailed(cmd, io);
    res = ERR_FAILED;
  }
#endif
#if %'ModuleName'%.SILENT_PREFIX_CHAR_ENABLED
  if (!silent) {
    %'ModuleName'%.PrintPrompt(io);
  }
#else
  %'ModuleName'%.PrintPrompt(io);
#endif
  return res;
}

%endif %- ParseWithCommandTable
%-BW_METHOD_END ParseWithCommandTable
%-************************************************************************************************************
%-BW_METHOD_BEGIN SetStdio
%ifdef SetStdio
%define! Parstdio
%define! RetVal
%include Common\ShellSetStdio.Inc
uint8_t %'ModuleName'%.%SetStdio(%'ModuleName'_ConstStdIOTypePtr stdio)
{
  %'ModuleName'%.currStdIO = stdio;
  return ERR_OK;
}

%endif %- SetStdio
%-BW_METHOD_END SetStdio
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetStdio
%ifdef GetStdio
%define! RetVal
%include Common\ShellGetStdio.Inc
%'ModuleName'_ConstStdIOTypePtr %'ModuleName'%.%GetStdio(void)
{
  return %'ModuleName'%.currStdIO;
}

%endif %- GetStdio
%-BW_METHOD_END GetStdio
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadAndParseWithCommandTable
%ifdef ReadAndParseWithCommandTable
%define! ParcmdBuf
%define! ParcmdBufSize
%define! Pario
%define! ParparseCallback
%define! RetVal
%include Common\ShellReadAndParseWithCommandTable.Inc
uint8_t %'ModuleName'%.%ReadAndParseWithCommandTable(uint8_t *cmdBuf, size_t cmdBufSize, %'ModuleName'_ConstStdIOType *io, %'ModuleName'_ConstParseCommandCallback *parseCallback)
{
  /* IMPORTANT NOTE: this function *appends* to the buffer, so the buffer needs to be initialized first! */
  uint8_t res = ERR_OK;
  size_t len;

  if (io==NULL) { /* no I/O handler? */
    return ERR_FAILED;
  }
  len = %@Utility@'ModuleName'%.strlen((const char*)cmdBuf);
  if (%'ModuleName'%.ReadLine(cmdBuf, cmdBuf+len, cmdBufSize-len, io)) {
    len = %@Utility@'ModuleName'%.strlen((const char*)cmdBuf);   %>40/* length of buffer string */
    if (len==0) { /* error case */
      return ERR_FAILED;
    } else if (len==1 && (cmdBuf[0]=='\n' || cmdBuf[0]=='\r')) { %>40/* eat preceding newline characters */
      cmdBuf[0] = '\0';
    }
    if (len>=cmdBufSize-1) {                                     %>40/* buffer overflow? Parse what we have, will be likely return an error */
      (void)%'ModuleName'%.%ParseWithCommandTable(cmdBuf, io, parseCallback);
      cmdBuf[0] = '\0'; /* start again */
      res = ERR_OVERFLOW;
    } else if (cmdBuf[len-1]=='\n' || cmdBuf[len-1]=='\r') {     %>40/* line end: parse command */
      cmdBuf[len-1] = '\0';                                      %>40/* remove line end character for parser */
      res = %'ModuleName'%.%ParseWithCommandTable(cmdBuf, io, parseCallback);
      cmdBuf[0] = '\0';                                          %>40/* start again */
    } else {
      /* continue to append to buffer */
    }
  }
  return res;
}

%endif %- ReadAndParseWithCommandTable
%-BW_METHOD_END ReadAndParseWithCommandTable
%-************************************************************************************************************
%-BW_METHOD_BEGIN RequestSerial
%ifdef RequestSerial
%include Common\ShellRequestSerial.Inc
void %'ModuleName'%.%RequestSerial(void)
{
%if defined(OperatingSystemId) & OperatingSystemId = 'FreeRTOS' & defined(ConsoleSempahore) & %ConsoleSempahore='yes'
  (void)xSemaphoreTakeRecursive(ShellSem, portMAX_DELAY);
%endif
}

%endif %- RequestSerial
%-BW_METHOD_END RequestSerial
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReleaseSerial
%ifdef ReleaseSerial
%include Common\ShellReleaseSerial.Inc
void %'ModuleName'%.%ReleaseSerial(void)
{
%if defined(OperatingSystemId) & OperatingSystemId = 'FreeRTOS' & defined(ConsoleSempahore) & %ConsoleSempahore='yes'
  (void)xSemaphoreGiveRecursive(ShellSem);
%endif
}

%endif %- ReleaseSerial
%-BW_METHOD_END ReleaseSerial
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetSemaphore
%ifdef GetSemaphore
%define! RetVal
%include Common\ShellGetSemaphore.Inc
void* %'ModuleName'%.%GetSemaphore(void)
{
%if defined(OperatingSystemId) & OperatingSystemId = 'FreeRTOS' & defined(ConsoleSempahore) & %ConsoleSempahore='yes'
  return ShellSem;
%else
  return NULL;
%endif
}

%endif %- GetSemaphore
%-BW_METHOD_END GetSemaphore
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG SendSeparatedStrings
%define! ParstrA
%define! ParstrB
%define! PartabChar
%define! PartabPos
%define! Pario
%include Common\GeneralInternalGlobal.inc (SendSeparatedStrings)
static void SendSeparatedStrings(const uint8_t *strA, const uint8_t *strB, uint8_t tabChar, uint8_t tabPos, %'ModuleName'_StdIO_OutErr_FctType io)
{
  /* write command part */
  while(*strA!='\0' && tabPos>0) {
    io(*strA++);
    tabPos--;
  }
  /* fill up until ';' */
  while(tabPos>0) {
    io(' ');
    tabPos--;
  }
  /* write separator */
  io(tabChar);
  io(' ');
  /* write help text */
  %'ModuleName'%.%SendStr(strB, io);
}

%-INTERNAL_METHOD_END SendSeparatedStrings
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendHelpStr
%ifdef SendHelpStr
%define! ParstrCmd
%define! Pario
%define! ParstrHelp
%include Common\ShellSendHelpStr.Inc
void %'ModuleName'%.%SendHelpStr(const uint8_t *strCmd, const uint8_t *strHelp, %'ModuleName'_StdIO_OutErr_FctType io)
{
  #define HELP_SEMICOLON_POS  %HelpSemicolonPos /* position of the ';' after the command string */
  SendSeparatedStrings(strCmd, strHelp, ';', HELP_SEMICOLON_POS, io);
}

%endif %- SendHelpStr
%-BW_METHOD_END SendHelpStr
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendStatusStr
%ifdef SendStatusStr
%define! ParstrItem
%define! ParstrStatus
%define! Pario
%include Common\ShellSendStatusStr.Inc
void %'ModuleName'%.%SendStatusStr(const uint8_t *strItem, const uint8_t *strStatus, %'ModuleName'_StdIO_OutErr_FctType io)
{
  #define STATUS_COLON_POS  %StatusColonPos /* position of the ':' after the item string */
  SendSeparatedStrings(strItem, strStatus, ':', STATUS_COLON_POS, io);
}

%endif %- SendStatusStr
%-BW_METHOD_END SendStatusStr
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadChar
%ifdef ReadChar
%define! Parc
%include Common\ShellReadChar.Inc
void %'ModuleName'%.%ReadChar(uint8_t *c)
{
%if defined(Serial)
  uint8_t res;

%if defined(OperatingSystemId) & OperatingSystemId = 'FreeRTOS' & defined(ConsoleSempahore) & %ConsoleSempahore='yes'
  (void)xSemaphoreTakeRecursive(ShellSem, portMAX_DELAY);
%endif
%if defined(Serial)
  res = %@Serial@'ModuleName'%.RecvChar((uint8_t*)c);
  if (res==ERR_RXEMPTY) {
    /* no character in buffer */
    *c = '\0';
  }
%endif
%if defined(OperatingSystemId) & OperatingSystemId = 'FreeRTOS' & defined(ConsoleSempahore) & %ConsoleSempahore='yes'
  (void)xSemaphoreGiveRecursive(ShellSem);
%endif
%else
  *c = '\0';
  return; /* no serial component set up in properties */
%endif
}

%endif %- ReadChar
%-BW_METHOD_END ReadChar
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendChar
%ifdef SendChar
%define! Parch
%include Common\ShellSendChar.Inc
void %'ModuleName'%.%SendChar(uint8_t ch)
{
%if defined(Serial)
  %if BlockingSend='yes'
  uint8_t res;
  %endif
%if defined(ShellBlockingSendTimeoutMs) & %ShellBlockingSendTimeoutMs >. '0' & defined(WaitTimeMs) & WaitTimeMs >. '0'
  int timeoutMs = %ShellBlockingSendTimeoutMs;

%endif

%if defined(OperatingSystemId) & OperatingSystemId = 'FreeRTOS' & defined(ConsoleSempahore) & %ConsoleSempahore='yes'
  (void)xSemaphoreTakeRecursive(ShellSem, portMAX_DELAY);
%endif
 %if defined(Serial)
  %if BlockingSend='yes'
  do {
    res = %@Serial@'ModuleName'%.SendChar((uint8_t)ch);          %>40/* Send char */
  %if defined(WaitTimeMs) & WaitTimeMs >. '0'
    if (res==ERR_TXFULL) {
    %if defined(RTOSWait) & RTOSWait='yes'
      %@Wait@'ModuleName'%.WaitOSms(%WaitTimeMs);
    %else
      %@Wait@'ModuleName'%.Waitms(%WaitTimeMs);
    %endif
    }
  %endif
  %if defined(ShellBlockingSendTimeoutMs) & %ShellBlockingSendTimeoutMs >. '0'
    if(timeoutMs<=0) {
      break; /* timeout */
    }
    timeoutMs -= %WaitTimeMs;
  %endif
  } while(res==ERR_TXFULL);
  %else
  (void)%@Serial@'ModuleName'%.SendChar((uint8_t)ch);            %>40/* non blocking send */
  %endif
 %endif
%if defined(OperatingSystemId) & OperatingSystemId = 'FreeRTOS' & defined(ConsoleSempahore) & %ConsoleSempahore='yes'
  (void)xSemaphoreGiveRecursive(ShellSem);
%endif
%else
  (void)ch;                                                      %>40/* avoid compiler warning about unused argument */
  return;                                                        %>40/* no serial component set up in properties */
%endif
}

%endif %- SendChar
%-BW_METHOD_END SendChar
%-************************************************************************************************************
%-BW_METHOD_BEGIN KeyPressed
%ifdef KeyPressed
%define! RetVal
%include Common\ShellKeyPressed.Inc
bool %'ModuleName'%.%KeyPressed(void)
{
%if defined(Serial)
  bool res;

%if defined(OperatingSystemId) & OperatingSystemId = 'FreeRTOS' & defined(ConsoleSempahore) & %ConsoleSempahore='yes'
  (void)xSemaphoreTakeRecursive(ShellSem, portMAX_DELAY);
%endif
%if defined(Serial)
  res = (bool)((%@Serial@'ModuleName'%.GetCharsInRxBuf()==0U) ? FALSE : TRUE); /* true if there are characters in receive buffer */
%endif
%if defined(OperatingSystemId) & OperatingSystemId = 'FreeRTOS' & defined(ConsoleSempahore) & %ConsoleSempahore='yes'
  (void)xSemaphoreGiveRecursive(ShellSem);
%endif
  return res;
%else
  return FALSE; /* no serial component set up in properties */
%endif
}

%endif %- KeyPressed
%-BW_METHOD_END KeyPressed
%-************************************************************************************************************
%-BW_METHOD_BEGIN Init
%ifdef Init
%include Common\ShellInit.Inc
void %'ModuleName'%.%Init(void)
{
%if defined(OperatingSystemId) & OperatingSystemId = 'FreeRTOS' & defined(ConsoleSempahore) & %ConsoleSempahore='yes'
  bool schedulerStarted;
  %@CriticalSection@'ModuleName'%.CriticalVariable();

  schedulerStarted = (bool)(xTaskGetSchedulerState()!=taskSCHEDULER_NOT_STARTED);
  if (!schedulerStarted) { /* FreeRTOS not started yet. We are called in PE_low_level_init(), and interrupts are disabled */
    %@CriticalSection@'ModuleName'%.EnterCritical();
  }
  ShellSem = xSemaphoreCreateRecursiveMutex();
  if (!schedulerStarted) { /* above RTOS call might have enabled interrupts! Make sure we restore the state */
    %@CriticalSection@'ModuleName'%.ExitCritical();
  }
  if (ShellSem==NULL) { /* semaphore creation failed */
    for(;;) {} /* error, not enough memory? */
  }
  vQueueAddToRegistry(ShellSem, "%'ModuleName'%.Sem");
%endif
#if %'ModuleName'%.HISTORY_ENABLED
  {
    int i;

    %'ModuleName'_history_index = 0;
    for(i=0; i<%'ModuleName'%.NOF_HISTORY;i++) {
      %'ModuleName'_history[i][0] = '\0';
    }
  }
#endif
#if %'ModuleName'%.ECHO_ENABLED
  %'ModuleName'_EchoEnabled = FALSE;
#endif
}

%endif %- Init
%-BW_METHOD_END Init
%-************************************************************************************************************
%-BW_METHOD_BEGIN Deinit
%ifdef Deinit
%include Common\ShellDeinit.Inc
void %'ModuleName'%.%Deinit(void)
{
%if defined(OperatingSystemId) & OperatingSystemId = 'FreeRTOS' & defined(ConsoleSempahore) & %ConsoleSempahore='yes'
  vQueueUnregisterQueue(ShellSem);
  vSemaphoreDelete(ShellSem);
  ShellSem = NULL;
%endif
}

%endif %- Deinit
%-BW_METHOD_END Deinit
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendData
%ifdef SendData
%define! Pardata
%define! PardataSize
%define! Pario
%include Common\ShellSendData.Inc
/*!
 * \brief Sends data using I/O callbacks
 * \param[in] data Pointer to data to be sent
 * \param[in] io I/O function to be used for sending
 */
void %'ModuleName'%.%SendData(const uint8_t *data, uint16_t dataSize, %'ModuleName'_StdIO_OutErr_FctType io)
{
  while(dataSize>0) {
    io(*data++);
    dataSize--;
  }
}

%endif %- SendData
%-BW_METHOD_END SendData
%-BW_IMPLEMENT_END
/* END %ModuleName. */

%include Common\Header.End
%-
%-
%-BW_EVENT_IMPLEMENT_START
%-BW_METHOD_BEGIN OnBeforeIterateCmd
%ifdef OnBeforeIterateCmd
%IMPLEMENTATION OnBeforeIterateCmd
%define! Parcmd
%include Common\ShellOnBeforeIterateCmd.Inc
void %OnBeforeIterateCmd(const uint8_t *cmd)
{
  /* Write your code here ... */
}

%endif %- OnBeforeIterateCmd
%-BW_METHOD_END OnBeforeIterateCmd
%-BW_METHOD_BEGIN OnAfterIterateCmd
%ifdef OnAfterIterateCmd
%IMPLEMENTATION OnAfterIterateCmd
%define! Parcmd
%include Common\ShellOnAfterIterateCmd.Inc
void %OnAfterIterateCmd(const uint8_t *cmd)
{
  /* Write your code here ... */
}

%endif %- OnAfterIterateCmd
%-BW_METHOD_END OnAfterIterateCmd
%-BW_EVENT_IMPLEMENT_END
%INITIALIZATION
  /* ### %DeviceType "%DeviceName" init code ... */
%CODE_BEGIN
  %'ModuleName'%.Init(); /* initialize shell */
%CODE_END
%-
%ENABLE
%CODE_BEGIN
%CODE_END
%-
%else %- Language (& Compiler)
  %error^ This component is not implemented in selected language & compiler !
%endif %- Language (& Compiler)
%DEBUG
%ALL_SYMBOLS
%-
