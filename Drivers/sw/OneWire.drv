%-Driver pre-generated by the Component Development Environment
%-      Copyright: 1997 - 2014 Freescale Semiconductor, Inc. All Rights Reserved.
%-
%- WARNING !
%-
%- Do not make changes to these lines (if you make some changes, you damage this driver)
%- which begins with:
%-
%-  %-STARTUSERTYPES
%-  %-ENDUSRTYPES
%-  /* END %ModuleName. */
%-  /* MODULE %ModuleName. */
%-  %-INTERNAL_METHOD_BEG
%-  %-INTERNAL_METHOD_END
%-  %-INHERITED_EVENT_BEGIN
%-  %-INHERITED_EVENT_END
%-  %-BW_DEFINITION_START
%-  %-BW_DEFINITION_END
%-  %-BW_IMPLEMENT_START
%-  %-BW_IMPLEMENT_END
%-  %-BW_EVENT_DEFINITION_START
%-  %-BW_EVENT_DEFINITION_END
%-  %-BW_EVENT_IMPLEMENT_START
%-  %-BW_EVENT_IMPLEMENT_END
%-  %-BW_METHOD_MACROS_START
%-  %-BW_METHOD_MACROS_END
%-  %-BW_SECTIONS_INSERT
%-  %-BW_INTERN_COMMENTS_START
%-  %-BW_INTERN_COMMENTS_END
%-  %-BW_BEAN_CONSTANTS_START
%-  %-BW_BEAN_CONSTANTS_END
%-
%-
%- These lines are not comments, but they are necessary for Component Wizard
%- If you change these lines, Component Development Environment will not be responsible for loosing or damaging your code!
%-
%-
%- readyCPU ...
%- readyDEVICE ...
%-
%define DriverAuthor
%define DriverVersion 01.00
%define DriverDate    09/09/2014
%-
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END
%-
%-BW_INTERN_COMMENTS_START
%- List of descriptions of internal methods
%-BW_INTERN_COMMENTS_END
%-
%define CDEversion Community
%-BW_SECTIONS_INSERT
%if Language='ANSIC'
  %-
%-
%INTERFACE
%define! Settings Common\OneWireSettings.Inc
%define! Abstract Common\OneWireAbstract.Inc
%include Common\Header.h

#ifndef __%'ModuleName'_H
#define __%'ModuleName'_H

/* MODULE %ModuleName. */
#include "%@sdk@ModuleName.h" /* SDK and API used */
#include "%'ModuleName'config.h" /* configuration */
%if defined(Shell)
#include "%@Shell@ModuleName.h" /* Shell */
%endif
#include <stddef.h> /* for size_t */
%-BW_CUSTOM_INCLUDE_START_H
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%-BW_CUSTOM_INCLUDE_END_H
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END
%-STARTUSERTYPES - Do not make changes between lines (included this lines) marked with %-STARTUSERTYPES and %-ENDUSRTYPES

%-ENDUSRTYPES
%-BW_BEAN_CONSTANTS_START  - Do not make changes between lines (included this lines) marked with %-BW_BEAN_CONSTANTS_START and %-BW_BEAN_CONSTANTS_END
%- No constants defined in the BeanWizard for this bean
%-BW_BEAN_CONSTANTS_END
%-BW_CUSTOM_USERTYPE_START
%- Write your own types here ...
%-  Example:
%-    typedef int TMyInteger;
%-
#ifdef __cplusplus
extern "C" {
#endif

#define %'ModuleName'%.ROM_CODE_SIZE   (8)
  /*!< Number of bytes for ROM code */

#define %'ModuleName'%.PARSE_COMMAND_ENABLED    %'ModuleName'%.CONFIG_PARSE_COMMAND_ENABLED
  /*!< set to 1 if method ParseCommand() is present, 0 otherwise */
%-BW_CUSTOM_USERTYPE_END

%-BW_DEFINITION_START
%-*****************************************************************************************************
%-BW_METHOD_BEGIN Count
%ifdef Count
%define!  RetVal
%include Common\OneWireCount.inc
uint8_t %'ModuleName'%.%Count(void);
%endif  %-Count
%-BW_METHOD_END Count
%-*****************************************************************************************************
%ifdef Receive
%define! Parcounter
%define! RetVal
%include Common\OneWireReceive.inc
uint8_t %'ModuleName'%.%Receive(uint8_t counter);
%endif %- Receive
%-*****************************************************************************************************
%ifdef SendByte
%define! Pardata
%define! RetVal
%include Common\OneWireSendByte.inc
uint8_t %'ModuleName'%.%SendByte(uint8_t data);
%endif %- SendBytes
%-*****************************************************************************************************
%ifdef SendBytes
%define! Pardata
%define! Parcount
%define! RetVal
%include Common\OneWireSendBytes.inc
uint8_t %'ModuleName'%.%SendBytes(uint8_t *data, uint8_t count);
%endif %- SendBytes
%-*****************************************************************************************************
%-BW_METHOD_BEGIN SendReset
%ifdef SendReset
%define! RetVal
%include Common\OneWireSendReset.inc
uint8_t %'ModuleName'%.%SendReset(void);
%endif %- SendReset
%-BW_METHOD_END SendReset
%-*****************************************************************************************************
%-BW_METHOD_BEGIN GetByte
%ifdef GetByte
%define! Pardata
%define! RetVal
%include Common\OneWireGetByte.inc
uint8_t %'ModuleName'%.%GetByte(uint8_t *data);
%endif %- GetByte
%-BW_METHOD_END GetByte
%-*****************************************************************************************************
%-BW_METHOD_BEGIN GetBytes
%ifdef GetBytes
%define! Pardata
%define! Parcount
%define! RetVal
%include Common\OneWireGetBytes.inc
uint8_t %'ModuleName'%.%GetBytes(uint8_t *data, uint8_t count);
%endif %- GetBytes
%-BW_METHOD_END GetBytes
%-*****************************************************************************************************
%-BW_METHOD_BEGIN Init
%ifdef Init
%include Common\OneWireInit.inc
void %'ModuleName'%.%Init(void);
%endif  %-Init
%-BW_METHOD_END Init
%-************************************************************************************************************
%-BW_METHOD_BEGIN Deinit
%ifdef Deinit
void %'ModuleName'%.%Deinit(void);
%include Common\OneWireDeinit.Inc

%endif %- Deinit
%-BW_METHOD_END Deinit
%-************************************************************************************************************
%-BW_METHOD_BEGIN CalcCRC
%ifdef CalcCRC
uint8_t %'ModuleName'%.%CalcCRC(uint8_t *data, uint8_t dataSize);
%define! Pardata
%define! PardataSize
%define! RetVal
%include Common\OneWireCalcCRC.Inc

%endif %- CalcCRC
%-BW_METHOD_END CalcCRC
%-************************************************************************************************************
%-BW_METHOD_BEGIN ParseCommand
%ifdef ParseCommand
uint8_t %'ModuleName'%.%ParseCommand(const unsigned char* cmd, bool *handled, const %@Shell@'ModuleName'%.StdIOType *io);
%define! Parcmd
%define! Parhandled
%define! Pario
%define! RetVal
%include Common\OneWireParseCommand.Inc

%endif %- ParseCommand
%-BW_METHOD_END ParseCommand
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadRomCode
%ifdef ReadRomCode
uint8_t %'ModuleName'%.%ReadRomCode(uint8_t *romCodeBuffer);
%define! ParromCodeBuffer
%define! RetVal
%include Common\OneWireReadRomCode.Inc

%endif %- ReadRomCode
%-BW_METHOD_END ReadRomCode
%-************************************************************************************************************
%-BW_METHOD_BEGIN strcatRomCode
%ifdef strcatRomCode
uint8_t %'ModuleName'%.%strcatRomCode(uint8_t *buf, size_t bufSize, uint8_t *romCode);
%define! ParromCode
%define! Parbuf
%define! ParbufSize
%define! RetVal
%include Common\OneWirestrcatRomCode.Inc

%endif %- strcatRomCode
%-BW_METHOD_END strcatRomCode
%-************************************************************************************************************
%-BW_METHOD_BEGIN ResetSearch
%ifdef ResetSearch
void %'ModuleName'%.%ResetSearch(void);
%include Common\OneWireResetSearch.Inc

%endif %- ResetSearch
%-BW_METHOD_END ResetSearch
%-************************************************************************************************************
%-BW_METHOD_BEGIN TargetSearch
%ifdef TargetSearch
void %'ModuleName'%.%TargetSearch(uint8_t familyCode);
%define! ParfamilyCode
%include Common\OneWireTargetSearch.Inc

%endif %- TargetSearch
%-BW_METHOD_END TargetSearch
%-************************************************************************************************************
%-BW_METHOD_BEGIN Search
%ifdef Search
bool %'ModuleName'%.%Search(uint8_t *newAddr, bool search_mode);
%define! ParnewAddr
%define! Parsearch_mode
%define! RetVal
%include Common\OneWireSearch.Inc

%endif %- Search
%-BW_METHOD_END Search
%-BW_DEFINITION_END
/* END %ModuleName. */

#ifdef __cplusplus
}  /* extern "C" */
#endif

#endif
/* ifndef __%'ModuleName'_H */
%include Common\Header.End
%-
%-BW_EVENT_DEFINITION_START
%-*****************************************************************************************************

%-BW_EVENT_DEFINITION_END
%IMPLEMENTATION
%define! Settings Common\OneWireSettings.Inc
%define! Abstract Common\OneWireAbstract.Inc
%include Common\Header.C

/* MODULE %ModuleName. */

#include "%'ModuleName'.h"
#include "%@DataPin@ModuleName.h" /* data pin */
#include "%@input@ModuleName.h" /* input ring buffer */
#include "%@Utility@ModuleName.h" /* Utility */
#include "%@Wait@ModuleName.h" /* Waiting */

%-BW_CUSTOM_INCLUDE_START_M
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%-BW_CUSTOM_INCLUDE_END_M
%-BW_CUSTOM_VARIABLE_START
%- Write your static variables here
%-   Example:
%-     static int counter1;
%-     int %'ModuleName'%.counter2;
%-
/* global search state and information */
static unsigned char ROM_NO[8];
static uint8_t LastDiscrepancy;
static uint8_t LastFamilyDiscrepancy;
static uint8_t LastDeviceFlag;

/* Rom commands */
#define RC_READ_ROM          0x33
#define RC_MATCH_ROM         0x55
#define RC_SKIP_ROM          0xCC
#define RC_SEARCH_COND       0xEC
#define RC_SEARCH            0xF0
#define RC_RELEASE           0xFF

#if %'ModuleName'%.CONFIG_WRITE_PIN /* extra pin only for write bit */
  #define DQ_Init               %@DataPin@'ModuleName'%.Init(); %'ModuleName'%.CONFIG_WRITE_PIN_INIT
  #define DQ_Deinit             %@DataPin@'ModuleName'%.Init(); %'ModuleName'%.CONFIG_WRITE_PIN_DEINIT
#else
  #define DQ_Init               %@DataPin@'ModuleName'%.Init()
  #define DQ_Deinit             %@DataPin@'ModuleName'%.Deinit()
#endif
#if %'ModuleName'%.CONFIG_WRITE_PIN /* using dedicated circuit with separate pin to control the 1-wire write */
  #define DQ_SetLow             %'ModuleName'%.CONFIG_WRITE_PIN_SET_OUTPUT
  #define DQ_Low                %'ModuleName'%.CONFIG_WRITE_PIN_HIGH
  #define DQ_Floating           %'ModuleName'%.CONFIG_WRITE_PIN_LOW
#else
  #define DQ_SetLow             %@DataPin@'ModuleName'%.ClrVal()
  #define DQ_Low                %@DataPin@'ModuleName'%.SetOutput()
  #define DQ_Floating           %@DataPin@'ModuleName'%.SetInput()
#endif
#if %'ModuleName'%.CONFIG_DEBUG_READ_PIN_ENABLED
  #define DBG_Init              %'ModuleName'%.CONFIG_DEBUG_READ_PIN_INIT
  #define DBG_Deinit            %'ModuleName'%.CONFIG_DEBUG_READ_PIN_DEINIT
  #define DQ_Read               (%'ModuleName'%.CONFIG_DEBUG_READ_PIN_TOGGLE, %@DataPin@'ModuleName'%.GetVal()!=0)
#else
  #define DBG_Init              /* empty */
  #define DBG_Deinit            /* empty */
  #define DQ_Read               (%@DataPin@'ModuleName'%.GetVal()!=0)
#endif

static uint8_t read_bit(void) {
  uint8_t bit;
  %@CS@'ModuleName'%.CriticalVariable();

  %@CS@'ModuleName'%.EnterCritical();
  DQ_Low;
  %@Wait@'ModuleName'%.Waitus(%'ModuleName'%.CONFIG_A_READ_LOW_TIME);
  DQ_Floating;
  %@Wait@'ModuleName'%.Waitus(%'ModuleName'%.CONFIG_E_BEFORE_READ_DELAY_TIME);
  bit = DQ_Read;
  %@CS@'ModuleName'%.ExitCritical();
  %@Wait@'ModuleName'%.Waitus(%'ModuleName'%.CONFIG_F_AFTER_READ_DELAY_TIME);
  return bit;
}

static void write_bit(uint8_t bit) {
  %@CS@'ModuleName'%.CriticalVariable();

  if (bit&1) {
    %@CS@'ModuleName'%.EnterCritical();
    DQ_Low;
    %@Wait@'ModuleName'%.Waitus(%'ModuleName'%.CONFIG_A_WRITE_1_LOW_TIME);
    DQ_Floating;
    %@Wait@'ModuleName'%.Waitus(%'ModuleName'%.CONFIG_B_WRITE_1_HIGH_TIME);
    %@CS@'ModuleName'%.ExitCritical();
  } else { /* zero bit */
    %@CS@'ModuleName'%.EnterCritical();
    DQ_Low;
    %@Wait@'ModuleName'%.Waitus(%'ModuleName'%.CONFIG_C_WRITE_0_LOW_TIME);
    DQ_Floating;
    %@Wait@'ModuleName'%.Waitus(%'ModuleName'%.CONFIG_D_WRITE_0_HIGH_TIME);
    %@CS@'ModuleName'%.ExitCritical();
  }
}

%if defined(Shell)
#if %'ModuleName'%.CONFIG_PARSE_COMMAND_ENABLED
static uint8_t PrintStatus(const %@Shell@'ModuleName'%.StdIOType *io) {
  %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"%'ModuleName'", (unsigned char*)"\r\n", io->stdOut);
#if %'ModuleName'%.CONFIG_DEBUG_READ_PIN_ENABLED
  %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"  debug pin", (unsigned char*)"yes\r\n", io->stdOut);
#else
  %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"  debug pin", (unsigned char*)"no\r\n", io->stdOut);
#endif
  return ERR_OK;
}

static uint8_t PrintHelp(const %@Shell@'ModuleName'%.StdIOType *io) {
  %@Shell@'ModuleName'%.SendHelpStr((unsigned char*)"%'ModuleName'", (unsigned char*)"Group of %'ModuleName' commands\r\n", io->stdOut);
  %@Shell@'ModuleName'%.SendHelpStr((unsigned char*)"  help|status", (unsigned char*)"Print help or status information\r\n", io->stdOut);
  %@Shell@'ModuleName'%.SendHelpStr((unsigned char*)"  reset", (unsigned char*)"Send a RESET sequence to the bus\r\n", io->stdOut);
  %@Shell@'ModuleName'%.SendHelpStr((unsigned char*)"  read rom", (unsigned char*)"Send a READ ROM (0x33) to the bus\r\n", io->stdOut);
  %@Shell@'ModuleName'%.SendHelpStr((unsigned char*)"  search", (unsigned char*)"Search for devices on the bus\r\n", io->stdOut);
  return ERR_OK;
}
#endif /* %'ModuleName'%.CONFIG_PARSE_COMMAND_ENABLED */
%endif %- Shell

%-BW_CUSTOM_VARIABLE_END
%-BW_INTERN_METHOD_DECL_START
%- List of internal methods headers
%-BW_INTERN_METHOD_DECL_END
%-BW_IMPLEMENT_START

%-*****************************************************************************************************
%-BW_METHOD_BEGIN SendReset
%ifdef SendReset
%define! RetVal
%include Common\OneWireSendReset.inc
uint8_t %'ModuleName'%.%SendReset(void)
{
  uint8_t bit;
  %@CS@'ModuleName'%.CriticalVariable();

  %@CS@'ModuleName'%.EnterCritical();
  DQ_Low;
  %@Wait@'ModuleName'%.Waitus(%'ModuleName'%.CONFIG_H_RESET_TIME);
  DQ_Floating;
  %@Wait@'ModuleName'%.Waitus(%'ModuleName'%.CONFIG_I_RESET_RESPONSE_TIME);
  bit = DQ_Read;
  %@CS@'ModuleName'%.ExitCritical();
  %@Wait@'ModuleName'%.Waitus(%'ModuleName'%.CONFIG_J_RESET_WAIT_TIME);
  if (!bit) { /* a device pulled the data line low: at least one device is present */
    return ERR_OK;
  } else {
    return ERR_BUSOFF; /* no device on the bus? */
  }
}
%endif %- SendReset
%-BW_METHOD_END SendReset

%-*****************************************************************************************************
%-BW_METHOD_BEGIN SendByte
%ifdef SendByte
%define! Pardata
%define! RetVal
%include Common\OneWireSendByte.inc
uint8_t %'ModuleName'%.%SendByte(uint8_t data)
{
  int i;

  for(i=0;i<8;i++) {
    write_bit(data&1); /* send LSB first */
    data >>= 1; /* next bit */
  } /* for */
  return ERR_OK;
}
%endif %- SendByte
%-BW_METHOD_END SendByte

%-************************************************************************************************************
%-BW_METHOD_BEGIN SendBytes
%ifdef SendBytes
%define! Pardata
%define! Parcount
%define! RetVal
%include Common\OneWireSendBytes.Inc
uint8_t %'ModuleName'%.%SendBytes(uint8_t *data, uint8_t count)
{
  uint8_t res;

  while(count>0) {
    res = %'ModuleName'%.%SendByte(*data);
    if (res!=ERR_OK) {
      return res; /* failed */
    }
    data++;
    count--;
  }
  return ERR_OK;
}

%endif %- SendBytes
%-BW_METHOD_END SendBytes
%-*****************************************************************************************************
%-BW_METHOD_BEGIN Receive
%ifdef Receive
%define! Parcounter
%define! RetVal
%include Common\OneWireReceive.inc
uint8_t %'ModuleName'%.%Receive(uint8_t counter)
{
  int i;
  uint8_t val, mask;

  while(counter>0) {
    val = 0; mask = 1;
    for(i=0;i<8;i++) {
      if (read_bit()) { /* read bits (LSB first) */
        val |= mask;
      }
      mask <<= 1; /* next bit */
    } /* for */
    (void)%@Input@'ModuleName'%.Put(val); /* put it into the queue so it can be retrieved by GetBytes() */
    counter--;
  }
  return ERR_OK;
}
%endif %- Receive
%-BW_METHOD_END Receive

%-*****************************************************************************************************
%-BW_METHOD_BEGIN Count
%ifdef Count
%define! RetVal
%include Common\OneWireCount.inc
uint8_t %'ModuleName'%.%Count(void)
{
  return %@Input@'ModuleName'%.NofElements();
}
%endif %-Count
%-BW_METHOD_END Count

%-*****************************************************************************************************
%-BW_METHOD_BEGIN GetByte
%ifdef GetByte
%define! Pardata
%define! RetVal
%include Common\OneWireGetByte.inc
uint8_t %'ModuleName'%.%GetByte(uint8_t *data)
{
  if (%@Input@'ModuleName'%.NofElements()==0) {
    return ERR_FAILED;
  }
  (void)%@Input@'ModuleName'%.Get(data);
  return ERR_OK;
}
%endif %- GetByte
%-BW_METHOD_END GetByte

%-*****************************************************************************************************
%-BW_METHOD_BEGIN GetBytes
%ifdef GetBytes
%define! Par_byte
%define! Pardata
%define! Parcount
%define! RetVal
%include Common\OneWireGetBytes.inc
uint8_t %'ModuleName'%.%GetBytes(uint8_t *data, uint8_t count)
{
  if(count > %@Input@'ModuleName'%.NofElements()) {
    return ERR_FAILED;
  }
  for(;count>0;count--) {
    (void)%@Input@'ModuleName'%.Get(data);
    data++;
  }
  return ERR_OK;
}
%endif %- GetBytes
%-BW_METHOD_END GetBytes

%-************************************************************************************************************
%-BW_METHOD_BEGIN CalcCRC
%ifdef CalcCRC
%define! Pardata
%define! PardataSize
%define! RetVal
%include Common\OneWireCalcCRC.Inc
uint8_t %'ModuleName'%.%CalcCRC(uint8_t *data, uint8_t dataSize)
{
  uint8_t crc, i, x, y;

  crc = 0;
  for(x=0;x<dataSize;x++){
    y = data[x];
    for(i=0;i<8;i++) { /* go through all bits of the data byte */
      if((crc&0x01)^(y&0x01)) {
        crc >>= 1;
        crc ^= 0x8c;
      } else {
        crc >>= 1;
      }
      y >>= 1;
    }
  }
  return crc;
}

%endif %- CalcCRC
%-BW_METHOD_END CalcCRC
%-*****************************************************************************************************
%-BW_METHOD_BEGIN Init
%ifdef Init
%include Common\OneWireInit.inc
void %'ModuleName'%.%Init(void)
{
#if %@sdk@'ModuleName'%.CONFIG_NXP_SDK_USED
  /* using SDK, need to initialize inherited components */
  DQ_Init; /* data pin */
  DBG_Init; /* optional debug pin */
  %@Input@'ModuleName'%.Init(); /* input ring buffer */
#endif
  DQ_Floating; /* input mode, let the pull-up take the signal high */
  /* load LOW to output register. We won't change that value afterwards, we only switch between output and input/float mode */
  DQ_SetLow;
}
%endif %-Init
%-BW_METHOD_END Init

%-************************************************************************************************************
%-BW_METHOD_BEGIN Deinit
%ifdef Deinit
%include Common\OneWireDeinit.Inc
void %'ModuleName'%.%Deinit(void)
{
  DQ_Deinit; /* data pin */
  DQ_Floating; /* input mode, tristate pin */
  DBG_Deinit; /* optional debug pin */
  %@Input@'ModuleName'%.Deinit(); /* input ring buffer */
}

%endif %- Deinit
%-BW_METHOD_END Deinit

%-************************************************************************************************************
%-BW_METHOD_BEGIN ParseCommand
%ifdef ParseCommand
%define! Parcmd
%define! Parhandled
%define! Pario
%define! RetVal
%include Common\OneWireParseCommand.Inc
uint8_t %'ModuleName'%.%ParseCommand(const unsigned char* cmd, bool *handled, const %@Shell@'ModuleName'%.StdIOType *io)
{
#if %'ModuleName'%.CONFIG_PARSE_COMMAND_ENABLED
  uint8_t res = ERR_OK;
  uint8_t buf[32];

  if (%@Utility@'ModuleName'%.strcmp((char*)cmd, %@Shell@'ModuleName'%.CMD_HELP) == 0
    || %@Utility@'ModuleName'%.strcmp((char*)cmd, "%'ModuleName' help") == 0)
  {
    *handled = TRUE;
    return PrintHelp(io);
  } else if (   (%@Utility@'ModuleName'%.strcmp((char*)cmd, %@Shell@'ModuleName'%.CMD_STATUS)==0)
             || (%@Utility@'ModuleName'%.strcmp((char*)cmd, "%'ModuleName' status")==0)
            )
  {
    *handled = TRUE;
    res = PrintStatus(io);
  } else if (%@Utility@'ModuleName'%.strcmp((char*)cmd, "%'ModuleName' read rom")==0) {
    uint8_t rom[%'ModuleName'%.ROM_CODE_SIZE];

    *handled = TRUE;
    res = %'ModuleName'%.%ReadRomCode(&rom[0]);
    if (res!=ERR_OK) {
      %@Utility@'ModuleName'%.strcpy(buf, sizeof(buf), (unsigned char*)"ReadRomCode() ERROR (");
      %@Utility@'ModuleName'%.strcatNum8u(buf, sizeof(buf), res);
      %@Utility@'ModuleName'%.strcat(buf, sizeof(buf), (unsigned char*)")\r\n");
      %@Shell@'ModuleName'%.SendStr(buf, io->stdErr);
    } else {
      buf[0] = '\0';
      (void)%'ModuleName'%.%strcatRomCode(buf, sizeof(buf), &rom[0]);
      %@Utility@'ModuleName'%.strcat(buf, sizeof(buf), (unsigned char*)"\r\n");
      %@Shell@'ModuleName'%.SendStr(buf, io->stdOut);
    }
  } else if (%@Utility@'ModuleName'%.strcmp((char*)cmd, "%'ModuleName' reset")==0) {
    *handled = TRUE;
    res = %'ModuleName'%.%SendReset();
    if (res==ERR_OK) {
      %@Shell@'ModuleName'%.SendStr((unsigned char*)"Device present\r\n", io->stdOut);
    } else {
      %@Shell@'ModuleName'%.SendStr((unsigned char*)"No device present?\r\n", io->stdErr);
    }
  } else if (%@Utility@'ModuleName'%.strcmp((char*)cmd, "%'ModuleName' search")==0) {
    uint8_t rom[%'ModuleName'%.ROM_CODE_SIZE];
    bool found;
    int nofFound = 0;

    *handled = TRUE;
    %'ModuleName'%.%ResetSearch();
    do {
      found = %'ModuleName'%.%Search(&rom[0], TRUE);
      if (found) {
        nofFound++;
        buf[0] = '\0';
        (void)%'ModuleName'%.%strcatRomCode(buf, sizeof(buf), &rom[0]);
        %@Utility@'ModuleName'%.strcat(buf, sizeof(buf), (unsigned char*)"\r\n");
        %@Shell@'ModuleName'%.SendStr(buf, io->stdOut);
      }
    } while(found);
    if (nofFound==0) {
      %@Shell@'ModuleName'%.SendStr((unsigned char*)"No device found!\r\n", io->stdErr);
    }
    return ERR_OK;
  }
  return res;
#else
  (void)cmd;
  (void)handled;
  (void)io;
  return ERR_OK;
#endif
}

%endif %- ParseCommand
%-BW_METHOD_END ParseCommand
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadRomCode
%ifdef ReadRomCode
%define! ParromCodeBuffer
%define! RetVal
%include Common\OneWireReadRomCode.Inc
uint8_t %'ModuleName'%.%ReadRomCode(uint8_t *romCodeBuffer)
{
  uint8_t res;

  %'ModuleName'%.%SendReset();
  %'ModuleName'%.%SendByte(RC_READ_ROM);
  %'ModuleName'%.%Receive(%'ModuleName'%.ROM_CODE_SIZE); /* 8 bytes for the ROM code */
  %'ModuleName'%.%SendByte(RC_RELEASE);
  /* copy ROM code */
  res = %'ModuleName'%.%GetBytes(romCodeBuffer, %'ModuleName'%.ROM_CODE_SIZE); /* 8 bytes */
  if (res!=ERR_OK) {
    return res; /* error */
  }
  /* index 0  : family code
     index 1-6: 48bit serial number
     index 7  : CRC
  */
  if (%'ModuleName'%.%CalcCRC(&romCodeBuffer[0], %'ModuleName'%.ROM_CODE_SIZE-1)!=romCodeBuffer[%'ModuleName'%.ROM_CODE_SIZE-1]) {
    return ERR_CRC; /* wrong CRC? */
  }
  return ERR_OK; /* ok */
}

%endif %- ReadRomCode
%-BW_METHOD_END ReadRomCode
%-************************************************************************************************************
%-BW_METHOD_BEGIN strcatRomCode
%ifdef strcatRomCode
%define! ParromCode
%define! Parbuf
%define! ParbufSize
%define! RetVal
%include Common\OneWirestrcatRomCode.Inc
uint8_t %'ModuleName'%.%strcatRomCode(uint8_t *buf, size_t bufSize, uint8_t *romCode)
{
  int j;

  for(j=0;j<%'ModuleName'%.ROM_CODE_SIZE;j++) {
    %@Utility@'ModuleName'%.strcatNum8Hex(buf, bufSize, romCode[j]);
    if(j<%'ModuleName'%.ROM_CODE_SIZE-1) {
      %@Utility@'ModuleName'%.chcat(buf, bufSize, '-');
    }
  }
  return ERR_OK;
}

%endif %- strcatRomCode
%-BW_METHOD_END strcatRomCode
%-************************************************************************************************************
%-BW_METHOD_BEGIN ResetSearch
%ifdef ResetSearch
%include Common\OneWireResetSearch.Inc
void %'ModuleName'%.%ResetSearch(void)
{
  /* reset the search state */
  int i;

  LastDiscrepancy = 0;
  LastDeviceFlag = FALSE;
  LastFamilyDiscrepancy = 0;
  for(i = 7; ; i--) {
    ROM_NO[i] = 0;
    if (i==0) {
      break;
    }
  }
}

%endif %- ResetSearch
%-BW_METHOD_END ResetSearch
%-************************************************************************************************************
%-BW_METHOD_BEGIN TargetSearch
%ifdef TargetSearch
%define! ParfamilyCode
%include Common\OneWireTargetSearch.Inc
void %'ModuleName'%.%TargetSearch(uint8_t familyCode)
{
  /* set the search state to find SearchFamily type devices */
  int i;

  ROM_NO[0] = familyCode;
  for (i = 1; i < 8; i++) {
    ROM_NO[i] = 0;
  }
  LastDiscrepancy = 64;
  LastFamilyDiscrepancy = 0;
  LastDeviceFlag = FALSE;
}

%endif %- TargetSearch
%-BW_METHOD_END TargetSearch
%-************************************************************************************************************
%-BW_METHOD_BEGIN Search
%ifdef Search
%define! ParnewAddr
%define! Parsearch_mode
%define! RetVal
%include Common\OneWireSearch.Inc
bool %'ModuleName'%.%Search(uint8_t *newAddr, bool search_mode)
{
// Version from https://raw.githubusercontent.com/PaulStoffregen/OneWire/master/OneWire.cpp
//--------------------------------------------------------------------------
// Perform the 1-Wire Search Algorithm on the 1-Wire bus using the existing
// search state.
// Return TRUE  : device found, ROM number in ROM_NO buffer
//        FALSE : device not found, end of search
  uint8_t id_bit_number;
  uint8_t last_zero, rom_byte_number, search_result;
  uint8_t id_bit, cmp_id_bit;
  unsigned char rom_byte_mask, search_direction;
  uint8_t res;

  /* initialize for search */
  id_bit_number = 1;
  last_zero = 0;
  rom_byte_number = 0;
  rom_byte_mask = 1;
  search_result = 0;

  /* if the last call was not the last one */
  if (!LastDeviceFlag) {
    /* 1-Wire reset */
    res = %'ModuleName'%.%SendReset();
    if (res!=ERR_OK) {
      /* reset the search */
      LastDiscrepancy = 0;
      LastDeviceFlag = FALSE;
      LastFamilyDiscrepancy = 0;
      return FALSE;
    }
    /* issue the search command */
    if (search_mode) {
      %'ModuleName'%.%SendByte(RC_SEARCH);   /* NORMAL SEARCH */
    } else {
      %'ModuleName'%.%SendByte(RC_SEARCH_COND);   /* CONDITIONAL SEARCH */
    }
    /* loop to do the search */
    do  {
      /* read a bit and its complement */
      id_bit = read_bit();
      cmp_id_bit = read_bit();

      /* check for no devices on 1-wire */
      if ((id_bit==1) && (cmp_id_bit==1)) {
        break;
      } else {
        /* all devices coupled have 0 or 1 */
        if (id_bit != cmp_id_bit) {
          search_direction = id_bit;  // bit write value for search
        } else {
          /* if this discrepancy if before the Last Discrepancy */
          /* on a previous next then pick the same as last time */
          if (id_bit_number < LastDiscrepancy) {
            search_direction = ((ROM_NO[rom_byte_number] & rom_byte_mask) > 0);
          } else {
            /* if equal to last pick 1, if not then pick 0 */
            search_direction = (id_bit_number == LastDiscrepancy);
          }
          /* if 0 was picked then record its position in LastZero */
          if (search_direction == 0) {
            last_zero = id_bit_number;
            /* check for Last discrepancy in family */
            if (last_zero < 9)
               LastFamilyDiscrepancy = last_zero;
            }
          }

          /* set or clear the bit in the ROM byte rom_byte_number */
          /* with mask rom_byte_mask */
          if (search_direction == 1) {
            ROM_NO[rom_byte_number] |= rom_byte_mask;
          } else {
            ROM_NO[rom_byte_number] &= ~rom_byte_mask;
          }
          /* serial number search direction write bit */
          write_bit(search_direction);

          /* increment the byte counter id_bit_number */
          /* and shift the mask rom_byte_mask */
          id_bit_number++;
          rom_byte_mask <<= 1;

          /* if the mask is 0 then go to new SerialNum byte rom_byte_number and reset mask */
          if (rom_byte_mask == 0) {
            rom_byte_number++;
            rom_byte_mask = 1;
          }
       }
    }
    while(rom_byte_number < 8);  /* loop until through all ROM bytes 0-7 */
    /* if the search was successful then */
    if (!(id_bit_number < 65)) {
      /* search successful so set LastDiscrepancy,LastDeviceFlag,search_result */
      LastDiscrepancy = last_zero;

      /* check for last device */
      if (LastDiscrepancy == 0) {
        LastDeviceFlag = TRUE;
      }
      search_result = TRUE;
    }
  }
  /* if no device found then reset counters so next 'search' will be like a first */
  if (!search_result || !ROM_NO[0])  {
    LastDiscrepancy = 0;
    LastDeviceFlag = FALSE;
    LastFamilyDiscrepancy = 0;
    search_result = FALSE;
  } else {
    for (int i = 0; i < 8; i++) {
      newAddr[i] = ROM_NO[i];
    }
  }
  return search_result;
}

%endif %- Search
%-BW_METHOD_END Search
%-BW_IMPLEMENT_END
/* END %ModuleName. */

%include Common\Header.End
%-
%-
%-BW_EVENT_IMPLEMENT_START
%-*****************************************************************************************************
%-BW_EVENT_IMPLEMENT_END
%INITIALIZATION
  /* ### %DeviceType "%DeviceName" init code ... */
%CODE_BEGIN
  %'ModuleName'%.%Init();
%CODE_END
%-
%ENABLE
%CODE_BEGIN
%CODE_END
%-
%else %- Language (& Compiler)
  %error^ This component is not implemented in selected language & compiler !
%endif %- Language (& Compiler)
%DEBUG
%ALL_SYMBOLS
%-
%-----------------------------------------------------------------------------------------
%if defined(sdk) & %@sdk@ConfigFilesFolderName <> ""
  %define  ConfigSrcDirFolder %%@sdk@ConfigFilesFolderName/
%else
  %define  ConfigSrcDirFolder
%endif
%----------------------------
%FILE %'DirRel_Code'%'ConfigSrcDirFolder'%'ModuleName'config.h
/**
 * \file
 * \brief Configuration header file for 1-Wire
 *
 * This header file is used to configure settings of the 1-Wire module.
 */

#ifndef __%'ModuleName'_CONFIG_H
#define __%'ModuleName'_CONFIG_H

#ifdef __cplusplus
extern "C" {
#endif

/* protocol timing in micro seconds */
/* write */
#define %'ModuleName'%.CONFIG_A_WRITE_1_LOW_TIME                 %>60 %write1LowTime%>70/* A: standard 6 us, low time to write one bit */
#define %'ModuleName'%.CONFIG_B_WRITE_1_HIGH_TIME                %>60 %write1HighTime%>70/* B: standard 64 us, high time after writing one bit (A) */
#define %'ModuleName'%.CONFIG_C_WRITE_0_LOW_TIME                 %>60 %write0LowTime%>70/* C: standard 60 us, Low time writing zero bit */
#define %'ModuleName'%.CONFIG_D_WRITE_0_HIGH_TIME                %>60 %write0HighTime%>70/* D: standard 10 us, High time after writing zero bit (C) */
/* read */
#define %'ModuleName'%.CONFIG_A_READ_LOW_TIME                    %>60 %readLowTime%>60/* Low time to start read */
#define %'ModuleName'%.CONFIG_E_BEFORE_READ_DELAY_TIME           %>60 %beforeReadDelayTime%>70/* E: standard 9 us, wait time after starting read (when to read bit) */
#define %'ModuleName'%.CONFIG_F_AFTER_READ_DELAY_TIME            %>60 %afterReadDelayTime%>70/* F: standard 55 us, wait time after reading bit (E)  */
/* reset */
#define %'ModuleName'%.CONFIG_H_RESET_TIME                       %>60 %resetTime%>70/* H: standard 480 us, reset low time */
#define %'ModuleName'%.CONFIG_I_RESET_RESPONSE_TIME              %>60 %responseTime%>70/* I: standard 70 us, wait time after reset low time (H) until read response */
#define %'ModuleName'%.CONFIG_J_RESET_WAIT_TIME                  %>60 %ResetWaitTime%>70/* J: standard 410 us, wait time after reading presence (I)  */

#define %'ModuleName'%.CONFIG_SLOT_TIME                          %>60 %slotTime

%if defined(DbgReadPin)
#define %'ModuleName'%.CONFIG_DEBUG_READ_PIN_ENABLED             %>60 (1)
%else
#define %'ModuleName'%.CONFIG_DEBUG_READ_PIN_ENABLED             %>60 (0)
%endif
  /*!< 1: Toggle extra GPIO pin during 1-wire read access; 0: no debug */

#if %'ModuleName'%.CONFIG_DEBUG_READ_PIN_ENABLED
%if defined(DbgReadPin)
  #include "%@DbgReadPin@ModuleName.h" /* SDK and API used */
  #define %'ModuleName'%.CONFIG_DEBUG_READ_PIN_INIT              %>60 %@DbgReadPin@'ModuleName'%.Init()
  #define %'ModuleName'%.CONFIG_DEBUG_READ_PIN_DEINIT            %>60 %@DbgReadPin@'ModuleName'%.Deinit()
  #define %'ModuleName'%.CONFIG_DEBUG_READ_PIN_TOGGLE            %>60 %@DbgReadPin@'ModuleName'%.NegVal()
%else
  #include "DbgReadPin.h"
  #define %'ModuleName'%.CONFIG_DEBUG_READ_PIN_INIT              %>60 DbgReadPin_Init()
  #define %'ModuleName'%.CONFIG_DEBUG_READ_PIN_DEINIT            %>60 DbgReadPin_Deinit()
  #define %'ModuleName'%.CONFIG_DEBUG_READ_PIN_TOGGLE            %>60 DbgReadPin_NegVal()
%endif
#endif

#ifndef %'ModuleName'%.CONFIG_WRITE_PIN
%if defined(WritePin)
  #define %'ModuleName'%.CONFIG_WRITE_PIN                        %>60 (1)
%else
  #define %'ModuleName'%.CONFIG_WRITE_PIN                        %>60 (0)
%endif
    /*!< 1: using dedicated write pin; 0: using single pin for read/write */
#endif

#if %'ModuleName'%.CONFIG_WRITE_PIN
%if defined(WritePin)
  #include "%@WritePin@ModuleName.h" /* SDK and API used */
  #define %'ModuleName'%.CONFIG_WRITE_PIN_INIT                   %>60 %@WritePin@'ModuleName'%.Init()
  #define %'ModuleName'%.CONFIG_WRITE_PIN_DEINIT                 %>60 %@WritePin@'ModuleName'%.Deinit()
  #define %'ModuleName'%.CONFIG_WRITE_PIN_LOW                    %>60 %@WritePin@'ModuleName'%.ClrVal()
  #define %'ModuleName'%.CONFIG_WRITE_PIN_HIGH                   %>60 %@WritePin@'ModuleName'%.SetVal()
  #define %'ModuleName'%.CONFIG_WRITE_PIN_SET_OUTPUT             %>60 %@WritePin@'ModuleName'%.SetOutput()
%else
  #include "WritePin.h"
  #define %'ModuleName'%.CONFIG_WRITE_PIN_INIT                   %>60 WritePin_Init()
  #define %'ModuleName'%.CONFIG_WRITE_PIN_DEINIT                 %>60 WritePin_Deinit()
  #define %'ModuleName'%.CONFIG_WRITE_PIN_LOW                    %>60 WritePin_ClrVal()
  #define %'ModuleName'%.CONFIG_WRITE_PIN_HIGH                   %>60 WritePin_SetVal()
  #define %'ModuleName'%.CONFIG_WRITE_PIN_SET_OUTPUT             %>60 WritePin_SetOutput()
%endif
#endif

#if !defined(%'ModuleName'%.CONFIG_PARSE_COMMAND_ENABLED)
%ifdef ParseCommand
  #define %'ModuleName'%.CONFIG_PARSE_COMMAND_ENABLED            %>60(1)
%else
  #define %'ModuleName'%.CONFIG_PARSE_COMMAND_ENABLED            %>60(0)
%endif %- ParseCommand
    /*!< 1: shell support enabled, 0: otherwise */
#endif

#ifdef __cplusplus
}  /* extern "C" */
#endif

#endif /* __%'ModuleName'_CONFIG_H */
%-----------------------------------------------------------------------------------------
