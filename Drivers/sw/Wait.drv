%-Driver generated by the Bean Wizard
%-
%- WARNING !
%-
%- Do not make changes to these lines (if you make some changes, you damage this driver)
%- which begins with:
%-
%-  %-STARTUSERTYPES
%-  %-ENDUSRTYPES
%-  /* END %ModuleName. */
%-  /* MODULE %ModuleName. */
%-  %-INTERNAL_METHOD_BEG
%-  %-INTERNAL_METHOD_END
%-  %-INHERITED_EVENT_BEGIN
%-  %-INHERITED_EVENT_END
%-  %-BW_METHOD_BEGIN
%-  %-BW_METHOD_END
%-  %-BW_DEFINITION_START
%-  %-BW_DEFINITION_END
%-  %-BW_IMPLEMENT_START
%-  %-BW_IMPLEMENT_END
%-  %-BW_EVENT_DEFINITION_START
%-  %-BW_EVENT_DEFINITION_END
%-  %-BW_EVENT_IMPLEMENT_START
%-  %-BW_EVENT_IMPLEMENT_END
%-  %-BW_METHOD_MACROS_START
%-  %-BW_METHOD_MACROS_END
%-  %-BW_SECTIONS_INSERT
%-  %-BW_INTERN_COMMENTS_START
%-  %-BW_INTERN_COMMENTS_END
%-  %-BW_BEAN_CONSTANTS_START
%-  %-BW_BEAN_CONSTANTS_END
%-
%-
%- These lines are not comments, but they are necessary for Bean Wizard
%- If you change these lines, Bean Wizard will not be responsible for loosing or damaging your code!
%-
%-
%- readyCPU ...
%- readyDEVICE ...
%-
%define DriverAuthor  Author
%define DriverVersion 01.00
%define DriverDate    14.06.2008
%-
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END
%-
%-BW_INTERN_COMMENTS_START
%- List of descriptions of internal methods
%-BW_INTERN_COMMENTS_END
%-
%-BW_SECTIONS_INSERT
%if Language='ANSIC'
%-
%-
%INTERFACE
%define! Settings Common\WaitSettings.Inc
%define! Abstract Common\WaitAbstract.Inc
%include Common\Header.h

#ifndef __%'ModuleName'_H
#define __%'ModuleName'_H

/* MODULE %ModuleName. */
#include "%@sdk@ModuleName.h" /* SDK and API used */
#include "%'ModuleName'config.h" /* configuration */

%-BW_CUSTOM_INCLUDE_START_H
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
/* other includes needed */
#if %'ModuleName'%.CONFIG_USE_RTOS_WAIT
  /* include RTOS header files */
  %if defined(RTOS)
  #include "%@RTOS@ModuleName.h"
  %else
  #include "McuRTOS.h"
  %endif
  #if %@sdk@'ModuleName'%.CONFIG_CPU_IS_ESP32
    #include "freertos/FreeRTOS.h" /* for vTaskDelay() */
    #include "freertos/task.h"
  #else
    #include "FreeRTOS.h" /* for vTaskDelay() */
    #include "task.h"
  #endif
#endif
%-
%-BW_CUSTOM_INCLUDE_END_H
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END
%include sw\CommonSupport.prg
%-

#ifdef __cplusplus
extern "C" {
#endif

%if defined(ManualClockValues) & ManualClockValues='yes'
#undef CPU_BUS_CLK_HZ         %>%CTAB /* if already defined in "%ProcessorModule.h" */
#define CPU_BUS_CLK_HZ          %'CpuBusClkHz'UL      %>%CTAB /*!< CPU clock frequency (normal operation) */

#undef CPU_BUS_CLK_HZ_HIGH    %>%CTAB /* if already defined in "%ProcessorModule.h" */
#define CPU_BUS_CLK_HZ_HIGH     %'CpuBusClkHzHigh'UL  %>%CTAB /*!< CPU clock frequency in high speed mode */

#undef CPU_BUS_CLK_HZ_SLOW    %>%CTAB /* if already defined in "%ProcessorModule.h" */
#define CPU_BUS_CLK_HZ_SLOW     %'CpuBusClkHzSlow'UL  %>%CTAB /*!< CPU clock frequency in low speed mode */

#undef CPU_BUS_CLK_HZ_LOW     %>%CTAB /* if already defined in "%ProcessorModule.h" */
#define CPU_BUS_CLK_HZ_LOW      %'CpuBusClkHzLow'UL   %>%CTAB /*!< CPU clock frequency in slow speed mode */

%endif
%if (%CPUDB_prph_has_feature(CPU,SDK_SUPPORT) = 'yes') %- TRUE/FALSE not defined for SDK projects
#define CPU_CORE_CLK_HZ        %>%CTAB SystemCoreClock /*!< CPU clock frequency defined in SDK */
%endif

%if ndefined(LowClock_kHz) & ndefined(SlowClock_kHz)
  %define WaitUseMacroVersion  /* static clock: use inline version */
%endif
%-
%ifdef COMPILER_HIX
/* disable some compiler messages, as our inlined macros may generate some of them */
#pragma MESSAGE DISABLE C4000 /* Condition always TRUE */
#pragma MESSAGE DISABLE C4001 /* Condition always FALSE */
%endif
%-
#if %@sdk@'ModuleName'%.CONFIG_SDK_VERSION_USED == %@sdk@'ModuleName'%.CONFIG_SDK_PROCESSOR_EXPERT
  %if (CPU_FAMILY = "Kinetis")
  #define %'ModuleName'%.INSTR_CLOCK_HZ       CPU_CORE_CLK_HZ   %>%CTAB /* for Kinetis, use core clock as base for instruction execution */
  %else
  #define %'ModuleName'%.INSTR_CLOCK_HZ       CPU_BUS_CLK_HZ    %>%CTAB /* for none-Kinetis, use buse clock as base for instruction execution */
  %endif
#else
  extern uint32_t SystemCoreClock; /* clock frequency variable defined system_<device>.h of the SDK */
  #define %'ModuleName'%.INSTR_CLOCK_HZ       SystemCoreClock   %>%CTAB  /* core clock frequency in Hz */
#endif
#define %'ModuleName'%.NofCyclesMs(ms, hz)  ((ms)*((hz)/1000))               %>%CTAB /* calculates the needed cycles based on bus clock frequency */
%if (CPU_FAMILY = "ColdFireV1")
%- ColdFire is too fast for a single instruction range: add plus 1 cycle to keep timing accurate enough
#define %'ModuleName'%.NofCyclesUs(us, hz)  (1+(((us)*(((hz)/1000)/1000))))      %>%CTAB /* calculates the needed cycles based on bus clock frequency */
#define %'ModuleName'%.NofCyclesNs(ns, hz)  (1+(((ns)*(((hz)/1000)/1000))/1000)) %>%CTAB /* calculates the needed cycles based on bus clock frequency */
%else
#define %'ModuleName'%.NofCyclesUs(us, hz)  ((us)*(((hz)/1000)/1000))        %>%CTAB /* calculates the needed cycles based on bus clock frequency */
#define %'ModuleName'%.NofCyclesNs(ns, hz)  (((ns)*(((hz)/1000)/1000))/1000) %>%CTAB /* calculates the needed cycles based on bus clock frequency */
%endif

#define %'ModuleName'%.WAIT_C(cycles) \
     ( (cycles)<=10 ? \
          %'ModuleName'%.Wait10Cycles() \
        : %'ModuleName'%.WaitCycles(cycles) \
      )  %>%CTAB /*!< wait for some cycles */

%if (CPU_FAMILY = "HCS08") | (CPU_FAMILY = "HC08") | (CPU_FAMILY = "RS08") | (CPU_FAMILY = "HCS12X") | (CPU_FAMILY = "HCS12")
#pragma MESSAGE DISABLE C5908 /* Constant switch expression */
#define %'ModuleName'%.WAIT_CYCLES(cycles) \
  switch(cycles) { \
    case 10: __asm("nop"); \
    case  9: __asm("nop"); \
    case  8: __asm("nop"); \
    case  7: __asm("nop"); \
    case  6: __asm("nop"); \
    case  5: __asm("nop"); \
    case  4: __asm("nop"); \
    case  3: __asm("nop"); \
    case  2: __asm("nop"); \
    case  1: __asm("nop"); break;\
    default: WAIT1_WAIT_C(cycles); break; \
  } /*!< wait for some cycles */
%endif /* %if (CPU_FAMILY = "HCS08") | (CPU_FAMILY = "HC08") | (CPU_FAMILY = "RS08") | (CPU_FAMILY = "HCS12X") | (CPU_FAMILY = "HCS12") */
%-
%-
%-STARTUSERTYPES - Do not make changes between lines (included this lines) marked with %-STARTUSERTYPES and %-ENDUSRTYPES

%-ENDUSRTYPES
%-BW_BEAN_CONSTANTS_START  - Do not make changes between lines (included this lines) marked with %-BW_BEAN_CONSTANTS_START and %-BW_BEAN_CONSTANTS_END
%- No constants defined in the BeanWizard for this bean
%-BW_BEAN_CONSTANTS_END
%-BW_CUSTOM_USERTYPE_START
%- Write your own types here ...
%-  Example:
%-    typedef int TMyInteger;
%-
%-BW_CUSTOM_USERTYPE_END
%-BW_DEFINITION_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN Wait10Cycles
%ifdef Wait10Cycles
void %'ModuleName'%.%Wait10Cycles(void);
%include Common\WaitWait10Cycles.Inc

%endif %- Wait10Cycles
%-BW_METHOD_END Wait10Cycles
%-************************************************************************************************************
%-BW_METHOD_BEGIN Wait100Cycles
%ifdef Wait100Cycles
void %'ModuleName'%.%Wait100Cycles(void);
%include Common\WaitWait100Cycles.Inc

%endif %- Wait100Cycles
%-BW_METHOD_END Wait100Cycles
%-************************************************************************************************************
%-BW_METHOD_BEGIN WaitCycles
%ifdef WaitCycles
void %'ModuleName'%.%WaitCycles(uint32_t cycles);
%define! Parcycles
%include Common\WaitWaitCycles.Inc

%endif %- WaitCycles
%-BW_METHOD_END WaitCycles
%-************************************************************************************************************
%-BW_METHOD_BEGIN Waitms
%ifdef Waitms
void %'ModuleName'%.%Waitms(uint32_t ms);
%define! Parms
%include Common\WaitWaitms.Inc

%endif %- Waitms
%-BW_METHOD_END Waitms
%-************************************************************************************************************
%-BW_METHOD_BEGIN Waitus
%ifdef Waitus
%if defined(WaitUseMacroVersion)
/* we are having a static clock configuration: implement as macro/inlined version */
#define %'ModuleName'%.Waitus(us)  \
        /*lint -save -e(505,506,522) Constant value Boolean, Redundant left argument to comma. */\
       (  ((%'ModuleName'%.NofCyclesUs((us),%'ModuleName'%.INSTR_CLOCK_HZ)==0)||(us)==0) ? \
          (void)0 : \
          ( ((us)/1000)==0 ? (void)0 : %'ModuleName'%.Waitms(((us)/1000))) \
          , (%'ModuleName'%.NofCyclesUs(((us)%%1000), %'ModuleName'%.INSTR_CLOCK_HZ)==0) ? (void)0 : \
            %'ModuleName'%.WAIT_C(%'ModuleName'%.NofCyclesUs(((us)%%1000), %'ModuleName'%.INSTR_CLOCK_HZ)) \
       /*lint -restore */\
       )
%else
void %'ModuleName'%.%Waitus(uint32_t us);
%endif
%define! Parus
%include Common\WaitWaitus.Inc

%endif %- Waitus
%-BW_METHOD_END Waitus
%-************************************************************************************************************
%-BW_METHOD_BEGIN Waitns
%ifdef Waitns
%if defined(WaitUseMacroVersion)
/* we are having a static clock configuration: implement as macro/inlined version */
#define %'ModuleName'%.Waitns(ns)  \
        /*lint -save -e(505,506,522) Constant value Boolean, Redundant left argument to comma. */\
       (  ((%'ModuleName'%.NofCyclesNs((ns), %'ModuleName'%.INSTR_CLOCK_HZ)==0)||(ns)==0) ? \
          (void)0 : \
          %'ModuleName'%.Waitus((ns)/1000) \
          , (%'ModuleName'%.NofCyclesNs((ns)%%1000, %'ModuleName'%.INSTR_CLOCK_HZ)==0) ? \
              (void)0 : \
              %'ModuleName'%.WAIT_C(%'ModuleName'%.NofCyclesNs(((ns)%%1000), %'ModuleName'%.INSTR_CLOCK_HZ)) \
       /*lint -restore */\
       )
%else
void %'ModuleName'%.%Waitns(uint32_t ns);
%endif
%define! Parns
%include Common\WaitWaitns.Inc

%endif %- Waitns
%-BW_METHOD_END Waitns
%-************************************************************************************************************
%-BW_METHOD_BEGIN WaitOSms
%ifdef WaitOSms
#if %'ModuleName'%.CONFIG_USE_RTOS_WAIT
  #define %'ModuleName'%.%WaitOSms(ms) vTaskDelay(pdMS_TO_TICKS(ms)) /* use FreeRTOS API */
#else
  #define %'ModuleName'%.%WaitOSms(ms)  %'ModuleName'%.%Waitms(ms) /* use normal wait */
#endif
%include Common\WaitWaitOSms.Inc

%endif %- WaitOSms
%-BW_METHOD_END WaitOSms
%-************************************************************************************************************
%-BW_METHOD_BEGIN WaitLongCycles
%ifdef WaitLongCycles
void %'ModuleName'%.%WaitLongCycles(uint32_t cycles);
%define! Parcycles
%include Common\WaitWaitLongCycles.Inc

%endif %- WaitLongCycles
%-BW_METHOD_END WaitLongCycles
%-************************************************************************************************************
%-BW_METHOD_BEGIN Init
%ifdef Init
void %'ModuleName'%.%Init(void);
%include Common\WaitInit.Inc

%endif %- Init
%-BW_METHOD_END Init
%-************************************************************************************************************
%-BW_METHOD_BEGIN Deinit
%ifdef Deinit
void %'ModuleName'%.%Deinit(void);
%include Common\WaitDeinit.Inc

%endif %- Deinit
%-BW_METHOD_END Deinit
%-BW_DEFINITION_END
/* END %ModuleName. */

#ifdef __cplusplus
}  /* extern "C" */
#endif

#endif
/* ifndef __%'ModuleName'_H */
%include Common\Header.End
%-
%-BW_EVENT_DEFINITION_START
%-BW_EVENT_DEFINITION_END
%IMPLEMENTATION
%define! Settings Common\WaitSettings.Inc
%define! Abstract Common\WaitAbstract.Inc
%include Common\Header.C

/* MODULE %ModuleName. */

%for var from EventModules
#include "%var.h"
%endfor
#include "%'ModuleName'.h"
%-BW_CUSTOM_INCLUDE_START_M
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%-BW_CUSTOM_INCLUDE_END_M

%-BW_CUSTOM_VARIABLE_START
%- Write your static variables here
%-   Example:
%-     static int counter1;
%-     int %'ModuleName'%.counter2;
%if (CPU_FAMILY = "ColdFireV1")
/* tell the compiler not to inline functions in this module, as they are timing critical */
#pragma dont_inline on
%endif

%-
%-BW_CUSTOM_VARIABLE_END
%-BW_INTERN_METHOD_DECL_START
%- List of internal methods headers
%-BW_INTERN_METHOD_DECL_END
%-BW_IMPLEMENT_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN Wait10Cycles
%ifdef Wait10Cycles
%include Common\WaitWait10Cycles.Inc
#ifdef __GNUC__
#if %@sdk@'ModuleName'%.CONFIG_CPU_IS_RISC_V || %@sdk@'ModuleName'%.CONFIG_CPU_IS_ESP32 /* naked is ignored for RISC-V or ESP32 gcc */
  #ifdef __cplusplus  /* gcc 4.7.3 in C++ mode does not like no_instrument_function: error: can't set 'no_instrument_function' attribute after definition */
  #else
    __attribute__((no_instrument_function))
  #endif
#else
  #ifdef __cplusplus  /* gcc 4.7.3 in C++ mode does not like no_instrument_function: error: can't set 'no_instrument_function' attribute after definition */
    __attribute__((naked))
  #else
    __attribute__((naked, no_instrument_function))
  #endif
#endif
#endif
void %'ModuleName'%.%Wait10Cycles(void)
{
  /* This function will wait 10 CPU cycles (including call overhead). */
  /*lint -save -e522 function lacks side effect. */
%if (CPU_FAMILY = "HCS08") | (CPU_FAMILY = "HC08")
  __asm {
      ; BSR to here  ;  [5]
      ; RTS would be    [6]
  }
%elif (CPU_FAMILY = "RS08")
  __asm {
      ; jsr to here [4]
      nop          ;[1]
      nop          ;[1]
      nop          ;[1]
      ; rts         [3]
  }
%elif (CPU_FAMILY = "HCS12X") | (CPU_FAMILY = "HCS12")
  __asm {
      ; call to here   [7]
      ; RTC would be   [7]
  }
%elif (CPU_FAMILY = "ColdFireV1") | (CPU_FAMILY = "MCF")
  __asm {
                       %>%CTAB /* [3] JSR to here on the caller side */
    nop                %>%CTAB /* [1]  */
    nop                %>%CTAB /* [1]  */
                       %>%CTAB /* [5] for RTS, return from subroutine */
  }
%elif (CPU_FAMILY = "Kinetis") || (CPU_FAMILY = "S32K")

#if %@sdk@'ModuleName'%.CONFIG_CPU_IS_ARM_CORTEX_M
  /* NOTE: Cortex-M0 and M4 have 1 cycle for a NOP */
%-  /* Compiler is %Compiler */
#if %@sdk@'ModuleName'%.CONFIG_COMPILER==%@sdk@'ModuleName'%.CONFIG_COMPILER_GNU
  __asm (
   /* bl Wait10Cycles() to here: [4] */
   "nop   \n\t" /* [1] */
   "nop   \n\t" /* [1] */
   "nop   \n\t" /* [1] */
   "bx lr \n\t" /* [3] */
  );
#elif %@sdk@'ModuleName'%.CONFIG_COMPILER==%@sdk@'ModuleName'%.CONFIG_COMPILER_IAR
  /* bl Wai10Cycles() to here: [4] */
  __asm("nop");   /* [1] */
  __asm("nop");   /* [1] */
  __asm("nop");   /* [1] */
  __asm("bx lr"); /* [3] */
#elif %@sdk@'ModuleName'%.CONFIG_COMPILER==%@sdk@'ModuleName'%.CONFIG_COMPILER_KEIL
  __asm {
    nop                %>%CTAB /* [1] */
    nop                %>%CTAB /* [1] */
    nop                %>%CTAB /* [1] */
    /*bx lr*/          %>%CTAB /* [3] */
  }
#else
  __asm {
    nop                %>%CTAB /* [1] */
    nop                %>%CTAB /* [1] */
    nop                %>%CTAB /* [1] */
    bx lr              %>%CTAB /* [3] */
  }
#endif
#elif %@sdk@'ModuleName'%.CONFIG_CPU_IS_RISC_V
  __asm ( /* assuming [4] for overhead */
   "nop   \n\t" /* [1] */
   "nop   \n\t" /* [1] */
   "nop   \n\t" /* [1] */
   "nop   \n\t" /* [1] */
  );
#endif
%elif (CPU_FAMILY = "56800")
  /* JSR to here is 4-5 cycles */
  /* RTS is 8 cycles */
  /* so we already burned more than 10 cycles... */
%else
  #warning "unsupported CPU family %CPUfamily"
  volatile int i = 0; /* just something to wait, NOT the requested 10 cycles */
%endif
  /*lint -restore */
}

%endif %- Wait10Cycles
%-BW_METHOD_END Wait10Cycles
%-BW_METHOD_BEGIN Wait100Cycles
%ifdef Wait100Cycles
%include Common\WaitWait100Cycles.Inc
#if %@sdk@'ModuleName'%.CONFIG_COMPILER==%@sdk@'ModuleName'%.CONFIG_COMPILER_IAR
  /* Implemented in assembly file, as IAR does not support labels in HLI */
#else
%if ((CPU_FAMILY = "Kinetis") || (CPU_FAMILY = "S32K")) & %Compiler = "GNUC"
#ifdef __GNUC__
  #if %@sdk@'ModuleName'%.CONFIG_CPU_IS_RISC_V || %@sdk@'ModuleName'%.CONFIG_CPU_IS_ESP32 /* naked is ignored for RISC-V or ESP32 gcc */
    #ifdef __cplusplus  /* gcc 4.7.3 in C++ mode does not like no_instrument_function: error: can't set 'no_instrument_function' attribute after definition */
    #else
      __attribute__((no_instrument_function))
    #endif
  #else
    #ifdef __cplusplus  /* gcc 4.7.3 in C++ mode does not like no_instrument_function: error: can't set 'no_instrument_function' attribute after definition */
      __attribute__((naked))
    #else
      __attribute__((naked, no_instrument_function))
    #endif
  #endif
#endif
void %'ModuleName'%.%Wait100Cycles(void)
%elif ((CPU_FAMILY = "Kinetis") || (CPU_FAMILY = "S32K")) & (%Compiler = "ARM_CC") %- Keil/ARM compiler
__asm void %'ModuleName'%.%Wait100Cycles(void)
%else
void %'ModuleName'%.%Wait100Cycles(void)
%endif
{
  /* This function will spend 100 CPU cycles (including call overhead). */
  /*lint -save -e522 function lacks side effect. */
%if (CPU_FAMILY = "HCS08") | (CPU_FAMILY = "HC08")
  __asm {
      ; BSR to here  ;  [5]
      PSHH            ; [2], reserve space on stack
      LDA #13         ; [2], n
      TSX             ; [2]
      STA 0,X         ; [2]
    Label:
      DBNZ X,Label    ; 13*[6] =[78]
      PULH            ; [3]
      ; RTS would be    [6]
  }
%elif (CPU_FAMILY = "RS08")
  __asm {
      ; jsr to here [4]
      LDA #23      ;[2]
    Label:
      DECA         ;[1]
      BNE Label    ;[3]
      ; rts         [3]
  }
%elif (CPU_FAMILY = "HCS12X") | (CPU_FAMILY = "HCS12")
  __asm {
      ; call to here   [7]
      LDAB  #22      ; [1]
  Label:
      DBNE B, Label  ; [3]
      ; RTC would be   [7]
  }
%elif (CPU_FAMILY = "ColdFireV1") | (CPU_FAMILY = "MCF")
  __asm {
                       %>%CTAB /* [3] JSR to here on the caller side */
    move.l #31,d1      %>%CTAB /* [1] number of iterations */
  loopWait100Cycles:
    subq.l #1,d1       %>%CTAB /* [1] decrement d1 */
    bne.b loopWait100Cycles         %>%CTAB /* [2] repeat 31x=([1]+[2])*31=[93] */
                       %>%CTAB /* [5] return from subroutine */
  }
%elif (CPU_FAMILY = "Kinetis") || (CPU_FAMILY = "S32K")
#if %@sdk@'ModuleName'%.CONFIG_CPU_IS_ARM_CORTEX_M
#if %@sdk@'ModuleName'%.CONFIG_COMPILER==%@sdk@'ModuleName'%.CONFIG_COMPILER_GNU
  __asm (
   /* bl to here:               [4] */
   "push {r0}   \n\t"        /* [2] */
   "movs r0, #0 \n\t"        /* [1] */
   "loopWait100Cycles:       \n\t"
   "nop         \n\t"        /* [1] */
   "nop         \n\t"        /* [1] */
   "nop         \n\t"        /* [1] */
   "nop         \n\t"        /* [1] */
   "add r0,#1   \n\t"        /* [1] */
   "cmp r0,#9   \n\t"        /* [1] */
   "bls loopWait100Cycles    \n\t"        /* [3] taken, [1] not taken */
   "nop         \n\t"        /* [1] */
   "nop         \n\t"        /* [1] */
   "nop         \n\t"        /* [1] */
   "nop         \n\t"        /* [1] */
   "nop         \n\t"        /* [1] */
   "nop         \n\t"        /* [1] */
   "nop         \n\t"        /* [1] */
   "pop {r0}    \n\t"        /* [2] */
   "bx lr       \n\t"        /* [3] */
  );
#elif %@sdk@'ModuleName'%.CONFIG_COMPILER==%@sdk@'ModuleName'%.CONFIG_COMPILER_IAR
  /* need to implement in assembly, as IAR does not support labels in HLI */
#elif %@sdk@'ModuleName'%.CONFIG_COMPILER==%@sdk@'ModuleName'%.CONFIG_COMPILER_KEIL
   /* bl to here:    [4] */
    movs r0, #0   /* [1] */
loop
    nop           /* [1] */
    nop           /* [1] */
    nop           /* [1] */
    nop           /* [1] */
    nop           /* [1] */
    adds r0,r0,#1 /* [1] */
    cmp r0,#9     /* [1] */
    bls loop      /* [3] taken, [1] not taken */
    nop           /* [1] */
    bx lr         /* [3] */
#else
  __asm {
   /* bl Wai10Cycles() to here: [4] */
    movs r0, #0 /* [1] */
   loop:
    nop         /* [1] */
    nop         /* [1] */
    nop         /* [1] */
    nop         /* [1] */
    nop         /* [1] */
    add r0,#1   /* [1] */
    cmp r0,#9   /* [1] */
    bls loop    /* [3] taken, [1] not taken */
    nop         /* [1] */
    bx lr       /* [3] */
  }
#endif
#elif %@sdk@'ModuleName'%.CONFIG_CPU_IS_RISC_V
  __asm ( /* assuming [10] for overhead */
    "  li a5,20        \n\t"
    "LoopWait100Cycles:             \n\t"
    "  addi a5,a5,-1   \n\t"
    "  bgtz a5, LoopWait100Cycles   \n\t"
  );
#endif
%elif (CPU_FAMILY = "56800")
  /* JSR to here is 4-5 cycles */
  __asm {
    move.w #11, A  /* 2 cycles  */
    /* burn 100-5-2-8=85 cycles. Doing this with 11*8=88 cycles */
    do A, label    /* 8 cycles */
    label:
  }
  /* RTS is 8 cycles */
%else
  #warning "unsupported CPU family %CPUfamily"
  volatile int i;
  for(i=0; i<50; i++); /* just something to wait, NOT the requested 100 cycles */
%endif
  /*lint -restore */
}
#endif  /* %@sdk@'ModuleName'%.CONFIG_COMPILER==%@sdk@'ModuleName'%.CONFIG_COMPILER_IAR */

%endif %- Wait100Cycles
%-BW_METHOD_END Wait100Cycles
%-************************************************************************************************************
%-BW_METHOD_BEGIN WaitCycles
%ifdef WaitCycles
%define! Parcycles
%include Common\WaitWaitCycles.Inc
void %'ModuleName'%.%WaitCycles(uint32_t cycles)
{
  /*lint -save -e522 function lacks side effect. */
#if %'ModuleName'%.CONFIG_USE_CYCLE_COUNTER
  uint32_t counter = cycles;

%if defined(CortexTools)
  counter += %@CortexTools@'ModuleName'%.GetCycleCounter();
  while(%@CortexTools@'ModuleName'%.GetCycleCounter()<counter) {
%else
  counter += McuArmTools_GetCycleCounter();
  while(McuArmTools_GetCycleCounter()<counter) {
%endif
    /* wait */
  }
#else
  while(cycles >= 100u) {
    %'ModuleName'%.%Wait100Cycles();
    cycles -= 100u;
  }
  while(cycles >= 10u) {
    %'ModuleName'%.%Wait10Cycles();
    cycles -= 10u;
  }
#endif
  /*lint -restore */
}

%endif %- WaitCycles
%-BW_METHOD_END WaitCycles
%-************************************************************************************************************
%-BW_METHOD_BEGIN WaitLongCycles
%ifdef WaitLongCycles
%define! Parcycles
%include Common\WaitWaitLongCycles.Inc
void %'ModuleName'%.%WaitLongCycles(uint32_t cycles)
{
#if %'ModuleName'%.CONFIG_USE_CYCLE_COUNTER
  uint32_t counter = cycles;

%if defined(CortexTools)
  counter += %@CortexTools@'ModuleName'%.GetCycleCounter();
  while(%@CortexTools@'ModuleName'%.GetCycleCounter()<counter) {
%else
  counter += McuArmTools_GetCycleCounter();
  while(McuArmTools_GetCycleCounter()<counter) {
%endif
    /* wait */
  }
#else
  /*lint -save -e522 function lacks side effect. */
  while(cycles>60000) {
    %'ModuleName'%.%WaitCycles(60000);
    cycles -= 60000;
  }
  %'ModuleName'%.%WaitCycles(cycles);
  /*lint -restore */
#endif
}

%endif %- WaitLongCycles
%-BW_METHOD_END WaitLongCycles
%-************************************************************************************************************
%-BW_METHOD_BEGIN Waitms
%ifdef Waitms
%define! Parms
%include Common\WaitWaitms.Inc
%ifdef COMPILER_HIX
#pragma MESSAGE DISABLE C5905 /* multiplication with one */
%endif
void %'ModuleName'%.%Waitms(uint32_t ms)
{
  /*lint -save -e522 function lacks side effect. */
%if (CPU_FAMILY = "Kinetis") | (CPU_FAMILY = "S32K") | (CPU_FAMILY = "HCS08") | (CPU_FAMILY = "HC08") | (CPU_FAMILY = "RS08")  | (CPU_FAMILY = "HCS12X") | (CPU_FAMILY = "HCS12")
  uint32_t msCycles; /* cycles for 1 ms */

%if defined(LowClock_kHz) | defined(SlowClock_kHz)
  /* dynamic clock/speed configuration */
  if (CpuMode == HIGH_SPEED) {
    msCycles = %'ModuleName'%.NofCyclesMs(1, %'ModuleName'%.INSTR_CLOCK_HZ);
 %if defined(LowClock_kHz)
  %if defined(SlowClock_kHz)
  } else if (CpuMode == LOW_SPEED) {
  %else
  } else { /* LOW_SPEED */
  %endif
    msCycles = %'ModuleName'%.NofCyclesMs(1, CPU_BUS_CLK_HZ_LOW);
 %endif
 %if defined(SlowClock_kHz)
  } else { /* SLOW_SPEED */
    msCycles = %'ModuleName'%.NofCyclesMs(1, CPU_BUS_CLK_HZ_SLOW);
 %endif
  }
%else
  /* static clock/speed configuration */
  msCycles = %'ModuleName'%.NofCyclesMs(1, %'ModuleName'%.INSTR_CLOCK_HZ);
%endif
  while(ms>0) {
    %'ModuleName'%.WaitLongCycles(msCycles);
  %if WatchdogEnabled='yes'
    %if defined(Watchdog)
    %@Watchdog@'ModuleName'%.Clear();                            %>40/* kick the dog in order not to timeout */
    %elif defined(WatchdogLDD)
    (void)%@WatchdogLDD@'ModuleName'%.Clear(%@WatchdogLDD@'ModuleName'%.DeviceData);%>40/* kick the dog in order not to timeout */
    %endif
  %endif
    ms--;
  }
%else
  if (ms>0) {
%if (defined(PEversionDecimal) && PEversionDecimal <0 '1089') %- old version of PE in classic CW for MCU 6.3
    /* old version of PE in classic CW for MCU 6.3: PEversionDecimal: %PEversionDecimal */
    %Delay100usFunction(ms*10); /* Use function in CPU component. If you get a compiler error here, this typically means that the method is not enabled. Enable this method in the CPU component */
%else
    %'ProcessorModule'%.%Delay100usFunction(ms*10); /* Use function in CPU component. If you get a compiler error here, this typically means that the method is not enabled. Enable this method in the CPU component */
%endif
  %if WatchdogEnabled='yes'
    %if defined(Watchdog)
    %@Watchdog@'ModuleName'%.Clear();                            %>40/* kick the dog in order not to timeout */
    %elif defined(WatchdogLDD)
    (void)%@WatchdogLDD@'ModuleName'%.Clear(%@WatchdogLDD@'ModuleName'%.DeviceData);%>40/* kick the dog in order not to timeout */
    %endif
  %endif
  }
%endif
  /*lint -restore */
}
%ifdef COMPILER_HIX
#pragma MESSAGE DEFAULT C5905 /* multiplication with one */
%endif
%endif %- Waitms
%-BW_METHOD_END Waitms
%-************************************************************************************************************
%-BW_METHOD_BEGIN Waitus
%ifdef Waitus
%define! Parus
%include Common\WaitWaitus.Inc
%if defined(WaitUseMacroVersion)
/* implemented as macro version. See header file. */
%else
%ifdef COMPILER_HIX
#pragma MESSAGE DISABLE C5905 /* multiplication with one */
%endif
void %'ModuleName'%.%Waitus(uint32_t us)
{
%if defined(LowClock_kHz) | defined(SlowClock_kHz)
  /* dynamic clock/speed configuration */
  if (CpuMode == HIGH_SPEED) {
    %'ModuleName'%.WaitCycles(%'ModuleName'%.NofCyclesUs(us, %'ModuleName'%.INSTR_CLOCK_HZ));
 %if defined(LowClock_kHz)
  %if defined(SlowClock_kHz)
  } else if (CpuMode == LOW_SPEED) {
  %else
  } else { /* LOW_SPEED */
  %endif
    %'ModuleName'%.WaitCycles(%'ModuleName'%.NofCyclesUs(us, CPU_BUS_CLK_HZ_LOW));
 %endif
 %if defined(SlowClock_kHz)
  } else { /* SLOW_SPEED */
    %'ModuleName'%.WaitCycles(%'ModuleName'%.NofCyclesUs(us, CPU_BUS_CLK_HZ_SLOW));
 %endif
  }
%else
  /* static clock/speed configuration */
  %'ModuleName'%.WaitCycles(%'ModuleName'%.NofCyclesUs(us, %'ModuleName'%.INSTR_CLOCK_HZ));
%endif
}
%ifdef COMPILER_HIX
#pragma MESSAGE DEFAULT C5905 /* multiplication with one */
%endif
%endif
%endif %- Waitus
%-BW_METHOD_END Waitus
%-************************************************************************************************************
%-BW_METHOD_BEGIN Waitns
%ifdef Waitns
%define! Parns
%include Common\WaitWaitns.Inc
%if defined(WaitUseMacroVersion)
/* implemented as macro version. See header file. */
%else
%ifdef COMPILER_HIX
#pragma MESSAGE DISABLE C5905 /* multiplication with one */
%endif
void %'ModuleName'%.%Waitns(uint32_t ns)
{
%if defined(LowClock_kHz) | defined(SlowClock_kHz)
  /* dynamic clock/speed configuration */
  if (CpuMode == HIGH_SPEED) {
    %'ModuleName'%.WaitCycles(%'ModuleName'%.NofCyclesNs(ns, CPU_BUS_CLK_HZ_HIGH));
 %if defined(LowClock_kHz)
  %if defined(SlowClock_kHz)
  } else if (CpuMode == LOW_SPEED) {
  %else
  } else { /* LOW_SPEED */
  %endif
    %'ModuleName'%.WaitCycles(%'ModuleName'%.NofCyclesNs(ns, CPU_BUS_CLK_HZ_LOW));
 %endif
 %if defined(SlowClock_kHz)
  } else { /* SLOW_SPEED */
    %'ModuleName'%.WaitCycles(%'ModuleName'%.NofCyclesNs(ns, CPU_BUS_CLK_HZ_SLOW));
 %endif
  }
%else
  %'ModuleName'%.WaitCycles(%'ModuleName'%.NofCyclesNs(ns, %'ModuleName'%.INSTR_CLOCK_HZ));
%endif
}
%ifdef COMPILER_HIX
#pragma MESSAGE DEFAULT C5905 /* multiplication with one */
%endif
%endif
%endif %- Waitns
%-BW_METHOD_END Waitns
%-************************************************************************************************************
%-BW_METHOD_BEGIN WaitOSms
%ifdef WaitOSms
%include Common\WaitWaitOSms.Inc
/*
void %'ModuleName'%.%WaitOSms(void)
{
  Method is implemented as macro in the header file
}
*/

%endif %- WaitOSms
%-BW_METHOD_END WaitOSms
%-************************************************************************************************************
%-BW_METHOD_BEGIN Init
%ifdef Init
%include Common\WaitInit.Inc
void %'ModuleName'%.%Init(void)
{
#if %'ModuleName'%.CONFIG_USE_CYCLE_COUNTER
  /* init cycle counter */
%if defined(CortexTools)
  %@CortexTools@'ModuleName'%.InitCycleCounter();
  %@CortexTools@'ModuleName'%.ResetCycleCounter();
  %@CortexTools@'ModuleName'%.EnableCycleCounter();
%else
  McuArmTools_InitCycleCounter();
  McuArmTools_ResetCycleCounter();
  McuArmTools_EnableCycleCounter();
%endif
#endif
}

%endif %- Init
%-BW_METHOD_END Init
%-************************************************************************************************************
%-BW_METHOD_BEGIN Deinit
%ifdef Deinit
%include Common\WaitDeinit.Inc
void %'ModuleName'%.%Deinit(void)
{
#if %'ModuleName'%.CONFIG_USE_CYCLE_COUNTER
  /* disable hardware cycle counter */
%if defined(CortexTools)
  %@CortexTools@'ModuleName'%.DisableCycleCounter();
%else
  McuArmTools_DisableCycleCounter();
%endif
#endif
}

%endif %- Deinit
%-BW_METHOD_END Deinit
%-BW_IMPLEMENT_END
/* END %ModuleName. */

%include Common\Header.End
%-
%-
%-BW_EVENT_IMPLEMENT_START
%-BW_EVENT_IMPLEMENT_END
%INITIALIZATION
%CODE_BEGIN
%if (CPUfamily = "S32K")
#ifdef CPU_INIT_MCUONECLIPSE_DRIVERS
%endif
  %'ModuleName'%.%Init(); /* ### %DeviceType "%DeviceName" init code ... */
%if (CPUfamily = "S32K")
#endif
%endif
%CODE_END
%-
%ENABLE
%CODE_BEGIN
%CODE_END
%-
%if (%Compiler = "IARARM")
%- need to implement the handler in assembly, as IAR does not support inline assembly with labels?
/* NOTE: because the IAR compiler cannot handle inline assembly with labels,
 * this assembly file has to be included for IAR projects.
 * If this file is provided with .s.txt extension:
 * Remove the .txt extension and build it with the IAR project.
 */
%FILE %'DirRel_Code'%'ModuleName'%.%Wait100Cycles.s
  /* use code segment, and we are generating ARM thumb code: */
  RSEG    CODE:CODE(2)
  thumb

  /* external interface declaration; */
  PUBLIC %'ModuleName'%.%Wait100Cycles

/*-----------------------------------------------------------*/
%'ModuleName'%.%Wait100Cycles:
  /* bl to here:  [4] */
  movs r0,#0   /* [1] load loop counter */
  loopWait100Cycles:        /* 9*[10] */
  nop          /* [1] */
  nop          /* [1] */
  nop          /* [1] */
  nop          /* [1] */
  nop          /* [1] */
  adds r0,#1   /* [1] increment loop counter */
  cmp r0,#9    /* [1] 9*10 cycles */
  bls loopWait100Cycles     /* [3] for taken, [1] for not taken */
  nop          /* additional nop to fill up to 100 cycles */
  bx lr        /* return to caller */
/*-----------------------------------------------------------*/
  END
%endif %- (%Compiler = "IARARM")
%-----------------------------------------------------------------------------------------
%if defined(sdk) & %@sdk@ConfigFilesFolderName <> ""
  %define  ConfigSrcDirFolder %%@sdk@ConfigFilesFolderName/
%else
  %define  ConfigSrcDirFolder
%endif
%----------------------------
%FILE %'DirRel_Code'%'ConfigSrcDirFolder'%'ModuleName'config.h
/**
 * \file
 * \brief Configuration header file for Wait
 * Copyright (c) 2020, Erich Styger
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * This header file is used to configure settings of the busy waiting module.
 */

#ifndef __%'ModuleName'_CONFIG_H
#define __%'ModuleName'_CONFIG_H

#include "%@sdk@ModuleName.h" /* include library configuration */

#ifndef %'ModuleName'%.CONFIG_USE_CYCLE_COUNTER
%if defined(useCycleCounter) & %useCycleCounter='yes'
  #define %'ModuleName'%.CONFIG_USE_CYCLE_COUNTER  (1 && (%@sdk@'ModuleName'%.CONFIG_CPU_IS_ARM_CORTEX_M && %@sdk@'ModuleName'%.CONFIG_CORTEX_M>=3))
%else
  #define %'ModuleName'%.CONFIG_USE_CYCLE_COUNTER  (0 && (%@sdk@'ModuleName'%.CONFIG_CPU_IS_ARM_CORTEX_M && %@sdk@'ModuleName'%.CONFIG_CORTEX_M>=3))
%endif
    /*!< 1: Use hardware cycle counter (if present, only on Cortex-M3 or higher), 0: not using hardware cycle counter */
#endif

#ifndef %'ModuleName'%.CONFIG_USE_RTOS_WAIT
%if defined(RTOS)
  #define %'ModuleName'%.CONFIG_USE_RTOS_WAIT  (1 && %@sdk@'ModuleName'%.CONFIG_SDK_USE_FREERTOS)
%else
  #define %'ModuleName'%.CONFIG_USE_RTOS_WAIT  (0 && %@sdk@'ModuleName'%.CONFIG_SDK_USE_FREERTOS)
%endif
    /*!< 1: Use RTOS wait if RTOS is present; 0: use normal busy waiting */
#endif

#if %'ModuleName'%.CONFIG_USE_CYCLE_COUNTER
%if defined(CortexTools)
  #include "%@CortexTools@ModuleName.h" /* include Cortex utility functions */
%else
  #include "KIN1.h" /* include Cortex utility functions */
%endif
#endif

#endif /* __%'ModuleName'_CONFIG_H */
%-----------------------------------------------------------------------------------------
%else %- Language (& Compiler)
  %error^ This bean is not implemented in selected language & compiler !
%endif %- Language (& Compiler)
%DEBUG
%ALL_SYMBOLS
%-
