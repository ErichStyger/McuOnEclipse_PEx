%-Driver generated by the Component Wizard
%-
%- WARNING !
%-
%- Do not make changes to these lines (if you make some changes, you damage this driver)
%- which begins with:
%-
%-  %-STARTUSERTYPES
%-  %-ENDUSRTYPES
%-  /* END %ModuleName. */
%-  /* MODULE %ModuleName. */
%-  %-INTERNAL_METHOD_BEG
%-  %-INTERNAL_METHOD_END
%-  %-INHERITED_EVENT_BEGIN
%-  %-INHERITED_EVENT_END
%-  %-BW_METHOD_BEGIN
%-  %-BW_METHOD_END
%-  %-BW_DEFINITION_START
%-  %-BW_DEFINITION_END
%-  %-BW_IMPLEMENT_START
%-  %-BW_IMPLEMENT_END
%-  %-BW_EVENT_DEFINITION_START
%-  %-BW_EVENT_DEFINITION_END
%-  %-BW_EVENT_IMPLEMENT_START
%-  %-BW_EVENT_IMPLEMENT_END
%-  %-BW_METHOD_MACROS_START
%-  %-BW_METHOD_MACROS_END
%-  %-BW_SECTIONS_INSERT
%-  %-BW_INTERN_COMMENTS_START
%-  %-BW_INTERN_COMMENTS_END
%-  %-BW_BEAN_CONSTANTS_START
%-  %-BW_BEAN_CONSTANTS_END
%-
%-
%- These lines are not comments, but they are necessary for Component Wizard
%- If you change these lines, Component Wizard will not be responsible for loosing or damaging your code!
%-
%-
%- readyCPU ...
%- readyDEVICE ...
%-
%define DriverAuthor  Author
%define DriverVersion 01.00
%define DriverDate    16.12.2010
%-
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END
%-
%-BW_INTERN_COMMENTS_START
%- List of descriptions of internal methods
%define! Description_Delay The method waits in delay loop.
%define! Description_Read The method reads one byte of data from the bus.
%define! Description_GetAck The method reads ACK from the bus.
%define! Description_Write The method sends one byte of data to the bus.
%define! Description_InternalStop The method generates the Stop condition on the bus.
%-BW_INTERN_COMMENTS_END
%-
%-BW_SECTIONS_INSERT
%if Language='ANSIC'
%-
%-
%INTERFACE
%define! Settings Common\GenericSWI2CSettings.Inc
%define! Abstract Common\GenericSWI2CAbstract.Inc
%include Common\Header.h

#ifndef __%'ModuleName'_H
#define __%'ModuleName'_H

/* MODULE %ModuleName. */
#include "%@sdk@ModuleName.h" /* SDK and API used */
#include "%'ModuleName'config.h" /* configuration */

%-BW_CUSTOM_INCLUDE_START_H
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%-BW_CUSTOM_INCLUDE_END_H
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END
%-STARTUSERTYPES - Do not make changes between lines (included this lines) marked with %-STARTUSERTYPES and %-ENDUSRTYPES

%-ENDUSRTYPES
%-BW_BEAN_CONSTANTS_START  - Do not make changes between lines (included this lines) marked with %-BW_BEAN_CONSTANTS_START and %-BW_BEAN_CONSTANTS_END
%- No constants defined in the BeanWizard for this bean
%-BW_BEAN_CONSTANTS_END
%-BW_CUSTOM_USERTYPE_START
%- Write your own types here ...
%-  Example:
%-    typedef int TMyInteger;
%-
%if defined(RecvBlockCustom)
#define %'ModuleName'%.RECVBLOCKCUSTOM_AVAILABLE  (1)
%else
#define %'ModuleName'%.RECVBLOCKCUSTOM_AVAILABLE  (0)
%endif
  /*!< Define which can be used to check if the function RecvBlockCustom() is available */

typedef enum %'ModuleName'%.EnumStartFlags_ {
  %'ModuleName'%.SEND_START,        /* Start is sent */
  %'ModuleName'%.DO_NOT_SEND_START  /* Start is not sent */
} %'ModuleName'%.EnumStartFlags;

typedef enum %'ModuleName'%.EnumAckFlags_ {
  %'ModuleName'%.SEND_LAST_ACK,   /* Nack after last received byte is sent */
  %'ModuleName'%.DO_NOT_LAST_ACK  /* Nack after last received byte is not sent */
} %'ModuleName'%.EnumAckFlags;

/* defines to be used for %'ModuleName'%.%SendAck(); */
#define %'ModuleName'%.ACK         0U
#define %'ModuleName'%.NOACK       1U
%-BW_CUSTOM_USERTYPE_END

%-BW_DEFINITION_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN Init
%ifdef Init
void %'ModuleName'%.%Init(void);
%include Common\GenericSWI2CInit.Inc

%endif %- Init
%-BW_METHOD_END Init
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendChar
%ifdef SendChar
uint8_t %'ModuleName'%.%SendChar(uint8_t Chr);
%define! ParChr
%define! RetVal
%include Common\GenericSWI2CSendChar.Inc

%endif %- SendChar
%-BW_METHOD_END SendChar
%-************************************************************************************************************
%-BW_METHOD_BEGIN RecvChar
%ifdef RecvChar
uint8_t %'ModuleName'%.%RecvChar(uint8_t *Chr);
%define! ParChr
%define! RetVal
%include Common\GenericSWI2CRecvChar.Inc

%endif %- RecvChar
%-BW_METHOD_END RecvChar
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendBlock
%ifdef SendBlock
uint8_t %'ModuleName'%.%SendBlock(void *Ptr, uint16_t Siz, uint16_t *Snt);
%define! ParPtr
%define! ParSiz
%define! ParSnt
%define! RetVal
%include Common\GenericSWI2CSendBlock.Inc

%endif %- SendBlock
%-BW_METHOD_END SendBlock
%-************************************************************************************************************
%-BW_METHOD_BEGIN RecvBlock
%ifdef RecvBlock
uint8_t %'ModuleName'%.%RecvBlock(void *Ptr, uint16_t Siz, uint16_t *Rcv);
%define! ParPtr
%define! ParSiz
%define! ParRcv
%define! RetVal
%include Common\GenericSWI2CRecvBlock.Inc

%endif %- RecvBlock
%-BW_METHOD_END RecvBlock
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendStop
%ifdef SendStop
uint8_t %'ModuleName'%.%SendStop(void);
%define! RetVal
%include Common\GenericSWI2CSendStop.Inc

%endif %- SendStop
%-BW_METHOD_END SendStop
%-************************************************************************************************************
%-BW_METHOD_BEGIN SelectSlave
%ifdef SelectSlave
uint8_t %'ModuleName'%.%SelectSlave(uint8_t Slv);
%define! ParSlv
%define! RetVal
%include Common\GenericSWI2CSelectSlave.Inc

%endif %- SelectSlave
%-BW_METHOD_END SelectSlave
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetSelected
%ifdef GetSelected
uint8_t %'ModuleName'%.%GetSelected(uint8_t *Slv);
%define! ParSlv
%define! RetVal
%include Common\GenericSWI2CGetSelected.Inc

%endif %- GetSelected
%-BW_METHOD_END GetSelected
%-************************************************************************************************************
%-BW_METHOD_BEGIN ResetBus
%ifdef ResetBus
bool %'ModuleName'%.%ResetBus(void);
%define! RetVal
%include Common\GenericSWI2CResetBus.Inc

%endif %- ResetBus
%-BW_METHOD_END ResetBus
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendBlockContinue
%ifdef SendBlockContinue
uint8_t %'ModuleName'%.%SendBlockContinue(void *Ptr, uint16_t Siz, uint16_t *Snt);
%define! ParPtr
%define! ParSiz
%define! ParSnt
%define! RetVal
%include Common\GenericSWI2CSendBlockContinue.Inc

%endif %- SendBlockContinue
%-BW_METHOD_END SendBlockContinue
%-************************************************************************************************************
%-BW_METHOD_BEGIN RecvBlockCustom
%ifdef RecvBlockCustom
uint8_t %'ModuleName'%.%RecvBlockCustom(void *Ptr, uint16_t Siz, uint16_t *Rcv, %'ModuleName'%.EnumStartFlags flagsStart, %'ModuleName'%.EnumAckFlags flagsAck);
%define! ParPtr
%define! ParSiz
%define! ParRcv
%define! ParflagsStart
%define! ParflagsAck
%define! RetVal
%include Common\GenericSWI2CRecvBlockCustom.Inc

%endif %- RecvBlockCustom
%-BW_METHOD_END RecvBlockCustom
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendAck
%ifdef SendAck
void %'ModuleName'%.%SendAck(bool Ack);
%define! ParAck
%include Common\GenericSWI2CSendAck.Inc

%endif %- SendAck
%-BW_METHOD_END SendAck
%-************************************************************************************************************
%-BW_METHOD_BEGIN Deinit
%ifdef Deinit
void %'ModuleName'%.%Deinit(void);
%include Common\GenericSWI2CDeinit.Inc

%endif %- Deinit
%-BW_METHOD_END Deinit
%-BW_DEFINITION_END
/* END %ModuleName. */

#endif
/* ifndef __%'ModuleName'_H */
%include Common\Header.End
%-
%-BW_EVENT_DEFINITION_START
%-BW_METHOD_BEGIN OnNACK
%ifdef OnNACK
%INTERFACE OnNACK
void %OnNACK(void);
%include Common\GenericSWI2COnNACK.Inc

%endif %- OnNACK
%-BW_METHOD_END OnNACK
%-BW_METHOD_BEGIN OnTxChar
%ifdef OnTxChar
%INTERFACE OnTxChar
void %OnTxChar(void);
%include Common\GenericSWI2COnTxChar.Inc

%endif %- OnTxChar
%-BW_METHOD_END OnTxChar
%-BW_METHOD_BEGIN OnRxChar
%ifdef OnRxChar
%INTERFACE OnRxChar
void %OnRxChar(void);
%include Common\GenericSWI2COnRxChar.Inc

%endif %- OnRxChar
%-BW_METHOD_END OnRxChar
%-BW_EVENT_DEFINITION_END
%IMPLEMENTATION
%define! Settings Common\GenericSWI2CSettings.Inc
%define! Abstract Common\GenericSWI2CAbstract.Inc
%include Common\Header.C

/* MODULE %ModuleName. */

#include "%'ModuleName'.h"
#include "%@Wait@ModuleName.h" /* waiting routines */
#include "%@sdk@ModuleName.h" /* SDK defines */
#include "%@SDA@ModuleName.h" /* SDA pin */
#include "%@SCL@ModuleName.h" /* SCL pin */
%-BW_CUSTOM_INCLUDE_START_M
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%-BW_CUSTOM_INCLUDE_END_M

%-BW_CUSTOM_VARIABLE_START
%- Write your static variables here
%-   Example:
%-     static int counter1;
%-     int %'ModuleName'%.counter2;
%-
#if %@sdk@'ModuleName'%.CONFIG_SDK_USE_FREERTOS
  /* include RTOS header files */
  #include "FreeRTOS.h" /* for yielding */
  #include "task.h"
#endif

#if %@sdk@'ModuleName'%.CONFIG_SDK_USE_FREERTOS && %'ModuleName'%.CONFIG_DO_YIELD
  #define %'ModuleName'%.OSYIELD() taskYIELD()
#else
  #define %'ModuleName'%.OSYIELD() /* do nothing */
#endif

#define OUTPUT      1U
#define INPUT       0U
#define WRITE       0U
#define READ        1U

static uint8_t SlaveAddr;             /* destination slave address      */

#define SCL_SetDir(dir) %@SCL@'ModuleName'%.SetDir(dir)
#define SCL_ClrVal()    %@SCL@'ModuleName'%.ClrVal()
#define SCL_GetVal()    %@SCL@'ModuleName'%.GetVal()

#define SDA_SetDir(dir) %@SDA@'ModuleName'%.SetDir(dir)
#define SDA_ClrVal()    %@SDA@'ModuleName'%.ClrVal()
#define SDA_GetVal()    %@SDA@'ModuleName'%.GetVal()

#if %@sdk@'ModuleName'%.CONFIG_SDK_VERSION_USED == %@sdk@'ModuleName'%.CONFIG_SDK_PROCESSOR_EXPERT
  #define SCL_Init()      /* Init does not exist with Processor Expert API */
  #define SCL_Deinit()    /* Deinit does not exist with Processor Expert API */
  #define SDA_Init()      /* Init does not exist with Processor Expert API */
  #define SDA_Deinit()    /* Deinit does not exist with Processor Expert API */
#else
  #define SCL_Init()      %@SCL@'ModuleName'%.Init()
  #define SCL_Deinit()    %@SCL@'ModuleName'%.Deinit()
  #define SDA_Init()      %@SDA@'ModuleName'%.Init()
  #define SDA_Deinit()    %@SDA@'ModuleName'%.Deinit()
#endif

%-BW_CUSTOM_VARIABLE_END
%-BW_INTERN_METHOD_DECL_START
%- List of internal methods headers
%-UNLOCKED
/* Internal method prototypes */
%-INTERNAL_LOC_METHOD_BEG Delay
static void Delay(void);
%-INTERNAL_LOC_METHOD_END Delay
%-INTERNAL_LOC_METHOD_BEG Read
static uint8_t Read(void);
%-INTERNAL_LOC_METHOD_END Read
%-INTERNAL_LOC_METHOD_BEG GetAck
static bool GetAck(void);
%-INTERNAL_LOC_METHOD_END GetAck
%-INTERNAL_LOC_METHOD_BEG Write
static void Write(uint8_t Data);
%-INTERNAL_LOC_METHOD_END Write
%-INTERNAL_LOC_METHOD_BEG InternalStop
static void InternalStop(void);
%-INTERNAL_LOC_METHOD_END InternalStop
%-

%-BW_INTERN_METHOD_DECL_END
%-BW_IMPLEMENT_START
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG Delay
%include Common\GeneralInternalGlobal.inc (Delay)
static void Delay(void)
{
  %'ModuleName'%.OSYIELD();
  %@Wait@'ModuleName'%.Waitns(%'ModuleName'%.CONFIG_DELAY_NS);
}

%-INTERNAL_METHOD_END Delay
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG Write
%define! ParData
%include Common\GeneralInternalGlobal.inc (Write)
static void Write(uint8_t Data)
{
  uint8_t Shift;
  uint8_t I;
  uint16_t timeout;

  Shift = 0x80U;
  for (I = 0x08U; I != 0U; I--) {
    if (Data & Shift) {
      SDA_SetDir((bool)INPUT);   /* SDA HIGH */
    } else {
      SDA_SetDir((bool)OUTPUT);
      SDA_ClrVal();              /* SDA LOW */
    }
    Delay();
    Shift = (uint8_t)(Shift >> 1);
    SCL_SetDir((bool)INPUT);     /* CLOCK HIGH PULSE */
    Delay();
    timeout = %'ModuleName'%.CONFIG_TIMEOUT_COUNTER_VALUE;
    while((SCL_GetVal()==0U)&&(timeout!=0U)) { /* WAIT FOR CLOCK HIGH PULSE */
      timeout--;
      %'ModuleName'%.OSYIELD();
    }
    Delay();
    SCL_SetDir((bool)OUTPUT);
    SCL_ClrVal();                /* CLOCK LOW PULSE */
    Delay();
  }
}

%-INTERNAL_METHOD_END Write
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG Read
%define! RetVal
%include Common\GeneralInternalGlobal.inc (Read)
static uint8_t Read(void)
{
  uint8_t Shift;
  uint8_t I;
  uint16_t timeout;

  Shift = 0U;
  SDA_SetDir((bool)INPUT);       /* SDA INPUT MODE */
  Delay(); /* give SDA setup time */
  for (I = 0x08U; I != 0U; I--) {
    SCL_SetDir((bool)INPUT);     /* CLOCK HIGH PULSE */
    Delay();
    timeout = %'ModuleName'%.CONFIG_TIMEOUT_COUNTER_VALUE;
    while((SCL_GetVal()==0U)&&(timeout!=0U)) { /* WAIT FOR CLOCK HIGH PULSE */
      timeout--;
      %'ModuleName'%.OSYIELD();
    }
    Delay();
    Shift = (uint8_t)(Shift << 1);
    if (SDA_GetVal()) {
      Shift++;
    }
    SCL_SetDir((bool)OUTPUT);
    SCL_ClrVal();                /* CLOCK LOW PULSE */
    Delay();
  }
  return Shift;
}

%-INTERNAL_METHOD_END Read
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG GetAck
%define! RetVal
%include Common\GeneralInternalGlobal.inc (GetAck)
static bool GetAck(void)
{
  uint16_t timeout;

  SDA_SetDir((bool)INPUT);       /* SDA HIGH */
  Delay();
  SCL_SetDir((bool)INPUT);       /* CLOCK HIGH PULSE */
  Delay();
  timeout = %'ModuleName'%.CONFIG_TIMEOUT_COUNTER_VALUE;
  while((SCL_GetVal()==0U)&&(timeout!=0U)) { /* WAIT FOR CLOCK HIGH PULSE */
    timeout--;
    %'ModuleName'%.OSYIELD();
  }
  return((bool)SDA_GetVal());    /* ACKNOWLEDGE VALUE */
}

%-INTERNAL_METHOD_END GetAck
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendAck
%ifdef SendAck
%define! ParAck
%include Common\GenericSWI2CSendAck.Inc
void %'ModuleName'%.%SendAck(bool Ack)
{
  uint16_t timeout;

  Delay();
  if (Ack) {
    SDA_SetDir((bool)INPUT);     /* MASTER NOACKNOWLEDGE - SDA HIGH */
  } else {
    SDA_SetDir((bool)OUTPUT);
    SDA_ClrVal();                /* MASTER ACKNOWLEDGE - SDA LOW */
  }
  Delay();
  SCL_SetDir((bool)INPUT);       /* HIGH CLOCK PULSE */
  Delay();
  timeout = %'ModuleName'%.CONFIG_TIMEOUT_COUNTER_VALUE;
  while((SCL_GetVal()==0U)&&(timeout!=0U)) { /* WAIT FOR CLOCK HIGH PULSE */
    timeout--;
    %'ModuleName'%.OSYIELD();
  }
  Delay();
  SCL_SetDir((bool)OUTPUT);
  SCL_ClrVal();                  /* LOW CLOCK PULSE */
  Delay();
  SDA_SetDir((bool)INPUT);       /* ACKNOWLEDGE END - SDA HIGH  */
  Delay();
}

%endif %- SendAck
%-BW_METHOD_END SendAck
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG InternalStop
%include Common\GeneralInternalGlobal.inc (InternalStop)
static void InternalStop(void)
{
  Delay();
  SDA_SetDir((bool)OUTPUT);
  SDA_ClrVal();                  /* STOP SETUP */
  SCL_SetDir((bool)INPUT);       /* CLOCK HIGH PULSE + STOP SETUP TIME */
  Delay();
  SDA_SetDir((bool)INPUT);       /* STOP CONDITION */
  Delay();                       /* stop setup time to SCL low (which might follow) */
}

%-INTERNAL_METHOD_END InternalStop
%-************************************************************************************************************
%-BW_METHOD_BEGIN ResetBus
%ifdef ResetBus
%define! RetVal
%include Common\GenericSWI2CResetBus.Inc
bool %'ModuleName'%.%ResetBus(void)
{
  char i;

  if(SDA_GetVal() && SCL_GetVal()) {
    return TRUE;
  }
  SCL_SetDir((bool)INPUT);
  SDA_SetDir((bool)INPUT);
  Delay();
  if(!SCL_GetVal()) {
    return FALSE; /* SCL held low externally, nothing we can do */
  }
  for(i = 0; i<9; i++) { /* up to 9 clocks until SDA goes high */
    SCL_SetDir((bool)OUTPUT);
    SCL_ClrVal();
    Delay();
    SCL_SetDir((bool)INPUT);
    Delay();
    if( SDA_GetVal()) {
      break; /* finally SDA high so we can generate a STOP */
    }
  } /* for */
  if(!SDA_GetVal()) {
    return FALSE; /* after 9 clocks still nothing */
  }
  InternalStop();
  return(SDA_GetVal() && SCL_GetVal()); /* both high then we succeeded */
}

%endif %- ResetBus
%-BW_METHOD_END ResetBus
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendChar
%ifdef SendChar
%define! ParChr
%define! RetVal
%include Common\GenericSWI2CSendChar.Inc
uint8_t %'ModuleName'%.%SendChar(uint8_t Chr)
{
  uint16_t Trial;
  bool Acknowledge;
  uint16_t timeout;

  Trial = %'ModuleName'%.CONFIG_NOF_TRIALS;
  do {
    SDA_SetDir((bool)INPUT);     /* SDA HIGH - START SETUP*/
    SCL_SetDir((bool)INPUT);     /* CLOCK HIGH PULSE */
    Delay();                       /* CLOCK HIGH PULSE & BUS FREE TIME */
    /* check that we have a valid start condition: SDA needs to be high */
    timeout = %'ModuleName'%.CONFIG_TIMEOUT_COUNTER_VALUE;
    while((SDA_GetVal()==0U)&&(timeout!=0U)) { /* WAIT FOR CLOCK HIGH PULSE */
      timeout--;
      %'ModuleName'%.OSYIELD();
    }
    Delay();
    if (timeout==0) {
      InternalStop();
      return ERR_BUSY;
    }
    SDA_SetDir((bool)OUTPUT);
    SDA_ClrVal();                /* START CONDITION */
    Delay();                       /* START HOLD TIME */
    SCL_SetDir((bool)OUTPUT);
    SCL_ClrVal();                /* CLOCK LOW PULSE */
    Delay();
    Write((uint8_t)(SlaveAddr + WRITE));
    Acknowledge = GetAck();
    --Trial;
  } while ((Trial != 0U) && Acknowledge);
  if (Acknowledge) {               /* WRONG ACKNOWLEDGE */
%if defined(OnNACK)
    %OnNACK();
%endif
    SCL_SetDir((bool)OUTPUT);
    SCL_ClrVal();                /* CLOCK LOW PULSE */
    InternalStop();
    return ERR_BUSY;
  } else {
    SCL_SetDir((bool)OUTPUT);
    SCL_ClrVal();                /* CLOCK LOW PULSE */
    Delay();
  }
  Write(Chr);
  if (GetAck()) {                  /* WRONG ACKNOWLEDGE */
%if defined(OnNACK)
    %OnNACK();
%endif
    SCL_SetDir((bool)OUTPUT);
    SCL_ClrVal();                /* CLOCK LOW PULSE */
    InternalStop();
    return ERR_BUSY;
  } else {
%if defined(OnTxChar)
    %OnTxChar();
%endif
    SCL_SetDir((bool)OUTPUT);
    SCL_ClrVal();                /* CLOCK LOW PULSE */
    Delay();
  }
  return ERR_OK;
}

%endif %- SendChar
%-BW_METHOD_END SendChar
%-************************************************************************************************************
%-BW_METHOD_BEGIN RecvChar
%ifdef RecvChar
%define! ParChr
%define! RetVal
%include Common\GenericSWI2CRecvChar.Inc
uint8_t %'ModuleName'%.%RecvChar(uint8_t *Chr)
{
  uint16_t Trial;
  bool Acknowledge;
  uint16_t timeout;

  Trial = %'ModuleName'%.CONFIG_NOF_TRIALS;
  do {
    SDA_SetDir((bool)INPUT);     /* SDA HIGH - START SETUP */
    SCL_SetDir((bool)INPUT);     /* CLOCK HIGH PULSE */
    Delay();                     /* CLOCK HIGH PULSE & BUS FREE TIME */
    /* check that we have a valid start condition: SDA needs to be high */
    timeout = %'ModuleName'%.CONFIG_TIMEOUT_COUNTER_VALUE;
    while((SDA_GetVal()==0U)&&(timeout!=0U)) { /* WAIT FOR CLOCK HIGH PULSE */
      timeout--;
      %'ModuleName'%.OSYIELD();
    }
    Delay();
    if (timeout==0) {
      InternalStop();
      return ERR_BUSY;
    }
    SDA_SetDir((bool)OUTPUT);
    SDA_ClrVal();                /* START CONDITION */
    Delay();                       /* START HOLD TIME */
    SCL_SetDir((bool)OUTPUT);
    SCL_ClrVal();                /* CLOCK LOW PULSE */
    Delay();
    Write((uint8_t)(SlaveAddr + READ));
    Acknowledge = GetAck();
    --Trial;
  } while ((Trial != 0U) && Acknowledge);
  if (Acknowledge) {
%if defined(OnNACK)
    %OnNACK();
%endif
    SCL_SetDir((bool)OUTPUT);
    SCL_ClrVal();                /* CLOCK LOW PULSE */
    InternalStop();
    return ERR_BUSY;
  } else {
    SCL_SetDir((bool)OUTPUT);
    SCL_ClrVal();                /* CLOCK LOW PULSE */
    Delay();
  }
  *Chr = Read();
%if defined(OnRxChar)
  %OnRxChar();
%endif
  %'ModuleName'%.SendAck((bool)%'ModuleName'%.NOACK);
  return ERR_OK;
}

%endif %- RecvChar
%-BW_METHOD_END RecvChar
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendBlock
%ifdef SendBlock
%define! ParPtr
%define! ParSiz
%define! ParSnt
%define! RetVal
%include Common\GenericSWI2CSendBlock.Inc
uint8_t %'ModuleName'%.%SendBlock(void *Ptr, uint16_t Siz, uint16_t *Snt)
{
  register uint16_t I;
  bool Acknowledge;
  uint16_t Trial;
  uint16_t timeout;

  *Snt = 0U;
  Trial = %'ModuleName'%.CONFIG_NOF_TRIALS;
  do {
    SDA_SetDir((bool)INPUT);     /* SDA HIGH  - START SETUP */
    SCL_SetDir((bool)INPUT);     /* CLOCK HIGH PULSE */
    Delay();                     /* CLOCK HIGH PULSE + BUS FREE TIME */
    /* check that we have a valid start condition: SDA needs to be high */
    timeout = %'ModuleName'%.CONFIG_TIMEOUT_COUNTER_VALUE;
    while((SDA_GetVal()==0U)&&(timeout!=0U)) { /* WAIT FOR CLOCK HIGH PULSE */
      timeout--;
      %'ModuleName'%.OSYIELD();
    }
    Delay();
    if (timeout==0) {
      return ERR_BUSY;
    }
    SDA_SetDir((bool)OUTPUT);
    SDA_ClrVal();                /* START CONDITION */
    Delay();                     /* START HOLD TIME */
    SCL_SetDir((bool)OUTPUT);
    SCL_ClrVal();                /* CLOCK LOW PULSE */
    Delay();
    Write((uint8_t)(SlaveAddr + WRITE));
    Acknowledge = GetAck();
    --Trial;
  } while ((Trial != 0U) && Acknowledge);
  if (Acknowledge) {
%if defined(OnNACK)
    %OnNACK();
%endif
    return ERR_BUSY;
  } else {
    SCL_SetDir((bool)OUTPUT);
    SCL_ClrVal();                /* CLOCK LOW PULSE */
    Delay();
  }
  for (I = 0U; I < Siz; I++) {
    Write (*((const uint8_t*)Ptr + I) );
    if (GetAck()) {
%if defined(OnNACK)
      %OnNACK();
%endif
      SCL_SetDir((bool)OUTPUT);
      SCL_ClrVal();              /* CLOCK LOW PULSE */
      InternalStop();
      return ERR_BUSY;
    } else {
%if defined(OnTxChar)
      %OnTxChar();
%endif
      SCL_SetDir((bool)OUTPUT);
      SCL_ClrVal();              /* CLOCK LOW PULSE */
      Delay();
    }
    ++(*Snt);
  }
  Delay();
  timeout = %'ModuleName'%.CONFIG_TIMEOUT_COUNTER_VALUE;
  while((SDA_GetVal()==0U)&&(timeout!=0U)) { /* WAIT FOR CLOCK HIGH PULSE */
    timeout--;
    %'ModuleName'%.OSYIELD();
  }
  if (timeout==0) {
    return ERR_BUSY;
  }
  return ERR_OK;
}

%endif %- SendBlock
%-BW_METHOD_END SendBlock
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendBlockContinue
%ifdef SendBlockContinue
%define! ParPtr
%define! ParSiz
%define! ParSnt
%define! RetVal
%include Common\GenericSWI2CSendBlockContinue.Inc
uint8_t %'ModuleName'%.%SendBlockContinue(void *Ptr, uint16_t Siz, uint16_t *Snt)
{
  register uint16_t I;
  uint16_t timeout;

  *Snt = 0U;
  for (I = 0U; I < Siz; I++) {
    Write (*((const uint8_t*)Ptr + I) );
    if (GetAck()) {
%if defined(OnNACK)
      %OnNACK();
%endif
      SCL_SetDir((bool)OUTPUT);
      SCL_ClrVal();              /* CLOCK LOW PULSE */
      InternalStop();
      return ERR_BUSY;
    } else {
      SCL_SetDir((bool)OUTPUT);
      SCL_ClrVal();              /* CLOCK LOW PULSE */
      Delay();
    }
    ++(*Snt);
  }
  Delay();
  timeout = %'ModuleName'%.CONFIG_TIMEOUT_COUNTER_VALUE;
  while((SDA_GetVal()==0U)&&(timeout!=0U)) { /* WAIT FOR CLOCK HIGH PULSE */
    timeout--;
    %'ModuleName'%.OSYIELD();
  }
  if (timeout==0) {
    return ERR_BUSY;
  }
  return ERR_OK;
}

%endif %- SendBlockContinue
%-BW_METHOD_END SendBlockContinue
%-************************************************************************************************************
%-BW_METHOD_BEGIN RecvBlockCustom
%ifdef RecvBlockCustom
%define! ParPtr
%define! ParSiz
%define! ParRcv
%define! ParflagsStart
%define! ParflagsAck
%define! RetVal
%include Common\GenericSWI2CRecvBlockCustom.Inc
uint8_t %'ModuleName'%.%RecvBlockCustom(void *Ptr, uint16_t Siz, uint16_t *Rcv, %'ModuleName'%.EnumStartFlags flagsStart, %'ModuleName'%.EnumAckFlags flagsAck)
{
  register uint16_t I;
  bool Acknowledge;
  uint16_t Trial;
  uint16_t timeout;

  *Rcv = 0U;
  Trial = %'ModuleName'%.CONFIG_NOF_TRIALS;
  if (flagsStart == %'ModuleName'%.SEND_START) {
    do {
      SDA_SetDir((bool)INPUT);     /* SDA HIGH - START SETUP */
      SCL_SetDir((bool)INPUT);     /* CLOCK HIGH PULSE */
      Delay();                     /* CLOCK HIGH PULSE + BUS FREE TIME */
      /* check that we have a valid start condition: SDA needs to be high */
      timeout = %'ModuleName'%.CONFIG_TIMEOUT_COUNTER_VALUE;
      while((SDA_GetVal()==0U) && (timeout!=0U)) { /* WAIT FOR CLOCK HIGH PULSE */
        timeout--;
        %'ModuleName'%.OSYIELD();
      }
      Delay();
      if (timeout==0) {
        /* InternalStop(); */
        return ERR_BUSY;
      }
      SDA_SetDir((bool)OUTPUT);
      SDA_ClrVal();                /* START CONDITION */
      Delay();                     /* START HOLD TIME */
      SCL_SetDir((bool)OUTPUT);
      SCL_ClrVal();                /* CLOCK LOW PULSE */
      Delay();
      Write((uint8_t)(SlaveAddr + READ));
      Acknowledge = GetAck();
      --Trial;
    } while ((Trial != 0U) && Acknowledge);
    if (Acknowledge) {
%if defined(OnNACK)
      %OnNACK();
%endif
      /* SCL_SetDir((bool)OUTPUT); */
      /* SCL_ClrVal(); */               /* CLOCK LOW PULSE */
      /* InternalStop(); */
      return ERR_BUSY;
    } else {
      SCL_SetDir((bool)OUTPUT);
      SCL_ClrVal();                /* CLOCK LOW PULSE */
      Delay();
    }
  } /* %'ModuleName'%.SEND_START */
  for (I = 0U; I < Siz; I++) {
    *((uint8_t *)Ptr + I) = Read();
%if defined(OnRxChar)
    %OnRxChar();
%endif
    timeout = %'ModuleName'%.CONFIG_TIMEOUT_COUNTER_VALUE;
    while((SDA_GetVal()==0U)&&(timeout!=0U)) { /* WAIT FOR CLOCK HIGH PULSE */
      timeout--;
      %'ModuleName'%.OSYIELD();
    }
    if (timeout==0) {
      /* InternalStop(); */
      return ERR_BUSY;
    }
    if (I == (Siz - 1U)) {
      if(flagsAck == %'ModuleName'%.SEND_LAST_ACK){
        %'ModuleName'%.SendAck((bool)%'ModuleName'%.NOACK);
      }
    } else {
      %'ModuleName'%.SendAck((bool)%'ModuleName'%.ACK);
    }
    ++(*Rcv);
  }
  return ERR_OK;
}

%endif %- RecvBlockCustom
%-BW_METHOD_END RecvBlockCustom
%-************************************************************************************************************
%-BW_METHOD_BEGIN RecvBlock
%ifdef RecvBlock
%define! ParPtr
%define! ParSiz
%define! ParRcv
%define! RetVal
%include Common\GenericSWI2CRecvBlock.Inc
uint8_t %'ModuleName'%.%RecvBlock(void *Ptr, uint16_t Siz, uint16_t *Rcv)
{
  return %'ModuleName'%.%RecvBlockCustom(Ptr, Siz, Rcv, %'ModuleName'%.SEND_START, %'ModuleName'%.SEND_LAST_ACK);
}

%endif %- RecvBlock
%-BW_METHOD_END RecvBlock
%-************************************************************************************************************
%-BW_METHOD_BEGIN SendStop
%ifdef SendStop
%define! RetVal
%include Common\GenericSWI2CSendStop.Inc
uint8_t %'ModuleName'%.%SendStop(void)
{
  Delay();
  SDA_SetDir((bool)OUTPUT);
  SDA_ClrVal();                  /* STOP SETUP */
  Delay();
  SCL_SetDir((bool)INPUT);       /* HIGH CLOCK PULSE + STOP SETUP TIME */
  Delay();
  SDA_SetDir((bool)INPUT);       /* STOP CONDITION */
  Delay(); /* add stop time */
  return ERR_OK;
}

%endif %- SendStop
%-BW_METHOD_END SendStop
%-************************************************************************************************************
%-BW_METHOD_BEGIN SelectSlave
%ifdef SelectSlave
%define! ParSlv
%define! RetVal
%include Common\GenericSWI2CSelectSlave.Inc
uint8_t %'ModuleName'%.%SelectSlave(uint8_t Slv)
{
  SlaveAddr = (uint8_t)(Slv<<1);
  return ERR_OK;
}

%endif %- SelectSlave
%-BW_METHOD_END SelectSlave
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetSelected
%ifdef GetSelected
%define! ParSlv
%define! RetVal
%include Common\GenericSWI2CGetSelected.Inc
uint8_t %'ModuleName'%.%GetSelected(uint8_t *Slv)
{
  *Slv = (uint8_t)(SlaveAddr>>1);
  return ERR_OK;
}

%endif %- GetSelected
%-BW_METHOD_END GetSelected
%-************************************************************************************************************
%-BW_METHOD_BEGIN Init
%ifdef Init
%include Common\GenericSWI2CInit.Inc
void %'ModuleName'%.%Init(void)
{
  SlaveAddr = 0;
  SDA_Init();
  SCL_Init();
}

%endif %- Init
%-BW_METHOD_END Init
%-************************************************************************************************************
%-BW_METHOD_BEGIN Deinit
%ifdef Deinit
%include Common\GenericSWI2CDeinit.Inc
void %'ModuleName'%.%Deinit(void)
{
  SCL_Deinit();
  SDA_Deinit();
  SlaveAddr = 0;
}

%endif %- Deinit
%-BW_METHOD_END Deinit
%-BW_IMPLEMENT_END
/* END %ModuleName. */

%include Common\Header.End
%-
%-
%-BW_EVENT_IMPLEMENT_START
%-BW_METHOD_BEGIN OnNACK
%ifdef OnNACK
%IMPLEMENTATION OnNACK
%include Common\GenericSWI2COnNACK.Inc
void %OnNACK(void)
{
  /* Write your code here ... */
}

%endif %- OnNACK
%-BW_METHOD_END OnNACK
%-BW_METHOD_BEGIN OnTxChar
%ifdef OnTxChar
%IMPLEMENTATION OnTxChar
%include Common\GenericSWI2COnTxChar.Inc
void %OnTxChar(void)
{
  /* Write your code here ... */
}

%endif %- OnTxChar
%-BW_METHOD_END OnTxChar
%-BW_METHOD_BEGIN OnRxChar
%ifdef OnRxChar
%IMPLEMENTATION OnRxChar
%include Common\GenericSWI2COnRxChar.Inc
void %OnRxChar(void)
{
  /* Write your code here ... */
}

%endif %- OnRxChar
%-BW_METHOD_END OnRxChar
%-BW_EVENT_IMPLEMENT_END
%INITIALIZATION
%CODE_BEGIN
%if (CPUfamily = "S32K")
#ifdef CPU_INIT_MCUONECLIPSE_DRIVERS
%endif
  %'ModuleName'%.%Init(); /* ### %DeviceType "%DeviceName" init code ... */
%if (CPUfamily = "S32K")
#endif
%endif
%CODE_END
%-
%ENABLE
%CODE_BEGIN
%CODE_END
%-----------------------------------------------------------------------------------------
%if defined(sdk) & %@sdk@ConfigFilesFolderName <> ""
  %define  ConfigSrcDirFolder %%@sdk@ConfigFilesFolderName/
%else
  %define  ConfigSrcDirFolder
%endif
%----------------------------
%FILE %'DirRel_Code'%'ConfigSrcDirFolder'%'ModuleName'config.h
/**
 * \file
 * \brief Configuration header file for GenericSWI2C
 * Copyright (c) 2020, Erich Styger
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * This header file is used to configure settings of the software (bit-banging) I2C module.
 */

#ifndef __%'ModuleName'_CONFIG_H
#define __%'ModuleName'_CONFIG_H

#ifndef %'ModuleName'%.CONFIG_TIMEOUT_COUNTER_VALUE
  #define %'ModuleName'%.CONFIG_TIMEOUT_COUNTER_VALUE    (%TimeoutCntrVal)
    /*!< Timeout counter value waiting for a SDA or CLK line change. The higher the value, the longer the timeout */
#endif

#ifndef %'ModuleName'%.CONFIG_DELAY_NS
  #define %'ModuleName'%.CONFIG_DELAY_NS    (%DelayNs)
    /*!< delay time in ns */
#endif

#ifndef %'ModuleName'%.CONFIG_NOF_TRIALS
  #define %'ModuleName'%.CONFIG_NOF_TRIALS    (%NofTrials)
    /*!< number of trials */
#endif

#ifndef %'ModuleName'%.CONFIG_DO_YIELD
%if defined(Yield) & %Yield='yes'
  #define %'ModuleName'%.CONFIG_DO_YIELD    (1)
%else
  #define %'ModuleName'%.CONFIG_DO_YIELD    (0)
%endif
    /*!< 1: if RTOS present, do a yield. 0: do not yield during waiting */
#endif

#endif /* __%'ModuleName'_CONFIG_H */
%-----------------------------------------------------------------------------------------
%else %- Language (& Compiler)
  %error^ This component is not implemented in selected language & compiler !
%endif %- Language (& Compiler)
%DEBUG
%ALL_SYMBOLS
%-
