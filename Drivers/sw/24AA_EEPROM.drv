%-Driver generated by the Bean Wizard
%-
%- WARNING !
%-
%- Do not make changes to these lines (if you make some changes, you damage this driver)
%- which begins with:
%-
%-  %-STARTUSERTYPES
%-  %-ENDUSRTYPES
%-  /* END %ModuleName. */
%-  /* MODULE %ModuleName. */
%-  %-INTERNAL_METHOD_BEG
%-  %-INTERNAL_METHOD_END
%-  %-INHERITED_EVENT_BEGIN
%-  %-INHERITED_EVENT_END
%-  %-BW_METHOD_BEGIN
%-  %-BW_METHOD_END
%-  %-BW_DEFINITION_START
%-  %-BW_DEFINITION_END
%-  %-BW_IMPLEMENT_START
%-  %-BW_IMPLEMENT_END
%-  %-BW_EVENT_DEFINITION_START
%-  %-BW_EVENT_DEFINITION_END
%-  %-BW_EVENT_IMPLEMENT_START
%-  %-BW_EVENT_IMPLEMENT_END
%-  %-BW_METHOD_MACROS_START
%-  %-BW_METHOD_MACROS_END
%-  %-BW_SECTIONS_INSERT
%-  %-BW_INTERN_COMMENTS_START
%-  %-BW_INTERN_COMMENTS_END
%-  %-BW_BEAN_CONSTANTS_START
%-  %-BW_BEAN_CONSTANTS_END
%-
%-
%- These lines are not comments, but they are necessary for Bean Wizard
%- If you change these lines, Bean Wizard will not be responsible for loosing or damaging your code!
%-
%-
%- readyCPU ...
%- readyDEVICE ...
%-
%define DriverAuthor  Author
%define DriverVersion 01.00
%define DriverDate    01.07.2009
%-
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END
%-
%-BW_INTERN_COMMENTS_START
%- List of descriptions of internal methods
%define! Description_WriteBlockPage Writes a block with pages of data to the EEPROM
%-BW_INTERN_COMMENTS_END
%-
%-BW_SECTIONS_INSERT
%if Language='ANSIC'
%-
%-
%INTERFACE
%define! Settings Common\24AA_EEPROMSettings.Inc
%define! Abstract Common\24AA_EEPROMAbstract.Inc
%include Common\Header.h

#ifndef __%'ModuleName'_H
#define __%'ModuleName'_H

/* MODULE %ModuleName. */
#include "%@sdk@ModuleName.h" /* SDK and API used */
#include "%'ModuleName'config.h" /* configuration */

#if %'ModuleName'%.CONFIG_USE_SHELL
%if defined(Shell)
  #include "%@Shell@ModuleName.h"
%else
  #include "McuShell.h"
%endif
#endif

%-BW_CUSTOM_INCLUDE_START_H
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%-BW_CUSTOM_INCLUDE_END_H
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END

#if %'ModuleName'%.CONFIG_DEVICE_ID==8
  #define %'ModuleName'%.MAX_I2C_ADDR_MASK 0                     %>40 /* A2|A1|A0 are not used */
  #define %'ModuleName'%.MAX_ADDRESS       0x03FF                %>40 /* 8 kBit is 1KByte */
  #define %'ModuleName'%.ADDRT             uint16_t              %>40 /* a word/16bit is enough to hold the address */
  #define %'ModuleName'%.PAGE_SIZE         16                    %>40 /* maximum page size (for page/block operation) */
#elif %'ModuleName'%.CONFIG_DEVICE_ID==16
  #define %'ModuleName'%.MAX_I2C_ADDR_MASK 0                     %>40 /* A2|A1|A0 are not used */
  #define %'ModuleName'%.MAX_ADDRESS       0x07FF                %>40 /* 16 kBit is 2KByte */
  #define %'ModuleName'%.ADDRT             uint16_t              %>40 /* a word/16bit is enough to hold the address */
  #define %'ModuleName'%.PAGE_SIZE         16                    %>40 /* maximum page size (for page/block operation) */
#elif %'ModuleName'%.CONFIG_DEVICE_ID==32
  #define %'ModuleName'%.MAX_I2C_ADDR_MASK 7                     %>40 /* A2|A1|A0 form the I2C device address => address cannot be more than 7 (8 devices) */
  #define %'ModuleName'%.MAX_ADDRESS       0x0FFF                %>40 /* 32 kBit are 4KByte */
  #define %'ModuleName'%.ADDRT             uint16_t              %>40 /* a word/16bit is enough to hold the address */
  #define %'ModuleName'%.PAGE_SIZE         8                     %>40 /* maximum page size (for page/block operation) */
#elif %'ModuleName'%.CONFIG_DEVICE_ID==256
  #define %'ModuleName'%.MAX_I2C_ADDR_MASK 7                     %>40 /* A2|A1|A0 form the I2C device address => address cannot be more than 7 (8 devices) */
  #define %'ModuleName'%.MAX_ADDRESS       0x7FFF                %>40 /* 256 kBit are 32KByte */
  #define %'ModuleName'%.ADDRT             uint16_t              %>40 /* a word/16bit is enough to hold the address */
  #define %'ModuleName'%.PAGE_SIZE         64                    %>40 /* maximum page size (for page/block operation) */
#elif %'ModuleName'%.CONFIG_DEVICE_ID==512
  #define %'ModuleName'%.MAX_I2C_ADDR_MASK 7                     %>40 /* A2|A1|A0 form the I2C device address => address cannot be more than 7 (8 devices) */
  #define %'ModuleName'%.MAX_ADDRESS       0xFFFF                %>40 /* 512 kBit are 64KByte */
  #define %'ModuleName'%.ADDRT             uint16_t              %>40 /* a word/16bit is enough to hold the address */
  #define %'ModuleName'%.PAGE_SIZE         128                   %>40 /* maximum page size (for page/block operation) */
#elif %'ModuleName'%.CONFIG_DEVICE_ID==1025
  #define %'ModuleName'%.MAX_I2C_ADDR_MASK 3                     %>40 /* A1|A0 form the I2C device address => address cannot be more than 3 (4 devices) */
  #define %'ModuleName'%.MAX_ADDRESS       0x1FFFF               %>40 /* 1024 kBit are 128KByte */
  #define %'ModuleName'%.ADDRT             uint32_t              %>40 /* a longword/32bit is needed to hold the address */
  #define %'ModuleName'%.PAGE_SIZE         128                   %>40 /* maximum page size (for page/block operation) */
#else
  #error "unknown device?"
#endif
%-STARTUSERTYPES - Do not make changes between lines (included this lines) marked with %-STARTUSERTYPES and %-ENDUSRTYPES

#ifndef __BWUserType_%'ModuleName'_Address
#define __BWUserType_%'ModuleName'_Address
  typedef  %'ModuleName'%.ADDRT %'ModuleName'%.Address;          %>40/* A type large enought to hold the address, depending on the EEPROM used. */
#endif

%-ENDUSRTYPES
%-BW_BEAN_CONSTANTS_START  - Do not make changes between lines (included this lines) marked with %-BW_BEAN_CONSTANTS_START and %-BW_BEAN_CONSTANTS_END
%- No constants defined in the BeanWizard for this bean
%-BW_BEAN_CONSTANTS_END
%-BW_CUSTOM_USERTYPE_START
%- Write your own types here ...
%-  Example:
%-    typedef int TMyInteger;
%ifdef ParseCommand
#define %'ModuleName'%.PARSE_COMMAND_ENABLED  1  /* set to 1 if method ParseCommand() is present, 0 otherwise */
%else
#define %'ModuleName'%.PARSE_COMMAND_ENABLED  0 /* set to 1 if method ParseCommand() is present, 0 otherwise */
%endif %- ParseCommand

%-
%-BW_CUSTOM_USERTYPE_END
%-BW_DEFINITION_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN WriteByte
%ifdef WriteByte
uint8_t %'ModuleName'%.%WriteByte(%'ModuleName'_Address addr, uint8_t data);
%define! Paraddr
%define! Pardata
%define! RetVal
%include Common\24AA_EEPROMWriteByte.Inc

%endif %- WriteByte
%-BW_METHOD_END WriteByte
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadByte
%ifdef ReadByte
uint8_t %'ModuleName'%.%ReadByte(%'ModuleName'_Address addr, uint8_t *data);
%define! Paraddr
%define! Pardata
%define! RetVal
%include Common\24AA_EEPROMReadByte.Inc

%endif %- ReadByte
%-BW_METHOD_END ReadByte
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadBlock
%ifdef ReadBlock
uint8_t %'ModuleName'%.%ReadBlock(%'ModuleName'_Address addr, uint8_t *data, uint16_t dataSize);
%define! Paraddr
%define! Pardata
%define! PardataSize
%define! RetVal
%include Common\24AA_EEPROMReadBlock.Inc

%endif %- ReadBlock
%-BW_METHOD_END ReadBlock
%-************************************************************************************************************
%-BW_METHOD_BEGIN WriteBlock
%ifdef WriteBlock
uint8_t %'ModuleName'%.%WriteBlock(%'ModuleName'_Address addr, uint8_t *data, uint16_t dataSize);
%define! Paraddr
%define! Pardata
%define! PardataSize
%define! RetVal
%include Common\24AA_EEPROMWriteBlock.Inc

%endif %- WriteBlock
%-BW_METHOD_END WriteBlock
%-************************************************************************************************************
%-BW_METHOD_BEGIN Test
%ifdef Test
uint8_t %'ModuleName'%.%Test(void);
%define! RetVal
%include Common\24AA_EEPROMTest.Inc

%endif %- Test
%-BW_METHOD_END Test
%-************************************************************************************************************
%-BW_METHOD_BEGIN WriteProtect
%ifdef WriteProtect
void %'ModuleName'%.%WriteProtect(void);
%include Common\24AA_EEPROMWriteProtect.Inc

%endif %- WriteProtect
%-BW_METHOD_END WriteProtect
%-************************************************************************************************************
%-BW_METHOD_BEGIN WriteUnprotect
%ifdef WriteUnprotect
void %'ModuleName'%.%WriteUnprotect(void);
%include Common\24AA_EEPROMWriteUnprotect.Inc

%endif %- WriteUnprotect
%-BW_METHOD_END WriteUnprotect
%-************************************************************************************************************
%-BW_METHOD_BEGIN SelectDevice
%ifdef SelectDevice
uint8_t %'ModuleName'%.%SelectDevice(uint8_t addrI2C);
%define! ParaddrI2C
%define! RetVal
%include Common\24AA_EEPROMSelectDevice.Inc

%endif %- SelectDevice
%-BW_METHOD_END SelectDevice
%-************************************************************************************************************
%-BW_METHOD_BEGIN ParseCommand
%ifdef ParseCommand
uint8_t %'ModuleName'%.%ParseCommand(const unsigned char *cmd, bool *handled, const %@Shell@'ModuleName'%.StdIOType *io);
%define! Parcmd
%define! Parhandled
%define! Pario
%define! RetVal
%include Common\MAG3110ParseCommand.Inc

%endif %- ParseCommand
%-BW_METHOD_END ParseCommand
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetSelectedDevice
%ifdef GetSelectedDevice
uint8_t %'ModuleName'%.%GetSelectedDevice(void);
%define! RetVal
%include Common\24AA_EEPROMGetSelectedDevice.Inc

%endif %- GetSelectedDevice
%-BW_METHOD_END GetSelectedDevice
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG WriteBlockPage
uint8_t %'ModuleName'%.WriteBlockPage(%'ModuleName'_Address addr, uint8_t *data, uint16_t dataSize);
%define! Paraddr
%define! Pardata
%define! PardataSize
%define! RetVal
%include Common\GeneralInternal.inc (WriteBlockPage)

%-INTERNAL_METHOD_END WriteBlockPage
%-************************************************************************************************************
%-BW_METHOD_BEGIN Deinit
%ifdef Deinit
void %'ModuleName'%.%Deinit(void);
%include Common\24AA_EEPROMDeinit.Inc

%endif %- Deinit
%-BW_METHOD_END Deinit
%-************************************************************************************************************
%-BW_METHOD_BEGIN Init
%ifdef Init
void %'ModuleName'%.%Init(void);
%include Common\24AA_EEPROMInit.Inc

%endif %- Init
%-BW_METHOD_END Init
%-BW_DEFINITION_END
/* END %ModuleName. */

#endif
/* ifndef __%'ModuleName'_H */
%include Common\Header.End
%-
%-BW_EVENT_DEFINITION_START
%-BW_EVENT_DEFINITION_END
%IMPLEMENTATION
%define! Settings Common\24AA_EEPROMSettings.Inc
%define! Abstract Common\24AA_EEPROMAbstract.Inc
%include Common\Header.C

/* MODULE %ModuleName. */

%for var from EventModules
#include "%var.h"
%endfor
#include "%'ModuleName'.h"
#if %'ModuleName'%.CONFIG_HAS_WP_PIN
%if defined(WP)
  #include "%@WP@ModuleName.h"
%else
  #include "WPpin1.h"
%endif
#endif
%if defined(Wait)
#include "%@Wait@ModuleName.h"
%else
#include "McuWait.h"
%endif
#if %'ModuleName'%.CONFIG_USE_SHELL
%if defined(Shell)
  #include "%@Shell@ModuleName.h"
%else
  #include "McuShell.h"
%endif
#endif
#if %'ModuleName'%.CONFIG_USE_UTILITY
%if defined(Utility)
  #include "%@Utility@ModuleName.h"
%else
  #include "McuUtility.h"
%endif
#endif
%if defined(I2C)
#include "%@I2C@ModuleName.h"
%else
#include "McuGenericI2C.h"
%endif
#if %'ModuleName'%.CONFIG_USE_TIMEOUT
%if defined(Timeout)
  #include "%@Timeout@ModuleName.h"
%else
  #include "McuTimeout.h"
%endif
#endif

%-BW_CUSTOM_INCLUDE_START_M
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
#if %'ModuleName'%.CONFIG_USE_TIMEOUT
%if defined(Timeout)
  #define %'ModuleName'%.TIMEOUT_BYTE_TICKS     (%'ModuleName'%.CONFIG_TIMEOUT_BYTE_MS/(%@Timeout@'ModuleName'%.TICK_PERIOD_MS))
  #define %'ModuleName'%.TIMEOUT_BLOCK_TICKS    (%'ModuleName'%.CONFIG_TIMEOUT_BLOCK_MS/(%@Timeout@'ModuleName'%.TICK_PERIOD_MS))
%else
  #define %'ModuleName'%.TIMEOUT_BYTE_TICKS     (%'ModuleName'%.CONFIG_TIMEOUT_BYTE_MS/(McuTimeout_TICK_PERIOD_MS))
  #define %'ModuleName'%.TIMEOUT_BLOCK_TICKS    (%'ModuleName'%.CONFIG_TIMEOUT_BLOCK_MS/(McuTimeout_TICK_PERIOD_MS))
%endif
#endif
%-BW_CUSTOM_INCLUDE_END_M

%-BW_CUSTOM_VARIABLE_START
%- Write your static variables here
%-   Example:
%-     static int counter1;
%-     int %'ModuleName'%.counter2;
%-
%ifdef SelectDevice
static uint8_t %'ModuleName'%.I2CAddress = (%'ModuleName'%.CONFIG_DEVICE_I2C_ADDRESS_BITS&%'ModuleName'%.MAX_I2C_ADDR_MASK);%>40 /* current I2C address used */
%else
#define %'ModuleName'%.I2CAddress (%'ModuleName'%.CONFIG_DEVICE_I2C_ADDRESS_BITS&%'ModuleName'%.MAX_I2C_ADDR_MASK)%>40 /* address defined by the A2|A1|A0 pins */
%endif %- SelectDevice

/* macros for the control byte: */
#define %'ModuleName'%.CTRL_NBL       (0x0A<<3)                  %>40 /* control byte high nibble. Typically this is 1010 (shifted by one to the right) */
#if (%'ModuleName'%.CONFIG_DEVICE_ID==8) || (%'ModuleName'%.CONFIG_DEVICE_ID==16)
  #define %'ModuleName'%.CTRL_ADDR      0                        %>40 /* no additional address bits */
  /* define control byte as 1010|Bx|B1|B0 */
  #define %'ModuleName'%.BANK_0         (0<<2)                   %>40 /* B0 bit (0) inside the CTRL_BYTE: 1010|B0|A1|A0 */
  #define %'ModuleName'%.BANK_1         (1<<2)                   %>40 /* B0 bit (1) inside the CTRL_BYTE: 1010|B0|A1|A0 */
  #define %'ModuleName'%.CTRL_BYTE      (%'ModuleName'%.CTRL_NBL|%'ModuleName'%.CTRL_ADDR)%>40 /* 1010|B0|A1|A0 */
  #define %'ModuleName'%.DEVICE_ADDR(addr) \
    ( %'ModuleName'%.CTRL_BYTE|((addr>>8)&0x07) )
  #if 0 /* old style */
    (((addr)&0x400)? \
        (%'ModuleName'%.CTRL_BYTE|%'ModuleName'%.BANK_1) \
      : (%'ModuleName'%.CTRL_BYTE|%'ModuleName'%.BANK_0) )       %>40 /* 7bit address of device used to select device */
  #endif
#elif (%'ModuleName'%.CONFIG_DEVICE_ID==32) || (%'ModuleName'%.CONFIG_DEVICE_ID==256) || (%'ModuleName'%.CONFIG_DEVICE_ID==512)
  #define %'ModuleName'%.CTRL_ADDR      %'ModuleName'%.I2CAddress%>40 /* address inside control byte */
  /* define control byte as 1010|A2|A1|A0 */
  #define %'ModuleName'%.CTRL_BYTE         (%'ModuleName'%.CTRL_NBL|%'ModuleName'%.CTRL_ADDR)%>40 /* 1010|A2|A1|A0 */
  #define %'ModuleName'%.DEVICE_ADDR(addr) %'ModuleName'%.CTRL_BYTE%>40 /* 7bit address of device used to select device */
#elif %'ModuleName'%.CONFIG_DEVICE_ID==1025
  #define %'ModuleName'%.CTRL_ADDR      %'ModuleName'%.I2CAddress%>40 /* address inside control byte */
  /* define control byte as 1010|Bx|A1|A0 */
  #define %'ModuleName'%.BANK_0         (0<<2)                   %>40 /* B0 bit (0) inside the CTRL_BYTE: 1010|B0|A1|A0 */
  #define %'ModuleName'%.BANK_1         (1<<2)                   %>40 /* B0 bit (1) inside the CTRL_BYTE: 1010|B0|A1|A0 */
  #define %'ModuleName'%.CTRL_BYTE      (%'ModuleName'%.CTRL_NBL|%'ModuleName'%.CTRL_ADDR)%>40 /* 1010|B0|A1|A0 */
  #define %'ModuleName'%.DEVICE_ADDR(addr) \
    (((addr)&0x10000)? \
        (%'ModuleName'%.CTRL_BYTE|%'ModuleName'%.BANK_1) \
      : (%'ModuleName'%.CTRL_BYTE|%'ModuleName'%.BANK_0) )       %>40 /* 7bit address of device used to select device */
#endif

%if defined(Shell)
static uint8_t PrintStatus(const %@Shell@'ModuleName'%.StdIOType *io) {
  unsigned char buf[32];

  %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"%'ModuleName'", (unsigned char*)"\r\n", io->stdOut);

  %@Utility@'ModuleName'%.strcpy(buf, sizeof(buf), (unsigned char*)"0x");
  %@Utility@'ModuleName'%.strcatNum8Hex(buf, sizeof(buf), (uint8_t)%'ModuleName'%.DEVICE_ADDR(0));
  %@Utility@'ModuleName'%.strcat(buf, sizeof(buf), (unsigned char*)" (for memory @0x00)\r\n");
  %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"  I2C Addr", buf, io->stdOut);

  %@Utility@'ModuleName'%.Num16uToStr(buf, sizeof(buf), (uint16_t)%'ModuleName'%.CONFIG_DEVICE_ID);
  %@Utility@'ModuleName'%.strcat(buf, sizeof(buf), (unsigned char*)"\r\n");
  %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"  Type", buf, io->stdOut);

  return ERR_OK;
}

static uint8_t PrintHelp(const %@Shell@'ModuleName'%.StdIOType *io) {
  %@Shell@'ModuleName'%.SendHelpStr((unsigned char*)"%'ModuleName'", (unsigned char*)"Group of %'ModuleName' commands\r\n", io->stdOut);
  %@Shell@'ModuleName'%.SendHelpStr((unsigned char*)"  help|status", (unsigned char*)"Print help or status information\r\n", io->stdOut);
  %@Shell@'ModuleName'%.SendHelpStr((unsigned char*)"  read 0x<addr>", (unsigned char*)"Read a byte from an address\r\n", io->stdOut);
  %@Shell@'ModuleName'%.SendHelpStr((unsigned char*)"  write 0x<addr> 0x<value>", (unsigned char*)"Write a byte to an address\r\n", io->stdOut);
  return ERR_OK;
}

%endif
%-BW_CUSTOM_VARIABLE_END
%-BW_INTERN_METHOD_DECL_START
%- List of internal methods headers
%-BW_INTERN_METHOD_DECL_END
%-BW_IMPLEMENT_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN WriteByte
%ifdef WriteByte
%define! Paraddr
%define! Pardata
%define! RetVal
%include Common\24AA_EEPROMWriteByte.Inc
uint8_t %'ModuleName'%.%WriteByte(%'ModuleName'_Address addr, uint8_t data)
{
  uint8_t res, block[3];
#if %'ModuleName'%.CONFIG_USE_TIMEOUT
%if defined(Timeout)
#if %'ModuleName'%.DO_ACKNOWLEDGE_POLLING && %'ModuleName'%.TIMEOUT_BYTE_TICKS>0
  %@Timeout@'ModuleName'%.CounterHandle timeout;
  bool isTimeout;
#endif
%endif
#endif

  res = %@I2C@'ModuleName'%.SelectSlave(%'ModuleName'%.DEVICE_ADDR(addr));
  if (res != ERR_OK) {
    (void)%@I2C@'ModuleName'%.UnselectSlave();
    return res;
  }
  #if (%'ModuleName'%.CONFIG_DEVICE_ID==8) || (%'ModuleName'%.CONFIG_DEVICE_ID==16)
    block[0] = (uint8_t)(addr&0xff);                             %>40 /* low byte of address */
    block[1] = data; /* switch to read mode */
    res = %@I2C@'ModuleName'%.WriteBlock(block, 2, %@I2C@'ModuleName'%.SEND_STOP);%>40 /* send address and data */
  #else
    block[0] = (uint8_t)(addr>>8);                               %>40 /* high byte of address */
    block[1] = (uint8_t)(addr&0xff);                             %>40 /* low byte of address */
    block[2] = data; /* switch to read mode */
    res = %@I2C@'ModuleName'%.WriteBlock(block, sizeof(block), %@I2C@'ModuleName'%.SEND_STOP);%>40 /* send address and data */
  #endif
  if (res != ERR_OK) {
    (void)%@I2C@'ModuleName'%.UnselectSlave();
    return res;
  }
#if %'ModuleName'%.DO_ACKNOWLEDGE_POLLING
  /* do acknowledge polling */
  block[0] = 0xff; /* dummy value */
#if %'ModuleName'%.CONFIG_USE_TIMEOUT
%if defined(Timeout)
#if %'ModuleName'%.TIMEOUT_BYTE_TICKS>0
    timeout = %@Timeout@'ModuleName'%.GetCounter(%'ModuleName'%.TIMEOUT_BYTE_TICKS); /* set up timeout counter */
    if (timeout==%@Timeout@'ModuleName'%.OUT_OF_HANDLE) {
      (void)%@I2C@'ModuleName'%.UnselectSlave();
      return ERR_FAILED;
    }
#endif
%endif
#endif
  do {
#if %'ModuleName'%.CONFIG_USE_TIMEOUT
%if defined(Timeout)
#if %'ModuleName'%.TIMEOUT_BYTE_TICKS>0
    isTimeout = %@Timeout@'ModuleName'%.CounterExpired(timeout);
    if (isTimeout) {
      break; /* break while() */
    }
#endif
%endif
#endif
    %@Wait@'ModuleName'%.WaitOSms(%'ModuleName'%.CONFIG_PAGE_WRITE_TIME_MS);
    res = %@I2C@'ModuleName'%.ProbeACK(block, 1, %@I2C@'ModuleName'%.SEND_STOP, %'ModuleName'%.CONFIG_ACK_POLLING_TIME_US);%>40 /* send address and data */
  } while(res!=ERR_OK); /* wait until we get an ACK */
#if %'ModuleName'%.CONFIG_USE_TIMEOUT
%if defined(Timeout)
#if %'ModuleName'%.TIMEOUT_BYTE_TICKS>0
    %@Timeout@'ModuleName'%.LeaveCounter(timeout);
    if (isTimeout) {
      res = ERR_FAILED;
    }
#endif
%endif
#endif
#endif /* %'ModuleName'%.CONFIG_DO_ACKNOWLEDGE_POLLING */
  if (res != ERR_OK) {
    (void)%@I2C@'ModuleName'%.UnselectSlave();
    return res;
  }
  return %@I2C@'ModuleName'%.UnselectSlave();
}

%endif %- WriteByte
%-BW_METHOD_END WriteByte
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadByte
%ifdef ReadByte
%define! Paraddr
%define! Pardata
%define! RetVal
%include Common\24AA_EEPROMReadByte.Inc
uint8_t %'ModuleName'%.%ReadByte(%'ModuleName'_Address addr, uint8_t *data)
{
  uint8_t res;
  #if (%'ModuleName'%.CONFIG_DEVICE_ID==8) || (%'ModuleName'%.CONFIG_DEVICE_ID==16)
    uint8_t addr8;
    addr8 = (uint8_t)(addr&0xff); /* low address byte */
  #else
    uint8_t addr16[2];                                           %>40 /* big endian address on I2C bus needs to be 16bit */

    addr16[0] = (uint8_t)(addr>>8); /* 16 bit address must be in big endian format */
    addr16[1] = (uint8_t)(addr&0xff);
  #endif

  res = %@I2C@'ModuleName'%.SelectSlave(%'ModuleName'%.DEVICE_ADDR(addr));
  if (res != ERR_OK) {
    (void)%@I2C@'ModuleName'%.UnselectSlave();
    return res;
  }
  #if (%'ModuleName'%.CONFIG_DEVICE_ID==8) || (%'ModuleName'%.CONFIG_DEVICE_ID==16)
    res = %@I2C@'ModuleName'%.WriteBlock(&addr8, 1, %@I2C@'ModuleName'%.DO_NOT_SEND_STOP);%>40 /* send 8bit address */
  #else /* use 16bit address */
    res = %@I2C@'ModuleName'%.WriteBlock(addr16, 2, %@I2C@'ModuleName'%.DO_NOT_SEND_STOP);%>40 /* send 16bit address */
  #endif
  if (res != ERR_OK) {
    (void)%@I2C@'ModuleName'%.UnselectSlave();
    return res;
  }
  res = %@I2C@'ModuleName'%.ReadBlock(data, 1, %@I2C@'ModuleName'%.SEND_STOP);%>40 /* read data byte from bus */
  if (res != ERR_OK) {
    (void)%@I2C@'ModuleName'%.UnselectSlave();
    return res;
  }
  return %@I2C@'ModuleName'%.UnselectSlave();
}

%endif %- ReadByte
%-BW_METHOD_END ReadByte
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadBlock
%ifdef ReadBlock
%define! Paraddr
%define! Pardata
%define! PardataSize
%define! RetVal
%include Common\24AA_EEPROMReadBlock.Inc
uint8_t %'ModuleName'%.%ReadBlock(%'ModuleName'_Address addr, uint8_t *data, uint16_t dataSize)
{
  uint8_t res;
  #if (%'ModuleName'%.CONFIG_DEVICE_ID==8) || (%'ModuleName'%.CONFIG_DEVICE_ID==16)
    uint8_t addr8;
    addr8 = (uint8_t)(addr&0xff);
  #else
    uint8_t addr16[2];                                           %>40 /* big endian address on I2C bus needs to be 16bit */
    addr16[0] = (uint8_t)(addr>>8); /* 16 bit address must be in big endian format */
    addr16[1] = (uint8_t)(addr&0xff);
  #endif

  res = %@I2C@'ModuleName'%.SelectSlave(%'ModuleName'%.DEVICE_ADDR(addr));
  if (res != ERR_OK) {
    (void)%@I2C@'ModuleName'%.UnselectSlave();
    return res;
  }
  #if (%'ModuleName'%.CONFIG_DEVICE_ID==8) || (%'ModuleName'%.CONFIG_DEVICE_ID==16)
    res = %@I2C@'ModuleName'%.WriteBlock(&addr8, 1, %@I2C@'ModuleName'%.DO_NOT_SEND_STOP);%>40 /* send 8bit address */
  #else
    res = %@I2C@'ModuleName'%.WriteBlock(addr16, 2, %@I2C@'ModuleName'%.DO_NOT_SEND_STOP);%>40 /* send 16bit address */
  #endif
  if (res != ERR_OK) {
    (void)%@I2C@'ModuleName'%.UnselectSlave();
    return res;
  }
  res = %@I2C@'ModuleName'%.ReadBlock(data, dataSize, %@I2C@'ModuleName'%.SEND_STOP);
  if (res != ERR_OK) {
    (void)%@I2C@'ModuleName'%.UnselectSlave();
    return res;
  }
  return %@I2C@'ModuleName'%.UnselectSlave();
}

%endif %- ReadBlock
%-BW_METHOD_END ReadBlock
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG WriteBlockPage
%define! Paraddr
%define! Pardata
%define! PardataSize
%define! RetVal
%include Common\GeneralInternal.inc (WriteBlockPage)
#ifdef __HIWARE__
#pragma MESSAGE DISABLE C1855 /* recursive function call */
#endif
uint8_t %'ModuleName'%.WriteBlockPage(%'ModuleName'_Address addr, uint8_t *data, uint16_t dataSize)
{
#if %'ModuleName'%.CONFIG_USE_TIMEOUT
%if defined(Timeout)
#if %'ModuleName'%.DO_ACKNOWLEDGE_POLLING && %'ModuleName'%.TIMEOUT_BLOCK_TICKS>0
  %@Timeout@'ModuleName'%.CounterHandle timeout;
  bool isTimeout;
#endif
%endif
#endif
  uint8_t res, i, *p, block[%'ModuleName'%.CONFIG_BLOCK_BUF_SIZE+2];%>40 /* additional 2 bytes for the address */
  uint16_t eepromPage = (uint16_t)(addr/%'ModuleName'%.PAGE_SIZE);
  uint8_t offset = (uint8_t)(addr%%%'ModuleName'%.PAGE_SIZE);

  if (dataSize==0 || dataSize>%'ModuleName'%.CONFIG_BLOCK_BUF_SIZE) {
    return ERR_OVERFLOW;                                         %>40 /* you may increase the buffer size in the properties? */
  }
  if (dataSize>%'ModuleName'%.PAGE_SIZE) {
    uint16_t size;

    size = (uint16_t)(%'ModuleName'%.PAGE_SIZE-offset);
    if (size!=0) {
      res = %'ModuleName'%.WriteBlock(addr, data, size);         %>40 /* first page write */
      if (res != ERR_OK) {
        return res;
      }
      data += size; /* increment data pointer */
      addr += size; /* increment address */
      dataSize -= size; /* reduce size */
    }
    /* write multiple block of PAGE_SIZE */
    while (dataSize>%'ModuleName'%.PAGE_SIZE) {
      res = %'ModuleName'%.WriteBlock(addr, data, %'ModuleName'%.PAGE_SIZE);
      if (res != ERR_OK) {
        return res;
      }
      data += %'ModuleName'%.PAGE_SIZE; /* increment data pointer */
      addr += %'ModuleName'%.PAGE_SIZE; /* increment address */
      dataSize -= %'ModuleName'%.PAGE_SIZE; /* reduce size */
    }
    /* write remainder (if any) */
    if (dataSize>0) {
      return %'ModuleName'%.WriteBlock(addr, data, dataSize);
    }
    return ERR_OK;
  }
  if (offset+dataSize <= %'ModuleName'%.PAGE_SIZE) {             %>40 /* no page boundary crossing */
    res = %@I2C@'ModuleName'%.SelectSlave(%'ModuleName'%.DEVICE_ADDR(addr));
    if (res != ERR_OK) {
      (void)%@I2C@'ModuleName'%.UnselectSlave();
      return res;
    }
    #if (%'ModuleName'%.CONFIG_DEVICE_ID==8) || (%'ModuleName'%.CONFIG_DEVICE_ID==16)
      /* 8 bit address byte, high byte of address have been place in SelectSlave(addr) */
      block[0] = (uint8_t)(addr&0xff);                           %>40 /* low byte of address */
      p = &block[1]; i = (uint8_t)dataSize;
    #else /* 16 bit address byte */
      block[0] = (uint8_t)(addr>>8);                             %>40 /* high byte of address */
      block[1] = (uint8_t)(addr&0xff);                           %>40 /* low byte of address */
      p = &block[2]; i = (uint8_t)dataSize;
    #endif

    /* copy block */
    while(i>0) {
      *p++ = *data++;
      i--;
    }
    res = %@I2C@'ModuleName'%.WriteBlock(block,
        dataSize+((%'ModuleName'%.CONFIG_DEVICE_ID==8)||(%'ModuleName'%.CONFIG_DEVICE_ID==16)? 1:2), %@I2C@'ModuleName'%.SEND_STOP);%>40 /* send address and data */
    if (res != ERR_OK) {
      (void)%@I2C@'ModuleName'%.UnselectSlave();
      return res;
    }
#if %'ModuleName'%.DO_ACKNOWLEDGE_POLLING
    /* do acknowledge polling */
#if %'ModuleName'%.CONFIG_USE_TIMEOUT
%if defined(Timeout)
#if %'ModuleName'%.TIMEOUT_BLOCK_TICKS>0
    timeout = %@Timeout@'ModuleName'%.GetCounter(%'ModuleName'%.TIMEOUT_BLOCK_TICKS); /* set up timeout counter */
    if (timeout==%@Timeout@'ModuleName'%.OUT_OF_HANDLE) {
      (void)%@I2C@'ModuleName'%.UnselectSlave();
      return ERR_OVERFLOW;
    }
#endif
%endif
#endif
    block[0] = 0xff; /* dummy value */
    do {
      %@Wait@'ModuleName'%.WaitOSms(%'ModuleName'%.CONFIG_PAGE_WRITE_TIME_MS);
      res = %@I2C@'ModuleName'%.ProbeACK(block, 1, %@I2C@'ModuleName'%.SEND_STOP, %'ModuleName'%.CONFIG_ACK_POLLING_TIME_US);%>40 /* send address and data */
#if %'ModuleName'%.CONFIG_USE_TIMEOUT
%if defined(Timeout)
#if %'ModuleName'%.TIMEOUT_BLOCK_TICKS>0
      isTimeout = %@Timeout@'ModuleName'%.CounterExpired(timeout);
      if (isTimeout) {
        res = ERR_FAULT;
        break;
      }
#endif
%endif
#endif
    } while(res!=ERR_OK); /* wait until we get an ACK */
#if %'ModuleName'%.CONFIG_USE_TIMEOUT
%if defined(Timeout)
#if %'ModuleName'%.TIMEOUT_BLOCK_TICKS>0
    %@Timeout@'ModuleName'%.LeaveCounter(timeout);
    if (isTimeout) {
      res = ERR_FAILED;
    }
#endif
%endif
#endif
    if (res != ERR_OK) {
      (void)%@I2C@'ModuleName'%.UnselectSlave();
      return res;
    }
#endif /* %'ModuleName'%.CONFIg_DO_ACKNOWLEDGE_POLLING */
    return %@I2C@'ModuleName'%.UnselectSlave();
  } else { /* crossing page boundaries: make two page writes */
    res = %'ModuleName'%.WriteBlock(addr, data, (uint16_t)(%'ModuleName'%.PAGE_SIZE-offset));%>40 /* first page write */
    if (res != ERR_OK) {
      return res;
    }
    res = %'ModuleName'%.WriteBlock((%'ModuleName'_Address)((eepromPage+1)*%'ModuleName'%.PAGE_SIZE),
       data+(%'ModuleName'%.PAGE_SIZE-offset),
       (uint16_t)(dataSize-(%'ModuleName'%.PAGE_SIZE-offset)));  %>40 /* first page write */
    if (res != ERR_OK) {
      return res;
    }
  }
  return res;
}
#ifdef __HIWARE__
  #pragma MESSAGE DEFAULT C1855 /* recursive function call */
#endif

%-INTERNAL_METHOD_END WriteBlockPage
%-************************************************************************************************************
%-BW_METHOD_BEGIN WriteBlock
%ifdef WriteBlock
%define! Paraddr
%define! Pardata
%define! PardataSize
%define! RetVal
%include Common\24AA_EEPROMWriteBlock.Inc
uint8_t %'ModuleName'%.%WriteBlock(%'ModuleName'_Address addr, uint8_t *data, uint16_t dataSize)
{
  int32_t size;

  if (dataSize<=%'ModuleName'%.CONFIG_BLOCK_BUF_SIZE) { /* fits into internal buffer */
    return %'ModuleName'%.WriteBlockPage(addr, data, dataSize);
  }
  size = dataSize;
  while(size>=%'ModuleName'%.CONFIG_BLOCK_BUF_SIZE) { /* write in chunks %'ModuleName'%.CONFIG_BLOCK_BUF_SIZE */
    if (%'ModuleName'%.WriteBlock(addr, data, %'ModuleName'%.CONFIG_BLOCK_BUF_SIZE)!=ERR_OK) {
      return ERR_FAILED;
    }
    addr += %'ModuleName'%.CONFIG_BLOCK_BUF_SIZE;
    data += %'ModuleName'%.CONFIG_BLOCK_BUF_SIZE;
    size -= %'ModuleName'%.CONFIG_BLOCK_BUF_SIZE;
  }
  if (size>0) { /* write remainder which is < EE241_BLOCK_BUF_SIZE  */
    if (%'ModuleName'%.WriteBlockPage(addr, data, size)!=ERR_OK) {
      return ERR_FAILED;
    }
  }
  return ERR_OK;
}

%endif %- WriteBlock
%-BW_METHOD_END WriteBlock
%-************************************************************************************************************
%-BW_METHOD_BEGIN Test
%ifdef Test
%define! RetVal
%include Common\24AA_EEPROMTest.Inc
#include <string.h> /* for strcmp() */
static void Err(void) {
  static uint8_t errCnt = 0;

  errCnt++;
}

uint8_t %'ModuleName'%.%Test(void)
{
  uint8_t res, val, data[16];

  res = %'ModuleName'%.WriteByte(0x0000, 0);
  if (res != ERR_OK) {
    Err();
    return res;
  }
  res = %'ModuleName'%.WriteByte(0x0001, 1);
  if (res != ERR_OK) {
    Err();
    return res;
  }
  res = %'ModuleName'%.WriteByte(0x0002, 2);
  if (res != ERR_OK) {
    Err();
    return res;
  }
  res = %'ModuleName'%.WriteByte(0x0003, 3);
  if (res != ERR_OK) {
    Err();
    return res;
  }
  res = %'ModuleName'%.WriteByte(0x0004, 4);
  if (res != ERR_OK) {
    Err();
    return res;
  }
  res = %'ModuleName'%.WriteByte(0x0010, 5);
  if (res != ERR_OK) {
    Err();
    return res;
  }

  res = %'ModuleName'%.ReadByte(0x0000, &val);
  if (res != ERR_OK) {
    Err();
    return res;
  }
  if (val != 0) {
    Err();
    return ERR_FAULT;
  }
  res = %'ModuleName'%.ReadByte(0x0001, &val);
  if (res != ERR_OK) {
    Err();
    return res;
  }
  if (val != 1) {
    Err();
    return ERR_FAULT;
  }
  res = %'ModuleName'%.ReadByte(0x0002, &val);
  if (res != ERR_OK) {
    Err();
    return res;
  }
  if (val != 2) {
    Err();
    return ERR_FAULT;
  }
  res = %'ModuleName'%.ReadByte(0x0003, &val);
  if (res != ERR_OK) {
    Err();
    return res;
  }
  if (val != 3) {
    Err();
    return ERR_FAULT;
  }
  res = %'ModuleName'%.ReadByte(0x0004, &val);
  if (res != ERR_OK) {
    Err();
    return res;
  }
  if (val != 4) {
    Err();
    return ERR_FAULT;
  }
  res = %'ModuleName'%.ReadByte(0x0010, &val);
  if (res != ERR_OK) {
    Err();
    return res;
  }
  if (val != 5) {
    Err();
    return ERR_FAULT;
  }
  res = %'ModuleName'%.WriteBlock(0x10, (uint8_t*)"Hello", sizeof("Hello"));
  if (res != ERR_OK) {
    Err();
    return res;
  }
  res = %'ModuleName'%.ReadBlock(0x10, data, sizeof(data));
  if (res != ERR_OK) {
    Err();
    return res;
  }
  if (strcmp((char*)"Hello", (char*)data) != 0) {
    Err();
    return ERR_FAULT;
  }
  /* testing crossing page boundary */
  res = %'ModuleName'%.WriteBlock(%'ModuleName'%.PAGE_SIZE-5, (uint8_t*)"Hello World!", sizeof("Hello World!"));
  if (res != ERR_OK) {
    Err();
    return res;
  }
  res = %'ModuleName'%.ReadBlock(%'ModuleName'%.PAGE_SIZE-5, data, sizeof(data));
  if (res != ERR_OK) {
    Err();
    return res;
  }
  if (strcmp((char*)"Hello World!", (char*)data) != 0) return ERR_FAULT;
#if %'ModuleName'%.CONFIG_DEVICE_ID==1025
  /* testing writing to second bank */
  res = %'ModuleName'%.WriteBlock(0x10005, (uint8_t*)"Hello bank 1!", sizeof("Hello bank 1!"));
  if (res != ERR_OK) {
    Err();
    return res;
  }
  res = %'ModuleName'%.ReadBlock(0x10005, data,(uint8_t*) sizeof(data));
  if (res != ERR_OK) {
    Err();
    return res;
  }
  if (strcmp((char*)"Hello bank 1!", (char*)data) != 0) {
    Err();
    return ERR_FAULT;
  }
#endif
  return ERR_OK;
}

%endif %- Test
%-BW_METHOD_END Test
%-************************************************************************************************************
%-BW_METHOD_BEGIN WriteProtect
%ifdef WriteProtect
%include Common\24AA_EEPROMWriteProtect.Inc
void %'ModuleName'%.%WriteProtect(void)
{
#if %'ModuleName'%.CONFIG_HAS_WP_PIN
%ifdef WP
  %@WP@'ModuleName'%.SetVal();                                   %>40 /* Tie pin to Vcc/High level to protect the memory */
%else
  WPpin1_SetVal();                                               %>40 /* Tie pin to Vcc/High level to protect the memory */
%endif
#endif
}

%endif %- WriteProtect
%-BW_METHOD_END WriteProtect
%-************************************************************************************************************
%-BW_METHOD_BEGIN WriteUnprotect
%ifdef WriteUnprotect
%include Common\24AA_EEPROMWriteUnprotect.Inc
void %'ModuleName'%.%WriteUnprotect(void)
{
#if %'ModuleName'%.CONFIG_HAS_WP_PIN
%ifdef WP
  %@WP@'ModuleName'%.ClrVal();                                   %>40 /* Tie pin to Vss/Low level to allow writing to the memory */
%else
  WPpin1_ClrVal();                                               %>40 /* Tie pin to Vss/Low level to allow writing to the memory */
%endif
#endif
}

%endif %- WriteUnprotect
%-BW_METHOD_END WriteUnprotect
%-************************************************************************************************************
%-BW_METHOD_BEGIN SelectDevice
%ifdef SelectDevice
%define! ParaddrI2C
%define! RetVal
%include Common\24AA_EEPROMSelectDevice.Inc
uint8_t %'ModuleName'%.%SelectDevice(uint8_t addrI2C)
{
  if (addrI2C>%'ModuleName'%.MAX_I2C_ADDR_MASK) {
    return ERR_VALUE;                                            %>40 /* Device address too large for device address pins available. */
  }
  %'ModuleName'%.I2CAddress = addrI2C;
  return ERR_OK;
}

%endif %- SelectDevice
%-BW_METHOD_END SelectDevice
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetSelectedDevice
%ifdef GetSelectedDevice
%define! RetVal
%include Common\24AA_EEPROMGetSelectedDevice.Inc
uint8_t %'ModuleName'%.%GetSelectedDevice(void)
{
 return %'ModuleName'%.I2CAddress;
}

%endif %- GetSelectedDevice
%-BW_METHOD_END GetSelectedDevice
%-************************************************************************************************************
%-BW_METHOD_BEGIN ParseCommand
%ifdef ParseCommand
%define! Parcmd
%define! Parhandled
%define! Pario
%define! RetVal
%include Common\24AA_EEPROMParseCommand.Inc
uint8_t %'ModuleName'%.%ParseCommand(const unsigned char *cmd, bool *handled, const %@Shell@'ModuleName'%.StdIOType *io)
{
  const unsigned char *p;
  uint16_t addr16;
  uint8_t val8, buf[8];

  if (%@Utility@'ModuleName'%.strcmp((char*)cmd, %@Shell@'ModuleName'%.CMD_HELP)==0 || %@Utility@'ModuleName'%.strcmp((char*)cmd, "%'ModuleName' help")==0) {
    *handled = TRUE;
    return PrintHelp(io);
  } else if ((%@Utility@'ModuleName'%.strcmp((char*)cmd, %@Shell@'ModuleName'%.CMD_STATUS)==0) || (%@Utility@'ModuleName'%.strcmp((char*)cmd, "%'ModuleName' status")==0)) {
    *handled = TRUE;
    return PrintStatus(io);
  } else if (%@Utility@'ModuleName'%.strncmp((char*)cmd, (char*)"%'ModuleName' read ", sizeof("%'ModuleName' read ")-1)==0) {
    p = cmd+sizeof("%'ModuleName' read ")-1;
    if (%@Utility@'ModuleName'%.ScanHex16uNumber(&p, &addr16)==ERR_OK) {
      if (%'ModuleName'%.%ReadByte(addr16, &val8)==ERR_OK) {
        %@Utility@'ModuleName'%.strcpy(buf, sizeof(buf), (unsigned char*)"0x");
        %@Utility@'ModuleName'%.strcatNum8Hex(buf, sizeof(buf), val8);
        %@Utility@'ModuleName'%.strcat(buf, sizeof(buf), (unsigned char*)"\r\n");
        %@Shell@'ModuleName'%.SendStr(buf, io->stdOut);
      } else {
        %@Shell@'ModuleName'%.SendStr((unsigned char*)"**** read failed!\r\n", io->stdErr);
      }
    } else {
      %@Shell@'ModuleName'%.SendStr((unsigned char*)"**** wrong address\r\n", io->stdErr);
    }
    *handled = TRUE;
  } else if (%@Utility@'ModuleName'%.strncmp((char*)cmd, (char*)"%'ModuleName' write ", sizeof("%'ModuleName' write ")-1)==0) {
    p = cmd+sizeof("%'ModuleName' write ")-1;
    if (%@Utility@'ModuleName'%.ScanHex16uNumber(&p, &addr16)==ERR_OK) {
      if (%@Utility@'ModuleName'%.ScanHex8uNumber(&p, &val8)==ERR_OK) {
        if (%'ModuleName'%.%WriteByte(addr16, val8)!=ERR_OK) {
          %@Shell@'ModuleName'%.SendStr((unsigned char*)"**** write failed!\r\n", io->stdErr);
        }
      } else {
        %@Shell@'ModuleName'%.SendStr((unsigned char*)"**** wrong value\r\n", io->stdErr);
      }
    } else {
      %@Shell@'ModuleName'%.SendStr((unsigned char*)"**** wrong address\r\n", io->stdErr);
    }
    *handled = TRUE;
  }
  return ERR_OK;
}

%endif %- ParseCommand
%-BW_METHOD_END ParseCommand
%-************************************************************************************************************
%-BW_METHOD_BEGIN Deinit
%ifdef Deinit
%include Common\24AA_EEPROMDeinit.Inc
void %'ModuleName'%.%Deinit(void)
{
  /* nothing needed */
}

%endif %- Deinit
%-BW_METHOD_END Deinit
%-************************************************************************************************************
%-BW_METHOD_BEGIN Init
%ifdef Init
%include Common\24AA_EEPROMInit.Inc
void %'ModuleName'%.%Init(void)
{
  /* nothing needed */
}

%endif %- Init
%-BW_METHOD_END Init
%-BW_IMPLEMENT_END
/* END %ModuleName. */

%include Common\Header.End
%-
%-
%-BW_EVENT_IMPLEMENT_START
%-BW_EVENT_IMPLEMENT_END
%INITIALIZATION
  /* ### %DeviceType "%DeviceName" init code ... */
%CODE_BEGIN
  /* Write code here ... */
%CODE_END
%-
%ENABLE
%CODE_BEGIN
%CODE_END
%-
%-----------------------------------------------------------------------------------------
%if defined(sdk) & %@sdk@ConfigFilesFolderName <> ""
  %define  ConfigSrcDirFolder %%@sdk@ConfigFilesFolderName/
%else
  %define  ConfigSrcDirFolder
%endif
%-----------------------------------------------------------------------------------------
%FILE %'DirRel_Code'%'ConfigSrcDirFolder'%'ModuleName'config.h
/**
 * \file
 * \brief Configuration header file for 24AA_EEPROM
 * Copyright (c) 2020, Erich Styger
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * This header file is used to configure settings the External I2C EEPROM module.
 */

#ifndef __%'ModuleName'_CONFIG_H
#define __%'ModuleName'_CONFIG_H

/* actual device */
#ifndef %'ModuleName'%.CONFIG_DEVICE_ID
  #define %'ModuleName'%.CONFIG_DEVICE_ID      %Device
    /*!< Supported Device IDs: 8 (24AA08, 24LC08), 16 (24AA16, 24LC16), 32 (24AA32, 24LC32), 256 (24AA256, 24LC256, 24FC256), 512 (24AA512, 24LC512, 24FC256) or 1025 (24AA1025, 24LC1025, 24FC1025) */
#endif

#ifndef %'ModuleName'%.CONFIG_HAS_WP_PIN
%ifdef WP
  #define %'ModuleName'%.CONFIG_HAS_WP_PIN      (1)
%else
  #define %'ModuleName'%.CONFIG_HAS_WP_PIN      (0)
%endif
    /*!<< 1: Write Protect Pin available. 0: no Write Protect pin */
#endif

#ifndef %'ModuleName'%.CONFIG_DEVICE_I2C_ADDRESS_BITS
%if defined(DeviceAddress)
  #define %'ModuleName'%.CONFIG_DEVICE_I2C_ADDRESS_BITS   (%DeviceAddress)
%else
  #define %'ModuleName'%.CONFIG_DEVICE_I2C_ADDRESS_BITS   (0)
%endif
    /* Address bits for I2C address, usually formed by the A0, A1 and A3 pins. Admissible range: 0..7 */
#endif

#ifndef %'ModuleName'%.CONFIG_BLOCK_BUF_SIZE
  #define %'ModuleName'%.CONFIG_BLOCK_BUF_SIZE   (%BlockBufSize)
    /*!< buffer used for block read/write. Max is 128. Keep it small to reduce stack consumption. */
#endif

#ifndef %'ModuleName'%.CONFIG_DO_ACKNOWLEDGE_POLLING
%if defined(DoAcknowledgePolling) & %DoAcknowledgePolling = 'yes'
  #define %'ModuleName'%.CONFIG_DO_ACKNOWLEDGE_POLLING    (1)
%else
  #define %'ModuleName'%.CONFIG_DO_ACKNOWLEDGE_POLLING    (0)
%endif
    /*!< 1: Perform acknowledge polling in the driver. 0: no acknowledge polling */
#endif

#ifndef %'ModuleName'%.CONFIG_PAGE_WRITE_TIME_MS
%if defined(PageWriteTimeMs)
  #define %'ModuleName'%.CONFIG_PAGE_WRITE_TIME_MS        (%PageWriteTimeMs)
%else
  #define %'ModuleName'%.CONFIG_PAGE_WRITE_TIME_MS        (5)
%endif
    /*!< Page Write Time as per data sheet, used with %'ModuleName'%.CONFIG_DO_ACKNOWLEDGE_POLLING */
#endif

#ifndef %'ModuleName'%.CONFIG_ACK_POLLING_TIME_US
%if defined(AckPollingTimeUs)
  #define %'ModuleName'%.CONFIG_ACK_POLLING_TIME_US       (%AckPollingTimeUs)
%else
  #define %'ModuleName'%.CONFIG_ACK_POLLING_TIME_US       (100)
%endif
    /*!< Acknowledge polling time in the I2C driver, used with %'ModuleName'%.CONFIG_DO_ACKNOWLEDGE_POLLING  */
#endif

#ifndef %'ModuleName'%.CONFIG_USE_TIMEOUT
%if defined(Timeout)
  #define %'ModuleName'%.CONFIG_USE_TIMEOUT               (1)
%else
  #define %'ModuleName'%.CONFIG_USE_TIMEOUT               (0)
%endif
    /*!< 1: use timeout, 0: do not use timeout */
#endif

#ifndef %'ModuleName'%.CONFIG_TIMEOUT_BYTE_MS
%if defined(timeoutByteMs)
  #define %'ModuleName'%.CONFIG_TIMEOUT_BYTE_MS           (%timeoutByteMs)
%else
  #define %'ModuleName'%.CONFIG_TIMEOUT_BYTE_MS           (10)
%endif
    /*!< number of milli seconds for timeout using byte write */
#endif

#ifndef %'ModuleName'%.CONFIG_TIMEOUT_BLOCK_MS
%if defined(timeoutBlockMs)
  #define %'ModuleName'%.CONFIG_TIMEOUT_BLOCK_MS          (%timeoutBlockMs)
%else
  #define %'ModuleName'%.CONFIG_TIMEOUT_BLOCK_MS          (60)
%endif
    /*!< number of milliseconds for timeout using for block write */
#endif

#ifndef %'ModuleName'%.CONFIG_USE_SHELL
%if defined(Shell)
  #define %'ModuleName'%.CONFIG_USE_SHELL               (1)
%else
  #define %'ModuleName'%.CONFIG_USE_SHELL               (0)
%endif
    /*!< 1: use shell, 0: do not use shell */
#endif

#ifndef %'ModuleName'%.CONFIG_USE_UTILITY
%if defined(Utility)
  #define %'ModuleName'%.CONFIG_USE_UTILITY               (1)
%else
  #define %'ModuleName'%.CONFIG_USE_UTILITY               (0)
%endif
    /*!< 1: use utility module, 0: do not use utility module */
#endif

#endif /* __%'ModuleName'_CONFIG_H */
%-----------------------------------------------------------------------------------------
%else %- Language (& Compiler)
  %error^ This component is not implemented in selected language & compiler !
%endif %- Language (& Compiler)
%DEBUG
%ALL_SYMBOLS
%-
