%-Driver generated by the Component Wizard
%-
%- WARNING !
%-
%- Do not make changes to these lines (if you make some changes, you damage this driver)
%- which begins with:
%-
%-  %-STARTUSERTYPES
%-  %-ENDUSRTYPES
%-  /* END %ModuleName. */
%-  /* MODULE %ModuleName. */
%-  %-INTERNAL_METHOD_BEG
%-  %-INTERNAL_METHOD_END
%-  %-INHERITED_EVENT_BEGIN
%-  %-INHERITED_EVENT_END
%-  %-BW_METHOD_BEGIN
%-  %-BW_METHOD_END
%-  %-BW_DEFINITION_START
%-  %-BW_DEFINITION_END
%-  %-BW_IMPLEMENT_START
%-  %-BW_IMPLEMENT_END
%-  %-BW_EVENT_DEFINITION_START
%-  %-BW_EVENT_DEFINITION_END
%-  %-BW_EVENT_IMPLEMENT_START
%-  %-BW_EVENT_IMPLEMENT_END
%-  %-BW_METHOD_MACROS_START
%-  %-BW_METHOD_MACROS_END
%-  %-BW_SECTIONS_INSERT
%-  %-BW_INTERN_COMMENTS_START
%-  %-BW_INTERN_COMMENTS_END
%-  %-BW_BEAN_CONSTANTS_START
%-  %-BW_BEAN_CONSTANTS_END
%-
%-
%- These lines are not comments, but they are necessary for Component Wizard
%- If you change these lines, Component Wizard will not be responsible for loosing or damaging your code!
%-
%-
%- readyCPU ...
%- readyDEVICE ...
%-
%define DriverAuthor  Author
%define DriverVersion 01.00
%define DriverDate    19.07.2012
%-
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END
%-
%-BW_INTERN_COMMENTS_START
%- List of descriptions of internal methods
%define! Description_SD_Wait Wait until SD operation is completed
%ifdef SDHC
  %ifdef @SDHC@OnCardInserted
    %define! Description_%@SDHC@OnCardInserted This event is called when a card is inserted into the slot. The card identification number is retrieved and it is passed to the event. If card detection pin is not available, the DetectCards method calls this event. The event services the event of the inherited component and eventually invokes other events.
  %endif %- @SDHC@OnCardInserted
%endif %- SDHC
%ifdef SDHC
  %ifdef @SDHC@OnCardRemoved
    %define! Description_%@SDHC@OnCardRemoved This event is called after a card is removed. The card identification number is retrieved and it is passed to the event. If card detection pin is not available, the SelectCard method calls this event after a try to select the removed card. The event services the event of the inherited component and eventually invokes other events.
  %endif %- @SDHC@OnCardRemoved
%endif %- SDHC
%ifdef SDHC
  %ifdef @SDHC@OnFinished
    %define! Description_%@SDHC@OnFinished This event is called after an operation, initiated by user, has finished. The event services the event of the inherited component and eventually invokes other events.
  %endif %- @SDHC@OnFinished
%endif %- SDHC
%-BW_INTERN_COMMENTS_END
%-
%-BW_SECTIONS_INSERT
%if Language='ANSIC'
%-
%-
%INTERFACE
%define! Settings Common\FatFsMemSDHCSettings.Inc
%define! Abstract Common\FatFsMemSDHCAbstract.Inc
%include Common\Header.h

#ifndef __%'ModuleName'_H
#define __%'ModuleName'_H

/* MODULE %ModuleName. */
%ifdef SharedModules
/* Include shared modules, which are used for whole project */
  %for var from IncludeSharedModules
#include "%'var'.h"
  %endfor
%endif
/* Include inherited beans */
#include <stdbool.h>
%ifdef InhrSymbolList
  %for var from InhrSymbolList
#include "%@%var@ModuleName.h"
  %endfor
%endif
%-BW_CUSTOM_INCLUDE_START_H
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%-BW_CUSTOM_INCLUDE_END_H
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END

#include "%ProcessorModule.h"

%if %DisableMPU='yes'
#define %'ModuleName'%.CONFIG_DISABLE_MPU   (1)
%else
#define %'ModuleName'%.CONFIG_DISABLE_MPU   (0)
%endif
  /*!< For the Kinetis K64F, the MPU has to be disabled for SDHC to work! */

/* interface for FatFS low level disk functions */
#include "diskio.h"

DSTATUS %'ModuleName'%.disk_initialize (
        uint8_t drv                                              %>40 /* Physical drive number (0..) */
);
DSTATUS %'ModuleName'%.disk_status (
        uint8_t drv                                              %>40 /* Physical drive number (0..) */
);
DRESULT %'ModuleName'%.disk_read (
        uint8_t drv,                                             %>40 /* Physical drive number (0..) */
        uint8_t *buff,                                           %>40 /* Data buffer to store read data */
        uint32_t sector,                                         %>40 /* Sector address (LBA) */
        uint8_t count                                            %>40 /* Number of sectors to read (1..255) */
);
#if _READONLY == 0
DRESULT %'ModuleName'%.disk_write (
        uint8_t drv,                                             %>40 /* Physical drive number (0..) */
        const uint8_t *buff,                                     %>40 /* Data to be written */
        uint32_t sector,                                         %>40 /* Sector address (LBA) */
        uint8_t count                                            %>40 /* Number of sectors to write (1..255) */
);
#endif
DRESULT %'ModuleName'%.disk_ioctl (
        uint8_t drv,                                             %>40 /* Physical drive number (0..) */
        uint8_t ctrl,                                            %>40 /* Control code */
        void *buff                                               %>40 /* Buffer to send/receive control data */
);

typedef struct {
  LDD_TDeviceData *SDHCPtr;     /* SDHC component data */
  bool Finished;                /* Operation end indication */
  bool Inserted;                /* Card insertion indication */
  uint8_t CardId;               /* Initialized card ID */
  LDD_SDHC_TCardInfo CardInfo;  /* Initialized card info */
} TSDData;

#define %'ModuleName'%.BLOCK_SIZE        512   /* sector size. Values >512 give LDD_SDHC_ERR_BLOCK_LEN_ERROR? So hardcoded for now. */
#define %'ModuleName'%.WAIT_TIMEOUT_MS   1024  /* wait timeout in millis seconds for commands */

%-STARTUSERTYPES - Do not make changes between lines (included this lines) marked with %-STARTUSERTYPES and %-ENDUSRTYPES

%-ENDUSRTYPES
%-BW_BEAN_CONSTANTS_START  - Do not make changes between lines (included this lines) marked with %-BW_BEAN_CONSTANTS_START and %-BW_BEAN_CONSTANTS_END
%- No constants defined in the BeanWizard for this bean
%-BW_BEAN_CONSTANTS_END
%-BW_CUSTOM_USERTYPE_START
%- Write your own types here ...
%-  Example:
%-    typedef int TMyInteger;
%-
%-BW_CUSTOM_USERTYPE_END


%-BW_DEFINITION_START
%-INHERITED_EVENT_BEGIN SDHC OnCardInserted
%ifdef @SDHC@OnCardInserted
void %@SDHC@OnCardInserted(LDD_TUserData *UserDataPtr, uint8_t Id);

%endif %- @SDHC@OnCardInserted
%-INHERITED_EVENT_END SDHC OnCardInserted
%-INHERITED_EVENT_BEGIN SDHC OnCardRemoved
%ifdef @SDHC@OnCardRemoved
void %@SDHC@OnCardRemoved(LDD_TUserData *UserDataPtr, uint8_t Id);

%endif %- @SDHC@OnCardRemoved
%-INHERITED_EVENT_END SDHC OnCardRemoved
%-INHERITED_EVENT_BEGIN SDHC OnFinished
%ifdef @SDHC@OnFinished
void %@SDHC@OnFinished(LDD_TUserData *UserDataPtr);

%endif %- @SDHC@OnFinished
%-INHERITED_EVENT_END SDHC OnFinished
%-************************************************************************************************************
%-BW_METHOD_BEGIN CardPresent
%ifdef CardPresent
bool %'ModuleName'%.%CardPresent(void);
%define! RetVal
%include Common\FatFsMemSDHCCardPresent.Inc

%endif %- CardPresent
%-BW_METHOD_END CardPresent
%-************************************************************************************************************
%-BW_METHOD_BEGIN Init
%ifdef Init
uint8_t %'ModuleName'%.%Init(LDD_TUserData *UserDataPtr);
%define! ParUserDataPtr
%define! RetVal
%include Common\FatFsMemSDHCInit.Inc

%endif %- Init
%-BW_METHOD_END Init
%-************************************************************************************************************
%-BW_METHOD_BEGIN Deinit
%ifdef Deinit
uint8_t %'ModuleName'%.%Deinit(LDD_TDeviceData *DeviceDataPtr);
%define! ParDeviceDataPtr
%define! RetVal
%include Common\FatFsMemSDHCDeinit.Inc

%endif %- Deinit
%-BW_METHOD_END Deinit
%-************************************************************************************************************
%-BW_METHOD_BEGIN Activate
%ifdef Activate
void %'ModuleName'%.%Activate(void);
%include Common\FatFsMemSDHCActivate.Inc

%endif %- Activate
%-BW_METHOD_END Activate
%-************************************************************************************************************
%-BW_METHOD_BEGIN Deactivate
%ifdef Deactivate
void %'ModuleName'%.%Deactivate(void);
%include Common\FatFsMemSDHCDeactivate.Inc

%endif %- Deactivate
%-BW_METHOD_END Deactivate
%-************************************************************************************************************
%-BW_METHOD_BEGIN isWriteProtected
%ifdef isWriteProtected
bool %'ModuleName'%.%isWriteProtected(void);
%define! RetVal
%include Common\FatFsMemSDHCisWriteProtected.Inc

%endif %- isWriteProtected
%-BW_METHOD_END isWriteProtected
%-BW_DEFINITION_END
/* END %ModuleName. */

#endif
/* ifndef __%'ModuleName'_H */
%include Common\Header.End
%-
%-BW_EVENT_DEFINITION_START
%-BW_METHOD_BEGIN OnCardInserted
%ifdef OnCardInserted
%INTERFACE OnCardInserted
void %OnCardInserted(LDD_TUserData *UserDataPtr, uint8_t Id);
%define! ParUserDataPtr
%define! ParId
%include Common\FatFsMemSDHCOnCardInserted.Inc

%endif %- OnCardInserted
%-BW_METHOD_END OnCardInserted
%-BW_METHOD_BEGIN OnCardRemoved
%ifdef OnCardRemoved
%INTERFACE OnCardRemoved
void %OnCardRemoved(LDD_TUserData *UserDataPtr, uint8_t Id);
%define! ParUserDataPtr
%define! ParId
%include Common\FatFsMemSDHCOnCardRemoved.Inc

%endif %- OnCardRemoved
%-BW_METHOD_END OnCardRemoved
%-BW_METHOD_BEGIN OnFinished
%ifdef OnFinished
%INTERFACE OnFinished
void %OnFinished(LDD_TUserData *UserDataPtr);
%define! ParUserDataPtr
%include Common\FatFsMemSDHCOnFinished.Inc

%endif %- OnFinished
%-BW_METHOD_END OnFinished
%-BW_METHOD_BEGIN OnError
%ifdef OnError
%INTERFACE OnError
void %OnError(int errorNo);
%define! ParerrorNo
%include Common\FatFsMemSDHCOnError.Inc

%endif %- OnError
%-BW_METHOD_END OnError
%-BW_EVENT_DEFINITION_END
%IMPLEMENTATION
%define! Settings Common\FatFsMemSDHCSettings.Inc
%define! Abstract Common\FatFsMemSDHCAbstract.Inc
%include Common\Header.C
%-
%-
%-BW_EVENT_IMPLEMENT_START

/* MODULE %ModuleName. */

%for var from EventModules
#include "%var.h"
%endfor
#include "%'ModuleName'.h"
%-BW_CUSTOM_INCLUDE_START_M
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
#include "ff.h"
#include "diskio.h"

%-
%-BW_CUSTOM_INCLUDE_END_M

%-BW_CUSTOM_VARIABLE_START
%- Write your static variables here
%-   Example:
%-     static int counter1;
%-     int %'ModuleName'%.counter2;
static volatile DSTATUS Stat = STA_NOINIT; /* Disk status */
static TSDData SD;              /* Application data */

#define %'ModuleName'%.SPEED_INDEX_SLOW    %SpeedIndexSlow       %>40/* set by property, has to correspond to less than 400 kHz. */
#define %'ModuleName'%.SPEED_INDEX_NORMAL  %SpeedIndexNormal     %>40/* set by property, up to 12 MHz. */
#define %'ModuleName'%.SPEED_INDEX_FAST    %SpeedIndexFast       %>40/* set by property, depends on card, but could be as high as 48 MHz. */

%-
%-BW_CUSTOM_VARIABLE_END
%-BW_INTERN_METHOD_DECL_START
%- List of internal methods headers
%-UNLOCKED
/* Internal method prototypes */
%-INTERNAL_LOC_METHOD_BEG SD_Wait
static void SD_Wait(TSDData *SD, bool *ErrorFlag);
%-INTERNAL_LOC_METHOD_END SD_Wait
%-

%-BW_INTERN_METHOD_DECL_END
%-BW_IMPLEMENT_START
%-INHERITED_EVENT_BEGIN SDHC OnCardInserted
%ifdef @SDHC@OnCardInserted
%include Common\GeneralInternal.inc (OnCardInserted)
void %@SDHC@OnCardInserted(LDD_TUserData *UserDataPtr, uint8_t Id)
{
  TSDData *SD = (TSDData*)UserDataPtr;

  SD->CardId = Id;
  %ifdef OnCardInserted
  %OnCardInserted(UserDataPtr, Id);
  %endif OnCardInserted
}

%endif %- @SDHC@OnCardInserted
%-INHERITED_EVENT_END SDHC OnCardInserted
%-INHERITED_EVENT_BEGIN SDHC OnCardRemoved
%ifdef @SDHC@OnCardRemoved
%include Common\GeneralInternal.inc (OnCardRemoved)
void %@SDHC@OnCardRemoved(LDD_TUserData *UserDataPtr, uint8_t Id)
{
  TSDData *SD = (TSDData*)UserDataPtr;

  SD->CardId = %@SDHC@'ModuleName'%.NO_CARD;
  %ifdef OnCardRemoved
  %OnCardRemoved(UserDataPtr, Id);
  %else
  (void)Id; /* unused */
  %endif OnCardRemoved
}

%endif %- @SDHC@OnCardRemoved
%-INHERITED_EVENT_END SDHC OnCardRemoved
%-INHERITED_EVENT_BEGIN SDHC OnFinished
%ifdef @SDHC@OnFinished
%include Common\GeneralInternal.inc (OnFinished)
void %@SDHC@OnFinished(LDD_TUserData *UserDataPtr)
{
  TSDData *SD = (TSDData*)UserDataPtr;

  SD->Finished = TRUE;
  %ifdef OnFinished
  %OnFinished(UserDataPtr);
  %endif OnFinished
}

%endif %- @SDHC@OnFinished
%-INHERITED_EVENT_END SDHC OnFinished
%-************************************************************************************************************
%-BW_METHOD_BEGIN CardPresent
%ifdef CardPresent
%define! RetVal
%include Common\FatFsMemSDHCCardPresent.Inc
bool %'ModuleName'%.%CardPresent(void)
{
%if defined(CD)
%if %CDLowActive='yes'
  return %@CD@'ModuleName'%.GetVal()==0;
%else
  return %@CD@'ModuleName'%.GetVal()!=0;
%endif
%elif defined(CardPresentFunctionName)
  %if %CardPresentFunctionName='TRUE'
  return TRUE; /* 'TRUE' provided as CardPresent() function in properties */
  %elif %CardPresentFunctionName='FALSE'
  return FALSE; /* 'FALSE' provided as CardPresent() function in properties */
  %elif %CardPresentFunctionName<>""
  bool %CardPresentFunctionName(void); /* prototype for user defined function */
  return %CardPresentFunctionName(); /* call user provided function */
  %else
  return FALSE; /* no CD pin and no custom card present function, assume card is not inserted */
  %endif
%else
  return FALSE; /* no CD pin, assume card is not inserted */
%endif
}

%endif %- CardPresent
%-BW_METHOD_END CardPresent
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG SD_Wait
%define! ParSD
%define! ParErrorFlag
%include Common\GeneralInternalGlobal.inc (SD_Wait)
static void SD_Wait(TSDData *SD, bool *ErrorFlag)
{
  %@Timeout@'ModuleName'%.CounterHandle timeout;
  bool isTimeout;      /* Timeout flag */
  LDD_SDHC_TError err;     /* SDHC error */

  if (!SD->Finished) { /* not finished yet? */
    isTimeout = FALSE;
    timeout = %@Timeout@'ModuleName'%.GetCounter(%'ModuleName'%.WAIT_TIMEOUT_MS/%@Timeout@'ModuleName'%.TICK_PERIOD_MS); /* set up timeout counter */
    while (!SD->Finished && !isTimeout) {
      %@Wait@'ModuleName'%.WaitOSms(1);
      isTimeout = %@Timeout@'ModuleName'%.CounterExpired(timeout);
    }
    %@Timeout@'ModuleName'%.LeaveCounter(timeout);
    if (isTimeout) {
    %if defined(OnError)
      %OnError(0); /* call user error handler */
    %endif
      *ErrorFlag = TRUE;
    }
  }
  SD->Finished = FALSE; /* reset flag */
  err = SDHC1_GetError(SD->SDHCPtr, NULL);
  if (err != LDD_SDHC_ERR_OK) {
%if defined(OnError)
    %OnError(err); /* call user error handler */
%endif
    *ErrorFlag = TRUE;
  }
}

%-INTERNAL_METHOD_END SD_Wait
%-************************************************************************************************************
%-BW_METHOD_BEGIN Init
%ifdef Init
%define! ParUserDataPtr
%define! RetVal
%include Common\FatFsMemSDHCInit.Inc
%if defined(PullIncludeCode) & %PullCodeEnabled='yes'
%PullIncludeCode  /* user provided include code */
%else
/* no user include code provided/enabled */
%endif
uint8_t %'ModuleName'%.%Init(LDD_TUserData *UserDataPtr)
{
  bool Error = FALSE;

  (void)UserDataPtr; /* not used */
  /* Enable pull-up/pull-down on GPIO pin used for SD card detection with user code provided in properties */
%if defined(PullCodeEnabled) & %PullCodeEnabled='yes'
  %PullCode  /* user provided code */
%else
  /* no user code provided/enabled */
%endif
#if %'ModuleName'%.CONFIG_DISABLE_MPU
  MPU_CESR = 0; /* K64F has memory protection unit, disable it! */
#endif
  /* initialize device structure */
  SD.SDHCPtr = 0;
  SD.Finished = FALSE;
  SD.CardId = %@SDHC@'ModuleName'%.NO_CARD;
  SD.SDHCPtr = %@SDHC@'ModuleName'%.Init(&SD);
  SD.Inserted = %'ModuleName'%.%CardPresent();
  SD_Wait(&SD, &Error); /* Wait for card reset to finish */
  if (!Error) {
    return ERR_OK;
  } else {
    return ERR_FAILED;
  }
}

%endif %- Init
%-BW_METHOD_END Init
%-************************************************************************************************************
%-BW_METHOD_BEGIN Deinit
%ifdef Deinit
%define! ParDeviceDataPtr
%define! RetVal
%include Common\FatFsMemSDHCDeinit.Inc
uint8_t %'ModuleName'%.%Deinit(LDD_TDeviceData *DeviceDataPtr)
{
  (void)DeviceDataPtr; /* not used */
  /* Deinit components/devices */
  %@SDHC@'ModuleName'%.Deinit(SD.SDHCPtr);
  return ERR_OK;
}

%endif %- Deinit
%-BW_METHOD_END Deinit
%-************************************************************************************************************
%-BW_METHOD_BEGIN Activate
%ifdef Activate
%include Common\FatFsMemSDHCActivate.Inc
void %'ModuleName'%.%Activate(void)
{
  /* nothing needed right now */
}

%endif %- Activate
%-BW_METHOD_END Activate
%-************************************************************************************************************
%-BW_METHOD_BEGIN Deactivate
%ifdef Deactivate
%include Common\FatFsMemSDHCDeactivate.Inc
void %'ModuleName'%.%Deactivate(void)
{
  /* nothing needed right now */
}

%endif %- Deactivate
%-BW_METHOD_END Deactivate
%-************************************************************************************************************
%-BW_METHOD_BEGIN isWriteProtected
%ifdef isWriteProtected
%define! RetVal
%include Common\FatFsMemSDHCisWriteProtected.Inc
bool %'ModuleName'%.%isWriteProtected(void)
{
%if defined(WP)
  %if %WPLowActive='yes'
  return %@WP@'ModuleName'%.GetVal()==0;
  %else
  return %@WP@'ModuleName'%.GetVal()!=0;
  %endif
%elif defined(isWriteProtectedFunctionName)
  %if %isWriteProtectedFunctionName='TRUE'
  return TRUE; /* 'TRUE' provided as isWriteProtected() function in properties */
  %elif %isWriteProtectedFunctionName='FALSE'
  return FALSE; /* 'FALSE' provided as isWriteProtected() function in properties */
  %elif %isWriteProtectedFunctionName<>""
  bool %isWriteProtectedFunctionName(void); /* prototype for user defined function */
  return %isWriteProtectedFunctionName(); /* call user provided function */
  %else
  return FALSE; /* no CD pin and no custom isWriteProtected function, write protection is off */
  %endif
%else
  return FALSE; /* no card write protection pin available */
%endif
}

%endif %- isWriteProtected
%-BW_METHOD_END isWriteProtected
static uint32_t SD_ByteToCardAddress(LDD_SDHC_TCardInfo *CardInfo, uint32_t Address) {
  const uint32_t BlockSizeExp = 9;

  return (CardInfo->Caps.HighCapacity ? Address >> BlockSizeExp : Address);
}

static bool SD_TransferBlock(TSDData *SD, bool Read, uint32_t Address, uint8_t *Buffer) {
  bool Error = FALSE;
  const uint16_t BlockSize = %'ModuleName'%.BLOCK_SIZE;
  const uint16_t BlockCount = 1;
  uint32_t CardAddr = SD_ByteToCardAddress(&SD->CardInfo, Address); /* Read block address */
  LDD_SDHC_TBufferDesc BufferDesc;

  /* Init read buffer descriptor */
  BufferDesc.DataPtr = Buffer;
  BufferDesc.Size = BlockSize;
  /* Read card data block */
  if (%@SDHC@'ModuleName'%.TransferBlocks(SD->SDHCPtr, (Read ? LDD_SDHC_READ : LDD_SDHC_WRITE), CardAddr, &BufferDesc, BlockCount)!=ERR_OK) {
%if defined(OnError)
    %OnError(0); /* call user error handler */
%endif
    return TRUE; /* error */
  }
  SD_Wait(SD, &Error);
  return Error;
}
/*-----------------------------------------------------------------------*/
/* Initialize a Drive                                                    */
DSTATUS %'ModuleName'%.disk_initialize (
        uint8_t drv                                              %>40 /* Physical drive number (0..) */
)
{
  bool Error = FALSE;

  (void)drv; /* not used */
  if (Stat & STA_NODISK) {
    return Stat;                                                 %>40 /* No card in the socket */
  }
  if (SD.SDHCPtr!=NULL) { /* deallocate any existing driver structures first */
    %@SDHC@'ModuleName'%.Deinit(SD.SDHCPtr);
    SD.SDHCPtr = NULL;
  }
  if (%'ModuleName'%.%Init(NULL)!=ERR_OK) {
    return STA_NOINIT;
  }
  if (!Error && SD.Inserted) {
    if (%@SDHC@'ModuleName'%.DetectCards(SD.SDHCPtr)!=ERR_OK) {
      Error = TRUE;
    }
    SD_Wait(&SD, &Error);
    if (!Error && SD.CardId != %@SDHC@'ModuleName'%.NO_CARD) {
      /* card detected - selecting card... */
      if (%@SDHC@'ModuleName'%.SelectCard(SD.SDHCPtr, SD.CardId)!=ERR_OK) {
        Error = TRUE;
      }
      SD_Wait(&SD, &Error);
    }
    if (!Error) {
      /* card selected - requesting card info... */
      if (%@SDHC@'ModuleName'%.GetCardInfo(SD.SDHCPtr, &SD.CardInfo)!=ERR_OK) {
        Error = TRUE;
      }
      SD_Wait(&SD, &Error);
    }
    if (!Error) {
      /* switching gears for higher speed */
      Error = %@SDHC@'ModuleName'%.SelectBusClock(SD.SDHCPtr, (%@SDHC@'ModuleName'%.TBusClock)%'ModuleName'%.SPEED_INDEX_NORMAL)!=ERR_OK;
      %@Wait@'ModuleName'%.WaitOSms(10); /* switching the bus clock needs some time? */
      SD_Wait(&SD, &Error);
    }
    if (!Error) {
      if (SD.CardInfo.Caps.DataWidths&LDD_SDHC_CARD_DATA_WIDTH_8_BIT) {
        Error = %@SDHC@'ModuleName'%.SetDataWidth(SD.SDHCPtr, LDD_SDHC_CARD_DATA_WIDTH_8_BIT)!=ERR_OK;
      } else if (SD.CardInfo.Caps.DataWidths&LDD_SDHC_CARD_DATA_WIDTH_4_BIT) {
        Error = %@SDHC@'ModuleName'%.SetDataWidth(SD.SDHCPtr, LDD_SDHC_CARD_DATA_WIDTH_4_BIT)!=ERR_OK;
      } else if (SD.CardInfo.Caps.DataWidths&LDD_SDHC_CARD_DATA_WIDTH_1_BIT) {
        Error = %@SDHC@'ModuleName'%.SetDataWidth(SD.SDHCPtr, LDD_SDHC_CARD_DATA_WIDTH_1_BIT)!=ERR_OK;
      }
      SD_Wait(&SD, &Error);
    }
    if (!Error && SD.CardInfo.Caps.HighSpeed) {
      Error = %@SDHC@'ModuleName'%.SelectBusClock(SD.SDHCPtr, (%@SDHC@'ModuleName'%.TBusClock)%'ModuleName'%.SPEED_INDEX_FAST)!=ERR_OK;
      %@Wait@'ModuleName'%.WaitOSms(10); /* switching the bus clock needs some time? */
      SD_Wait(&SD, &Error);
      /* running at high speed (high slew rate on all the SDHC pins should be set) */
    }
  }
  if (!Error) { /* clear flag if there were no errors */
    Stat &= ~STA_NOINIT;                                         %>40 /* Clear STA_NOINIT */
  }
  return Stat;
}
/*-----------------------------------------------------------------------*/
/* Return Disk Status                                                    */
DSTATUS %'ModuleName'%.disk_status (
        uint8_t drv                                              %>40 /* Physical drive number (0..) */
)
{
  (void)drv; /* not used */
  return Stat;
}
/*-----------------------------------------------------------------------*/
/* Read Sector(s)                                                        */
DRESULT %'ModuleName'%.disk_read (
        uint8_t drv,                                             %>40 /* Physical drive number (0..) */
        uint8_t *buff,                                           %>40 /* Data buffer to store read data */
        uint32_t sector,                                         %>40 /* Sector address (LBA) */
        uint8_t count                                            %>40 /* Number of sectors to read (1..255) */
)
{
  (void)drv; /* not used */
  if (!count) {
    return RES_PARERR;
  }
  if (Stat & STA_NOINIT) {
    return RES_NOTRDY;
  }
  if (count == 1) {                                              %>40 /* Single block read */
    if (SD_TransferBlock(&SD, TRUE, sector*%'ModuleName'%.BLOCK_SIZE, buff)) {
      return RES_ERROR;
    }
    count = 0;
  } else { /* read multiple blocks */
    do {
      if (SD_TransferBlock(&SD, TRUE, sector*%'ModuleName'%.BLOCK_SIZE, buff)) {
        break;
      }
      sector++;
      buff += %'ModuleName'%.BLOCK_SIZE;
    } while(--count);
  }
  return count ? RES_ERROR : RES_OK;
}
/*-----------------------------------------------------------------------*/
/* Write Sector(s)                                                       */
#if _READONLY == 0
DRESULT %'ModuleName'%.disk_write (
        uint8_t drv,                                             %>40 /* Physical drive number (0..) */
        const uint8_t *buff,                                     %>40 /* Data to be written */
        uint32_t sector,                                         %>40 /* Sector address (LBA) */
        uint8_t count                                            %>40 /* Number of sectors to write (1..255) */
)
{
  (void)drv; /* not used */
  if (!count) {
    return RES_PARERR;
  }
  if (Stat & STA_NOINIT) {
    return RES_NOTRDY;
  }
  if (Stat & STA_PROTECT) {
    return RES_WRPRT;
  }
  if (count==1) {                                                %>40 /* Single block read */
    if (SD_TransferBlock(&SD, FALSE, sector*%'ModuleName'%.BLOCK_SIZE, (uint8_t*)buff)) {
      return RES_ERROR;
    }
    count = 0;
  } else { /* read multiple blocks */
    do {
      if (SD_TransferBlock(&SD, FALSE, sector*%'ModuleName'%.BLOCK_SIZE, (uint8_t*)buff)) {
        break;
      }
      sector++;
      buff += %'ModuleName'%.BLOCK_SIZE;
    } while(--count);
  }
  return count ? RES_ERROR : RES_OK;
}
#endif /* _READONLY */
/*-----------------------------------------------------------------------*/
/* Miscellaneous Functions                                               */
static bool chk_power(void) { return 1;}
static void power_off(void) {}
static void power_on(void) {}
/*-----------------------------------------------------------------------*/
DRESULT %'ModuleName'%.disk_ioctl (
        uint8_t drv,                                             %>40 /* Physical drive number (0..) */
        uint8_t ctrl,                                            %>40 /* Control code */
        void *buff                                               %>40 /* Buffer to send/receive control data */
)
{
  DRESULT res = RES_OK;
  uint8_t *ptr = (uint8_t*)buff;

  (void)drv; /* not used */
  if (ctrl == CTRL_POWER) {
    switch (*ptr) {
      case 0:                                                    %>40 /* Sub control code == 0 (POWER_OFF) */
        if (chk_power()) {
          power_off();                                           %>40 /* Power off */
        }
        break;
      case 1:                                                    %>40 /* Sub control code == 1 (POWER_ON) */
        power_on();                                              %>40 /* Power on */
        break;
      case 2:                                                    %>40 /* Sub control code == 2 (POWER_GET) */
        *(ptr+1) = (uint8_t)chk_power();
        break;
      default:
        res = RES_PARERR;
    } /* switch */
  } else {
    if (Stat & STA_NOINIT) {
      return RES_NOTRDY;
    }
    switch (ctrl) {
      case CTRL_SYNC :                                           %>40 /* Make sure that no pending write process. Do not remove this or written sector might not left updated. */
        %'ModuleName'%.%Activate();
        break;
      case MMC_GET_READ_BL_LEN:                                  %>40 /* Block Length */
        *(uint16_t*)ptr = SD.CardInfo.BlockLength;
        break;
      case MMC_GET_SDC_VERSION:                                  %>40 /* get CSD Version (1 byte: 1 for 1.xx or MMC, 2 for 2.0 */
        *ptr = 0;
        res = RES_PARERR; /* NYI or does not exist */
        break;
      case GET_SECTOR_COUNT:                                     %>40 /* Get number of sectors on the disk (uint32_t) */
        *(uint32_t*)buff = SD.CardInfo.BlockCount;
        break;
      case GET_SECTOR_SIZE:                                      %>40 /* Get R/W sector size (uint16_t) */
        *(uint16_t*)buff = %'ModuleName'%.BLOCK_SIZE;
        break;
      case GET_BLOCK_SIZE:                                       %>40 /* Get erase block size in unit of sector (uint32_t) */
        *(uint32_t*)buff = 0;
        res = RES_PARERR; /* NYI or does not exist */
        break;
      case MMC_GET_TYPE:                                         %>40 /* Get card type flags (1 byte) */
        if (SD.CardInfo.Type==LDD_SDHC_SD) {
          *ptr = CT_SD1;
        } else if (SD.CardInfo.Type==LDD_SDHC_SDIO) {
          *ptr = CT_SD2;
        } else if (SD.CardInfo.Type==LDD_SDHC_MMC) {
          *ptr = CT_MMC;
        } else if (SD.CardInfo.Type==LDD_SDHC_SDCOMBO) {
          *ptr = CT_SDC;
        } else if (SD.CardInfo.Type==LDD_SDHC_CE_ATA) {
          *ptr = CT_ATA;
        } else {
          *ptr = 0; /* unknown ? */
          res = RES_PARERR;
        }
        break;

      case MMC_GET_CSD:                                          %>40 /* Receive CSD as a data block (16 bytes) */
        *ptr = 0;
        res = RES_PARERR; /* NYI or does not exist */
        break;

      case MMC_GET_CID:                                          %>40 /* Receive CID as a data block (16 bytes) */
        *ptr = 0;
        res = RES_PARERR; /* NYI or does not exist */
        break;

      case MMC_GET_OCR:                                          %>40 /* Receive OCR as an R3 resp (4 bytes) */
       *ptr = 0;
       res = RES_PARERR; /* NYI or does not exist */
       break;

      case MMC_GET_SDSTAT:                                       %>40 /* Receive SD status as a data block (64 bytes) */
        *ptr = 0;
        res = RES_PARERR; /* NYI or does not exist */
        break;

      case MMC_GET_DRIVER_VERSION:                               %>40 /* 1 byte: return: 0 SPI driver, 1 LLD SDHC driver */
        *ptr = 1;
        break;

      case MMC_GET_LLD_INFO:
        /* ptr[0] is the command, ptr[1] is the size of data buffer, followed by the data buffer */
        switch(ptr[0]) {
          case MMC_GET_LLD_CMD_HIGH_CAPACITY:
            ptr[2] = SD.CardInfo.Caps.HighCapacity ? 1 : 0;
            break;
          case MMC_GET_LLD_CMD_HIGH_SPEED:
            ptr[2] = SD.CardInfo.Caps.HighSpeed ? 1 : 0;
            break;
          case MMC_GET_LLD_CMD_LOW_VOLTAGE:
            ptr[2] = SD.CardInfo.Caps.LowVoltage ? 1 : 0;
            break;
          case MMC_GET_LLD_CMD_DATA_WIDTHS:
            ptr[2] = SD.CardInfo.Caps.DataWidths;
            break;
          case MMC_GET_LLD_CMD_OPERATIONS:
            ptr[2] = SD.CardInfo.Caps.Operations;
            break;
          default:
            res = RES_PARERR;
            break;
        }
        break;

      default:
        res = RES_PARERR;
    } /* switch */
    %'ModuleName'%.%Deactivate();
  }
  return res;
}
%-BW_IMPLEMENT_END
/* END %ModuleName. */
%-BW_METHOD_BEGIN OnCardInserted
%ifdef OnCardInserted
%IMPLEMENTATION OnCardInserted
%define! ParUserDataPtr
%define! ParId
%include Common\FatFsMemSDHCOnCardInserted.Inc
void %OnCardInserted(LDD_TUserData *UserDataPtr, uint8_t Id)
{
  /* Write your code here ... */
}

%endif %- OnCardInserted
%-BW_METHOD_END OnCardInserted
%-BW_METHOD_BEGIN OnCardRemoved
%ifdef OnCardRemoved
%IMPLEMENTATION OnCardRemoved
%define! ParUserDataPtr
%define! ParId
%include Common\FatFsMemSDHCOnCardRemoved.Inc
void %OnCardRemoved(LDD_TUserData *UserDataPtr, uint8_t Id)
{
  /* Write your code here ... */
}

%endif %- OnCardRemoved
%-BW_METHOD_END OnCardRemoved
%-BW_METHOD_BEGIN OnFinished
%ifdef OnFinished
%IMPLEMENTATION OnFinished
%define! ParUserDataPtr
%include Common\FatFsMemSDHCOnFinished.Inc
void %OnFinished(LDD_TUserData *UserDataPtr)
{
  /* Write your code here ... */
}

%endif %- OnFinished
%-BW_METHOD_END OnFinished
%-BW_METHOD_BEGIN OnError
%ifdef OnError
%IMPLEMENTATION OnError
%define! ParerrorNo
%include Common\FatFsMemSDHCOnError.Inc
void %OnError(int errorNo)
{
  /* Write your code here ... */
}

%endif %- OnError
%-BW_METHOD_END OnError
%-BW_EVENT_IMPLEMENT_END
%INITIALIZATION
  /* ### %DeviceType "%DeviceName" init code ... */
%CODE_BEGIN
  /* Write code here ... */
%CODE_END
%-
%ENABLE
%CODE_BEGIN
%CODE_END
%-
%else %- Language (& Compiler)
  %error^ This component is not implemented in selected language & compiler !
%endif %- Language (& Compiler)
%DEBUG
%ALL_SYMBOLS
%-
