%-Driver generated by the Component Wizard
%-
%- WARNING !
%-
%- Do not make changes to these lines (if you make some changes, you damage this driver)
%- which begins with:
%-
%-  %-STARTUSERTYPES
%-  %-ENDUSRTYPES
%-  /* END %ModuleName. */
%-  /* MODULE %ModuleName. */
%-  %-INTERNAL_METHOD_BEG
%-  %-INTERNAL_METHOD_END
%-  %-INHERITED_EVENT_BEGIN
%-  %-INHERITED_EVENT_END
%-  %-BW_METHOD_BEGIN
%-  %-BW_METHOD_END
%-  %-BW_DEFINITION_START
%-  %-BW_DEFINITION_END
%-  %-BW_IMPLEMENT_START
%-  %-BW_IMPLEMENT_END
%-  %-BW_EVENT_DEFINITION_START
%-  %-BW_EVENT_DEFINITION_END
%-  %-BW_EVENT_IMPLEMENT_START
%-  %-BW_EVENT_IMPLEMENT_END
%-  %-BW_METHOD_MACROS_START
%-  %-BW_METHOD_MACROS_END
%-  %-BW_SECTIONS_INSERT
%-  %-BW_INTERN_COMMENTS_START
%-  %-BW_INTERN_COMMENTS_END
%-  %-BW_BEAN_CONSTANTS_START
%-  %-BW_BEAN_CONSTANTS_END
%-
%-
%- These lines are not comments, but they are necessary for Component Wizard
%- If you change these lines, Component Wizard will not be responsible for loosing or damaging your code!
%-
%-
%- readyCPU ...
%- readyDEVICE ...
%-
%define DriverAuthor  Author
%define DriverVersion 01.00
%define DriverDate    26.12.2012
%-
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END
%-
%-BW_INTERN_COMMENTS_START
%- List of descriptions of internal methods
%define! Description_HandlerC Additional handler which decodes the processor status
%-BW_INTERN_COMMENTS_END
%-
%-BW_SECTIONS_INSERT
%if Language='ANSIC'
%-
%-
%INTERFACE
%define! Settings Common\HardFaultSettings.Inc
%define! Abstract Common\HardFaultAbstract.Inc
%include Common\Header.h

#ifndef __%'ModuleName'_H
#define __%'ModuleName'_H

/* MODULE %ModuleName. */
#include "%@sdk@ModuleName.h" /* SDK and API used */
#include "%'ModuleName'config.h" /* configuration */
%-BW_CUSTOM_INCLUDE_START_H
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%-BW_CUSTOM_INCLUDE_END_H
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END

%-STARTUSERTYPES - Do not make changes between lines (included this lines) marked with %-STARTUSERTYPES and %-ENDUSRTYPES

%-ENDUSRTYPES
%-BW_BEAN_CONSTANTS_START  - Do not make changes between lines (included this lines) marked with %-BW_BEAN_CONSTANTS_START and %-BW_BEAN_CONSTANTS_END
%- No constants defined in the BeanWizard for this bean
%-BW_BEAN_CONSTANTS_END
%-BW_CUSTOM_USERTYPE_START
%- Write your own types here ...
%-  Example:
%-    typedef int TMyInteger;
%-
%-BW_CUSTOM_USERTYPE_END


%-BW_DEFINITION_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN HardFaultHandler
%ifdef HardFaultHandler
void %'ModuleName'%.%HardFaultHandler(void);
%include Common\HardFaultHardFaultHandler.Inc

%endif %- HardFaultHandler
%-BW_METHOD_END HardFaultHandler
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG HandlerC
#ifdef __GNUC__ /* 'used' attribute needed for GNU LTO (Link Time Optimization) */
void %'ModuleName'%.HandlerC(uint32_t *hardfault_args) __attribute__((used));
#else
void %'ModuleName'%.HandlerC(uint32_t *hardfault_args);
#endif
%define! Parhardfault_args
%include Common\GeneralInternal.inc (HandlerC)

%-INTERNAL_METHOD_END HandlerC
%-************************************************************************************************************
%-BW_METHOD_BEGIN Deinit
%ifdef Deinit
void %'ModuleName'%.%Deinit(void);
%include Common\HardFaultDeinit.Inc

%endif %- Deinit
%-BW_METHOD_END Deinit
%-************************************************************************************************************
%-BW_METHOD_BEGIN Init
%ifdef Init
void %'ModuleName'%.%Init(void);
%include Common\HardFaultInit.Inc

%endif %- Init
%-BW_METHOD_END Init
%-BW_DEFINITION_END
/* END %ModuleName. */

#endif
/* ifndef __%'ModuleName'_H */
%include Common\Header.End
%-
%-BW_EVENT_DEFINITION_START
%-BW_EVENT_DEFINITION_END
%IMPLEMENTATION
%define! Settings Common\HardFaultSettings.Inc
%define! Abstract Common\HardFaultAbstract.Inc
%include Common\Header.C

/* MODULE %ModuleName. */

%for var from EventModules
#include "%var.h"
%endfor
#include "%'ModuleName'.h"

#if %@sdk@'ModuleName'%.CONFIG_CPU_IS_ARM_CORTEX_M
%if defined(CPUfamily)
%if (CPUfamily = "Kinetis") | (CPUfamily = "S32K")
%- =============================================================================
%- Allocation of interrupt vectors by component.
%- =============================================================================
%-
%if (defined(PEversionDecimal) && (PEversionDecimal >=0 '1282')) %- this is only supported with MCU 10.3
%- Get interrupts info from CPU database
%- Note: this is done only for Kinetis for now.
%:tmp = %CPUDB_define_Interrupt_Vectors_info()
%-
 %for vect from InterruptVectors
   %if %"%'vect'" = 'defaultInt'
     %if vect = 'ivINT_Hard_Fault'
       %define_prj %'vect' %'ModuleName'%.%HardFaultHandler
     %else
       %- keep PEx default
     %endif
   %endif
 %endfor
%-
%endif %- MCU 10.3
%-
%else
  %error "this component is only supported for GCC and Kinetis!"
%endif %-(CPUfamily = "Kinetis") or "S32K"
%endif
%-BW_CUSTOM_INCLUDE_START_M
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%-BW_CUSTOM_INCLUDE_END_M

%-BW_CUSTOM_VARIABLE_START
%- Write your static variables here
%-   Example:
%-     static int counter1;
%-     int %'ModuleName'%.counter2;
%-
%-BW_CUSTOM_VARIABLE_END
%-BW_INTERN_METHOD_DECL_START
%- List of internal methods headers
%-BW_INTERN_METHOD_DECL_END
%-BW_IMPLEMENT_START
%-************************************************************************************************************
%-INTERNAL_METHOD_BEG HandlerC
%define! Parhardfault_args
%include Common\GeneralInternal.inc (HandlerC)
/**
 * This is called from the HardFaultHandler with a pointer the Fault stack
 * as the parameter. We can then read the values from the stack and place them
 * into local variables for ease of reading.
 * We then read the various Fault Status and Address Registers to help decode
 * cause of the fault.
 * The function ends with a BKPT instruction to force control back into the debugger
 */
%if %Compiler = "GNUC"
#pragma GCC diagnostic ignored "-Wunused-but-set-variable"
%endif
void %'ModuleName'%.HandlerC(uint32_t *hardfault_args)
{
  /*lint -save  -e550 Symbol not accessed. */
%if (%Compiler = "IARARM")
  volatile unsigned long stacked_r0;
  volatile unsigned long stacked_r1;
  volatile unsigned long stacked_r2;
  volatile unsigned long stacked_r3;
  volatile unsigned long stacked_r12;
  volatile unsigned long stacked_lr;
  volatile unsigned long stacked_pc;
  volatile unsigned long stacked_psr;
  volatile unsigned long _CFSR;
  volatile unsigned long _HFSR;
  volatile unsigned long _DFSR;
  volatile unsigned long _AFSR;
  volatile unsigned long _BFAR;
  volatile unsigned long _MMAR;
%else
  static volatile unsigned long stacked_r0;
  static volatile unsigned long stacked_r1;
  static volatile unsigned long stacked_r2;
  static volatile unsigned long stacked_r3;
  static volatile unsigned long stacked_r12;
  static volatile unsigned long stacked_lr;
  static volatile unsigned long stacked_pc;
  static volatile unsigned long stacked_psr;
  static volatile unsigned long _CFSR;
  static volatile unsigned long _HFSR;
  static volatile unsigned long _DFSR;
  static volatile unsigned long _AFSR;
  static volatile unsigned long _BFAR;
  static volatile unsigned long _MMAR;
%endif
  stacked_r0 = ((unsigned long)hardfault_args[0]);               %>60 /* http://www.asciiworld.com/-Smiley,20-.html                                   */
  stacked_r1 = ((unsigned long)hardfault_args[1]);               %>60 /*                         oooo$$$$$$$$$$$$oooo                                 */
  stacked_r2 = ((unsigned long)hardfault_args[2]);               %>60 /*                      oo$$$$$$$$$$$$$$$$$$$$$$$$o                             */
  stacked_r3 = ((unsigned long)hardfault_args[3]);               %>60 /*                    oo$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$o         o$   $$ o$      */
  stacked_r12 = ((unsigned long)hardfault_args[4]);              %>60 /*    o $ oo        o$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$o       $$ $$ $$o$     */
  stacked_lr = ((unsigned long)hardfault_args[5]);               %>60 /* oo $ $ "$      o$$$$$$$$$    $$$$$$$$$$$$$    $$$$$$$$$o       $$$o$$o$      */
  stacked_pc = ((unsigned long)hardfault_args[6]);               %>60 /* "$$$$$$o$     o$$$$$$$$$      $$$$$$$$$$$      $$$$$$$$$$o    $$$$$$$$       */
  stacked_psr = ((unsigned long)hardfault_args[7]);              %>60 /*   $$$$$$$    $$$$$$$$$$$      $$$$$$$$$$$      $$$$$$$$$$$$$$$$$$$$$$$       */
                                                                 %>60 /*   $$$$$$$$$$$$$$$$$$$$$$$    $$$$$$$$$$$$$    $$$$$$$$$$$$$$  """$$$         */
  /* Configurable Fault Status Register */                       %>60 /*    "$$$""""$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$     "$$$        */
  /* Consists of MMSR, BFSR and UFSR */                          %>60 /*     $$$   o$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$     "$$$o      */
  _CFSR = (*((volatile unsigned long *)(0xE000ED28)));           %>60 /*    o$$"   $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$       $$$o     */
                                                                 %>60 /*    $$$    $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$" "$$$$$$ooooo$$$$o   */
  /* Hard Fault Status Register */                               %>60 /*   o$$$oooo$$$$$  $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$   o$$$$$$$$$$$$$$$$$  */
  _HFSR = (*((volatile unsigned long *)(0xE000ED2C)));           %>60 /*   $$$$$$$$"$$$$   $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$     $$$$""""""""        */
                                                                 %>60 /*  """"       $$$$    "$$$$$$$$$$$$$$$$$$$$$$$$$$$$"      o$$$                 */
  /* Debug Fault Status Register */                              %>60 /*             "$$$o     """$$$$$$$$$$$$$$$$$$"$$"         $$$                  */
  _DFSR = (*((volatile unsigned long *)(0xE000ED30)));           %>60 /*               $$$o          "$$""$$$$$$""""           o$$$                   */
                                                                 %>60 /*                $$$$o                                o$$$"                    */
  /* Auxiliary Fault Status Register */                          %>60 /*                 "$$$$o      o$$$$$$o"$$$$o        o$$$$                      */
  _AFSR = (*((volatile unsigned long *)(0xE000ED3C)));           %>60 /*                   "$$$$$oo     ""$$$$o$$$$$o   o$$$$""                       */
                                                                 %>60 /*                      ""$$$$$oooo  "$$$o$$$$$$$$$"""                          */
                                                                 %>60 /*                         ""$$$$$$$oo $$$$$$$$$$                               */
  /* Read the Fault Address Registers. */                        %>60 /*                                 """"$$$$$$$$$$$                              */
  /* These may not contain valid values. */                      %>60 /*                                     $$$$$$$$$$$$                             */
  /* Check BFARVALID/MMARVALID to see */                         %>60 /*                                      $$$$$$$$$$"                             */
  /* if they are valid values */                                 %>60 /*                                       "$$$""                                 */
  /* MemManage Fault Address Register */
  _MMAR = (*((volatile unsigned long *)(0xE000ED34)));
  /* Bus Fault Address Register */
  _BFAR = (*((volatile unsigned long *)(0xE000ED38)));

#if 0 /* experimental, seems not to work properly with GDB in KDS V3.2.0 */
#ifdef __GNUC__ /* might improve stack, see https://www.element14.com/community/message/199113/l/gdb-assisted-debugging-of-hard-faults#199113 */
  __asm volatile (
      "tst lr,#4     \n" /* check which stack pointer we are using */
      "ite eq        \n"
      "mrseq r0, msp \n" /* use MSP */
      "mrsne r0, psp \n" /* use PSP */
      "mov sp, r0    \n" /* set stack pointer so GDB shows proper stack frame */
  );
#endif
#endif
  __asm("BKPT #0\n") ; /* cause the debugger to stop */
  /*lint -restore */
}

%-INTERNAL_METHOD_END HandlerC
%-************************************************************************************************************
%-BW_METHOD_BEGIN HardFaultHandler
%ifdef HardFaultHandler
%include Common\HardFaultHardFaultHandler.Inc
%if %Compiler = "GNUC"
#pragma GCC diagnostic ignored "-Wunused-but-set-variable"
__attribute__((naked))
#if %@sdk@'ModuleName'%.CONFIG_SDK_VERSION_USED==%@sdk@'ModuleName'%.CONFIG_SDK_RPI_PICO
void isr_hardfault(void)
#elif %@sdk@'ModuleName'%.CONFIG_SDK_VERSION_USED != %@sdk@'ModuleName'%.CONFIG_SDK_PROCESSOR_EXPERT
void HardFault_Handler(void)
#else
void %'ModuleName'%.%HardFaultHandler(void)
#endif
{
  __asm volatile (
    ".syntax unified              \n"  /* needed for the 'adds r1,#2' below */
    " movs r0,#4                  \n"  /* load bit mask into R0 */
    " mov r1, lr                  \n"  /* load link register into R1 */
    " tst r0, r1                  \n"  /* compare with bitmask */
    " beq _MSP                    \n"  /* if bitmask is set: stack pointer is in PSP. Otherwise in MSP */
    " mrs r0, psp                 \n"  /* otherwise: stack pointer is in PSP */
    " b _GetPC                    \n"  /* go to part which loads the PC */
  "_MSP:                          \n"  /* stack pointer is in MSP register */
    " mrs r0, msp                 \n"  /* load stack pointer into R0 */
  "_GetPC:                        \n"  /* find out where the hard fault happened */
    " ldr r1,[r0,#24]             \n"  /* load program counter into R1. R1 contains address of the next instruction where the hard fault happened */
#if %'ModuleName'%.CONFIG_SETTING_SEMIHOSTING
  /* The following code checks if the hard fault is caused by a semihosting BKPT instruction which is "BKPT 0xAB" (opcode: 0xBEAB)
     The idea is taken from the MCUXpresso IDE/SDK code, so credits and kudos to the MCUXpresso IDE team! */
    " ldrh r2,[r1]                \n"  /* load opcode causing the fault */
    " ldr r3,=0xBEAB              \n"  /* load constant 0xBEAB (BKPT 0xAB) into R3" */
    " cmp r2,r3                   \n"  /* is it the BKPT 0xAB? */
    " beq _SemihostReturn         \n"  /* if yes, return from semihosting */
    " b %'ModuleName'%.HandlerC   \n"  /* if no, dump the register values and halt the system */
  "_SemihostReturn:               \n"  /* returning from semihosting fault */
    " adds r1,#2                  \n"  /* r1 points to the semihosting BKPT instruction. Adjust the PC to skip it (2 bytes) */
    " str r1,[r0,#24]             \n"  /* store back the adjusted PC value to the interrupt stack frame */
    " movs r1,#32                 \n"  /* need to pass back a return value to emulate a successful semihosting operation. 32 is an arbitrary value */
    " str r1,[r0,#0]              \n"  /* store the return value on the stack frame */
    " bx lr                       \n"  /* return from the exception handler back to the application */
#else
    " b %'ModuleName'%.HandlerC   \n"  /* decode more information. R0 contains pointer to stack frame */
#endif
  );
}
%elif (%Compiler = "ARM_CC") %- Keil/ARM compiler
#if %@sdk@'ModuleName'%.SDK_VERSION_USED != %@sdk@'ModuleName'%.SDK_VERSION_NONE
__asm void HardFault_Handler(void)
#else
__asm void %'ModuleName'%.%HardFaultHandler(void)
#endif
{
  EXTERN %'ModuleName'%.HandlerC [CODE]

    movs r0,#4      /* load bit mask into R0 */
    mov r1, lr      /* load link register into R1 */
    tst r0, r1      /* compare with bitmask */
    beq _MSP        /* if bitmask is set: stack pointer is in PSP. Otherwise in MSP */
    mrs r0, psp     /* otherwise: stack pointer is in PSP */
    b _GetPC        /* go to part which loads the PC */
_MSP                /* stack pointer is in MSP register */
    mrs r0, msp     /* load stack pointer into R0 */
_GetPC              /* find out where the hard fault happened */
    ldr r1,[r0,#24] /* load program counter into R1. R1 contains address of the next instruction where the hard fault happened */
    ldr r3, = %'ModuleName'%.HandlerC
    bx r3           /* decode more information. R0 contains pointer to stack frame */
}
%elif (%Compiler = "IARARM")
  /* %'ModuleName'%.HardFaultHandler() is implemented in assembly in %'ModuleName'%.HardFaultHandler.s */
%elif (%Compiler = "CodeWarriorARM")
/* legacy Freescale ARM compiler */
#if %@sdk@'ModuleName'%.SDK_VERSION_USED != %@sdk@'ModuleName'%.SDK_VERSION_NONE
asm void HardFault_Handler(void) {
#else
asm void %'ModuleName'%.%HardFaultHandler(void)
#endif
{
    movs r0,#4       /* load bit mask into R0 */
    movs r1, lr      /* load link register into R1 */
    tst r0, r1       /* compare with bitmask */
    beq _MSP         /* if bitmask is set: stack pointer is in PSP. Otherwise in MSP */
    mrs r0, psp      /* otherwise: stack pointer is in PSP */
    b _GetPC         /* go to part which loads the PC */
  _MSP:              /* stack pointer is in MSP register */
    mrs r0, msp      /* load stack pointer into R0 */
  _GetPC:            /* find out where the hard fault happened */
    ldr r1,[r0,#24]  /* load stack pointer into R0 */
    ldr r3, =%'ModuleName'%.HandlerC   /* decode more information. R0 contains pointer to stack frame */
    bx r3            /* jump to handler */
}
%else
  #error "unsupported compiler."
%endif

%endif %- HardFaultHandler
%-BW_METHOD_END HardFaultHandler
%-************************************************************************************************************
%-BW_METHOD_BEGIN Deinit
%ifdef Deinit
%include Common\HardFaultDeinit.Inc
void %'ModuleName'%.%Deinit(void)
{
#if %'ModuleName'%.CONFIG_SETTING_DISABLE_WRITE_BUFFER
  #if %@sdk@'ModuleName'%.CONFIG_SDK_VERSION_USED == %@sdk@'ModuleName'%.CONFIG_SDK_PROCESSOR_EXPERT
    SCB_ACTLR &= ~(SCB_ACTLR_DISDEFWBUF_MASK); /* write buffer bit, see https://community.nxp.com/docs/DOC-103810 */
  #elif %@sdk@'ModuleName'%.CONFIG_NXP_SDK_USED && %@sdk@'ModuleName'%.McuLib_CONFIG_CORTEX_M!=7 /* not for M7? */
    SCnSCB->ACTLR &= ~SCnSCB_ACTLR_DISDEFWBUF_Msk;
  #endif
#endif
}

%endif %- Deinit
%-BW_METHOD_END Deinit
%-************************************************************************************************************
%-BW_METHOD_BEGIN Init
%ifdef Init
%include Common\HardFaultInit.Inc
void %'ModuleName'%.%Init(void)
{
#if %'ModuleName'%.CONFIG_SETTING_DISABLE_WRITE_BUFFER
  #if %@sdk@'ModuleName'%.CONFIG_SDK_VERSION_USED == %@sdk@'ModuleName'%.CONFIG_SDK_PROCESSOR_EXPERT
    SCB_ACTLR |= SCB_ACTLR_DISDEFWBUF_MASK; /* write buffer bit, see https://community.nxp.com/docs/DOC-103810 */
  #elif %@sdk@'ModuleName'%.CONFIG_NXP_SDK_USED && %@sdk@'ModuleName'%.McuLib_CONFIG_CORTEX_M!=7 /* not for M7? */
    SCnSCB->ACTLR |= SCnSCB_ACTLR_DISDEFWBUF_Msk;
  #endif
#endif
}

%endif %- Init
%-BW_METHOD_END Init
%-BW_IMPLEMENT_END

#endif /* %@sdk@'ModuleName'%.CONFIG_CPU_IS_ARM_CORTEX_M */
/* END %ModuleName. */

%include Common\Header.End
%-
%-
%-BW_EVENT_IMPLEMENT_START
%-BW_EVENT_IMPLEMENT_END
%INITIALIZATION
%CODE_BEGIN
%if (CPUfamily = "S32K")
#ifdef CPU_INIT_MCUONECLIPSE_DRIVERS
%endif
  %'ModuleName'%.%Init(); /* ### %DeviceType "%DeviceName" init code ... */
%if (CPUfamily = "S32K")
#endif
%endif
%CODE_END
%-
%ENABLE
%CODE_BEGIN
%CODE_END
%-
%if (%Compiler = "IARARM")
%- need to implement the handler in assembly, as IAR does not support inline assembly with labels?
%FILE %'DirRel_Code'%'ModuleName'%.HardFaultHandler.s
  /* use code segment, and we are generating ARM thumb code: */
  RSEG    CODE:CODE(2)
  thumb

  /* external interface declaration; */
  PUBLIC %'ModuleName'%.%HardFaultHandler

  /* list of external functions we are going to use: */
  EXTERN %'ModuleName'%.HandlerC

/*-----------------------------------------------------------*/
%'ModuleName'%.%HardFaultHandler:
  movs r0,#4       /* load bit mask into R0 */
  mov r1, lr       /* load link register into R1 */
  tst r0, r1       /* compare with bitmask */
  beq _MSP         /* if bitmask is set: stack pointer is in PSP. Otherwise in MSP */
  mrs r0, psp      /* otherwise: stack pointer is in PSP */
  b _GetPC         /* go to part which loads the PC */
  _MSP:            /* stack pointer is in MSP register */
  mrs r0, msp      /* load stack pointer into R0 */
  _GetPC:          /* find out where the hard fault happened */
  ldr r1,[r0,#24]  /* load program counter into R1. R1 contains address of the next instruction where the hard fault happened */
  b %'ModuleName'%.HandlerC  /* decode more information. R0 contains pointer to stack frame */
/*-----------------------------------------------------------*/
  END
%endif %- (%Compiler = "IARARM")
%else %- Language (& Compiler)
  %error^ This component is not implemented in selected language & compiler !
%endif %- Language (& Compiler)
%DEBUG
%ALL_SYMBOLS
%-
%-----------------------------------------------------------------------------------------
%if defined(sdk) & %@sdk@ConfigFilesFolderName <> ""
  %define  ConfigSrcDirFolder %%@sdk@ConfigFilesFolderName/
%else
  %define  ConfigSrcDirFolder
%endif
%----------------------------
%FILE %'DirRel_Code'%'ConfigSrcDirFolder'%'ModuleName'config.h
/**
 * \file
 * \brief Configuration header file for HardFault
 * Copyright (c) 2020, Erich Styger
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * This header file is used to configure settings of the HardFault module.
 */

#ifndef __%'ModuleName'_CONFIG_H
#define __%'ModuleName'_CONFIG_H

#include "%@sdk@ModuleName.h" /* SDK and API used */

%if (%CPUfamily = "Kinetis")
%if defined(ARMFamilyType) & %ARMFamilyType="M0+"
#define %'ModuleName'%.CONFIG_SETTING_HAS_ACTLR   (0 || (%@sdk@'ModuleName'%.CPU_IS_ARM_CORTEX_M && %@sdk@'ModuleName'%.CONFIG_CORTEX_M>=3))
%else
#define %'ModuleName'%.CONFIG_SETTING_HAS_ACTLR   (1 || (%@sdk@'ModuleName'%.CPU_IS_ARM_CORTEX_M && %@sdk@'ModuleName'%.CONFIG_CORTEX_M>=3))
%endif
%else
#define %'ModuleName'%.CONFIG_SETTING_HAS_ACTLR   (0 || (%@sdk@'ModuleName'%.CPU_IS_ARM_CORTEX_M && %@sdk@'ModuleName'%.CONFIG_CORTEX_M >= 3))
%endif
  /*!< 1: Cortex-M3, M4 have Auxiliary Control Register, ACTLR register */

#ifndef %'ModuleName'%.CONFIG_SETTING_DISABLE_WRITE_BUFFER
%if defined(DisableWriteBuffer) & %DisableWriteBuffer='yes'
  #define %'ModuleName'%.CONFIG_SETTING_DISABLE_WRITE_BUFFER   (1 && %'ModuleName'%.CONFIG_SETTING_HAS_ACTLR)
%else
  #define %'ModuleName'%.CONFIG_SETTING_DISABLE_WRITE_BUFFER   (0 && %'ModuleName'%.CONFIG_SETTING_HAS_ACTLR)
%endif
  /*!< 1: disable write buffer in ACTLR register */
#endif

#ifndef %'ModuleName'%.CONFIG_SETTING_SEMIHOSTING
%if defined(SemihostingSupport) & %SemihostingSupport='yes'
  #define %'ModuleName'%.CONFIG_SETTING_SEMIHOSTING   (1)
%else
  #define %'ModuleName'%.CONFIG_SETTING_SEMIHOSTING   (0)
%endif
  /*!< 1: do not stop in handler with semihosting and no debugger attached. 0: semihosting hardfault will stop target */
#endif


#endif /* __%'ModuleName'_CONFIG_H */
%-----------------------------------------------------------------------------------------
