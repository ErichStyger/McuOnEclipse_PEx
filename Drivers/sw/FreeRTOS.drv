%-Driver generated by the Bean Wizard
%-
%- WARNING !
%-
%- Do not make changes to these lines (if you make some changes, you damage this driver)
%- which begins with:
%-
%-  %-STARTUSERTYPES
%-  %-ENDUSRTYPES
%-  /* END %ModuleName. */
%-  /* MODULE %ModuleName. */
%-  %-INTERNAL_METHOD_BEG
%-  %-INTERNAL_METHOD_END
%-  %-INHERITED_EVENT_BEGIN
%-  %-INHERITED_EVENT_END
%-  %-BW_METHOD_BEGIN
%-  %-BW_METHOD_END
%-  %-BW_DEFINITION_START
%-  %-BW_DEFINITION_END
%-  %-BW_IMPLEMENT_START
%-  %-BW_IMPLEMENT_END
%-  %-BW_EVENT_DEFINITION_START
%-  %-BW_EVENT_DEFINITION_END
%-  %-BW_EVENT_IMPLEMENT_START
%-  %-BW_EVENT_IMPLEMENT_END
%-  %-BW_METHOD_MACROS_START
%-  %-BW_METHOD_MACROS_END
%-  %-BW_SECTIONS_INSERT
%-  %-BW_INTERN_COMMENTS_START
%-  %-BW_INTERN_COMMENTS_END
%-  %-BW_BEAN_CONSTANTS_START
%-  %-BW_BEAN_CONSTANTS_END
%-
%-
%- These lines are not comments, but they are necessary for Bean Wizard
%- If you change these lines, Bean Wizard will not be responsible for loosing or damaging your code!
%-
%-
%- readyCPU ...
%- readyDEVICE ...
%-
%define DriverAuthor  Author
%define DriverVersion 01.00
%define DriverDate    27.08.2009
%-
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END
%-
%-BW_INTERN_COMMENTS_START
%- List of descriptions of internal methods
%ifdef RuntimeCntrLDD
  %ifdef @RuntimeCntrLDD@OnCounterRestart
    %define! Description_%@RuntimeCntrLDD@OnCounterRestart Called if counter overflow/underflow or counter is reinitialized by modulo or compare register matching. OnCounterRestart event and Timer unit must be enabled. See <a href="TimerUnit_LDDMethods.html#SetEventMask">SetEventMask</a> and <a href="TimerUnit_LDDMethods.html#GetEventMask">GetEventMask</a> methods.This event is available only if a <a href="TimerUnit_LDDProperties.html#IntServiceCounter">Interrupt</a> is enabled. The event services the event of the inherited component and eventually invokes other events.
  %endif %- @RuntimeCntrLDD@OnCounterRestart
%endif %- RuntimeCntrLDD
%ifdef RuntimeCntr
  %ifdef @RuntimeCntr@OnInterrupt
    %define! Description_%@RuntimeCntr@OnInterrupt When a timer interrupt occurs this event is called (only when the component is enabled - <a href="TimerIntMethods.html#Enable">Enable</a> and the events are enabled - <a href="TimerIntMethods.html#EnableEvent">EnableEvent</a>). This event is enabled only if a <a href="TimerIntProperties.html#IntService">interrupt service/event</a> is enabled. The event services the event of the inherited component and eventually invokes other events.
  %endif %- @RuntimeCntr@OnInterrupt
%endif %- RuntimeCntr
%ifdef TickCntr
  %ifdef @TickCntr@OnInterrupt
    %define! Description_%@TickCntr@OnInterrupt This event is called when a compare matches the counter value (if compare or reload is selected as a interrupt source) or a counter overflows (for free-running devices). It is valid only when the component is enabled - <a href="FreeCntrMethods.html#Enable">"Enable"</a> and the events are enabled - <a href="FreeCntrMethods.html#EnableEvent">"EnableEvent"</a>. The event is available only if <a href="FreeCntrProperties.html#IntService">Interrupt service/event</a> is enabled. The event services the event of the inherited component and eventually invokes other events.
  %endif %- @TickCntr@OnInterrupt
%endif %- TickCntr
%ifdef TickTimerLDD
  %ifdef @TickTimerLDD@OnCounterRestart
    %define! Description_%@TickTimerLDD@OnCounterRestart Called if counter overflow/underflow or counter is reinitialized by modulo or compare register matching. OnCounterRestart event and Timer unit must be enabled. See <a href="TimerUnit_LDDMethods.html#SetEventMask">SetEventMask</a> and <a href="TimerUnit_LDDMethods.html#GetEventMask">GetEventMask</a> methods.This event is available only if a <a href="TimerUnit_LDDProperties.html#IntServiceCounter">Interrupt</a> is enabled. The event services the event of the inherited component and eventually invokes other events.
  %endif %- @TickTimerLDD@OnCounterRestart
%endif %- TickTimerLDD
%-BW_INTERN_COMMENTS_END
%-
%-BW_SECTIONS_INSERT
%if Language='ANSIC'
%-
%-
#include "FreeRTOSConfig.h"
%if %ModuleName = "FreeRTOS" %- avoid naming conflict with RTOS configuration file */
  %define RtosComponentConfigHeaderFileName %'ModuleName'_config.h
  %define RtosComponentHeaderFileName       %'ModuleName'_component.h
%else
  %define RtosComponentConfigHeaderFileName %'ModuleName'config.h
  %define RtosComponentHeaderFileName       %'ModuleName'.h
%endif
%-
%-
%include freeRTOS_Files.prg
%if defined(myDummy) %- dummy reference to the RTOS adaptor, otherwise the classic Component wizard will NOT include the file below in the package!
%include sw\RTOSAdaptor\FreeRTOS_RTOSAdaptor.prg
%endif
%-
%- NOT using INTERFACE as this can conflict if the name of the component is FreeRTOS (required for S32DS)
%- %INTERFACE
%FILE %'DirRel_Code'%'RtosComponentHeaderFileName'
%define! Settings Common\FreeRTOSSettings.Inc
%define! Abstract Common\FreeRTOSAbstract.Inc
%include Common\Header.h

%- Not using INTERFACE, otherwise it conflicts with names is component is named 'FreeRTOS' which is required for S32DS

#ifndef __%'ModuleName'_H
#define __%'ModuleName'_H

/* MODULE %ModuleName. */
#include "%@KinetisSDK@ModuleName.h" /* SDK and API used */
#if %@KinetisSDK@'ModuleName'%.CONFIG_SDK_USE_FREERTOS

#if %@KinetisSDK@'ModuleName'%.CONFIG_CPU_IS_ESP32
  #include "freertos/FreeRTOSConfig.h"
#else
  #include "FreeRTOSConfig.h"
#endif
#include "%'RtosComponentConfigHeaderFileName'" /* configuration file for component */

#if configUSE_SHELL
%if defined(Shell)
  #include "%@Shell@ModuleName.h"
%else
  #include "McuShell.h"
%endif
#endif
%-BW_CUSTOM_INCLUDE_START_H
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%-BW_CUSTOM_INCLUDE_END_H
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END

/* other includes needed */
#if %@KinetisSDK@'ModuleName'%.CONFIG_CPU_IS_ESP32
  #include "freertos/FreeRTOS.h"
  #include "freertos/task.h"                                     %>40/* task API */
  #include "freertos/semphr.h"                                   %>40/* semaphore API */
  #include "freertos/event_groups.h"                             %>40/* event group API */
  #include "freertos/timers.h"                                   %>40/* timer module API */
  #include "freertos/stream_buffer.h"                            %>40/* stream buffer module API */
#else
  #include "FreeRTOS.h"
  #include "task.h"                                              %>40/* task API */
  #include "semphr.h"                                            %>40/* semaphore API */
  #include "event_groups.h"                                      %>40/* event group API */
  #include "timers.h"                                            %>40/* timer module API */
  #include "stream_buffer.h"                                     %>40/* stream buffer module API */
#endif
#include <stddef.h>                                              %>40/* for size_t type */

#if configUSE_PERCEPIO_TRACE_HOOKS
%if defined(FRTrace)
  #include "%@FRTrace@ModuleName.h" /* Interface to Percepio Trace */
%else
  #include "McuPercepio.h" /* Interface to Percepio Trace */
%endif
#endif

/* Macro for shell support */
#define %'ModuleName'%.PARSE_COMMAND_ENABLED                     %>45 (configUSE_SHELL) /* set to 1 if method ParseCommand() is present, 0 otherwise */
%if defined(GenerateRTOSPExMacros) & %GenerateRTOSPExMacros='no'
#define %'ModuleName'%.GENERATE_PEX_RTOS_MACROS                  %>45 0  /* set to 1 to generate the RTOS macros PEX_RTOS_INIT() and PEX_RTOS_START() */
%else
#define %'ModuleName'%.GENERATE_PEX_RTOS_MACROS                  %>45 1  /* set to 1 to generate the RTOS macros PEX_RTOS_INIT() and PEX_RTOS_START() */
%endif

/* Macros used by Processor Expert */
#if %'ModuleName'%.GENERATE_PEX_RTOS_MACROS
  #define PEX_RTOS_INIT() /* macro called from PE_low_level_init() */ \
    %'ModuleName'%.%Init();

  #define PEX_RTOS_START()                                       %>>%'ModuleName'%.%vTaskStartScheduler()
#endif
/* macro to identify CPU: 0 for M0+ and 4 for M4 */
#if configCPU_FAMILY_IS_ARM_M0(configCPU_FAMILY)
  #define FREERTOS_CPU_CORTEX_M                                  %>>0 /* Cortex M0+ core */
#elif configCPU_FAMILY_IS_ARM_M4(configCPU_FAMILY)
  #define FREERTOS_CPU_CORTEX_M                                  %>>4 /* Cortex M4 core */
#elif configCPU_FAMILY_IS_ARM_M7(configCPU_FAMILY)
  #define FREERTOS_CPU_CORTEX_M                                  %>>7 /* Cortex M7 core */
#endif
%- =============================================================================
%- Add linker Entry Point - through .xlkr file
%- =============================================================================
%- %define_prj! PE_G_4PEx_ToolChain_Linker_EntryPoint __boot
%-
%- =============================================================================
%- Add other compiler language parameters - through .xlkr file
%- Currently disabled and fixed in source code.
%- =============================================================================
%if Compiler = 'CodeWarriorARM'
  %-if defined(XLKR_C_COMPILER_OTHER_PARAMS)
    %-error! xx %XLKR_C_COMPILER_OTHER_PARAMS
%-    %define_prj! PE_G_4PEx_ToolChain_Compiler_OtherParams -define __CODEWARRIOR__=1 -define __CWARM__=1 -define MQX_MQXLITE=1
  %-endif
  %-if defined(XLKR_ASM_COMPILER_OTHER_PARAMS)
%-    %define_prj! PE_G_4PEx_ToolChain_Asm_OtherParams -define __CODEWARRIOR__=1 -define __CWARM__=1 -define MQX_MQXLITE=1
  %-endif
%endif
%- Hints from Petr Uhlir:
%-1)        You can automatically detect core type by
%-  %if %CPUDB_prph_has_feature(CPU,ARM_CORTEX_M0P) = 'no'
%-    %define! mqx_core M4
%-  %elif %CPUDB_prph_has_feature(CPU,ARM_CORTEX_M0P) = 'yes'
%-    %define! mqx_core M0
%-  %else
%-    %error! Unsupported core platform!
%-  %endif
%-
%-2)        Detect FPU
%-%if %CPUDB_prph_has_feature(CPU, FPU) = 'yes'
%-#define MCU_HAS_FPU                                            %>>1
%-%else
%-#define MCU_HAS_FPU                                            %>>0
%-%endif
%-
%-
%if (CPUfamily = "Kinetis")
%- =============================================================================
%- Allocation of interrupt vectors by RTOS.
%- =============================================================================

/* Prototypes for interrupt service handlers */
%if defined(ARMFamilyType) & ARMFamilyType="M0+"
%- /* not used for Cortex-M0+ using the latest FreeRTOS port */
%else
void vPortSVCHandler(void);
%endif
void vPortPendSVHandler(void);
void vPortTickHandler(void);

/* Version of Processor Expert (variable VersionOfPEx): %PEversionDecimal */
%-
%if (defined(PEversionDecimal) && (PEversionDecimal >=0 '1282')) %- this is only supported with MCU 10.3
%- Get interrupts info from CPU database
%- Note: this is done only for Kinetis for now, and defaults are disabled in FreeRTOS_RTOSAdaptor.prg.
%:tmp = %CPUDB_define_Interrupt_Vectors_info()
%-
 %for vect from InterruptVectors
   %if %"%'vect'" = 'defaultInt'
     %if vect = 'ivINT_PendableSrvReq'
       %define_prj %'vect' vPortPendSVHandler
     %elif vect = 'ivINT_SVCall' & defined(ARMFamilyType) & ARMFamilyType!="M0+" %- not needed for M0+
       %define_prj %'vect' vPortSVCHandler
     %elif defined(useARMLowPowerTimer) & useARMLowPowerTimer='yes' & vect = 'ivINT_LPTMR0' %-(PEversionDecimal >=0 '1313')
       %define_prj %'vect' vPortTickHandler
     %elif defined(useARMLowPowerTimer) & useARMLowPowerTimer='yes' & vect = 'ivINT_LPTimer'
       %define_prj %'vect' vPortTickHandler
     %elif defined(useARMSysTickTimer) & useARMSysTickTimer='yes' & defined(useARMLowPowerTimer) & useARMLowPowerTimer='no' & vect = 'ivINT_SysTick'
       %define_prj %'vect' vPortTickHandler
     %else
       %- keep PEx default
     %endif
   %endif
 %endfor
%-
%endif %- MCU 10.3
%-
%endif %-(CPUfamily = "Kinetis")
%- =============================================================================
%- Required update of the generated linker command file.
%- =============================================================================
%- DATA SECTION
%- %append PE_G_LCF_ADDITIONAL_DATA_SECTION_CONTENT  /* FreeRTOS component BEGIN */
%- %append PE_G_LCF_ADDITIONAL_DATA_SECTION_CONTENT  . = ALIGN(0x10);
%- %append PE_G_LCF_ADDITIONAL_DATA_SECTION_CONTENT  *(.kernel_data)
%- %append PE_G_LCF_ADDITIONAL_DATA_SECTION_CONTENT  __KERNEL_DATA_START = ALIGN(0x10);
%- %append PE_G_LCF_ADDITIONAL_DATA_SECTION_CONTENT  . = __KERNEL_DATA_START + 0x0400;
%- %append PE_G_LCF_ADDITIONAL_DATA_SECTION_CONTENT  __KERNEL_DATA_END = .;
%- %append PE_G_LCF_ADDITIONAL_DATA_SECTION_CONTENT  /* FreeRTOS component END */
%- CODE SECTION
%- %append PE_G_LCF_ADDITIONAL_CODE_SECTION_CONTENT  /* FreeRTOS component BEGIN */
%- %append PE_G_LCF_ADDITIONAL_CODE_SECTION_CONTENT  * (KERNEL)
%- %append PE_G_LCF_ADDITIONAL_CODE_SECTION_CONTENT  __VECTOR_TABLE_START = __vector_table;
%- %append PE_G_LCF_ADDITIONAL_CODE_SECTION_CONTENT  . = ALIGN(0x4);
%- %append PE_G_LCF_ADDITIONAL_CODE_SECTION_CONTENT  *(.rdata)
%- %append PE_G_LCF_ADDITIONAL_CODE_SECTION_CONTENT  . = ALIGN(0x4);
%- %append PE_G_LCF_ADDITIONAL_CODE_SECTION_CONTENT  *(.exception)
%- %append PE_G_LCF_ADDITIONAL_CODE_SECTION_CONTENT  . = ALIGN(0x4);
%- %append PE_G_LCF_ADDITIONAL_CODE_SECTION_CONTENT  __exception_table_start__ = .;
%- %append PE_G_LCF_ADDITIONAL_CODE_SECTION_CONTENT  /* EXCEPTION */
%- %append PE_G_LCF_ADDITIONAL_CODE_SECTION_CONTENT  __exception_table_end__ = .;
%- %append PE_G_LCF_ADDITIONAL_CODE_SECTION_CONTENT  __sinit__ = .;
%- %append PE_G_LCF_ADDITIONAL_CODE_SECTION_CONTENT  /* STATICINIT */
%- %append PE_G_LCF_ADDITIONAL_CODE_SECTION_CONTENT  /* FreeRTOS component END */
%-
%-STARTUSERTYPES - Do not make changes between lines (included this lines) marked with %-STARTUSERTYPES and %-ENDUSRTYPES

#ifndef __BWUserType_Tsize_t
#define __BWUserType_Tsize_t
  typedef size_t Tsize_t;                                        %>40/* Alias to size_t standard type */
#endif

%-ENDUSRTYPES
%-BW_BEAN_CONSTANTS_START  - Do not make changes between lines (included this lines) marked with %-BW_BEAN_CONSTANTS_START and %-BW_BEAN_CONSTANTS_END
%- No constants defined in the BeanWizard for this bean
%-BW_BEAN_CONSTANTS_END
%-BW_CUSTOM_USERTYPE_START
%- Write your own types here ...
%-  Example:
%-    typedef int TMyInteger;
%-
%-BW_CUSTOM_USERTYPE_END

#ifdef __cplusplus
extern "C" {
#endif

%-BW_DEFINITION_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTaskCreate
%ifdef xTaskCreate

#define %'ModuleName'%.%xTaskCreate(pvTaskCode, pcName, usStackDepth, pvParameters, uxPriority, pvCreatedTask) \
        xTaskCreate(pvTaskCode, pcName, usStackDepth, pvParameters, uxPriority, pvCreatedTask)
%define! ParpvTaskCode
%define! ParpcName
%define! ParusStackDepth
%define! ParpvParameters
%define! ParuxPriority
%define! ParpvCreatedTask
%define! RetVal
%include Common\FreeRTOSxTaskCreate.Inc

%endif %- xTaskCreate
%-BW_METHOD_END xTaskCreate
%-************************************************************************************************************
%-BW_METHOD_BEGIN vTaskDelete
%ifdef vTaskDelete
#define %'ModuleName'%.%vTaskDelete(pxTask) \
        vTaskDelete(pxTask)
%define! ParpxTask
%include Common\FreeRTOSvTaskDelete.Inc

%endif %- vTaskDelete
%-BW_METHOD_END vTaskDelete
%-************************************************************************************************************
%-BW_METHOD_BEGIN vTaskStartScheduler
%ifdef vTaskStartScheduler
#define %'ModuleName'%.%vTaskStartScheduler() \
  vTaskStartScheduler()
%include Common\FreeRTOSvTaskStartScheduler.Inc

%endif %- vTaskStartScheduler
%-BW_METHOD_END vTaskStartScheduler
%-************************************************************************************************************
%-BW_METHOD_BEGIN taskYIELD
%ifdef taskYIELD
#define %'ModuleName'%.%taskYIELD() \
  taskYIELD()
%include Common\FreeRTOStaskYIELD.Inc

%endif %- taskYIELD
%-BW_METHOD_END taskYIELD
%-************************************************************************************************************
%-BW_METHOD_BEGIN taskENTER_CRITICAL
%ifdef taskENTER_CRITICAL
#define %'ModuleName'%.%taskENTER_CRITICAL() \
  taskENTER_CRITICAL()
%include Common\FreeRTOStaskENTER_CRITICAL.Inc

%endif %- taskENTER_CRITICAL
%-BW_METHOD_END taskENTER_CRITICAL
%-************************************************************************************************************
%-BW_METHOD_BEGIN taskEXIT_CRITICAL
%ifdef taskEXIT_CRITICAL
#define %'ModuleName'%.%taskEXIT_CRITICAL() \
  taskEXIT_CRITICAL()
%include Common\FreeRTOStaskEXIT_CRITICAL.Inc

%endif %- taskEXIT_CRITICAL
%-BW_METHOD_END taskEXIT_CRITICAL
%-************************************************************************************************************
%-BW_METHOD_BEGIN taskDISABLE_INTERRUPTS
%ifdef taskDISABLE_INTERRUPTS
#define %'ModuleName'%.%taskDISABLE_INTERRUPTS() \
  taskDISABLE_INTERRUPTS()
%include Common\FreeRTOStaskDISABLE_INTERRUPTS.Inc

%endif %- taskDISABLE_INTERRUPTS
%-BW_METHOD_END taskDISABLE_INTERRUPTS
%-************************************************************************************************************
%-BW_METHOD_BEGIN taskENABLE_INTERRUPTS
%ifdef taskENABLE_INTERRUPTS
#define %'ModuleName'%.%taskENABLE_INTERRUPTS() \
  taskENABLE_INTERRUPTS()
%include Common\FreeRTOStaskENABLE_INTERRUPTS.Inc

%endif %- taskENABLE_INTERRUPTS
%-BW_METHOD_END taskENABLE_INTERRUPTS
%-************************************************************************************************************
%-BW_METHOD_BEGIN vTaskEndScheduler
%ifdef vTaskEndScheduler
#define %'ModuleName'%.%vTaskEndScheduler() \
  vTaskEndScheduler()
%include Common\FreeRTOSvTaskEndScheduler.Inc

%endif %- vTaskEndScheduler
%-BW_METHOD_END vTaskEndScheduler
%-************************************************************************************************************
%-BW_METHOD_BEGIN vTaskSuspendAll
%ifdef vTaskSuspendAll
#define %'ModuleName'%.%vTaskSuspendAll() \
  vTaskSuspendAll()
%include Common\FreeRTOSvTaskSuspendAll.Inc

%endif %- vTaskSuspendAll
%-BW_METHOD_END vTaskSuspendAll
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTaskResumeAll
%ifdef xTaskResumeAll
#define %'ModuleName'%.%xTaskResumeAll() \
  xTaskResumeAll()
%define! RetVal
%include Common\FreeRTOSxTaskResumeAll.Inc

%endif %- xTaskResumeAll
%-BW_METHOD_END xTaskResumeAll
%-************************************************************************************************************
%-BW_METHOD_BEGIN vTaskDelay
%ifdef vTaskDelay
#define %'ModuleName'%.%vTaskDelay(xTicksToDelay) \
  vTaskDelay(xTicksToDelay)
%define! ParxTicksToDelay
%include Common\FreeRTOSvTaskDelay.Inc

%endif %- vTaskDelay
%-BW_METHOD_END vTaskDelay
%-************************************************************************************************************
%-BW_METHOD_BEGIN vTaskDelayUntil
%ifdef vTaskDelayUntil
#define %'ModuleName'%.%vTaskDelayUntil(pxPreviousWakeTime, xTimeIncrement) \
  vTaskDelayUntil(pxPreviousWakeTime, xTimeIncrement)
%define! ParpxPreviousWakeTime
%define! ParxTimeIncrement
%include Common\FreeRTOSvTaskDelayUntil.Inc

%endif %- vTaskDelayUntil
%-BW_METHOD_END vTaskDelayUntil
%-************************************************************************************************************
%-BW_METHOD_BEGIN uxTaskPriorityGet
%ifdef uxTaskPriorityGet
#define %'ModuleName'%.%uxTaskPriorityGet(pxTask) \
  uxTaskPriorityGet(pxTask)
%define! ParpxTask
%define! RetVal
%include Common\FreeRTOSuxTaskPriorityGet.Inc

%endif %- uxTaskPriorityGet
%-BW_METHOD_END uxTaskPriorityGet
%-************************************************************************************************************
%-BW_METHOD_BEGIN vTaskPrioritySet
%ifdef vTaskPrioritySet
#define %'ModuleName'%.%vTaskPrioritySet(pxTask, uxNewPriority) \
  vTaskPrioritySet(pxTask, uxNewPriority)
%define! ParpxTask
%define! ParuxNewPriority
%include Common\FreeRTOSvTaskPrioritySet.Inc

%endif %- vTaskPrioritySet
%-BW_METHOD_END vTaskPrioritySet
%-************************************************************************************************************
%-BW_METHOD_BEGIN xSemaphoreTakeRecursive
%ifdef xSemaphoreTakeRecursive
#define %'ModuleName'%.%xSemaphoreTakeRecursive(xMutex, xBlockTime) \
  xSemaphoreTakeRecursive(xMutex, xBlockTime)

%define! ParxMutex
%define! ParxBlockTime
%define! RetVal
%include Common\FreeRTOSxSemaphoreTakeRecursive.Inc

%endif %- xSemaphoreTakeRecursive
%-BW_METHOD_END xSemaphoreTakeRecursive
%-************************************************************************************************************
%-BW_METHOD_BEGIN xSemaphoreGiveRecursive
%ifdef xSemaphoreGiveRecursive
#define %'ModuleName'%.%xSemaphoreGiveRecursive(xMutex) \
  xSemaphoreGiveRecursive(xMutex)

%define! ParxMutex
%define! RetVal
%include Common\FreeRTOSxSemaphoreGiveRecursive.Inc

%endif %- xSemaphoreGiveRecursive
%-BW_METHOD_END xSemaphoreGiveRecursive
%-************************************************************************************************************
%-BW_METHOD_BEGIN xSemaphoreCreateRecursiveMutex
%ifdef xSemaphoreCreateRecursiveMutex
#define %'ModuleName'%.%xSemaphoreCreateRecursiveMutex() \
  xSemaphoreCreateRecursiveMutex()

%define! RetVal
%include Common\FreeRTOSxSemaphoreCreateRecursiveMutex.Inc

%endif %- xSemaphoreCreateRecursiveMutex
%-BW_METHOD_END xSemaphoreCreateRecursiveMutex
%-************************************************************************************************************
%-BW_METHOD_BEGIN vTaskSuspend
%ifdef vTaskSuspend
#define %'ModuleName'%.%vTaskSuspend(pxTaskToSuspend) \
  vTaskSuspend(pxTaskToSuspend)

%define! ParpxTaskToSuspend
%include Common\FreeRTOSvTaskSuspend.Inc

%endif %- vTaskSuspend
%-BW_METHOD_END vTaskSuspend
%-************************************************************************************************************
%-BW_METHOD_BEGIN vTaskResume
%ifdef vTaskResume
#define %'ModuleName'%.%vTaskResume(pxTaskToResume) \
  vTaskResume(pxTaskToResume)

%define! ParpxTaskToResume
%include Common\FreeRTOSvTaskResume.Inc

%endif %- vTaskResume
%-BW_METHOD_END vTaskResume
%-************************************************************************************************************
%-BW_METHOD_BEGIN xSemaphoreCreateMutex
%ifdef xSemaphoreCreateMutex
#define %'ModuleName'%.%xSemaphoreCreateMutex() \
  xSemaphoreCreateMutex()

%define! RetVal
%include Common\FreeRTOSxSemaphoreCreateMutex.Inc

%endif %- xSemaphoreCreateMutex
%-BW_METHOD_END xSemaphoreCreateMutex
%-************************************************************************************************************
%-BW_METHOD_BEGIN xSemaphoreTake
%ifdef xSemaphoreTake
#define %'ModuleName'%.%xSemaphoreTake(xMutex, xBlockTime) \
  xSemaphoreTake(xMutex, xBlockTime)

%define! ParxMutex
%define! ParxBlockTime
%define! RetVal
%include Common\FreeRTOSxSemaphoreTake.Inc

%endif %- xSemaphoreTake
%-BW_METHOD_END xSemaphoreTake
%-************************************************************************************************************
%-BW_METHOD_BEGIN xSemaphoreGive
%ifdef xSemaphoreGive
#define %'ModuleName'%.%xSemaphoreGive(xMutex) \
  xSemaphoreGive(xMutex)

%define! ParxMutex
%define! RetVal
%include Common\FreeRTOSxSemaphoreGive.Inc

%endif %- xSemaphoreGive
%-BW_METHOD_END xSemaphoreGive
%-************************************************************************************************************
%-BW_METHOD_BEGIN vSemaphoreCreateBinary
%ifdef vSemaphoreCreateBinary
#define %'ModuleName'%.%vSemaphoreCreateBinary(xSemaphore) \
  vSemaphoreCreateBinary(xSemaphore)

%define! ParxSemaphore
%include Common\FreeRTOSvSemaphoreCreateBinary.Inc

%endif %- vSemaphoreCreateBinary
%-BW_METHOD_END vSemaphoreCreateBinary
%-************************************************************************************************************
%-BW_METHOD_BEGIN xSemaphoreCreateCounting
%ifdef xSemaphoreCreateCounting
#define %'ModuleName'%.%xSemaphoreCreateCounting(uxMaxCount, uxInitialCount) \
  xSemaphoreCreateCounting(uxMaxCount, uxInitialCount)

%define! ParuxMaxCount
%define! ParuxInitialCount
%define! RetVal
%include Common\FreeRTOSxSemaphoreCreateCounting.Inc

%endif %- xSemaphoreCreateCounting
%-BW_METHOD_END xSemaphoreCreateCounting
%-************************************************************************************************************
%-BW_METHOD_BEGIN xSemaphoreGiveFromISR
%ifdef xSemaphoreGiveFromISR
#define %'ModuleName'%.%xSemaphoreGiveFromISR(xSemaphore, pxHigherPriorityTaskWoken) \
  xSemaphoreGiveFromISR(xSemaphore, pxHigherPriorityTaskWoken)

%define! ParxSemaphore
%define! ParpxHigherPriorityTaskWoken
%define! RetVal
%include Common\FreeRTOSxSemaphoreGiveFromISR.Inc

%endif %- xSemaphoreGiveFromISR
%-BW_METHOD_END xSemaphoreGiveFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN vSemaphoreDelete
%ifdef vSemaphoreDelete
#define %'ModuleName'%.%vSemaphoreDelete(xSemaphore) \
  vSemaphoreDelete(xSemaphore)
%define! ParxSemaphore
%include Common\FreeRTOSvSemaphoreDelete.Inc

%endif %- vSemaphoreDelete
%-BW_METHOD_END vSemaphoreDelete
%-************************************************************************************************************
%-BW_METHOD_BEGIN vTaskList
%ifdef vTaskList
#define %'ModuleName'%.%vTaskList(pcWriteBuffer, bufSize) \
  vTaskList(pcWriteBuffer, bufSize)

%define! ParpcWriteBuffer
%define! ParbufSize
%include Common\FreeRTOSvTaskList.Inc

%endif %- vTaskList
%-BW_METHOD_END vTaskList
%-************************************************************************************************************
%-BW_METHOD_BEGIN pvPortMalloc
%ifdef pvPortMalloc
#define %'ModuleName'%.%pvPortMalloc(xWantedSize) \
  pvPortMalloc(xWantedSize)
%define! ParxWantedSize
%define! RetVal
%include Common\FreeRTOSpvPortMalloc.Inc

%endif %- pvPortMalloc
%-BW_METHOD_END pvPortMalloc
%-************************************************************************************************************
%-BW_METHOD_BEGIN vPortFree
%ifdef vPortFree
#define %'ModuleName'%.%vPortFree(pv) \
  vPortFree(pv)
%define! Parpv
%include Common\FreeRTOSvPortFree.Inc

%endif %- vPortFree
%-BW_METHOD_END vPortFree
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTaskGetTickCount
%ifdef xTaskGetTickCount
#define %'ModuleName'%.%xTaskGetTickCount() \
  xTaskGetTickCount()
%define! RetVal
%include Common\FreeRTOSxTaskGetTickCount.Inc

%endif %- xTaskGetTickCount
%-BW_METHOD_END xTaskGetTickCount
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTaskGetSchedulerState
%ifdef xTaskGetSchedulerState
#define %'ModuleName'%.%xTaskGetSchedulerState() \
  xTaskGetSchedulerState()
%define! RetVal
%include Common\FreeRTOSxTaskGetSchedulerState.Inc

%endif %- xTaskGetSchedulerState
%-BW_METHOD_END xTaskGetSchedulerState
%-************************************************************************************************************
%-BW_METHOD_BEGIN uxTaskGetStackHighWaterMark
%ifdef uxTaskGetStackHighWaterMark
#define %'ModuleName'%.%uxTaskGetStackHighWaterMark(xTask) \
  uxTaskGetStackHighWaterMark(xTask)
%define! ParxTask
%define! RetVal
%include Common\FreeRTOSuxTaskGetStackHighWaterMark.Inc

%endif %- uxTaskGetStackHighWaterMark
%-BW_METHOD_END uxTaskGetStackHighWaterMark
%-************************************************************************************************************
%-BW_METHOD_BEGIN uxTaskGetNumberOfTasks
%ifdef uxTaskGetNumberOfTasks
#define %'ModuleName'%.%uxTaskGetNumberOfTasks() \
  uxTaskGetNumberOfTasks()
%define! RetVal
%include Common\FreeRTOSuxTaskGetNumberOfTasks.Inc

%endif %- uxTaskGetNumberOfTasks
%-BW_METHOD_END uxTaskGetNumberOfTasks
%-************************************************************************************************************
%-BW_METHOD_BEGIN vTaskGetRunTimeStats
%ifdef vTaskGetRunTimeStats
#define %'ModuleName'%.%vTaskGetRunTimeStats(pcWriteBuffer, bufSize) \
  vTaskGetRunTimeStats(pcWriteBuffer, bufSize)

%define! ParpcWriteBuffer
%define! ParbufSize
%include Common\FreeRTOSvTaskGetRunTimeStats.Inc

%endif %- vTaskGetRunTimeStats
%-BW_METHOD_END vTaskGetRunTimeStats
%-INHERITED_EVENT_BEGIN RuntimeCntr OnInterrupt
%ifdef RuntimeCntr
%ifdef @RuntimeCntr@OnInterrupt
extern uint32_t %'ModuleName'%.RunTimeCounter; /* runtime counter, used for configGENERATE_RUNTIME_STATS */
void %@RuntimeCntr@OnInterrupt(void);

%endif %- @RuntimeCntr@OnInterrupt
%endif
%-INHERITED_EVENT_END RuntimeCntr OnInterrupt
%-************************************************************************************************************
%-BW_METHOD_BEGIN xPortGetFreeHeapSize
%ifdef xPortGetFreeHeapSize
#define %'ModuleName'%.%xPortGetFreeHeapSize() \
  xPortGetFreeHeapSize()

%define! RetVal
%include Common\FreeRTOSxPortGetFreeHeapSize.Inc

%endif %- xPortGetFreeHeapSize
%-BW_METHOD_END xPortGetFreeHeapSize
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueueCreate
%ifdef xQueueCreate
#define %'ModuleName'%.%xQueueCreate(uxQueueLength, uxItemSize) \
  xQueueCreate(uxQueueLength, uxItemSize)
%define! ParuxQueueLength
%define! ParuxItemSize
%define! RetVal
%include Common\FreeRTOSxQueueCreate.Inc

%endif %- xQueueCreate
%-BW_METHOD_END xQueueCreate
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueueSendToFront
%ifdef xQueueSendToFront
#define %'ModuleName'%.%xQueueSendToFront(xQueue, pvItemToQueue, xTicksToWait) \
  xQueueSendToFront(xQueue, pvItemToQueue, xTicksToWait)
%define! ParxQueue
%define! ParpvItemToQueue
%define! ParxTicksToWait
%define! RetVal
%include Common\FreeRTOSxQueueSendToFront.Inc

%endif %- xQueueSendToFront
%-BW_METHOD_END xQueueSendToFront
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueueSendToBack
%ifdef xQueueSendToBack
#define %'ModuleName'%.%xQueueSendToBack(xQueue, pvItemToQueue, xTicksToWait) \
  xQueueSendToBack(xQueue, pvItemToQueue, xTicksToWait)
%define! ParxQueue
%define! ParpvItemToQueue
%define! ParxTicksToWait
%define! RetVal
%include Common\FreeRTOSxQueueSendToBack.Inc

%endif %- xQueueSendToBack
%-BW_METHOD_END xQueueSendToBack
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueueReceive
%ifdef xQueueReceive
#define %'ModuleName'%.%xQueueReceive(xQueue, pvBuffer, xTicksToWait) \
  xQueueReceive(xQueue, pvBuffer, xTicksToWait)
%define! ParxQueue
%define! ParxTicksToWait
%define! ParpvBuffer
%define! RetVal
%include Common\FreeRTOSxQueueReceive.Inc

%endif %- xQueueReceive
%-BW_METHOD_END xQueueReceive
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueuePeek
%ifdef xQueuePeek
#define %'ModuleName'%.%xQueuePeek(xQueue, pvBuffer, xTicksToWait) \
  xQueuePeek(xQueue, pvBuffer, xTicksToWait)
%define! ParxQueue
%define! ParpvBuffer
%define! ParxTicksToWait
%define! RetVal
%include Common\FreeRTOSxQueuePeek.Inc

%endif %- xQueuePeek
%-BW_METHOD_END xQueuePeek
%-************************************************************************************************************
%-BW_METHOD_BEGIN vQueueDelete
%ifdef vQueueDelete
#define %'ModuleName'%.%vQueueDelete(pxQueueToDelete) \
  vQueueDelete(pxQueueToDelete)
%define! ParpxQueueToDelete
%include Common\FreeRTOSvQueueDelete.Inc

%endif %- vQueueDelete
%-BW_METHOD_END vQueueDelete
%-************************************************************************************************************
%-BW_METHOD_BEGIN uxQueueMessagesWaiting
%ifdef uxQueueMessagesWaiting
#define %'ModuleName'%.%uxQueueMessagesWaiting(xQueue) \
  uxQueueMessagesWaiting(xQueue)
%define! ParxQueue
%define! RetVal
%include Common\FreeRTOSuxQueueMessagesWaiting.Inc

%endif %- uxQueueMessagesWaiting
%-BW_METHOD_END uxQueueMessagesWaiting
%-************************************************************************************************************
%-BW_METHOD_BEGIN uxQueueMessagesWaitingfromISR
%ifdef uxQueueMessagesWaitingfromISR
#define %'ModuleName'%.%uxQueueMessagesWaitingfromISR(xQueue) \
  uxQueueMessagesWaitingfromISR(xQueue)
%define! ParxQueue
%define! RetVal
%include Common\FreeRTOSuxQueueMessagesWaitingfromISR.Inc

%endif %- uxQueueMessagesWaitingfromISR
%-BW_METHOD_END uxQueueMessagesWaitingfromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueueReceiveFromISR
%ifdef xQueueReceiveFromISR
#define %'ModuleName'%.%xQueueReceiveFromISR(xQueue, pvBuffer, pxHigherPriorityTaskWoken) \
  xQueueReceiveFromISR(xQueue, pvBuffer, pxHigherPriorityTaskWoken)
%define! ParxQueue
%define! ParpvBuffer
%define! ParpxHigherPriorityTaskWoken
%define! RetVal
%include Common\FreeRTOSxQueueReceiveFromISR.Inc

%endif %- xQueueReceiveFromISR
%-BW_METHOD_END xQueueReceiveFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueueSendToFrontFromISR
%ifdef xQueueSendToFrontFromISR
#define %'ModuleName'%.%xQueueSendToFrontFromISR(xQueue, pvItemToQueue, pxHigherPriorityTaskWoken) \
  xQueueSendToFrontFromISR(xQueue, pvItemToQueue, pxHigherPriorityTaskWoken)
%define! ParxQueue
%define! ParpvItemToQueue
%define! ParpxHigherPriorityTaskWoken
%define! RetVal
%include Common\FreeRTOSxQueueSendToFrontFromISR.Inc

%endif %- xQueueSendToFrontFromISR
%-BW_METHOD_END xQueueSendToFrontFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueueSendToBackFromISR
%ifdef xQueueSendToBackFromISR
#define %'ModuleName'%.%xQueueSendToBackFromISR(xQueue, pvItemToQueue,pxHigherPriorityTaskWoken) \
  xQueueSendToBackFromISR(xQueue, pvItemToQueue,pxHigherPriorityTaskWoken)
%define! ParxQueue
%define! ParpvItemToQueue
%define! ParpxHigherPriorityTaskWoken
%define! RetVal
%include Common\FreeRTOSxQueueSendToBackFromISR.Inc

%endif %- xQueueSendToBackFromISR
%-BW_METHOD_END xQueueSendToBackFromISR
%-INHERITED_EVENT_BEGIN TickTimerLDD OnCounterRestart
%ifdef TickTimerLDD
%ifdef @TickTimerLDD@OnCounterRestart
void %@TickTimerLDD@OnCounterRestart(LDD_TUserData *UserDataPtr);

%endif %- @TickTimerLDD@OnCounterRestart
%endif %-TickTimerLDD
%-INHERITED_EVENT_END TickTimerLDD OnCounterRestart
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTaskResumeFromISR
%ifdef xTaskResumeFromISR
#define %'ModuleName'%.%xTaskResumeFromISR(pxTaskToResume) \
  xTaskResumeFromISR(pxTaskToResume)

%define! ParpxTaskToResume
%define! RetVal
%include Common\FreeRTOSxTaskResumeFromISR.Inc

%endif %- xTaskResumeFromISR
%-BW_METHOD_END xTaskResumeFromISR
%-************************************************************************************************************
%-INHERITED_EVENT_BEGIN RuntimeCntrLDD OnCounterRestart
%ifdef RuntimeCntrLDD
%ifdef @RuntimeCntrLDD@OnCounterRestart
extern uint32_t %'ModuleName'%.RunTimeCounter; /* runtime counter, used for configGENERATE_RUNTIME_STATS */
extern LDD_TDeviceData *%'ModuleName'%.RunTimeCounterHandle; /* runtime counter handle, used for configGENERATE_RUNTIME_STATS */
void %@RuntimeCntrLDD@OnCounterRestart(LDD_TUserData *UserDataPtr);

%endif %- @RuntimeCntrLDD@OnCounterRestart
%endif
%-INHERITED_EVENT_END RuntimeCntrLDD OnCounterRestart
%-INHERITED_EVENT_BEGIN TickCntr OnInterrupt
%if defined(TickCntr) & defined(@TickCntr@OnInterrupt)
void %@TickCntr@OnInterrupt(void);

%endif %- @TickCntr@OnInterrupt
%-INHERITED_EVENT_END TickCntr OnInterrupt
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueueReset
%ifdef xQueueReset
#define %'ModuleName'%.%xQueueReset(xQueue) \
  xQueueReset(xQueue)

%define! ParxQueue
%define! RetVal
%include Common\FreeRTOSxQueueReset.Inc

%endif %- xQueueReset
%-BW_METHOD_END xQueueReset
%-************************************************************************************************************
%-BW_METHOD_BEGIN xSemaphoreGetMutexHolder
%ifdef xSemaphoreGetMutexHolder
#define %'ModuleName'%.%xSemaphoreGetMutexHolder(xSemaphore) \
  xSemaphoreGetMutexHolder(xSemaphore)

%define! ParxSemaphore
%define! RetVal
%include Common\FreeRTOSxSemaphoreGetMutexHolder.Inc

%endif %- xSemaphoreGetMutexHolder
%-BW_METHOD_END xSemaphoreGetMutexHolder
%-************************************************************************************************************
%-BW_METHOD_BEGIN xSemaphoreTakeFromISR
%ifdef xSemaphoreTakeFromISR
#define %'ModuleName'%.%xSemaphoreTakeFromISR(xSemaphore, pxHigherPriorityTaskWoken) \
  xSemaphoreTakeFromISR(xSemaphore, pxHigherPriorityTaskWoken)

%define! ParxSemaphore
%define! ParpxHigherPriorityTaskWoken
%define! RetVal
%include Common\FreeRTOSxSemaphoreTakeFromISR.Inc

%endif %- xSemaphoreTakeFromISR
%-BW_METHOD_END xSemaphoreTakeFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN ParseCommand
%ifdef ParseCommand
#if configUSE_SHELL
uint8_t %'ModuleName'%.%ParseCommand(const unsigned char *cmd, bool *handled, const %@Shell@'ModuleName'%.StdIOType *io);
%define! Parcmd
%define! Parhandled
%define! Pario
%define! RetVal
%include Common\FreeRTOSParseCommand.Inc
#endif

%endif %- ParseCommand
%-BW_METHOD_END ParseCommand
%-************************************************************************************************************
%-BW_METHOD_BEGIN Init
%ifdef Init
void %'ModuleName'%.%Init(void);
%include Common\FreeRTOSInit.Inc

%endif %- Init
%-BW_METHOD_END Init
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTaskGetApplicationTaskTag
%ifdef xTaskGetApplicationTaskTag
#define %'ModuleName'%.%xTaskGetApplicationTaskTag(xTask) \
  xTaskGetApplicationTaskTag(xTask)
%define! ParxTask
%define! RetVal
%include Common\FreeRTOSxTaskGetApplicationTaskTag.Inc

%endif %- xTaskGetApplicationTaskTag
%-BW_METHOD_END xTaskGetApplicationTaskTag
%-************************************************************************************************************
%-BW_METHOD_BEGIN vTaskSetApplicationTaskTag
%ifdef vTaskSetApplicationTaskTag
#define %'ModuleName'%.%vTaskSetApplicationTaskTag(xTask, pxHookFunction) \
  vTaskSetApplicationTaskTag(xTask, pxHookFunction)
%define! ParxTask
%define! ParpxHookFunction
%define! ParVariable_1
%include Common\FreeRTOSvTaskSetApplicationTaskTag.Inc

%endif %- vTaskSetApplicationTaskTag
%-BW_METHOD_END vTaskSetApplicationTaskTag
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTaskGetCurrentTaskHandle
%ifdef xTaskGetCurrentTaskHandle
#define %'ModuleName'%.%xTaskGetCurrentTaskHandle() \
  xTaskGetCurrentTaskHandle()
%define! RetVal
%include Common\FreeRTOSxTaskGetCurrentTaskHandle.Inc

%endif %- xTaskGetCurrentTaskHandle
%-BW_METHOD_END xTaskGetCurrentTaskHandle
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTaskGetIdleTaskHandle
%ifdef xTaskGetIdleTaskHandle
#define %'ModuleName'%.%xTaskGetIdleTaskHandle() \
  xTaskGetIdleTaskHandle()
%define! RetVal
%include Common\FreeRTOSxTaskGetIdleTaskHandle.Inc

%endif %- xTaskGetIdleTaskHandle
%-BW_METHOD_END xTaskGetIdleTaskHandle
%-************************************************************************************************************
%-BW_METHOD_BEGIN eTaskGetState
%ifdef eTaskGetState
#define %'ModuleName'%.%eTaskGetState(xTask) \
  eTaskGetState(xTask)
%define! ParxTask
%define! RetVal
%include Common\FreeRTOSeTaskGetState.Inc

%endif %- eTaskGetState
%-BW_METHOD_END eTaskGetState
%-************************************************************************************************************
%-BW_METHOD_BEGIN pcTaskGetTaskName
%ifdef pcTaskGetTaskName
#define %'ModuleName'%.%pcTaskGetTaskName(xTaskToQuery) \
  pcTaskGetTaskName(xTaskToQuery)
%define! ParxTaskToQuery
%define! RetVal
%include Common\FreeRTOSpcTaskGetTaskName.Inc

%endif %- pcTaskGetTaskName
%-BW_METHOD_END pcTaskGetTaskName
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTaskGetTickCountFromISR
%ifdef xTaskGetTickCountFromISR
#define %'ModuleName'%.%xTaskGetTickCountFromISR() \
  xTaskGetTickCountFromISR()
%define! RetVal
%include Common\FreeRTOSxTaskGetTickCountFromISR.Inc

%endif %- xTaskGetTickCountFromISR
%-BW_METHOD_END xTaskGetTickCountFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTaskCallApplicationTaskHook
%ifdef xTaskCallApplicationTaskHook
#define %'ModuleName'%.%xTaskCallApplicationTaskHook(xTask, pvParameter) \
  xTaskCallApplicationTaskHook(xTask, pvParameter)
%define! ParxTask
%define! ParpvParameter
%define! RetVal
%include Common\FreeRTOSxTaskCallApplicationTaskHook.Inc

%endif %- xTaskCallApplicationTaskHook
%-BW_METHOD_END xTaskCallApplicationTaskHook
%-************************************************************************************************************
%-BW_METHOD_BEGIN vTaskStepTick
%ifdef vTaskStepTick
#define %'ModuleName'%.%vTaskStepTick(xTicksToJump) \
  vTaskStepTick(xTicksToJump)
%define! ParxTicksToJump
%include Common\FreeRTOSvTaskStepTick.Inc

%endif %- vTaskStepTick
%-BW_METHOD_END vTaskStepTick
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueuePeekFromISR
%ifdef xQueuePeekFromISR
#define %'ModuleName'%.%xQueuePeekFromISR(xQueue, pvBuffer, xTicksToWait) \
  xQueuePeekFromISR(xQueue, pvBuffer, xTicksToWait)
%define! ParxQueue
%define! ParpvBuffer
%define! ParxTicksToWait
%define! RetVal
%include Common\FreeRTOSxQueuePeekFromISR.Inc

%endif %- xQueuePeekFromISR
%-BW_METHOD_END xQueuePeekFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueueOverwrite
%ifdef xQueueOverwrite
#define %'ModuleName'%.%xQueueOverwrite(xQueue, pvItemToQueue) \
  xQueueOverwrite(xQueue, pvItemToQueue)
%define! ParxQueue
%define! ParpvItemToQueue
%define! RetVal
%include Common\FreeRTOSxQueueOverwrite.Inc

%endif %- xQueueOverwrite
%-BW_METHOD_END xQueueOverwrite
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueueOverwriteFromISR
%ifdef xQueueOverwriteFromISR
#define %'ModuleName'%.%xQueueOverwriteFromISR(xQueue, pvItemToQueue, pxHigherPriorityTaskWoken) \
  xQueueOverwriteFromISR(xQueue, pvItemToQueue, pxHigherPriorityTaskWoken)
%define! ParxQueue
%define! ParpvItemToQueue
%define! ParpxHigherPriorityTaskWoken
%define! RetVal
%include Common\FreeRTOSxQueueOverwriteFromISR.Inc

%endif %- xQueueOverwriteFromISR
%-BW_METHOD_END xQueueOverwriteFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN vQueueAddToRegistry
%ifdef vQueueAddToRegistry
#define %'ModuleName'%.%vQueueAddToRegistry(xQueue, pcQueueName) \
  vQueueAddToRegistry(xQueue, pcQueueName)
%define! ParxQueue
%define! ParpcQueueName
%include Common\FreeRTOSvQueueAddToRegistry.Inc

%endif %- vQueueAddToRegistry
%-BW_METHOD_END vQueueAddToRegistry
%-************************************************************************************************************
%-BW_METHOD_BEGIN vQueueUnregisterQueue
%ifdef vQueueUnregisterQueue
#define %'ModuleName'%.%vQueueUnregisterQueue(xQueue) \
  vQueueUnregisterQueue(xQueue)
%define! ParxQueue
%include Common\FreeRTOSvQueueUnregisterQueue.Inc

%endif %- vQueueUnregisterQueue
%-BW_METHOD_END vQueueUnregisterQueue
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueueIsQueueFullFromISR
%ifdef xQueueIsQueueFullFromISR
#define %'ModuleName'%.%xQueueIsQueueFullFromISR(xQueue) \
  xQueueIsQueueFullFromISR(xQueue)
%define! ParxQueue
%define! RetVal
%include Common\FreeRTOSxQueueIsQueueFullFromISR.Inc

%endif %- xQueueIsQueueFullFromISR
%-BW_METHOD_END xQueueIsQueueFullFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueueIsQueueEmptyFromISR
%ifdef xQueueIsQueueEmptyFromISR
#define %'ModuleName'%.%xQueueIsQueueEmptyFromISR(xQueue) \
  xQueueIsQueueEmptyFromISR(xQueue)
%define! ParxQueue
%define! RetVal
%include Common\FreeRTOSxQueueIsQueueEmptyFromISR.Inc

%endif %- xQueueIsQueueEmptyFromISR
%-BW_METHOD_END xQueueIsQueueEmptyFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueueAddToSet
%ifdef xQueueAddToSet
#define %'ModuleName'%.%xQueueAddToSet(xQueueOrSemaphore, xQueueSet) \
  xQueueAddToSet(xQueueOrSemaphore, xQueueSet)
%define! ParxQueueOrSemaphore
%define! ParxQueueSet
%define! RetVal
%include Common\FreeRTOSxQueueAddToSet.Inc

%endif %- xQueueAddToSet
%-BW_METHOD_END xQueueAddToSet
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueueCreateSet
%ifdef xQueueCreateSet
#define %'ModuleName'%.%xQueueCreateSet(uxEventQueueLength) \
  xQueueCreateSet(uxEventQueueLength)
%define! ParuxEventQueueLength
%define! RetVal
%include Common\FreeRTOSxQueueCreateSet.Inc

%endif %- xQueueCreateSet
%-BW_METHOD_END xQueueCreateSet
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueueRemoveFromSet
%ifdef xQueueRemoveFromSet
#define %'ModuleName'%.%xQueueRemoveFromSet(xQueueOrSemaphore, xQueueSet) \
  xQueueRemoveFromSet(xQueueOrSemaphore, xQueueSet)
%define! ParxQueueOrSemaphore
%define! ParxQueueSet
%define! RetVal
%include Common\FreeRTOSxQueueRemoveFromSet.Inc

%endif %- xQueueRemoveFromSet
%-BW_METHOD_END xQueueRemoveFromSet
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueueSelectFromSet
%ifdef xQueueSelectFromSet
#define %'ModuleName'%.%xQueueSelectFromSet(xQueueSet, xBlockTimeTicks) \
  xQueueSelectFromSet(xQueueSet, xBlockTimeTicks)
%define! ParxQueueSet
%define! ParxBlockTimeTicks
%define! RetVal
%include Common\FreeRTOSxQueueSelectFromSet.Inc

%endif %- xQueueSelectFromSet
%-BW_METHOD_END xQueueSelectFromSet
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueueSelectFromSetFromISR
%ifdef xQueueSelectFromSetFromISR
#define %'ModuleName'%.%xQueueSelectFromSetFromISR(xQueueSet) \
  xQueueSelectFromSetFromISR(xQueueSet)
%define! ParxQueueSet
%define! RetVal
%include Common\FreeRTOSxQueueSelectFromSetFromISR.Inc

%endif %- xQueueSelectFromSetFromISR
%-BW_METHOD_END xQueueSelectFromSetFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN xEventGroupCreate
%ifdef xEventGroupCreate
#define %'ModuleName'%.%xEventGroupCreate() \
  xEventGroupCreate()
%define! RetVal
%include Common\FreeRTOSxEventGroupCreate.Inc

%endif %- xEventGroupCreate
%-BW_METHOD_END xEventGroupCreate
%-************************************************************************************************************
%-BW_METHOD_BEGIN xEventGroupWaitBits
%ifdef xEventGroupWaitBits
#define %'ModuleName'%.%xEventGroupWaitBits(xEventGroup, uxBitsToWaitFor, xClearOnExit, xWaitForAllBits, xTicksToWait) \
  xEventGroupWaitBits(xEventGroup, uxBitsToWaitFor, xClearOnExit, xWaitForAllBits, xTicksToWait)
%define! ParxEventGroup
%define! ParuxBitsToWaitFor
%define! ParxClearOnExit
%define! ParxWaitForAllBits
%define! ParxTicksToWait
%define! RetVal
%include Common\FreeRTOSxEventGroupWaitBits.Inc

%endif %- xEventGroupWaitBits
%-BW_METHOD_END xEventGroupWaitBits
%-************************************************************************************************************
%-BW_METHOD_BEGIN xEventGroupSetBits
%ifdef xEventGroupSetBits
#define %'ModuleName'%.%xEventGroupSetBits(xEventGroup, uxBitsToSet) \
  xEventGroupSetBits(xEventGroup, uxBitsToSet)
%define! ParxEventGroup
%define! ParuxBitsToSet
%define! RetVal
%include Common\FreeRTOSxEventGroupSetBits.Inc

%endif %- xEventGroupSetBits
%-BW_METHOD_END xEventGroupSetBits
%-************************************************************************************************************
%-BW_METHOD_BEGIN xEventGroupSetBitsFromISR
%ifdef xEventGroupSetBitsFromISR
#define %'ModuleName'%.%xEventGroupSetBitsFromISR(xEventGroup, uxBitsToSet, pxHigherPriorityTaskWoken) \
  xEventGroupSetBitsFromISR(xEventGroup, uxBitsToSet, pxHigherPriorityTaskWoken)
%define! ParxEventGroup
%define! ParuxBitsToSet
%define! ParpxHigherPriorityTaskWoken
%define! RetVal
%include Common\FreeRTOSxEventGroupSetBitsFromISR.Inc

%endif %- xEventGroupSetBitsFromISR
%-BW_METHOD_END xEventGroupSetBitsFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN xEventGroupClearBits
%ifdef xEventGroupClearBits
#define %'ModuleName'%.%xEventGroupClearBits(xEventGroup, uxBitsToSet) \
  xEventGroupClearBits(xEventGroup, uxBitsToSet)
%define! ParxEventGroup
%define! ParuxBitsToSet
%define! RetVal
%include Common\FreeRTOSxEventGroupClearBits.Inc

%endif %- xEventGroupClearBits
%-BW_METHOD_END xEventGroupClearBits
%-************************************************************************************************************
%-BW_METHOD_BEGIN xEventGroupClearBitsFromISR
%ifdef xEventGroupClearBitsFromISR
#define %'ModuleName'%.%xEventGroupClearBitsFromISR(xEventGroup, uxBitsToSet) \
  xEventGroupClearBitsFromISR(xEventGroup, uxBitsToSet)
%define! ParxEventGroup
%define! ParuxBitsToSet
%define! RetVal
%include Common\FreeRTOSxEventGroupClearBitsFromISR.Inc

%endif %- xEventGroupClearBitsFromISR
%-BW_METHOD_END xEventGroupClearBitsFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN xEventGroupGetBits
%ifdef xEventGroupGetBits
#define %'ModuleName'%.%xEventGroupGetBits(xEventGroup) \
  xEventGroupGetBits(xEventGroup)
%define! ParxEventGroup
%define! RetVal
%include Common\FreeRTOSxEventGroupGetBits.Inc

%endif %- xEventGroupGetBits
%-BW_METHOD_END xEventGroupGetBits
%-************************************************************************************************************
%-BW_METHOD_BEGIN xEventGroupGetBitsFromISR
%ifdef xEventGroupGetBitsFromISR
#define %'ModuleName'%.%xEventGroupGetBitsFromISR(xEventGroup) \
  xEventGroupGetBitsFromISR(xEventGroup)
%define! ParxEventGroup
%define! RetVal
%include Common\FreeRTOSxEventGroupGetBitsFromISR.Inc

%endif %- xEventGroupGetBitsFromISR
%-BW_METHOD_END xEventGroupGetBitsFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN xEventGroupSync
%ifdef xEventGroupSync
#define %'ModuleName'%.%xEventGroupSync(xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTicksToWait) \
  xEventGroupSync(xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTicksToWait)
%define! ParxEventGroup
%define! ParuxBitsToSet
%define! ParuxBitsToWaitFor
%define! ParxTicksToWait
%define! RetVal
%include Common\FreeRTOSxEventGroupSync.Inc

%endif %- xEventGroupSync
%-BW_METHOD_END xEventGroupSync
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTimerCreate
%ifdef xTimerCreate
#define %'ModuleName'%.%xTimerCreate(pcTimerName, xTimerPeriod, uxAutoReload, pvTimerID, pxCallbackFunction) \
  xTimerCreate(pcTimerName, xTimerPeriod, uxAutoReload, pvTimerID, pxCallbackFunction)
%define! ParpcTimerName
%define! ParxTimerPeriod
%define! ParuxAutoReload
%define! ParpvTimerID
%define! ParpxCallbackFunction
%define! RetVal
%include Common\FreeRTOSxTimerCreate.Inc

%endif %- xTimerCreate
%-BW_METHOD_END xTimerCreate
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTimerIsTimerActive
%ifdef xTimerIsTimerActive
#define %'ModuleName'%.%xTimerIsTimerActive(xTimer) \
  xTimerIsTimerActive(xTimer)
%define! ParxTimer
%define! RetVal
%include Common\FreeRTOSxTimerIsTimerActive.Inc

%endif %- xTimerIsTimerActive
%-BW_METHOD_END xTimerIsTimerActive
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTimerStart
%ifdef xTimerStart
#define %'ModuleName'%.%xTimerStart(xTimer, xBlockTime) \
  xTimerStart(xTimer, xBlockTime)
%define! ParxTimer
%define! ParxBlockTime
%define! RetVal
%include Common\FreeRTOSxTimerStart.Inc

%endif %- xTimerStart
%-BW_METHOD_END xTimerStart
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTimerStop
%ifdef xTimerStop
#define %'ModuleName'%.%xTimerStop(xTimer, xBlockTime) \
  xTimerStop(xTimer, xBlockTime)
%define! ParxTimer
%define! ParxBlockTime
%define! RetVal
%include Common\FreeRTOSxTimerStop.Inc

%endif %- xTimerStop
%-BW_METHOD_END xTimerStop
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTimerChangePeriod
%ifdef xTimerChangePeriod
#define %'ModuleName'%.%xTimerChangePeriod(xTimer, xNewPeriod, xBlockTime) \
  xTimerChangePeriod(xTimer, xNewPeriod, xBlockTime)
%define! ParxTimer
%define! ParxNewPeriod
%define! ParxBlockTime
%define! RetVal
%include Common\FreeRTOSxTimerChangePeriod.Inc

%endif %- xTimerChangePeriod
%-BW_METHOD_END xTimerChangePeriod
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTimerDelete
%ifdef xTimerDelete
#define %'ModuleName'%.%xTimerDelete(xTimer, xBlockTime) \
  xTimerDelete(xTimer, xBlockTime)
%define! ParxTimer
%define! ParxBlockTime
%define! RetVal
%include Common\FreeRTOSxTimerDelete.Inc

%endif %- xTimerDelete
%-BW_METHOD_END xTimerDelete
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTimerReset
%ifdef xTimerReset
#define %'ModuleName'%.%xTimerReset(xTimer, xBlockTime) \
  xTimerReset(xTimer, xBlockTime)
%define! ParxTimer
%define! ParxBlockTime
%define! RetVal
%include Common\FreeRTOSxTimerReset.Inc

%endif %- xTimerReset
%-BW_METHOD_END xTimerReset
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTimerStartFromISR
%ifdef xTimerStartFromISR
#define %'ModuleName'%.%xTimerStartFromISR(xTimer, pxHigherPriorityTaskWoken) \
  xTimerStartFromISR(xTimer, pxHigherPriorityTaskWoken)
%define! ParxTimer
%define! ParpxHigherPriorityTaskWoken
%define! RetVal
%include Common\FreeRTOSxTimerStartFromISR.Inc

%endif %- xTimerStartFromISR
%-BW_METHOD_END xTimerStartFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTimerStopFromISR
%ifdef xTimerStopFromISR
#define %'ModuleName'%.%xTimerStopFromISR(xTimer, pxHigherPriorityTaskWoken) \
  xTimerStopFromISR(xTimer, pxHigherPriorityTaskWoken)
%define! ParpxHigherPriorityTaskWoken
%define! ParxTimer
%define! RetVal
%include Common\FreeRTOSxTimerStopFromISR.Inc

%endif %- xTimerStopFromISR
%-BW_METHOD_END xTimerStopFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTimerChangePeriodFromISR
%ifdef xTimerChangePeriodFromISR
#define %'ModuleName'%.%xTimerChangePeriodFromISR(xTimer, xNewPeriod, pxHigherPriorityTaskWoken) \
  xTimerChangePeriodFromISR(xTimer, xNewPeriod, pxHigherPriorityTaskWoken)
%define! ParxTimer
%define! ParxNewPeriod
%define! ParpxHigherPriorityTaskWoken
%define! RetVal
%include Common\FreeRTOSxTimerChangePeriodFromISR.Inc

%endif %- xTimerChangePeriodFromISR
%-BW_METHOD_END xTimerChangePeriodFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTimerResetFromISR
%ifdef xTimerResetFromISR
#define %'ModuleName'%.%xTimerResetFromISR(xTimer, pxHigherPriorityTaskWoken) \
  xTimerResetFromISR(xTimer, pxHigherPriorityTaskWoken)
%define! ParxTimer
%define! ParpxHigherPriorityTaskWoken
%define! RetVal
%include Common\FreeRTOSxTimerResetFromISR.Inc

%endif %- xTimerResetFromISR
%-BW_METHOD_END xTimerResetFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN pvTimerGetTimerID
%ifdef pvTimerGetTimerID
#define %'ModuleName'%.%pvTimerGetTimerID(xTimer) \
  pvTimerGetTimerID(xTimer)
%define! ParxTimer
%define! RetVal
%include Common\FreeRTOSpvTimerGetTimerID.Inc

%endif %- pvTimerGetTimerID
%-BW_METHOD_END pvTimerGetTimerID
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTimerGetTimerDaemonTaskHandle
%ifdef xTimerGetTimerDaemonTaskHandle
#define %'ModuleName'%.%xTimerGetTimerDaemonTaskHandle() \
  xTimerGetTimerDaemonTaskHandle()
%define! RetVal
%include Common\FreeRTOSxTimerGetTimerDaemonTaskHandle.Inc

%endif %- xTimerGetTimerDaemonTaskHandle
%-BW_METHOD_END xTimerGetTimerDaemonTaskHandle
%-************************************************************************************************************
%-BW_METHOD_BEGIN pcTimerGetTimerName
%ifdef pcTimerGetTimerName
#define %'ModuleName'%.%pcTimerGetTimerName(xTimer) \
  pcTimerGetTimerName(xTimer)
%define! ParxTimer
%define! RetVal
%include Common\FreeRTOSpcTimerGetTimerName.Inc

%endif %- pcTimerGetTimerName
%-BW_METHOD_END pcTimerGetTimerName
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTimerPendFunctionCall
%ifdef xTimerPendFunctionCall
#define %'ModuleName'%.%xTimerPendFunctionCall(xFunctionToPend, pvParameter1, ulParameter2, xTicksToWait) \
  xTimerPendFunctionCall(xFunctionToPend, pvParameter1, ulParameter2, xTicksToWait)
%define! ParxFunctionToPend
%define! ParpvParameter1
%define! ParulParameter2
%define! ParxTicksToWait
%define! RetVal
%include Common\FreeRTOSxTimerPendFunctionCall.Inc

%endif %- xTimerPendFunctionCall
%-BW_METHOD_END xTimerPendFunctionCall
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTimerPendFunctionCallFromISR
%ifdef xTimerPendFunctionCallFromISR
#define %'ModuleName'%.%xTimerPendFunctionCallFromISR(xFunctionToPend, pvParameter1, ulParameter2, pxHigherPriorityTaskWoken) \
  xTimerPendFunctionCallFromISR(xFunctionToPend, pvParameter1, ulParameter2, pxHigherPriorityTaskWoken)
%define! ParxFunctionToPend
%define! ParpvParameter1
%define! ParulParameter2
%define! ParpxHigherPriorityTaskWoken
%define! RetVal
%include Common\FreeRTOSxTimerPendFunctionCallFromISR.Inc

%endif %- xTimerPendFunctionCallFromISR
%-BW_METHOD_END xTimerPendFunctionCallFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTaskNotifyGive
%ifdef xTaskNotifyGive
#define %'ModuleName'%.%xTaskNotifyGive(xTaskToNotify) \
  xTaskNotifyGive(xTaskToNotify) \
%define! ParxTaskToNotify
%define! RetVal
%include Common\FreeRTOSxTaskNotifyGive.Inc

%endif %- xTaskNotifyGive
%-BW_METHOD_END xTaskNotifyGive
%-************************************************************************************************************
%-BW_METHOD_BEGIN ulTaskNotifyTake
%ifdef ulTaskNotifyTake
#define %'ModuleName'%.%ulTaskNotifyTake(xClearCountOnExit, xTicksToWait) \
  ulTaskNotifyTake(xClearCountOnExit, xTicksToWait)
%define! ParxClearCountOnExit
%define! ParxTicksToWait
%define! RetVal
%include Common\FreeRTOSulTaskNotifyTake.Inc

%endif %- ulTaskNotifyTake
%-BW_METHOD_END ulTaskNotifyTake
%-************************************************************************************************************
%-BW_METHOD_BEGIN vTaskNotifyGiveFromISR
%ifdef vTaskNotifyGiveFromISR
#define %'ModuleName'%.%vTaskNotifyGiveFromISR(xTaskToNotify, pxHigherPriorityTaskWoken) \
  vTaskNotifyGiveFromISR(xTaskToNotify, pxHigherPriorityTaskWoken)
%define! ParxTaskToNotify
%define! ParpxHigherPriorityTaskWoken
%include Common\FreeRTOSvTaskNotifyGiveFromISR.Inc

%endif %- vTaskNotifyGiveFromISR
%-BW_METHOD_END vTaskNotifyGiveFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTaskNotify
%ifdef xTaskNotify
#define %'ModuleName'%.%xTaskNotify(xTaskToNotify, ulValue, eAction) \
  xTaskNotify(xTaskToNotify, ulValue, eAction)
%define! ParxTaskToNotify
%define! ParulValue
%define! PareAction
%define! RetVal
%include Common\FreeRTOSxTaskNotify.Inc

%endif %- xTaskNotify
%-BW_METHOD_END xTaskNotify
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTaskNotifyFromISR
%ifdef xTaskNotifyFromISR
#define %'ModuleName'%.%xTaskNotifyFromISR(xTaskToNotify, ulValue, eAction, pxHigherPriorityTaskWoken) \
  xTaskNotifyFromISR(xTaskToNotify, ulValue, eAction, pxHigherPriorityTaskWoken)
%define! ParxTaskToNotify
%define! ParulValue
%define! PareAction
%define! ParpxHigherPriorityTaskWoken
%define! RetVal
%include Common\FreeRTOSxTaskNotifyFromISR.Inc

%endif %- xTaskNotifyFromISR
%-BW_METHOD_END xTaskNotifyFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTaskNotifyWait
%ifdef xTaskNotifyWait
#define %'ModuleName'%.%xTaskNotifyWait(ulBitsToClearOnEntry, ulBitsToClearOnExit, pulNotificationValue, xTicksToWait) \
  xTaskNotifyWait(ulBitsToClearOnEntry, ulBitsToClearOnExit, pulNotificationValue, xTicksToWait)
%define! ParulBitsToClearOnEntry
%define! ParulBitsToClearOnExit
%define! ParpulNotificationValue
%define! ParxTicksToWait
%define! RetVal
%include Common\FreeRTOSxTaskNotifyWait.Inc

%endif %- xTaskNotifyWait
%-BW_METHOD_END xTaskNotifyWait
%-************************************************************************************************************
%-BW_METHOD_BEGIN vTaskSetThreadLocalStoragePointer
%ifdef vTaskSetThreadLocalStoragePointer
#define %'ModuleName'%.%vTaskSetThreadLocalStoragePointer(xTaskToSet, xIndex, pvValue) \
  vTaskSetThreadLocalStoragePointer(xTaskToSet, xIndex, pvValue)
%define! ParxTaskToSet
%define! ParxIndex
%define! ParpvValue
%include Common\FreeRTOSvTaskSetThreadLocalStoragePointer.Inc

%endif %- vTaskSetThreadLocalStoragePointer
%-BW_METHOD_END vTaskSetThreadLocalStoragePointer
%-************************************************************************************************************
%-BW_METHOD_BEGIN pvTaskGetThreadLocalStoragePointer
%ifdef pvTaskGetThreadLocalStoragePointer
#define %'ModuleName'%.%pvTaskGetThreadLocalStoragePointer(xTaskToQuery, xIndex) \
  pvTaskGetThreadLocalStoragePointer(xTaskToQuery, xIndex)
%define! ParxTaskToQuery
%define! ParxIndex
%define! RetVal
%include Common\FreeRTOSpvTaskGetThreadLocalStoragePointer.Inc

%endif %- pvTaskGetThreadLocalStoragePointer
%-BW_METHOD_END pvTaskGetThreadLocalStoragePointer
%-************************************************************************************************************
%-BW_METHOD_BEGIN xSemaphoreCreateBinary
%ifdef xSemaphoreCreateBinary
#define %'ModuleName'%.%xSemaphoreCreateBinary() \
  xSemaphoreCreateBinary()
%define! RetVal
%include Common\FreeRTOSxSemaphoreCreateBinary.Inc

%endif %- xSemaphoreCreateBinary
%-BW_METHOD_END xSemaphoreCreateBinary
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTaskNotifyAndQuery
%ifdef xTaskNotifyAndQuery
#define %'ModuleName'%.%xTaskNotifyAndQuery(xTaskToNotify, ulValue, eAction, pulPreviousNotifyValue) \
  xTaskNotifyAndQuery(xTaskToNotify, ulValue, eAction, pulPreviousNotifyValue)
%define! ParxTaskToNotify
%define! ParulValue
%define! PareAction
%define! ParpulPreviousNotifyValue
%define! RetVal
%include Common\FreeRTOSxTaskNotifyAndQuery.Inc

%endif %- xTaskNotifyAndQuery
%-BW_METHOD_END xTaskNotifyAndQuery
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTaskNotifyAndQueryFromISR
%ifdef xTaskNotifyAndQueryFromISR
#define %'ModuleName'%.%xTaskNotifyAndQueryFromISR(xTaskToNotify, ulValue, eAction, pulPreviousNotifyValue, pxHigherPriorityTaskWoken) \
  xTaskNotifyAndQueryFromISR(xTaskToNotify, ulValue, eAction, pulPreviousNotifyValue, pxHigherPriorityTaskWoken)
%define! ParxTaskToNotify
%define! ParulValue
%define! PareAction
%define! ParpulPreviousNotifyValue
%define! ParpxHigherPriorityTaskWoken
%define! RetVal
%include Common\FreeRTOSxTaskNotifyAndQueryFromISR.Inc

%endif %- xTaskNotifyAndQueryFromISR
%-BW_METHOD_END xTaskNotifyAndQueryFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTaskNotifyStateClear
%ifdef xTaskNotifyStateClear
#define %'ModuleName'%.%xTaskNotifyStateClear(xTask) \
  xTaskNotifyStateClear(xTask)
%define! ParxTask
%define! RetVal
%include Common\FreeRTOSxTaskNotifyStateClear.Inc

%endif %- xTaskNotifyStateClear
%-BW_METHOD_END xTaskNotifyStateClear
%-************************************************************************************************************
%-BW_METHOD_BEGIN Deinit
%ifdef Deinit
void %'ModuleName'%.%Deinit(void);
%include Common\FreeRTOSDeinit.Inc

%endif %- Deinit
%-BW_METHOD_END Deinit
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTaskGetHandle
%ifdef xTaskGetHandle
#define %'ModuleName'%.%xTaskGetHandle(pcNameToQuery) \
  xTaskGetHandle(pcNameToQuery)

%define! ParpcNameToQuery
%define! RetVal
%include Common\FreeRTOSxTaskGetHandle.Inc

%endif %- xTaskGetHandle
%-BW_METHOD_END xTaskGetHandle
%-************************************************************************************************************
%-BW_METHOD_BEGIN pcTaskGetName
%ifdef pcTaskGetName
#define %'ModuleName'%.%pcTaskGetName(xTaskToQuery) \
  pcTaskGetName(xTaskToQuery)

%define! ParxTaskToQuery
%define! RetVal
%include Common\FreeRTOSpcTaskGetName.Inc

%endif %- pcTaskGetName
%-BW_METHOD_END pcTaskGetName
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTaskCreateStatic
%ifdef xTaskCreateStatic
#define %'ModuleName'%.%xTaskCreateStatic(pvTaskCode, pcName, usStackDepth, pvParameters, uxPriority, puxStackBuffer, pxTaskBuffer) \
  xTaskCreateStatic(pvTaskCode, pcName, usStackDepth, pvParameters, uxPriority, puxStackBuffer, pxTaskBuffer)

%define! ParpvTaskCode
%define! ParpcName
%define! ParusStackDepth
%define! ParpvParameters
%define! ParuxPriority
%define! ParpuxStackBuffer
%define! ParpxTaskBuffer
%define! RetVal
%include Common\FreeRTOSxTaskCreateStatic.Inc

%endif %- xTaskCreateStatic
%-BW_METHOD_END xTaskCreateStatic
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueueCreateStatic
%ifdef xQueueCreateStatic
#define %'ModuleName'%.%xQueueCreateStatic(uxQueueLength, uxItemSize, pucQueueStorageBuffer, pxQueueBuffer) \
  xQueueCreateStatic(uxQueueLength, uxItemSize, pucQueueStorageBuffer, pxQueueBuffer)

%define! ParuxQueueLength
%define! ParuxItemSize
%define! ParpucQueueStorageBuffer
%define! ParpxQueueBuffer
%define! RetVal
%include Common\FreeRTOSxQueueCreateStatic.Inc

%endif %- xQueueCreateStatic
%-BW_METHOD_END xQueueCreateStatic
%-************************************************************************************************************
%-BW_METHOD_BEGIN xEventGroupCreateStatic
%ifdef xEventGroupCreateStatic
#define %'ModuleName'%.%xEventGroupCreateStatic(pxEventGroupBuffer) \
  xEventGroupCreateStatic(pxEventGroupBuffer)

%define! ParpxEventGroupBuffer
%define! RetVal
%include Common\FreeRTOSxEventGroupCreateStatic.Inc

%endif %- xEventGroupCreateStatic
%-BW_METHOD_END xEventGroupCreateStatic
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTimerCreateStatic
%ifdef xTimerCreateStatic
#define %'ModuleName'%.%xTimerCreateStatic(pcTimerName, xTimerPeriod, uxAutoReload, pvTimerID, pxCallbackFunction, pxTimerBuffer) \
  xTimerCreateStatic(pcTimerName, xTimerPeriod, uxAutoReload, pvTimerID, pxCallbackFunction, pxTimerBuffer)

%define! ParpcTimerName
%define! ParxTimerPeriod
%define! ParuxAutoReload
%define! ParpvTimerID
%define! ParpxCallbackFunction
%define! ParpxTimerBuffer
%define! RetVal
%include Common\FreeRTOSxTimerCreateStatic.Inc

%endif %- xTimerCreateStatic
%-BW_METHOD_END xTimerCreateStatic
%-************************************************************************************************************
%-BW_METHOD_BEGIN xSemaphoreCreateBinaryStatic
%ifdef xSemaphoreCreateBinaryStatic
#define %'ModuleName'%.%xSemaphoreCreateBinaryStatic(pxSemaphoreBuffer) \
  xSemaphoreCreateBinaryStatic(pxSemaphoreBuffer)

%define! ParpxSemaphoreBuffer
%define! RetVal
%include Common\FreeRTOSxSemaphoreCreateBinaryStatic.Inc

%endif %- xSemaphoreCreateBinaryStatic
%-BW_METHOD_END xSemaphoreCreateBinaryStatic
%-************************************************************************************************************
%-BW_METHOD_BEGIN xSemaphoreCreateCountingStatic
%ifdef xSemaphoreCreateCountingStatic
#define %'ModuleName'%.%xSemaphoreCreateCountingStatic(uxMaxCount, uxInitialCount, pxSempahoreBuffer) \
  xSemaphoreCreateCountingStatic(uxMaxCount, uxInitialCount, pxSempahoreBuffer)
%define! ParuxMaxCount
%define! ParuxInitialCount
%define! ParpxSempahoreBuffer
%define! RetVal
%include Common\FreeRTOSxSemaphoreCreateCountingStatic.Inc

%endif %- xSemaphoreCreateCountingStatic
%-BW_METHOD_END xSemaphoreCreateCountingStatic
%-************************************************************************************************************
%-BW_METHOD_BEGIN xSemaphoreCreateMutexStatic
%ifdef xSemaphoreCreateMutexStatic
#define %'ModuleName'%.%xSemaphoreCreateMutexStatic(pxMutexBuffer) \
  xSemaphoreCreateMutexStatic(pxMutexBuffer)

%define! ParVariable_1
%define! RetVal
%include Common\FreeRTOSxSemaphoreCreateMutexStatic.Inc

%endif %- xSemaphoreCreateMutexStatic
%-BW_METHOD_END xSemaphoreCreateMutexStatic
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTaskAbortDelay
%ifdef xTaskAbortDelay
#define %'ModuleName'%.%xTaskAbortDelay(xTask) \
  xTaskAbortDelay(xTask)

%define! ParxTask
%define! RetVal
%include Common\FreeRTOSxTaskAbortDelay.Inc

%endif %- xTaskAbortDelay
%-BW_METHOD_END xTaskAbortDelay
%-************************************************************************************************************
%-BW_METHOD_BEGIN vTaskGetInfo
%ifdef vTaskGetInfo
#define %'ModuleName'%.%vTaskGetInfo(xTask, pxTaskStatus, xGetFreeStackSpace, eState) \
  vTaskGetInfo(xTask, pxTaskStatus, xGetFreeStackSpace, eState)
%define! ParxTask
%define! ParpxTaskStatus
%define! ParxGetFreeStackSpace
%define! PareState
%include Common\FreeRTOSvTaskGetInfo.Inc

%endif %- vTaskGetInfo
%-BW_METHOD_END vTaskGetInfo
%-************************************************************************************************************
%-BW_METHOD_BEGIN uxSemaphoreGetCount
%ifdef uxSemaphoreGetCount
#define %'ModuleName'%.%uxSemaphoreGetCount(xSemaphore) \
  uxSemaphoreGetCount(xSemaphore)
%define! ParxSemaphore
%define! RetVal
%include Common\FreeRTOSuxSemaphoreGetCount.Inc

%endif %- uxSemaphoreGetCount
%-BW_METHOD_END uxSemaphoreGetCount
%-************************************************************************************************************
%-BW_METHOD_BEGIN xSemaphoreCreateRecursiveMutexStatic
%ifdef xSemaphoreCreateRecursiveMutexStatic
#define %'ModuleName'%.%xSemaphoreCreateRecursiveMutexStatic(pxMutexBuffer) \
  xSemaphoreCreateRecursiveMutexStatic(pxMutexBuffer)
%define! ParVariable_1
%define! RetVal
%include Common\FreeRTOSxSemaphoreCreateRecursiveMutexStatic.Inc

%endif %- xSemaphoreCreateRecursiveMutexStatic
%-BW_METHOD_END xSemaphoreCreateRecursiveMutexStatic
%-************************************************************************************************************
%-BW_METHOD_BEGIN AppConfigureTimerForRuntimeStats
%ifdef AppConfigureTimerForRuntimeStats
void %'ModuleName'%.%AppConfigureTimerForRuntimeStats(void);
%include Common\FreeRTOSAppConfigureTimerForRuntimeStats.Inc

%endif %- AppConfigureTimerForRuntimeStats
%-BW_METHOD_END AppConfigureTimerForRuntimeStats
%-************************************************************************************************************
%-BW_METHOD_BEGIN AppGetRuntimeCounterValueFromISR
%ifdef AppGetRuntimeCounterValueFromISR
uint32_t %'ModuleName'%.%AppGetRuntimeCounterValueFromISR(void);
%define! RetVal
%include Common\FreeRTOSAppGetRuntimeCounterValueFromISR.Inc

%endif %- AppGetRuntimeCounterValueFromISR
%-BW_METHOD_END AppGetRuntimeCounterValueFromISR
%-BW_DEFINITION_END
/* END %ModuleName. */

#ifdef __cplusplus
}  /* extern "C" */
#endif

#endif /* %@KinetisSDK@'ModuleName'%.CONFIG_SDK_USE_FREERTOS */

#endif
/* ifndef __%'ModuleName'_H */
%include Common\Header.End
%-
%-BW_EVENT_DEFINITION_START
%-BW_METHOD_BEGIN vApplicationStackOverflowHook
%ifdef vApplicationStackOverflowHook
%INTERFACE vApplicationStackOverflowHook
%-STARTUSERTYPES - Do not make changes between lines (included this lines) marked with %-STARTUSERTYPES and %-ENDUSRTYPES

#ifndef __BWUserType_Tsize_t
#define __BWUserType_Tsize_t
  typedef size_t Tsize_t;                                        %>40/* Alias to size_t standard type */
#endif

%-ENDUSRTYPES

void %vApplicationStackOverflowHook(TaskHandle_t pxTask, char *pcTaskName);
%define! ParpxTask
%define! ParpcTaskName
%include Common\FreeRTOSvApplicationStackOverflowHook.Inc

%endif %- vApplicationStackOverflowHook
%-BW_METHOD_END vApplicationStackOverflowHook
%-BW_METHOD_BEGIN vApplicationTickHook
%ifdef vApplicationTickHook
%INTERFACE vApplicationTickHook
void %vApplicationTickHook(void);
%include Common\FreeRTOSvApplicationTickHook.Inc

%endif %- vApplicationTickHook
%-BW_METHOD_END vApplicationTickHook
%-BW_METHOD_BEGIN vApplicationIdleHook
%ifdef vApplicationIdleHook
%INTERFACE vApplicationIdleHook
void %vApplicationIdleHook(void);
%include Common\FreeRTOSvApplicationIdleHook.Inc

%endif %- vApplicationIdleHook
%-BW_METHOD_END vApplicationIdleHook
%-BW_METHOD_BEGIN vApplicationMallocFailedHook
%ifdef vApplicationMallocFailedHook
%INTERFACE vApplicationMallocFailedHook
void %vApplicationMallocFailedHook(void);
%include Common\FreeRTOSvApplicationMallocFailedHook.Inc

%endif %- vApplicationMallocFailedHook
%-BW_METHOD_END vApplicationMallocFailedHook
%-BW_METHOD_BEGIN vOnPostSleepProcessing
%ifdef vOnPostSleepProcessing
%INTERFACE vOnPostSleepProcessing
void %vOnPostSleepProcessing(TickType_t expectedIdleTicks);
%define! ParexpectedIdleTicks
%include Common\FreeRTOSvOnPostSleepProcessing.Inc

%endif %- vOnPostSleepProcessing
%-BW_METHOD_END vOnPostSleepProcessing
%-BW_METHOD_BEGIN vOnPreSleepProcessing
%ifdef vOnPreSleepProcessing
%INTERFACE vOnPreSleepProcessing
void %vOnPreSleepProcessing(TickType_t expectedIdleTicks);
%define! ParexpectedIdleTicks
%include Common\FreeRTOSvOnPreSleepProcessing.Inc

%endif %- vOnPreSleepProcessing
%-BW_METHOD_END vOnPreSleepProcessing
%-BW_EVENT_DEFINITION_END
%IMPLEMENTATION
%define! Settings Common\FreeRTOSSettings.Inc
%define! Abstract Common\FreeRTOSAbstract.Inc
%include Common\Header.C

/* MODULE %ModuleName. */
%- #include "%'ModuleName'.h"
#include "%'RtosComponentHeaderFileName'"
#if %@KinetisSDK@'ModuleName'%.CONFIG_SDK_USE_FREERTOS

#if !%@KinetisSDK@'ModuleName'%.CONFIG_CPU_IS_ESP32
  #include "portTicks.h"                                         %>40/* interface to tick counter */
#endif
%if defined(RuntimeCntrLDD)
#include "%@RuntimeCntrLDD@ModuleName.h" /* Interface to LDD Counter Interrupt */
%endif
#if configSYSTICK_USE_LOW_POWER_TIMER && %@KinetisSDK@'ModuleName'%.CONFIG_NXP_SDK_USED
  #include "fsl_clock.h"
#endif
%-BW_CUSTOM_INCLUDE_START_M
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%-BW_CUSTOM_INCLUDE_END_M
%if defined(Utility)
#include "%@Utility@ModuleName.h"
%else
#include "McuUtility.h"
%endif
%-BW_CUSTOM_VARIABLE_START
%- Write your static variables here
%-   Example:
%-     static int counter1;
%-     int %'ModuleName'%.counter2;
%-
#if configHEAP_SCHEME_IDENTIFICATION
  /* special variable identifying the used heap scheme */
  const uint8_t freeRTOSMemoryScheme = configUSE_HEAP_SCHEME;
#endif

%if defined(defaultvApplicationGetIdleTaskMemory) & defaultvApplicationGetIdleTaskMemory='yes'
#if configSUPPORT_STATIC_ALLOCATION
/* static memory allocation for the IDLE task */
#if configUSE_HEAP_SECTION_NAME && configCOMPILER==configCOMPILER_ARM_GCC
  #define SECTION __attribute__((section (configHEAP_SECTION_NAME_STRING)))
#else
  #define SECTION /* empty */
#endif
static StaticTask_t SECTION xIdleTaskTCBBuffer;
static StackType_t SECTION xIdleStack[configMINIMAL_STACK_SIZE];

void vApplicationGetIdleTaskMemory(StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize) {
  *ppxIdleTaskTCBBuffer = &xIdleTaskTCBBuffer;
  *ppxIdleTaskStackBuffer = &xIdleStack[0];
  *pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;
}
#endif

%endif %- defaultvApplicationGetIdleTaskMemory
%if defined(defaultvApplicationGetTimerTaskMemory) & defaultvApplicationGetTimerTaskMemory='yes'
#if configSUPPORT_STATIC_ALLOCATION && configUSE_TIMERS
/* static memory allocation for the Timer task */
static StaticTask_t SECTION xTimerTaskTCBBuffer;
static StackType_t SECTION xTimerStack[configTIMER_TASK_STACK_DEPTH];

/* If static allocation is supported then the application must provide the
   following callback function - which enables the application to optionally
   provide the memory that will be used by the timer task as the task's stack
   and TCB. */
void vApplicationGetTimerTaskMemory(StaticTask_t **ppxTimerTaskTCBBuffer, StackType_t **ppxTimerTaskStackBuffer, uint32_t *pulTimerTaskStackSize) {
  *ppxTimerTaskTCBBuffer = &xTimerTaskTCBBuffer;
  *ppxTimerTaskStackBuffer = &xTimerStack[0];
  *pulTimerTaskStackSize = configTIMER_TASK_STACK_DEPTH;
}
#endif

%endif %- defaultvApplicationGetTimerTaskMemory
%if (%CPUfamily = "Kinetis") & (%Compiler = "CodeWarriorARM")
/* The Freescale Kinetis compiler generates different code for the PendSV and PendSVC interrupt handlers in Events.c.
   This requires that different code needs to be used for xPortPendSVHandler() and vPortSVCHandler(). */
#if defined(__optlevel0) || defined(__optlevel1) || defined(__optlevel2) || defined(__optlevel3) || defined(__optlevel4)
  /* Starting with MCU10.2 release, the Kinetis compiler offers the above macros to indicate the optimization level,
     so let's check if we are using the right settings in the FreeRTOS component as well... */
%if %CompilerOptimizationLevel='0'
  #if !defined(__optlevel0) /* FreeRTOS Processor Expert component has set optimization level 0, but compiler has something different? */
%elif %CompilerOptimizationLevel='1'
  #if !defined(__optlevel1) /* FreeRTOS Processor Expert component has set optimization level 1, but compiler has something different? */
%elif %CompilerOptimizationLevel='2'
  #if !defined(__optlevel2) /* FreeRTOS Processor Expert component has set optimization level 2, but compiler has something different? */
%elif %CompilerOptimizationLevel='3'
  #if !defined(__optlevel3) /* FreeRTOS Processor Expert component has set optimization level 3, but compiler has something different? */
%elif %CompilerOptimizationLevel='4'
  #if !defined(__optlevel4) /* FreeRTOS Processor Expert component has set optimization level 4, but compiler has something different? */
%endif
    #error "Mismatch between compiler optimization level and FreeRTOS Processor Expert settings! Please check your compiler and component settings."
  #endif
#endif

%endif
%- NOTE: cannot OR the following two define: MCU6.3 will report an internal error
%if defined(RuntimeCntr) & defined(@RuntimeCntr@OnInterrupt)
uint32_t %'ModuleName'%.RunTimeCounter; /* runtime counter, used for configGENERATE_RUNTIME_STATS */
%elif defined(RuntimeCntrLDD) & defined(@RuntimeCntrLDD@OnCounterRestart)
uint32_t %'ModuleName'%.RunTimeCounter; /* runtime counter, used for configGENERATE_RUNTIME_STATS */
LDD_TDeviceData *%'ModuleName'%.RunTimeCounterHandle; /* runtime counter handle, used for configGENERATE_RUNTIME_STATS */
%endif

#if (configUSE_TOP_USED_PRIORITY || configLTO_HELPER) && !%@KinetisSDK@'ModuleName'%.CONFIG_CPU_IS_ESP32
  /* This is only really needed for debugging with openOCD:
   * Since at least FreeRTOS V7.5.3 uxTopUsedPriority is no longer
   * present in the kernel, so it has to be supplied by other means for
   * OpenOCD's threads awareness.
   *
   * Add this file to your project, and, if you're using --gc-sections,
   * ``--undefined=uxTopUsedPriority'' (or
   * ``-Wl,--undefined=uxTopUsedPriority'' when using gcc for final
   * linking) to your LDFLAGS; same with all the other symbols you need.
   */
#if 0 /* FreeRTOS V10.5.1 has it re-added to the kernel */
  const int
  #ifdef __GNUC__
  __attribute__((used))
  #endif
  uxTopUsedPriority = configMAX_PRIORITIES-1;
#endif
#endif

%if defined(Shell)
#if configUSE_SHELL
static uint8_t PrintTaskList(const %@Shell@'ModuleName'%.StdIOType *io) {
#if tskKERNEL_VERSION_MAJOR>=10 && !%@KinetisSDK@'ModuleName'%.CONFIG_CPU_IS_ESP32
  #define SHELL_MAX_NOF_TASKS %ShellMaxNofTasks /* maximum number of tasks, as specified in the properties */
  UBaseType_t nofTasks, i;
  TaskHandle_t taskHandles[SHELL_MAX_NOF_TASKS];
  StackType_t *stackBeg, *stackEnd, *topOfStack;
  uint8_t staticallyAllocated;
  uint8_t tmpBuf[32];
  uint16_t stackSize;
#endif
#if configUSE_TRACE_FACILITY && !((tskKERNEL_VERSION_MAJOR<10) || %@KinetisSDK@'ModuleName'%.CONFIG_CPU_IS_ESP32)
  TaskStatus_t taskStatus;
#endif
  uint8_t buf[32];
  uint8_t res;
#if configGENERATE_RUN_TIME_STATS
  uint32_t ulTotalTime;
#endif
#if configUSE_TRACE_FACILITY
  #define PAD_STAT_TASK_TCB             (sizeof("TCB ")-1)
#endif
  #define PAD_STAT_TASK_STATIC          (sizeof("yes(2) ")-1)
  #define PAD_STAT_TASK_HANDLE          (sizeof("0x20000398 ")-1)
  #define PAD_STAT_TASK_NAME            (configMAX_TASK_NAME_LEN+1)
#if configUSE_TRACE_FACILITY
  #define PAD_STAT_TASK_STATE           (sizeof("Suspended")-1)
#endif
#if configUSE_TRACE_FACILITY
  #define PAD_STAT_TASK_PRIO            (sizeof("(10,12) ")-1)
#else
  #define PAD_STAT_TASK_PRIO            (sizeof("Prio ")-1)
#endif
  #define PAD_STAT_TASK_STACK_BEG       (sizeof("0x20000398 ")-1)
  #define PAD_STAT_TASK_STACK_END       (sizeof("0x20000398 ")-1)
  #define PAD_STAT_TASK_STACK_SIZE      (sizeof("12000 B ")-1)
  #define PAD_STAT_TASK_STACK_TOP       (sizeof("0x200006FC (  132 B) ")-1)
#if configUSE_TRACE_FACILITY
  #define PAD_STAT_TASK_STACK_MARK      (sizeof("12345 B ")-1)
#endif
#if configGENERATE_RUN_TIME_STATS
  #define PAD_STAT_TASK_RUNTIME         (sizeof("0x20000398 (100%%)")-1)
#endif

  res = ERR_OK;
#if !configUSE_TRACE_FACILITY
  %@Shell@'ModuleName'%.SendStr((uint8_t*)"Info: Enable configUSE_TRACE_FACILITY for additional task information.\r\n", io->stdOut);
#endif
#if !configGENERATE_RUN_TIME_STATS
  %@Shell@'ModuleName'%.SendStr((uint8_t*)"Info: Enable configGENERATE_RUN_TIME_STATS for runtime statistics.\r\n", io->stdOut);
#endif
  /* header */
#if configUSE_TRACE_FACILITY
  buf[0] = '\0';
  %@Utility@'ModuleName'%.strcatPad(buf, sizeof(buf), (const unsigned char*)"TCB", ' ', PAD_STAT_TASK_TCB);
  %@Shell@'ModuleName'%.SendStr(buf, io->stdOut);
#endif
  buf[0] = '\0';
  %@Utility@'ModuleName'%.strcatPad(buf, sizeof(buf), (const unsigned char*)"Static", ' ', PAD_STAT_TASK_STATIC);
  %@Shell@'ModuleName'%.SendStr(buf, io->stdOut);

  buf[0] = '\0';
  %@Utility@'ModuleName'%.strcatPad(buf, sizeof(buf), (const unsigned char*)"Handle", ' ', PAD_STAT_TASK_HANDLE);
  %@Shell@'ModuleName'%.SendStr(buf, io->stdOut);

  buf[0] = '\0';
  %@Utility@'ModuleName'%.strcatPad(buf, sizeof(buf), (const unsigned char*)"Name", ' ', PAD_STAT_TASK_NAME);
  %@Shell@'ModuleName'%.SendStr(buf, io->stdOut);

#if configUSE_TRACE_FACILITY
  buf[0] = '\0';
  %@Utility@'ModuleName'%.strcatPad(buf, sizeof(buf), (const unsigned char*)"State", ' ', PAD_STAT_TASK_STATE);
  %@Shell@'ModuleName'%.SendStr(buf, io->stdOut);
#endif
  buf[0] = '\0';
  %@Utility@'ModuleName'%.strcatPad(buf, sizeof(buf), (const unsigned char*)"Prio", ' ', PAD_STAT_TASK_PRIO);
  %@Shell@'ModuleName'%.SendStr(buf, io->stdOut);

  buf[0] = '\0';
  %@Utility@'ModuleName'%.strcatPad(buf, sizeof(buf), (const unsigned char*)"Stack Beg", ' ', PAD_STAT_TASK_STACK_BEG);
  %@Shell@'ModuleName'%.SendStr(buf, io->stdOut);

  buf[0] = '\0';
  %@Utility@'ModuleName'%.strcatPad(buf, sizeof(buf), (const unsigned char*)"Stack End", ' ', PAD_STAT_TASK_STACK_END);
  %@Shell@'ModuleName'%.SendStr(buf, io->stdOut);

  buf[0] = '\0';
  %@Utility@'ModuleName'%.strcatPad(buf, sizeof(buf), (const unsigned char*)"Size", ' ', PAD_STAT_TASK_STACK_SIZE);
  %@Shell@'ModuleName'%.SendStr(buf, io->stdOut);

  buf[0] = '\0';
  %@Utility@'ModuleName'%.strcatPad(buf, sizeof(buf), (const unsigned char*)"Stack Top", ' ', PAD_STAT_TASK_STACK_TOP);
  %@Shell@'ModuleName'%.SendStr(buf, io->stdOut);
#if configUSE_TRACE_FACILITY
  buf[0] = '\0';
  %@Utility@'ModuleName'%.strcatPad(buf, sizeof(buf), (const unsigned char*)"Unused", ' ', PAD_STAT_TASK_STACK_MARK);
  %@Shell@'ModuleName'%.SendStr(buf, io->stdOut);
#endif
#if configGENERATE_RUN_TIME_STATS
  buf[0] = '\0';
  %@Utility@'ModuleName'%.strcatPad(buf, sizeof(buf), (const unsigned char*)"Runtime", ' ', PAD_STAT_TASK_RUNTIME);
  %@Shell@'ModuleName'%.SendStr(buf, io->stdOut);
#endif
  %@Shell@'ModuleName'%.SendStr((unsigned char*)"\r\n", io->stdOut);

#if configGENERATE_RUN_TIME_STATS
  ulTotalTime = portGET_RUN_TIME_COUNTER_VALUE(); /* get total time passed in system */
  ulTotalTime /= 100UL; /* For percentage calculations. */
#endif

#if (tskKERNEL_VERSION_MAJOR<10) || %@KinetisSDK@'ModuleName'%.CONFIG_CPU_IS_ESP32 /* otherwise xGetTaskHandles(), vTaskGetStackInfo(), pcTaskGetName() not available */
  %@Shell@'ModuleName'%.SendStr((unsigned char*)"FreeRTOS version must be at least 10.0.0 and not for ESP32\r\n", io->stdOut);
#else
  nofTasks = uxTaskGetNumberOfTasks();
  if (nofTasks>SHELL_MAX_NOF_TASKS) {
    %@Utility@'ModuleName'%.strcpy(buf, sizeof(buf), (const unsigned char*)"WARNING: more tasks than Shell maximum number of tasks.\r\n");
    %@Shell@'ModuleName'%.SendStr(buf, io->stdErr);
    nofTasks = SHELL_MAX_NOF_TASKS;
  }
  /* get task handles of all tasks. */
  nofTasks = xGetTaskHandles(&taskHandles[0], SHELL_MAX_NOF_TASKS);
  for(i=0;i<nofTasks;i++) {
    if (taskHandles[i]!=NULL) {
    #if configUSE_TRACE_FACILITY
      vTaskGetInfo(taskHandles[i], &taskStatus, pdTRUE, eInvalid);
    #endif
      vTaskGetStackInfo(taskHandles[i], &stackBeg, &stackEnd, &topOfStack, &staticallyAllocated);

#if configUSE_TRACE_FACILITY
      /* TCB */
      tmpBuf[0] = '\0';
      %@Utility@'ModuleName'%.strcatNum32u(tmpBuf, sizeof(tmpBuf), (uint32_t)taskStatus.xTaskNumber);
      buf[0] = '\0';
      %@Utility@'ModuleName'%.strcatPad(buf, sizeof(buf), tmpBuf, ' ', PAD_STAT_TASK_TCB);
      %@Shell@'ModuleName'%.SendStr(buf, io->stdOut);
#endif
      /* Static */
      tmpBuf[0] = '\0';
      if (staticallyAllocated==0) {
        %@Utility@'ModuleName'%.strcpy(tmpBuf, sizeof(tmpBuf), (unsigned char*)"no (0)");
      } else {
        %@Utility@'ModuleName'%.strcpy(tmpBuf, sizeof(tmpBuf), (unsigned char*)"yes(");
        %@Utility@'ModuleName'%.strcatNum8u(tmpBuf, sizeof(tmpBuf), staticallyAllocated);
        %@Utility@'ModuleName'%.strcat(tmpBuf, sizeof(tmpBuf), (unsigned char*)")");
      }
      buf[0] = '\0';
      %@Utility@'ModuleName'%.strcatPad(buf, sizeof(buf), tmpBuf, ' ', PAD_STAT_TASK_STATIC);
      %@Shell@'ModuleName'%.SendStr(buf, io->stdOut);

      /* task handle */
      %@Utility@'ModuleName'%.strcpy(tmpBuf, sizeof(tmpBuf), (unsigned char*)"0x");
      %@Utility@'ModuleName'%.strcatNum32Hex(tmpBuf, sizeof(tmpBuf), (uint32_t)taskHandles[i]);
      buf[0] = '\0';
      %@Utility@'ModuleName'%.strcatPad(buf, sizeof(buf), tmpBuf, ' ', PAD_STAT_TASK_HANDLE);
      %@Shell@'ModuleName'%.SendStr(buf, io->stdOut);

      /* task name */
      buf[0] = '\0';
      %@Utility@'ModuleName'%.strcatPad(buf, sizeof(buf), (unsigned char*)pcTaskGetName(taskHandles[i]), ' ', PAD_STAT_TASK_NAME);
      %@Shell@'ModuleName'%.SendStr(buf, io->stdOut);

#if configUSE_TRACE_FACILITY
      /* state */
      switch(taskStatus.eCurrentState) {
        case eRunning:   %@Utility@'ModuleName'%.strcpy(tmpBuf, sizeof(tmpBuf), (unsigned char*)"Running"); break;
        case eReady:     %@Utility@'ModuleName'%.strcpy(tmpBuf, sizeof(tmpBuf), (unsigned char*)"Ready"); break;
        case eSuspended: %@Utility@'ModuleName'%.strcpy(tmpBuf, sizeof(tmpBuf), (unsigned char*)"Suspended"); break;
        case eBlocked:   %@Utility@'ModuleName'%.strcpy(tmpBuf, sizeof(tmpBuf), (unsigned char*)"Blocked"); break;
        case eDeleted:   %@Utility@'ModuleName'%.strcpy(tmpBuf, sizeof(tmpBuf), (unsigned char*)"Deleted"); break;
        case eInvalid:   %@Utility@'ModuleName'%.strcpy(tmpBuf, sizeof(tmpBuf), (unsigned char*)"Invalid"); break;
        default:         %@Utility@'ModuleName'%.strcpy(tmpBuf, sizeof(tmpBuf), (unsigned char*)"UNKNOWN!"); break;
      }
      buf[0] = '\0';
      %@Utility@'ModuleName'%.strcatPad(buf, sizeof(buf), tmpBuf, ' ', PAD_STAT_TASK_STATE);
      %@Shell@'ModuleName'%.SendStr(buf, io->stdOut);
#endif
#if configUSE_TRACE_FACILITY
      /* (baseprio,currprio) */
      tmpBuf[0] = '\0';
      %@Utility@'ModuleName'%.chcat(tmpBuf, sizeof(tmpBuf), '(');
      %@Utility@'ModuleName'%.strcatNum32u(tmpBuf, sizeof(tmpBuf), taskStatus.uxBasePriority);
      %@Utility@'ModuleName'%.chcat(tmpBuf, sizeof(tmpBuf), ',');
      %@Utility@'ModuleName'%.strcatNum32u(tmpBuf, sizeof(tmpBuf), taskStatus.uxCurrentPriority);
      %@Utility@'ModuleName'%.chcat(tmpBuf, sizeof(tmpBuf), ')');
      buf[0] = '\0';
      %@Utility@'ModuleName'%.strcatPad(buf, sizeof(buf), tmpBuf, ' ', PAD_STAT_TASK_PRIO);
      %@Shell@'ModuleName'%.SendStr(buf, io->stdOut);
#else
      /* prio */
      tmpBuf[0] = '\0';
      %@Utility@'ModuleName'%.strcatNum32s(tmpBuf, sizeof(tmpBuf), uxTaskPriorityGet(taskHandles[i]));
      buf[0] = '\0';
      %@Utility@'ModuleName'%.strcatPad(buf, sizeof(buf), tmpBuf, ' ', PAD_STAT_TASK_PRIO);
      %@Shell@'ModuleName'%.SendStr(buf, io->stdOut);
#endif
      /* stack begin */
      %@Utility@'ModuleName'%.strcpy(tmpBuf, sizeof(tmpBuf), (unsigned char*)"0x");
      %@Utility@'ModuleName'%.strcatNum32Hex(tmpBuf, sizeof(tmpBuf), (uint32_t)stackBeg);
      buf[0] = '\0';
      %@Utility@'ModuleName'%.strcatPad(buf, sizeof(buf), tmpBuf, ' ', PAD_STAT_TASK_STACK_BEG);
      %@Shell@'ModuleName'%.SendStr(buf, io->stdOut);

      /* stack end */
      %@Utility@'ModuleName'%.strcpy(tmpBuf, sizeof(tmpBuf), (unsigned char*)"0x");
      %@Utility@'ModuleName'%.strcatNum32Hex(tmpBuf, sizeof(tmpBuf), (uint32_t)stackEnd);
      buf[0] = '\0';
      %@Utility@'ModuleName'%.strcatPad(buf, sizeof(buf), tmpBuf, ' ', PAD_STAT_TASK_STACK_END);
      %@Shell@'ModuleName'%.SendStr(buf, io->stdOut);

      /* stack size */
#if (portSTACK_GROWTH>0)
      stackSize = (uint16_t)(((uint32_t)stackEnd - (uint32_t)stackBeg)+sizeof(StackType_t));
#else
      stackSize = (uint16_t)(((uint32_t)stackBeg - (uint32_t)stackEnd)+ 2*sizeof(StackType_t));
#endif
      tmpBuf[0] = '\0';
      %@Utility@'ModuleName'%.strcatNum16uFormatted(tmpBuf, sizeof(tmpBuf), stackSize, ' ', 5);
      %@Utility@'ModuleName'%.strcat(tmpBuf, sizeof(tmpBuf), (unsigned char*)" B");
      buf[0] = '\0';
      %@Utility@'ModuleName'%.strcatPad(buf, sizeof(buf), tmpBuf, ' ', PAD_STAT_TASK_STACK_SIZE);
      %@Shell@'ModuleName'%.SendStr(buf, io->stdOut);

      /* stack top */
      %@Utility@'ModuleName'%.strcpy(tmpBuf, sizeof(tmpBuf), (unsigned char*)"0x");
      %@Utility@'ModuleName'%.strcatNum32Hex(tmpBuf, sizeof(tmpBuf), (uint32_t)topOfStack);
      %@Utility@'ModuleName'%.strcat(tmpBuf, sizeof(tmpBuf), (unsigned char*)" (");
#if (portSTACK_GROWTH>0)
      %@Utility@'ModuleName'%.strcatNum16uFormatted(tmpBuf, sizeof(tmpBuf), (uint16_t)(((uint32_t)topOfStack - (uint32_t)stackBeg))+sizeof(StackType_t), ' ', 5);
#else
      %@Utility@'ModuleName'%.strcatNum16uFormatted(tmpBuf, sizeof(tmpBuf), (uint16_t)(((uint32_t)stackBeg - (uint32_t)topOfStack))+sizeof(StackType_t), ' ', 5);
#endif
      %@Utility@'ModuleName'%.strcat(tmpBuf, sizeof(tmpBuf), (unsigned char*)" B)");
      buf[0] = '\0';
      %@Utility@'ModuleName'%.strcatPad(buf, sizeof(buf), tmpBuf, ' ', PAD_STAT_TASK_STACK_TOP);
      %@Shell@'ModuleName'%.SendStr(buf, io->stdOut);

#if configUSE_TRACE_FACILITY
      /* stack high water mark (the lower the number, the less stack available */
      tmpBuf[0] = '\0';
      %@Utility@'ModuleName'%.strcatNum16uFormatted(tmpBuf, sizeof(tmpBuf), taskStatus.usStackHighWaterMark*sizeof(portSTACK_TYPE), ' ', 5);
      %@Utility@'ModuleName'%.strcat(tmpBuf, sizeof(tmpBuf), (unsigned char*)" B");
      buf[0] = '\0';
      %@Utility@'ModuleName'%.strcatPad(buf, sizeof(buf), tmpBuf, ' ', PAD_STAT_TASK_STACK_MARK);
      %@Shell@'ModuleName'%.SendStr(buf, io->stdOut);
#endif
#if configGENERATE_RUN_TIME_STATS && configUSE_TRACE_FACILITY
      /* runtime */
      %@Utility@'ModuleName'%.strcpy(tmpBuf, sizeof(tmpBuf), (unsigned char*)"0x");
      %@Utility@'ModuleName'%.strcatNum32Hex(tmpBuf, sizeof(tmpBuf), taskStatus.ulRunTimeCounter);
      if (ulTotalTime>0) { /* to avoid division by zero */
        uint32_t ulStatsAsPercentage;

        /* What percentage of the total run time has the task used?
           This will always be rounded down to the nearest integer.
           ulTotalRunTime has already been divided by 100. */
        ulStatsAsPercentage = taskStatus.ulRunTimeCounter/ulTotalTime;
        if (ulStatsAsPercentage>0) {
          %@Utility@'ModuleName'%.strcat(tmpBuf, sizeof(tmpBuf), (unsigned char*)" (");
          %@Utility@'ModuleName'%.strcatNum16uFormatted(tmpBuf, sizeof(tmpBuf), ulStatsAsPercentage, ' ', 3);
          %@Utility@'ModuleName'%.strcat(tmpBuf, sizeof(tmpBuf), (unsigned char*)"%%)");
        } else {
          /* If the percentage is zero here then the task has consumed less than 1%% of the total run time. */
          %@Utility@'ModuleName'%.strcat(tmpBuf, sizeof(tmpBuf), (unsigned char*)" ( <1%%)");
        }
      }
      buf[0] = '\0';
      %@Utility@'ModuleName'%.strcatPad(buf, sizeof(buf), tmpBuf, ' ', PAD_STAT_TASK_RUNTIME);
      %@Shell@'ModuleName'%.SendStr(buf, io->stdOut);
#endif
      %@Shell@'ModuleName'%.SendStr((unsigned char*)"\r\n", io->stdOut);
    } /* if */
  } /* for */
#endif /* tskKERNEL_VERSION_MAJOR */
  return res;
}
#endif

#if configUSE_SHELL
static uint8_t PrintStatus(const %@Shell@'ModuleName'%.StdIOType *io) {
  uint8_t buf[16];

  %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"%'ModuleName'", (unsigned char*)"FreeRTOS status information\r\n", io->stdOut);
  %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"  Version", (const unsigned char*)tskKERNEL_VERSION_NUMBER, io->stdOut);
  %@Shell@'ModuleName'%.SendStr((unsigned char*)"\r\n", io->stdOut);
  %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"  RTOS ticks", (const unsigned char*)"", io->stdOut);
  %@Utility@'ModuleName'%.Num16sToStr(buf, sizeof(buf), configTICK_RATE_HZ);
  %@Shell@'ModuleName'%.SendStr(buf, io->stdOut);
  %@Shell@'ModuleName'%.SendStr((unsigned char*)" Hz, ", io->stdOut);
  %@Utility@'ModuleName'%.Num16sToStr(buf, sizeof(buf), 1000/configTICK_RATE_HZ);
  %@Shell@'ModuleName'%.SendStr(buf, io->stdOut);
  %@Shell@'ModuleName'%.SendStr((unsigned char*)" ms\r\n", io->stdOut);
#if configSUPPORT_DYNAMIC_ALLOCATION && configUSE_HEAP_SCHEME!=3 /* wrapper to malloc() does not have xPortGetFreeHeapSize() */
  %@Shell@'ModuleName'%.SendStatusStr((unsigned char*)"  Free heap", (const unsigned char*)"", io->stdOut);
  %@Utility@'ModuleName'%.Num32uToStr(buf, sizeof(buf), %'ModuleName'%.xPortGetFreeHeapSize());
  %@Shell@'ModuleName'%.SendStr(buf, io->stdOut);
  %@Shell@'ModuleName'%.SendStr((unsigned char*)" bytes\r\n", io->stdOut);
#endif
  return ERR_OK;
}
#endif

#if configUSE_SHELL
static uint8_t PrintHelp(const %@Shell@'ModuleName'%.StdIOType *io) {
  %@Shell@'ModuleName'%.SendHelpStr((unsigned char*)"%'ModuleName'", (unsigned char*)"Group of %'ModuleName' commands\r\n", io->stdOut);
  %@Shell@'ModuleName'%.SendHelpStr((unsigned char*)"  help|status", (unsigned char*)"Print help or status information\r\n", io->stdOut);
  %@Shell@'ModuleName'%.SendHelpStr((unsigned char*)"  tasklist", (unsigned char*)"Print tasklist\r\n", io->stdOut);
  return ERR_OK;
}
#endif

%endif
%if defined(GenerateOSAFunctions) & %GenerateOSAFunctions='yes'
#if %@KinetisSDK@'ModuleName'%.SDK_VERSION_USED == %@KinetisSDK@'ModuleName'%.SDK_VERSION_1_3
#include "fsl_os_abstraction.h"

/*!
 * \brief Initializes the OS Adapter layer for the Kinetis SDK.
 * \return Error code, kStatus_OSA_Success if everything is ok.
 */
osa_status_t OSA_Init(void) {
#if configUSE_PERCEPIO_TRACE_HOOKS
%if defined(FRTrace)
  %@FRTrace@'ModuleName'%.Startup(); /* Startup Percepio Trace. Need to do this before calling any RTOS functions. */
%else
  McuPercepio_Startup(); /* Startup Percepio Trace. Need to do this before calling any RTOS functions. */
%endif
#endif
  return kStatus_OSA_Success;
}

/*!
 * \brief Starts the OS within the OS Adapter layer of the Kinetis SDK
 * \return Error code, kStatus_OSA_Success if everything is ok.
 */
osa_status_t OSA_Start(void) {
  vTaskStartScheduler(); /* start the RTOS scheduler */
  return kStatus_OSA_Success;
}
#endif

%endif
%-BW_CUSTOM_VARIABLE_END
%-BW_INTERN_METHOD_DECL_START
%- List of internal methods headers
%-BW_INTERN_METHOD_DECL_END
%-BW_IMPLEMENT_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTaskCreate
%ifdef xTaskCreate
%define! ParpvTaskCode
%define! ParpcName
%define! ParusStackDepth
%define! ParpvParameters
%define! ParuxPriority
%define! ParpvCreatedTask
%define! RetVal
%include Common\FreeRTOSxTaskCreate.Inc
/*
portBASE_TYPE %'ModuleName'%.%xTaskCreate(pdTASK_CODE pvTaskCode, const portCHAR * const pcName, unsigned portSHORT usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pvCreatedTask)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xTaskCreate
%-BW_METHOD_END xTaskCreate
%-************************************************************************************************************
%-BW_METHOD_BEGIN vTaskDelete
%ifdef vTaskDelete
%define! ParpxTask
%include Common\FreeRTOSvTaskDelete.Inc
/*
void %'ModuleName'%.%vTaskDelete(xTaskHandle pxTask)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- vTaskDelete
%-BW_METHOD_END vTaskDelete
%-************************************************************************************************************
%-BW_METHOD_BEGIN vTaskStartScheduler
%ifdef vTaskStartScheduler
%include Common\FreeRTOSvTaskStartScheduler.Inc
/*
void %'ModuleName'%.%vTaskStartScheduler(void)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- vTaskStartScheduler
%-BW_METHOD_END vTaskStartScheduler
%-************************************************************************************************************
%-BW_METHOD_BEGIN taskYIELD
%ifdef taskYIELD
%include Common\FreeRTOStaskYIELD.Inc
/*
void %'ModuleName'%.%taskYIELD(void)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- taskYIELD
%-BW_METHOD_END taskYIELD
%-************************************************************************************************************
%-BW_METHOD_BEGIN taskENTER_CRITICAL
%ifdef taskENTER_CRITICAL
%include Common\FreeRTOStaskENTER_CRITICAL.Inc
/*
void %'ModuleName'%.%taskENTER_CRITICAL(void)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- taskENTER_CRITICAL
%-BW_METHOD_END taskENTER_CRITICAL
%-************************************************************************************************************
%-BW_METHOD_BEGIN taskEXIT_CRITICAL
%ifdef taskEXIT_CRITICAL
%include Common\FreeRTOStaskEXIT_CRITICAL.Inc
/*
void %'ModuleName'%.%taskEXIT_CRITICAL(void)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- taskEXIT_CRITICAL
%-BW_METHOD_END taskEXIT_CRITICAL
%-************************************************************************************************************
%-BW_METHOD_BEGIN taskDISABLE_INTERRUPTS
%ifdef taskDISABLE_INTERRUPTS
%include Common\FreeRTOStaskDISABLE_INTERRUPTS.Inc
/*
void %'ModuleName'%.%taskDISABLE_INTERRUPTS(void)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- taskDISABLE_INTERRUPTS
%-BW_METHOD_END taskDISABLE_INTERRUPTS
%-************************************************************************************************************
%-BW_METHOD_BEGIN taskENABLE_INTERRUPTS
%ifdef taskENABLE_INTERRUPTS
%include Common\FreeRTOStaskENABLE_INTERRUPTS.Inc
/*
void %'ModuleName'%.%taskENABLE_INTERRUPTS(void)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- taskENABLE_INTERRUPTS
%-BW_METHOD_END taskENABLE_INTERRUPTS
%-************************************************************************************************************
%-BW_METHOD_BEGIN vTaskEndScheduler
%ifdef vTaskEndScheduler
%include Common\FreeRTOSvTaskEndScheduler.Inc
/*
void %'ModuleName'%.%vTaskEndScheduler(void)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- vTaskEndScheduler
%-BW_METHOD_END vTaskEndScheduler
%-************************************************************************************************************
%-BW_METHOD_BEGIN vTaskSuspendAll
%ifdef vTaskSuspendAll
%include Common\FreeRTOSvTaskSuspendAll.Inc
/*
void %'ModuleName'%.%vTaskSuspendAll(void)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- vTaskSuspendAll
%-BW_METHOD_END vTaskSuspendAll
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTaskResumeAll
%ifdef xTaskResumeAll
%define! RetVal
%include Common\FreeRTOSxTaskResumeAll.Inc
/*
portBASE_TYPE %'ModuleName'%.%xTaskResumeAll(void)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xTaskResumeAll
%-BW_METHOD_END xTaskResumeAll
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTaskResumeFromISR
%ifdef xTaskResumeFromISR
%define! ParpxTaskToResume
%define! RetVal
%include Common\FreeRTOSxTaskResumeFromISR.Inc
/*
portBASE_TYPE %'ModuleName'%.%xTaskResumeFromISR(xTaskHandle pxTaskToResume)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xTaskResumeFromISR
%-BW_METHOD_END xTaskResumeFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN vTaskDelay
%ifdef vTaskDelay
%define! ParxTicksToDelay
%include Common\FreeRTOSvTaskDelay.Inc
/*
void %'ModuleName'%.%vTaskDelay(portTickType xTicksToDelay)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- vTaskDelay
%-BW_METHOD_END vTaskDelay
%-************************************************************************************************************
%-BW_METHOD_BEGIN vTaskDelayUntil
%ifdef vTaskDelayUntil
%define! ParpxPreviousWakeTime
%define! ParxTimeIncrement
%include Common\FreeRTOSvTaskDelayUntil.Inc
/*
void %'ModuleName'%.%vTaskDelayUntil(portTickType *pxPreviousWakeTime, portTickType xTimeIncrement)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- vTaskDelayUntil
%-BW_METHOD_END vTaskDelayUntil
%-************************************************************************************************************
%-BW_METHOD_BEGIN uxTaskPriorityGet
%ifdef uxTaskPriorityGet
%define! ParpxTask
%define! RetVal
%include Common\FreeRTOSuxTaskPriorityGet.Inc
/*
unsigned_portBASE_TYPE %'ModuleName'%.%uxTaskPriorityGet(xTaskHandle pxTask)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- uxTaskPriorityGet
%-BW_METHOD_END uxTaskPriorityGet
%-************************************************************************************************************
%-BW_METHOD_BEGIN vTaskPrioritySet
%ifdef vTaskPrioritySet
%define! ParpxTask
%define! ParuxNewPriority
%include Common\FreeRTOSvTaskPrioritySet.Inc
/*
void %'ModuleName'%.%vTaskPrioritySet(xTaskHandle pxTask, unsigned_portBASE_TYPE uxNewPriority)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- vTaskPrioritySet
%-BW_METHOD_END vTaskPrioritySet
%-************************************************************************************************************
%-BW_METHOD_BEGIN xSemaphoreTakeRecursive
%ifdef xSemaphoreTakeRecursive
%define! ParxMutex
%define! ParxBlockTime
%define! RetVal
%include Common\FreeRTOSxSemaphoreTakeRecursive.Inc
/*
bool %'ModuleName'%.%xSemaphoreTakeRecursive(xSemaphoreHandle xMutex, portTickType xBlockTime)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xSemaphoreTakeRecursive
%-BW_METHOD_END xSemaphoreTakeRecursive
%-************************************************************************************************************
%-BW_METHOD_BEGIN xSemaphoreGiveRecursive
%ifdef xSemaphoreGiveRecursive
%define! ParxMutex
%define! RetVal
%include Common\FreeRTOSxSemaphoreGiveRecursive.Inc
/*
bool %'ModuleName'%.%xSemaphoreGiveRecursive(xSemaphoreHandle xMutex)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xSemaphoreGiveRecursive
%-BW_METHOD_END xSemaphoreGiveRecursive
%-************************************************************************************************************
%-BW_METHOD_BEGIN xSemaphoreCreateRecursiveMutex
%ifdef xSemaphoreCreateRecursiveMutex
%define! RetVal
%include Common\FreeRTOSxSemaphoreCreateRecursiveMutex.Inc
/*
xSemaphoreHandle %'ModuleName'%.%xSemaphoreCreateRecursiveMutex(void)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xSemaphoreCreateRecursiveMutex
%-BW_METHOD_END xSemaphoreCreateRecursiveMutex
%-************************************************************************************************************
%-BW_METHOD_BEGIN vSemaphoreDelete
%ifdef vSemaphoreDelete
%define! ParxSemaphore
%include Common\FreeRTOSvSemaphoreDelete.Inc
/*
void %'ModuleName'%.%vSemaphoreDelete(xSemaphoreHandle xSemaphore)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- vSemaphoreDelete
%-BW_METHOD_END vSemaphoreDelete
%-************************************************************************************************************
%-BW_METHOD_BEGIN vTaskSuspend
%ifdef vTaskSuspend
%define! ParpxTaskToSuspend
%include Common\FreeRTOSvTaskSuspend.Inc
/*
void %'ModuleName'%.%vTaskSuspend(xTaskHandle pxTaskToSuspend)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- vTaskSuspend
%-BW_METHOD_END vTaskSuspend
%-************************************************************************************************************
%-BW_METHOD_BEGIN vTaskResume
%ifdef vTaskResume
%define! ParpxTaskToResume
%include Common\FreeRTOSvTaskResume.Inc
/*
void %'ModuleName'%.%vTaskResume(xTaskHandle pxTaskToResume)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- vTaskResume
%-BW_METHOD_END vTaskResume
%-************************************************************************************************************
%-BW_METHOD_BEGIN xSemaphoreCreateMutex
%ifdef xSemaphoreCreateMutex
%define! RetVal
%include Common\FreeRTOSxSemaphoreCreateMutex.Inc
/*
xSemaphoreHandle %'ModuleName'%.%xSemaphoreCreateMutex(void)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xSemaphoreCreateMutex
%-BW_METHOD_END xSemaphoreCreateMutex
%-************************************************************************************************************
%-BW_METHOD_BEGIN xSemaphoreTake
%ifdef xSemaphoreTake
%define! ParxMutex
%define! ParxBlockTime
%define! RetVal
%include Common\FreeRTOSxSemaphoreTake.Inc
/*
bool %'ModuleName'%.%xSemaphoreTake(xSemaphoreHandle xMutex, portTickType xBlockTime)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xSemaphoreTake
%-BW_METHOD_END xSemaphoreTake
%-************************************************************************************************************
%-BW_METHOD_BEGIN xSemaphoreGive
%ifdef xSemaphoreGive
%define! ParxMutex
%define! RetVal
%include Common\FreeRTOSxSemaphoreGive.Inc
/*
bool %'ModuleName'%.%xSemaphoreGive(xSemaphoreHandle xMutex)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xSemaphoreGive
%-BW_METHOD_END xSemaphoreGive
%-************************************************************************************************************
%-BW_METHOD_BEGIN vSemaphoreCreateBinary
%ifdef vSemaphoreCreateBinary
%define! ParxSemaphore
%include Common\FreeRTOSvSemaphoreCreateBinary.Inc
/*
void %'ModuleName'%.%vSemaphoreCreateBinary(xSemaphoreHandle xSemaphore)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- vSemaphoreCreateBinary
%-BW_METHOD_END vSemaphoreCreateBinary
%-************************************************************************************************************
%-BW_METHOD_BEGIN xSemaphoreCreateCounting
%ifdef xSemaphoreCreateCounting
%define! ParuxMaxCount
%define! ParuxInitialCount
%define! RetVal
%include Common\FreeRTOSxSemaphoreCreateCounting.Inc
/*
xSemaphoreHandle %'ModuleName'%.%xSemaphoreCreateCounting(unsigned_portBASE_TYPE uxMaxCount, unsigned_portBASE_TYPE uxInitialCount)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xSemaphoreCreateCounting
%-BW_METHOD_END xSemaphoreCreateCounting
%-************************************************************************************************************
%-BW_METHOD_BEGIN xSemaphoreGiveFromISR
%ifdef xSemaphoreGiveFromISR
%define! ParxSemaphore
%define! ParpxHigherPriorityTaskWoken
%define! RetVal
%include Common\FreeRTOSxSemaphoreGiveFromISR.Inc
/*
bool %'ModuleName'%.%xSemaphoreGiveFromISR(xSemaphoreHandle xSemaphore, signed_portBASE_TYPE *pxHigherPriorityTaskWoken)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xSemaphoreGiveFromISR
%-BW_METHOD_END xSemaphoreGiveFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN vTaskList
%ifdef vTaskList
%define! ParpcWriteBuffer
%define! ParbufSize
%include Common\FreeRTOSvTaskList.Inc
/*
void %'ModuleName'%.%vTaskList(signed portCHAR *pcWriteBuffer, size_t bufSize)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- vTaskList
%-BW_METHOD_END vTaskList
%-************************************************************************************************************
%-BW_METHOD_BEGIN pvPortMalloc
%ifdef pvPortMalloc
%define! ParxWantedSize
%define! RetVal
%include Common\FreeRTOSpvPortMalloc.Inc
/*
pVoid %'ModuleName'%.%pvPortMalloc(size_t xWantedSize)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- pvPortMalloc
%-BW_METHOD_END pvPortMalloc
%-************************************************************************************************************
%-BW_METHOD_BEGIN vPortFree
%ifdef vPortFree
%define! Parpv
%include Common\FreeRTOSvPortFree.Inc
/*
void %'ModuleName'%.%vPortFree(void *pv)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- vPortFree
%-BW_METHOD_END vPortFree
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTaskGetTickCount
%ifdef xTaskGetTickCount
%define! RetVal
%include Common\FreeRTOSxTaskGetTickCount.Inc
/*
portTickType %'ModuleName'%.%xTaskGetTickCount(void)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xTaskGetTickCount
%-BW_METHOD_END xTaskGetTickCount
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTaskGetSchedulerState
%ifdef xTaskGetSchedulerState
%define! RetVal
%include Common\FreeRTOSxTaskGetSchedulerState.Inc
/*
portBASE_TYPE %'ModuleName'%.%xTaskGetSchedulerState(void)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xTaskGetSchedulerState
%-BW_METHOD_END xTaskGetSchedulerState
%-************************************************************************************************************
%-BW_METHOD_BEGIN uxTaskGetStackHighWaterMark
%ifdef uxTaskGetStackHighWaterMark
%define! ParxTask
%define! RetVal
%include Common\FreeRTOSuxTaskGetStackHighWaterMark.Inc
/*
unsigned_portBASE_TYPE %'ModuleName'%.%uxTaskGetStackHighWaterMark(xTaskHandle xTask)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- uxTaskGetStackHighWaterMark
%-BW_METHOD_END uxTaskGetStackHighWaterMark
%-************************************************************************************************************
%-BW_METHOD_BEGIN uxTaskGetNumberOfTasks
%ifdef uxTaskGetNumberOfTasks
%define! RetVal
%include Common\FreeRTOSuxTaskGetNumberOfTasks.Inc
/*
unsigned_portBASE_TYPE %'ModuleName'%.%uxTaskGetNumberOfTasks(void)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- uxTaskGetNumberOfTasks
%-BW_METHOD_END uxTaskGetNumberOfTasks
%-************************************************************************************************************
%-BW_METHOD_BEGIN vTaskGetRunTimeStats
%ifdef vTaskGetRunTimeStats
%define! ParpcWriteBuffer
%define! ParbufSize
%include Common\FreeRTOSvTaskGetRunTimeStats.Inc
/*
void %'ModuleName'%.%vTaskGetRunTimeStats(portCHAR *pcWriteBuffer, size_t bufSize)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- vTaskGetRunTimeStats
%-BW_METHOD_END vTaskGetRunTimeStats
%-INHERITED_EVENT_BEGIN RuntimeCntr OnInterrupt
%ifdef RuntimeCntr
%ifdef @RuntimeCntr@OnInterrupt
%include Common\GeneralInternal.inc (OnInterrupt)
void %@RuntimeCntr@OnInterrupt(void)
{
  %'ModuleName'%.RunTimeCounter++; /* increment runtime counter */
}

%endif %- @RuntimeCntr@OnInterrupt
%endif
%-INHERITED_EVENT_END RuntimeCntr OnInterrupt
%-************************************************************************************************************
%-BW_METHOD_BEGIN xPortGetFreeHeapSize
%ifdef xPortGetFreeHeapSize
%define! RetVal
%include Common\FreeRTOSxPortGetFreeHeapSize.Inc
/*
Tsize_t %'ModuleName'%.%xPortGetFreeHeapSize(void)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xPortGetFreeHeapSize
%-BW_METHOD_END xPortGetFreeHeapSize
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueueCreate
%ifdef xQueueCreate
%define! ParuxQueueLength
%define! ParuxItemSize
%define! RetVal
%include Common\FreeRTOSxQueueCreate.Inc
/*
xQueueHandle %'ModuleName'%.%xQueueCreate(unsigned_portBASE_TYPE uxQueueLength, unsigned_portBASE_TYPE uxItemSize)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xQueueCreate
%-BW_METHOD_END xQueueCreate
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueueSendToFront
%ifdef xQueueSendToFront
%define! ParxQueue
%define! ParpvItemToQueue
%define! ParxTicksToWait
%define! RetVal
%include Common\FreeRTOSxQueueSendToFront.Inc
/*
portBASE_TYPE %'ModuleName'%.%xQueueSendToFront(xQueueHandle xQueue, const void *pvItemToQueue, portTickType xTicksToWait)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xQueueSendToFront
%-BW_METHOD_END xQueueSendToFront
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueueSendToBack
%ifdef xQueueSendToBack
%define! ParxQueue
%define! ParpvItemToQueue
%define! ParxTicksToWait
%define! RetVal
%include Common\FreeRTOSxQueueSendToBack.Inc
/*
portBASE_TYPE %'ModuleName'%.%xQueueSendToBack(xQueueHandle xQueue, const void *pvItemToQueue, portTickType xTicksToWait)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xQueueSendToBack
%-BW_METHOD_END xQueueSendToBack
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueueReceive
%ifdef xQueueReceive
%define! ParxQueue
%define! ParxTicksToWait
%define! ParpvBuffer
%define! RetVal
%include Common\FreeRTOSxQueueReceive.Inc
/*
portBASE_TYPE %'ModuleName'%.%xQueueReceive(xQueueHandle xQueue, void *pvBuffer, portTickType xTicksToWait)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xQueueReceive
%-BW_METHOD_END xQueueReceive
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueuePeek
%ifdef xQueuePeek
%define! ParxQueue
%define! ParpvBuffer
%define! ParxTicksToWait
%define! RetVal
%include Common\FreeRTOSxQueuePeek.Inc
/*
portBASE_TYPE %'ModuleName'%.%xQueuePeek(xQueueHandle xQueue, void *pvBuffer, portTickType xTicksToWait)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xQueuePeek
%-BW_METHOD_END xQueuePeek
%-************************************************************************************************************
%-BW_METHOD_BEGIN vQueueDelete
%ifdef vQueueDelete
%define! ParpxQueueToDelete
%include Common\FreeRTOSvQueueDelete.Inc
/*
void %'ModuleName'%.%vQueueDelete(xQueueHandle pxQueueToDelete)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- vQueueDelete
%-BW_METHOD_END vQueueDelete
%-************************************************************************************************************
%-BW_METHOD_BEGIN uxQueueMessagesWaiting
%ifdef uxQueueMessagesWaiting
%define! ParxQueue
%define! RetVal
%include Common\FreeRTOSuxQueueMessagesWaiting.Inc
/*
unsigned_portBASE_TYPE %'ModuleName'%.%uxQueueMessagesWaiting(xQueueHandle xQueue)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- uxQueueMessagesWaiting
%-BW_METHOD_END uxQueueMessagesWaiting
%-************************************************************************************************************
%-BW_METHOD_BEGIN uxQueueMessagesWaitingfromISR
%ifdef uxQueueMessagesWaitingfromISR
%define! ParxQueue
%define! RetVal
%include Common\FreeRTOSuxQueueMessagesWaitingfromISR.Inc
/*
unsigned_portBASE_TYPE %'ModuleName'%.%uxQueueMessagesWaitingfromISR(xQueueHandle xQueue)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- uxQueueMessagesWaitingfromISR
%-BW_METHOD_END uxQueueMessagesWaitingfromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueueReceiveFromISR
%ifdef xQueueReceiveFromISR
%define! ParxQueue
%define! ParpvBuffer
%define! ParpxHigherPriorityTaskWoken
%define! RetVal
%include Common\FreeRTOSxQueueReceiveFromISR.Inc
/*
portBASE_TYPE %'ModuleName'%.%xQueueReceiveFromISR(xQueueHandle xQueue, void *pvBuffer, portBASE_TYPE *pxHigherPriorityTaskWoken)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xQueueReceiveFromISR
%-BW_METHOD_END xQueueReceiveFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueueSendToFrontFromISR
%ifdef xQueueSendToFrontFromISR
%define! ParxQueue
%define! ParpvItemToQueue
%define! ParpxHigherPriorityTaskWoken
%define! RetVal
%include Common\FreeRTOSxQueueSendToFrontFromISR.Inc
/*
portBASE_TYPE %'ModuleName'%.%xQueueSendToFrontFromISR(xQueueHandle xQueue, const void *pvItemToQueue, portBASE_TYPE *pxHigherPriorityTaskWoken)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xQueueSendToFrontFromISR
%-BW_METHOD_END xQueueSendToFrontFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueueSendToBackFromISR
%ifdef xQueueSendToBackFromISR
%define! ParxQueue
%define! ParpvItemToQueue
%define! ParpxHigherPriorityTaskWoken
%define! RetVal
%include Common\FreeRTOSxQueueSendToBackFromISR.Inc
/*
portBASE_TYPE %'ModuleName'%.%xQueueSendToBackFromISR(xQueueHandle xQueue, const void *pvItemToQueue, portBASE_TYPE *pxHigherPriorityTaskWoken)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/
%endif %- xQueueSendToBackFromISR
%-BW_METHOD_END xQueueSendToBackFromISR
%-INHERITED_EVENT_BEGIN TickTimerLDD OnCounterRestart
%ifdef TickTimerLDD
%ifdef @TickTimerLDD@OnCounterRestart
%include Common\GeneralInternal.inc (OnCounterRestart)
%if (%Compiler = "GNUC")
__attribute__((naked)) void %@TickTimerLDD@OnCounterRestart(LDD_TUserData *UserDataPtr __attribute__((unused))) {
%elif (%Compiler = "IARARM")
void %@TickTimerLDD@OnCounterRestart(LDD_TUserData *UserDataPtr) {
%else
void %@TickTimerLDD@OnCounterRestart(LDD_TUserData *UserDataPtr __attribute__((unused))) {
%endif
  vPortTickHandler();
}

%endif %- @TickTimerLDD@OnCounterRestart
%endif %-TickTimerLDD
%-INHERITED_EVENT_END TickTimerLDD OnCounterRestart
%-************************************************************************************************************
%-INHERITED_EVENT_BEGIN RuntimeCntrLDD OnCounterRestart
%ifdef RuntimeCntrLDD
%ifdef @RuntimeCntrLDD@OnCounterRestart
%include Common\GeneralInternal.inc (OnCounterRestart)
void %@RuntimeCntrLDD@OnCounterRestart(LDD_TUserData *UserDataPtr __attribute__((unused)))
{
  %'ModuleName'%.RunTimeCounter++; /* increment runtime counter */
}

%endif %- @RuntimeCntrLDD@OnCounterRestart
%endif
%-INHERITED_EVENT_END RuntimeCntrLDD OnCounterRestart
%-************************************************************************************************************
%-INHERITED_EVENT_BEGIN TickCntr OnInterrupt
%if defined(TickCntr) & defined(@TickCntr@OnInterrupt)
%include Common\GeneralInternal.inc (OnInterrupt)
%if (CPUfamily = "HCS08") | (CPUfamily = "HC08")
#pragma NO_ENTRY /* do not create entry sequence */
#pragma NO_EXIT  /* do not create exit sequence */
#pragma NO_RETURN /* we care about this (RTI) */
%endif
void %@TickCntr@OnInterrupt(void)
{
  /* NOTE: we are called here from the tick interrupt (periodic timer bean, ISR). However, we need to imitate things in
           a way as this function would be the primary ISR (means that this function would have been raised directly by
           the interrupt. In order to do this, we need to to 'fix' the stack below in a rather hacky way :-( */
%if (CPUfamily = "ColdFireV1") | (CPUfamily = "MCF")
  asm { /* we are called from the main ISR bean: we need to correct stack as if this function would be the main ISR */
    naked                                                        %>40 /* No stack frame or compiler-generated rts */
    LEA     4(A7),A7                                             %>40 /* Remove the 4 bytes from stack from the Processor Export ISR (+JSR to here) */
    /* now simulate exit sequence of caller (this code is at the end of the Processor Expert Bean code */
%if (CPUfamily = "MCF")
%- NOTE: was MOVEM.L 8(A7),D0-D2/A0-A1  for normal periodic tick timer
    MOVEM.L 8(A7),D0-D2/A0-A1                                    %>40 /* Restore cpu registers which were pushed on stack in bean (caller of this function) */
    UNLK    A6                                                   %>40 /* Unlink instruction (normally done in caller/bean code) */
    ADDQ.L  #4,A7                                                %>40 /* normally done in the caller/bean code */
%else
    MOVEM.L (A7),D0-D2/A0-A1                                     %>40 /* Restore cpu registers which were pushed on stack in bean (caller of this function) */
    LEA     20(A7),A7                                            %>40 /* Unlink instruction (normally done in caller/bean code) */
    /* here would be the RTE in the embedded component code */
%endif
    /* now build up the stack frame, as we would be directly called by the interrupt service routine */
    LEA     -24(A7),A7                                           %>40 /* Reserve space for processor registers onto stack */
    MOVEM.L D0-D2/D7/A0-A1,(A7)                                  %>40 /* Save registers */
  }
  /* Increment the RTOS tick. */
  (void)portSET_INTERRUPT_MASK_FROM_ISR(); /* return value is in D0 */
  asm {
    MOVE.L D0, D7 ; /* save ulSavedInterruptMask for later */
  }
  %if defined(TickCntr) & defined(@TickCntr@Reset)
    %@TickCntr@'ModuleName'%.Reset(); /* reset tick counter: need this for trace */
  %else
    /* WARNING: Reset() not available, FreeRTOS Percepio Trace would need it! */
  %endif
  asm { /* need to do this in assembly, otherwise the compiler might use the stack! :-( */
    JSR xTaskIncrementTick  /* return value != 0 (pdFALSE): yield */
    TST D0
    BEQ noYield
  }
  taskYIELD();
  asm {
    noYield:
  }
  asm {
    MOVE.L D7,D0
    JSR ulPortSetIPL
  }
#if configUSE_TICKLESS_IDLE == 1
  portTickCntr=1; /* set flag so we know that interrupt has fired */
#endif
  /* now generate interrupt exit code */
  asm {
    MOVEM.L    (A7),D0-D2/D7/A0-A1                               %>40 /* Restore processor registers from stack */
    LEA        24(A7),A7                                         %>40 /* Remove space from stack */
    RTE                                                          %>40 /* Return to task or nested ISR */
  }
%elif (CPUfamily = "Kinetis")
  /* Kinetis is using LDD approach */
%elif (CPUfamily = "HCS08") | (CPUfamily = "HC08")
  __asm {
    PULH  ; remove return address from stack (from JSR to this function)
    PULH
#ifdef __BANKED__
    PULH  ; was a CALL instruction (not a JSR): there are 3 bytes on the stack.
#endif
  }
#if configUSE_TICKLESS_IDLE == 1
  portTickCntr=1; /* set flag so we know that interrupt has fired */
#endif
  #if configUSE_PREEMPTION == 1
    portSAVE_CONTEXT(); /* A context switch might happen so save the context. */
  %if defined(TickCntr) & defined(@TickCntr@Reset)
    %@TickCntr@'ModuleName'%.Reset(); /* reset tick counter: need this for trace */
  %else
    /* WARNING: Reset() not available, FreeRTOS Percepio Trace would need it! */
  %endif
    if (xTaskIncrementTick()!=pdFALSE) {
      vTaskSwitchContext(); /* a context switch is necessary */
    }
    /* Restore the context of a task - which may be a different task to that interrupted. */
    portRESTORE_CONTEXT(); /* includes PULH and RTI */
  #else
    %@TickCntr@'ModuleName'%.Reset(); /* reset tick counter: need this for trace */
    (void)xTaskIncrementTick(); /* non-preemptive mode, no context switch */
    __asm("PULH");
    __asm("RTI");
  #endif
%elif (CPUfamily = "HCS12") | (CPUfamily = "HCS12X")
  asm {
#ifdef __BANKED__
    LEAS 3,SP  ; was a CALL instruction (not a JSR): there are 3 bytes on the stack.
#else
    LEAS 2,SP
#endif
  }
#if configUSE_TICKLESS_IDLE == 1
  portTickCntr=1; /* set flag so we know that interrupt has fired */
#endif
  #if configUSE_PREEMPTION == 1
    portSAVE_CONTEXT(); /* A context switch might happen so save the context. */
  %if defined(TickCntr) & defined(@TickCntr@Reset)
    %@TickCntr@'ModuleName'%.Reset(); /* reset tick counter: need this for trace */
  %else
    /* WARNING: Reset() not available, FreeRTOS Percepio Trace would need it! */
  %endif
    if (xTaskIncrementTick()!=pdFALSE) {
      vTaskSwitchContext(); /* a context switch is necessary */
    }
    /* Restore the context of a task - which may be a different task to that interrupted. */
    portRESTORE_CONTEXT(); /* includes RTI */
  #else
    %@TickCntr@'ModuleName'%.Reset(); /* reset tick counter: need this for trace */
    (void)xTaskIncrementTick(); /* non-preemptive mode, no context switch */
    __asm("RTI"); /* return from interrupt */
  #endif
%elif (CPUfamily = "56800")
//  asm { /* we are called from the main ISR bean: we need to correct stack as if this function would be the main ISR */
//    naked                                                      %>40 /* No stack frame or compiler-generated rts */
//    LEA     4(A7),A7                                           %>40 /* Remove the 4 bytes from stack from the Processor Export ISR (+JSR to here) */
//    /* now simulate exit sequence of caller (this code is at the end of the Processor Expert Bean code */
//    MOVEM.L (A7),D0-D2/A0-A1                                   %>40 /* Restore cpu registers which were pushed on stack in bean (caller of this function) */
//    LEA     20(A7),A7                                          %>40 /* Unlink instruction (normally done in caller/bean code) */
    /* here would be the RTE in the embedded component code */
    /* now build up the stack frame, as we would be directly called by the interrupt service routine */
//    LEA     -24(A7),A7                                         %>40 /* Reserve space for processor registers onto stack */
//    MOVEM.L D0-D2/D7/A0-A1,(A7)                                %>40 /* Save registers */
//  }
  /* Increment the RTOS tick. */
  (void)portSET_INTERRUPT_MASK_FROM_ISR(); /* return value is in D0 */
//  asm {
//    MOVE.L D0, D7 ; /* save ulSavedInterruptMask for later */
//  }
  {
  %if defined(TickCntr) & defined(@TickCntr@Reset)
    %@TickCntr@'ModuleName'%.Reset(); /* reset tick counter: need this for trace */
  %else
    /* WARNING: Reset() not available, FreeRTOS Percepio Trace would need it! */
  %endif
    if (xTaskIncrementTick()!=pdFALSE) {
      taskYIELD();
    }
  }
//  asm {
//    MOVE.L D7,D0
//    JSR ulPortSetIPL
//  }

  /* If we are using the pre-emptive scheduler then also request a
     context switch as incrementing the tick could have unblocked a task. */
#if configUSE_TICKLESS_IDLE == 1
  portTickCntr=1; /* set flag so we know that interrupt has fired */
#endif
  /* now generate interrupt exit code */
//  asm {
//    MOVEM.L    (A7),D0-D2/D7/A0-A1                             %>40 /* Restore processor registers from stack */
//    LEA        24(A7),A7                                       %>40 /* Remove space from stack */
//    RTE                                                        %>40 /* Return to task or nested ISR */
//  }
%else
  #error "CPU %CPUfamily not supported"
%endif
}

%endif %- @TickCntr@OnInterrupt
%-INHERITED_EVENT_END TickCntr OnInterrupt
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueueReset
%ifdef xQueueReset
%define! ParxQueue
%define! RetVal
%include Common\FreeRTOSxQueueReset.Inc
/*
portBASE_TYPE %'ModuleName'%.%xQueueReset(xQueueHandle xQueue)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xQueueReset
%-BW_METHOD_END xQueueReset
%-************************************************************************************************************
%-BW_METHOD_BEGIN xSemaphoreGetMutexHolder
%ifdef xSemaphoreGetMutexHolder
%define! ParxSemaphore
%define! RetVal
%include Common\FreeRTOSxSemaphoreGetMutexHolder.Inc
/*
void* %'ModuleName'%.%xSemaphoreGetMutexHolder(xSemaphoreHandle xSemaphore)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xSemaphoreGetMutexHolder
%-BW_METHOD_END xSemaphoreGetMutexHolder
%-************************************************************************************************************
%-BW_METHOD_BEGIN xSemaphoreTakeFromISR
%ifdef xSemaphoreTakeFromISR
%define! ParxSemaphore
%define! ParpxHigherPriorityTaskWoken
%define! RetVal
%include Common\FreeRTOSxSemaphoreTakeFromISR.Inc
/*
bool %'ModuleName'%.%xSemaphoreTakeFromISR(xSemaphoreHandle xSemaphore, signed_portBASE_TYPE *pxHigherPriorityTaskWoken)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xSemaphoreTakeFromISR
%-BW_METHOD_END xSemaphoreTakeFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN ParseCommand
%ifdef ParseCommand
%define! Parcmd
%define! Parhandled
%define! Pario
%define! RetVal
%include Common\FreeRTOSParseCommand.Inc
#if configUSE_SHELL
uint8_t %'ModuleName'%.%ParseCommand(const unsigned char *cmd, bool *handled, const %@Shell@'ModuleName'%.StdIOType *io)
{
  if (%@Utility@'ModuleName'%.strcmp((char*)cmd, %@Shell@'ModuleName'%.CMD_HELP)==0 || %@Utility@'ModuleName'%.strcmp((char*)cmd, "%'ModuleName' help")==0) {
    *handled = TRUE;
    return PrintHelp(io);
  } else if ((%@Utility@'ModuleName'%.strcmp((char*)cmd, %@Shell@'ModuleName'%.CMD_STATUS)==0) || (%@Utility@'ModuleName'%.strcmp((char*)cmd, "%'ModuleName' status")==0)) {
    *handled = TRUE;
    return PrintStatus(io);
  } else if (%@Utility@'ModuleName'%.strcmp((char*)cmd, "%'ModuleName' tasklist")==0) {
    *handled = TRUE;
    return PrintTaskList(io);
  }
  return ERR_OK;
}
#endif

%endif %- ParseCommand
%-BW_METHOD_END ParseCommand
%-************************************************************************************************************
%-BW_METHOD_BEGIN Init
%ifdef Init
%include Common\FreeRTOSInit.Inc
void %'ModuleName'%.%Init(void)
{
%if %DisabledInterruptsInStartup='yes'
#if !%@KinetisSDK@'ModuleName'%.CONFIG_CPU_IS_ESP32
  portDISABLE_ALL_INTERRUPTS(); /* disable all interrupts, they get enabled in vStartScheduler() */
#endif
%else
  /* RTOS adapter is configured not to disable interrupts */
%endif
#if configSYSTICK_USE_LOW_POWER_TIMER
  /* enable clocking for low power timer, otherwise vPortStopTickTimer() will crash.
    Additionally, Percepio trace needs access to the timer early on. */
  #if %@KinetisSDK@'ModuleName'%.CONFIG_NXP_SDK_USED
  CLOCK_EnableClock(kCLOCK_Lptmr0);
  #else /* Processor Expert */
  SIM_PDD_SetClockGate(SIM_BASE_PTR, SIM_PDD_CLOCK_GATE_LPTMR0, PDD_ENABLE);
  #endif
#endif
#if !%@KinetisSDK@'ModuleName'%.CONFIG_CPU_IS_ESP32
  vPortStopTickTimer(); /* tick timer shall not run until the RTOS scheduler is started */
#endif
#if configUSE_PERCEPIO_TRACE_HOOKS
%if defined(FRTrace)
  %@FRTrace@'ModuleName'%.Startup(); /* Startup Percepio Trace. Need to do this before calling any RTOS functions. */
%else
  McuPercepio_Startup(); /* Startup Percepio Trace. Need to do this before calling any RTOS functions. */
%endif
#endif
}

%endif %- Init
%-BW_METHOD_END Init
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTaskGetApplicationTaskTag
%ifdef xTaskGetApplicationTaskTag
%define! ParxTask
%define! RetVal
%include Common\FreeRTOSxTaskGetApplicationTaskTag.Inc
/*
pdTASK_HOOK_CODE %'ModuleName'%.%xTaskGetApplicationTaskTag(xTaskHandle xTask)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xTaskGetApplicationTaskTag
%-BW_METHOD_END xTaskGetApplicationTaskTag
%-************************************************************************************************************
%-BW_METHOD_BEGIN vTaskSetApplicationTaskTag
%ifdef vTaskSetApplicationTaskTag
%define! ParxTask
%define! ParpxHookFunction
%define! ParVariable_1
%include Common\FreeRTOSvTaskSetApplicationTaskTag.Inc
/*
void %'ModuleName'%.%vTaskSetApplicationTaskTag(xTaskHandle xTask, pdTASK_HOOK_CODE pxHookFunction, byte Variable_1)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- vTaskSetApplicationTaskTag
%-BW_METHOD_END vTaskSetApplicationTaskTag
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTaskGetCurrentTaskHandle
%ifdef xTaskGetCurrentTaskHandle
%define! RetVal
%include Common\FreeRTOSxTaskGetCurrentTaskHandle.Inc
/*
xTaskHandle %'ModuleName'%.%xTaskGetCurrentTaskHandle(void)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xTaskGetCurrentTaskHandle
%-BW_METHOD_END xTaskGetCurrentTaskHandle
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTaskGetIdleTaskHandle
%ifdef xTaskGetIdleTaskHandle
%define! RetVal
%include Common\FreeRTOSxTaskGetIdleTaskHandle.Inc
/*
xTaskHandle %'ModuleName'%.%xTaskGetIdleTaskHandle(void)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xTaskGetIdleTaskHandle
%-BW_METHOD_END xTaskGetIdleTaskHandle
%-************************************************************************************************************
%-BW_METHOD_BEGIN eTaskGetState
%ifdef eTaskGetState
%define! ParxTask
%define! RetVal
%include Common\FreeRTOSeTaskGetState.Inc
/*
eTaskState %'ModuleName'%.%eTaskGetState(xTaskHandle xTask)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- eTaskGetState
%-BW_METHOD_END eTaskGetState
%-************************************************************************************************************
%-BW_METHOD_BEGIN pcTaskGetTaskName
%ifdef pcTaskGetTaskName
%define! ParxTaskToQuery
%define! RetVal
%include Common\FreeRTOSpcTaskGetTaskName.Inc
/*
signed char %'ModuleName'%.%pcTaskGetTaskName(xTaskHandle xTaskToQuery)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- pcTaskGetTaskName
%-BW_METHOD_END pcTaskGetTaskName
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTaskGetTickCountFromISR
%ifdef xTaskGetTickCountFromISR
%define! RetVal
%include Common\FreeRTOSxTaskGetTickCountFromISR.Inc
/*
portTickType %'ModuleName'%.%xTaskGetTickCountFromISR(void)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xTaskGetTickCountFromISR
%-BW_METHOD_END xTaskGetTickCountFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTaskCallApplicationTaskHook
%ifdef xTaskCallApplicationTaskHook
%define! ParxTask
%define! ParpvParameter
%define! RetVal
%include Common\FreeRTOSxTaskCallApplicationTaskHook.Inc
/*
portBASE_TYPE %'ModuleName'%.%xTaskCallApplicationTaskHook(xTaskHandle xTask, void* pvParameter)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xTaskCallApplicationTaskHook
%-BW_METHOD_END xTaskCallApplicationTaskHook
%-************************************************************************************************************
%-BW_METHOD_BEGIN vTaskStepTick
%ifdef vTaskStepTick
%define! ParxTicksToJump
%include Common\FreeRTOSvTaskStepTick.Inc
/*
void %'ModuleName'%.%vTaskStepTick(portTickType xTicksToJump)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- vTaskStepTick
%-BW_METHOD_END vTaskStepTick
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueuePeekFromISR
%ifdef xQueuePeekFromISR
%define! ParxQueue
%define! ParpvBuffer
%define! ParxTicksToWait
%define! RetVal
%include Common\FreeRTOSxQueuePeekFromISR.Inc
/*
portBASE_TYPE %'ModuleName'%.%xQueuePeekFromISR(xQueueHandle xQueue, void *pvBuffer, portTickType xTicksToWait)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xQueuePeekFromISR
%-BW_METHOD_END xQueuePeekFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueueOverwrite
%ifdef xQueueOverwrite
%define! ParxQueue
%define! ParpvItemToQueue
%define! RetVal
%include Common\FreeRTOSxQueueOverwrite.Inc
/*
portBASE_TYPE %'ModuleName'%.%xQueueOverwrite(xQueueHandle xQueue, const void *pvItemToQueue)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xQueueOverwrite
%-BW_METHOD_END xQueueOverwrite
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueueOverwriteFromISR
%ifdef xQueueOverwriteFromISR
%define! ParxQueue
%define! ParpvItemToQueue
%define! ParpxHigherPriorityTaskWoken
%define! RetVal
%include Common\FreeRTOSxQueueOverwriteFromISR.Inc
/*
portBASE_TYPE %'ModuleName'%.%xQueueOverwriteFromISR(xQueueHandle xQueue, const void *pvItemToQueue, portBASE_TYPE *pxHigherPriorityTaskWoken)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xQueueOverwriteFromISR
%-BW_METHOD_END xQueueOverwriteFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN vQueueAddToRegistry
%ifdef vQueueAddToRegistry
%define! ParxQueue
%define! ParpcQueueName
%include Common\FreeRTOSvQueueAddToRegistry.Inc
/*
void %'ModuleName'%.%vQueueAddToRegistry(xQueueHandle xQueue, char *pcQueueName)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- vQueueAddToRegistry
%-BW_METHOD_END vQueueAddToRegistry
%-************************************************************************************************************
%-BW_METHOD_BEGIN vQueueUnregisterQueue
%ifdef vQueueUnregisterQueue
%define! ParxQueue
%include Common\FreeRTOSvQueueUnregisterQueue.Inc
/*
void %'ModuleName'%.%vQueueUnregisterQueue(xQueueHandle xQueue)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- vQueueUnregisterQueue
%-BW_METHOD_END vQueueUnregisterQueue
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueueIsQueueFullFromISR
%ifdef xQueueIsQueueFullFromISR
%define! ParxQueue
%define! RetVal
%include Common\FreeRTOSxQueueIsQueueFullFromISR.Inc
/*
portBASE_TYPE %'ModuleName'%.%xQueueIsQueueFullFromISR(xQueueHandle xQueue)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xQueueIsQueueFullFromISR
%-BW_METHOD_END xQueueIsQueueFullFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueueIsQueueEmptyFromISR
%ifdef xQueueIsQueueEmptyFromISR
%define! ParxQueue
%define! RetVal
%include Common\FreeRTOSxQueueIsQueueEmptyFromISR.Inc
/*
portBASE_TYPE %'ModuleName'%.%xQueueIsQueueEmptyFromISR(xQueueHandle xQueue)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xQueueIsQueueEmptyFromISR
%-BW_METHOD_END xQueueIsQueueEmptyFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueueAddToSet
%ifdef xQueueAddToSet
%define! ParxQueueOrSemaphore
%define! ParxQueueSet
%define! RetVal
%include Common\FreeRTOSxQueueAddToSet.Inc
/*
portBASE_TYPE %'ModuleName'%.%xQueueAddToSet(xQueueSetMemberHandle xQueueOrSemaphore, xQueueSetHandle xQueueSet)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xQueueAddToSet
%-BW_METHOD_END xQueueAddToSet
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueueCreateSet
%ifdef xQueueCreateSet
%define! ParuxEventQueueLength
%define! RetVal
%include Common\FreeRTOSxQueueCreateSet.Inc
/*
xQueueSetHandle %'ModuleName'%.%xQueueCreateSet(unsigned portBASE_TYPE uxEventQueueLength)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xQueueCreateSet
%-BW_METHOD_END xQueueCreateSet
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueueRemoveFromSet
%ifdef xQueueRemoveFromSet
%define! ParxQueueOrSemaphore
%define! ParxQueueSet
%define! RetVal
%include Common\FreeRTOSxQueueRemoveFromSet.Inc
/*
portBASE_TYPE %'ModuleName'%.%xQueueRemoveFromSet(xQueueSetMemberHandle xQueueOrSemaphore, xQueueSetHandle xQueueSet)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xQueueRemoveFromSet
%-BW_METHOD_END xQueueRemoveFromSet
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueueSelectFromSet
%ifdef xQueueSelectFromSet
%define! ParxQueueSet
%define! ParxBlockTimeTicks
%define! RetVal
%include Common\FreeRTOSxQueueSelectFromSet.Inc
/*
xQueueSetMemberHandle %'ModuleName'%.%xQueueSelectFromSet(xQueueSetHandle xQueueSet, portTickType xBlockTimeTicks)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xQueueSelectFromSet
%-BW_METHOD_END xQueueSelectFromSet
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueueSelectFromSetFromISR
%ifdef xQueueSelectFromSetFromISR
%define! ParxQueueSet
%define! RetVal
%include Common\FreeRTOSxQueueSelectFromSetFromISR.Inc
/*
xQueueSetMemberHandle %'ModuleName'%.%xQueueSelectFromSetFromISR(xQueueSetHandle xQueueSet)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xQueueSelectFromSetFromISR
%-BW_METHOD_END xQueueSelectFromSetFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN xEventGroupCreate
%ifdef xEventGroupCreate
%define! RetVal
%include Common\FreeRTOSxEventGroupCreate.Inc
/*
EventGroupHandle_t %'ModuleName'%.%xEventGroupCreate(void)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xEventGroupCreate
%-BW_METHOD_END xEventGroupCreate
%-************************************************************************************************************
%-BW_METHOD_BEGIN xEventGroupWaitBits
%ifdef xEventGroupWaitBits
%define! ParxEventGroup
%define! ParuxBitsToWaitFor
%define! ParxClearOnExit
%define! ParxWaitForAllBits
%define! ParxTicksToWait
%define! RetVal
%include Common\FreeRTOSxEventGroupWaitBits.Inc
/*
byte %'ModuleName'%.%xEventGroupWaitBits(const EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xEventGroupWaitBits
%-BW_METHOD_END xEventGroupWaitBits
%-************************************************************************************************************
%-BW_METHOD_BEGIN xEventGroupSetBits
%ifdef xEventGroupSetBits
%define! ParxEventGroup
%define! ParuxBitsToSet
%define! RetVal
%include Common\FreeRTOSxEventGroupSetBits.Inc
/*
EventBits_t %'ModuleName'%.%xEventGroupSetBits(EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xEventGroupSetBits
%-BW_METHOD_END xEventGroupSetBits
%-************************************************************************************************************
%-BW_METHOD_BEGIN xEventGroupSetBitsFromISR
%ifdef xEventGroupSetBitsFromISR
%define! ParxEventGroup
%define! ParuxBitsToSet
%define! ParpxHigherPriorityTaskWoken
%define! RetVal
%include Common\FreeRTOSxEventGroupSetBitsFromISR.Inc
/*
EventBits_t %'ModuleName'%.%xEventGroupSetBitsFromISR(EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet , BaseType_t *pxHigherPriorityTaskWoken)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xEventGroupSetBitsFromISR
%-BW_METHOD_END xEventGroupSetBitsFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN xEventGroupClearBits
%ifdef xEventGroupClearBits
%define! ParxEventGroup
%define! ParuxBitsToSet
%define! RetVal
%include Common\FreeRTOSxEventGroupClearBits.Inc
/*
EventBits_t %'ModuleName'%.%xEventGroupClearBits(EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xEventGroupClearBits
%-BW_METHOD_END xEventGroupClearBits
%-************************************************************************************************************
%-BW_METHOD_BEGIN xEventGroupClearBitsFromISR
%ifdef xEventGroupClearBitsFromISR
%define! ParxEventGroup
%define! ParuxBitsToSet
%define! RetVal
%include Common\FreeRTOSxEventGroupClearBitsFromISR.Inc
/*
EventBits_t %'ModuleName'%.%xEventGroupClearBitsFromISR(EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xEventGroupClearBitsFromISR
%-BW_METHOD_END xEventGroupClearBitsFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN xEventGroupGetBits
%ifdef xEventGroupGetBits
%define! ParxEventGroup
%define! RetVal
%include Common\FreeRTOSxEventGroupGetBits.Inc
/*
EventBits_t %'ModuleName'%.%xEventGroupGetBits(EventGroupHandle_t xEventGroup)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xEventGroupGetBits
%-BW_METHOD_END xEventGroupGetBits
%-************************************************************************************************************
%-BW_METHOD_BEGIN xEventGroupGetBitsFromISR
%ifdef xEventGroupGetBitsFromISR
%define! ParxEventGroup
%define! RetVal
%include Common\FreeRTOSxEventGroupGetBitsFromISR.Inc
/*
EventBits_t %'ModuleName'%.%xEventGroupGetBitsFromISR(EventGroupHandle_t xEventGroup)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xEventGroupGetBitsFromISR
%-BW_METHOD_END xEventGroupGetBitsFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN xEventGroupSync
%ifdef xEventGroupSync
%define! ParxEventGroup
%define! ParuxBitsToSet
%define! ParuxBitsToWaitFor
%define! ParxTicksToWait
%define! RetVal
%include Common\FreeRTOSxEventGroupSync.Inc
/*
EventBits_t %'ModuleName'%.%xEventGroupSync(EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xEventGroupSync
%-BW_METHOD_END xEventGroupSync
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTimerCreate
%ifdef xTimerCreate
%define! ParpcTimerName
%define! ParxTimerPeriod
%define! ParuxAutoReload
%define! ParpvTimerID
%define! ParpxCallbackFunction
%define! RetVal
%include Common\FreeRTOSxTimerCreate.Inc
/*
TimerHandle_t %'ModuleName'%.%xTimerCreate(const char * const pcTimerName, const TickType_t xTimerPeriod, const UBaseType_t uxAutoReload, void *const pvTimerID, TimerCallbackFunction_t pxCallbackFunction)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xTimerCreate
%-BW_METHOD_END xTimerCreate
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTimerIsTimerActive
%ifdef xTimerIsTimerActive
%define! ParxTimer
%define! RetVal
%include Common\FreeRTOSxTimerIsTimerActive.Inc
/*
BaseType_t %'ModuleName'%.%xTimerIsTimerActive(TimerHandle_t xTimer)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xTimerIsTimerActive
%-BW_METHOD_END xTimerIsTimerActive
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTimerStart
%ifdef xTimerStart
%define! ParxTimer
%define! ParxBlockTime
%define! RetVal
%include Common\FreeRTOSxTimerStart.Inc
/*
BaseType_t %'ModuleName'%.%xTimerStart(TimerHandle_t xTimer, TickType_t xBlockTime)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xTimerStart
%-BW_METHOD_END xTimerStart
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTimerStop
%ifdef xTimerStop
%define! ParxTimer
%define! ParxBlockTime
%define! RetVal
%include Common\FreeRTOSxTimerStop.Inc
/*
BaseType_t %'ModuleName'%.%xTimerStop(TimerHandle_t xTimer, TickType_t xBlockTime)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xTimerStop
%-BW_METHOD_END xTimerStop
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTimerChangePeriod
%ifdef xTimerChangePeriod
%define! ParxTimer
%define! ParxNewPeriod
%define! ParxBlockTime
%define! RetVal
%include Common\FreeRTOSxTimerChangePeriod.Inc
/*
BaseType_t %'ModuleName'%.%xTimerChangePeriod(TimerHandle_t xTimer, TickType_t xNewPeriod, TickType_t xBlockTime)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xTimerChangePeriod
%-BW_METHOD_END xTimerChangePeriod
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTimerDelete
%ifdef xTimerDelete
%define! ParxTimer
%define! ParxBlockTime
%define! RetVal
%include Common\FreeRTOSxTimerDelete.Inc
/*
BaseType_t %'ModuleName'%.%xTimerDelete(TickType_t xTimer, TickType_t xBlockTime)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xTimerDelete
%-BW_METHOD_END xTimerDelete
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTimerReset
%ifdef xTimerReset
%define! ParxTimer
%define! ParxBlockTime
%define! RetVal
%include Common\FreeRTOSxTimerReset.Inc
/*
BaseType_t %'ModuleName'%.%xTimerReset(TimerHandle_t xTimer, TickType_t xBlockTime)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xTimerReset
%-BW_METHOD_END xTimerReset
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTimerStartFromISR
%ifdef xTimerStartFromISR
%define! ParxTimer
%define! ParpxHigherPriorityTaskWoken
%define! RetVal
%include Common\FreeRTOSxTimerStartFromISR.Inc
/*
BaseType_t %'ModuleName'%.%xTimerStartFromISR(TimerHandle_t xTimer, BaseType_t *pxHigherPriorityTaskWoken)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xTimerStartFromISR
%-BW_METHOD_END xTimerStartFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTimerStopFromISR
%ifdef xTimerStopFromISR
%define! ParpxHigherPriorityTaskWoken
%define! ParxTimer
%define! RetVal
%include Common\FreeRTOSxTimerStopFromISR.Inc
/*
BaseType_t %'ModuleName'%.%xTimerStopFromISR(TimerHandle_t xTimer, BaseType_t *pxHigherPriorityTaskWoken)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xTimerStopFromISR
%-BW_METHOD_END xTimerStopFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTimerChangePeriodFromISR
%ifdef xTimerChangePeriodFromISR
%define! ParxTimer
%define! ParxNewPeriod
%define! ParpxHigherPriorityTaskWoken
%define! RetVal
%include Common\FreeRTOSxTimerChangePeriodFromISR.Inc
/*
BaseType_t %'ModuleName'%.%xTimerChangePeriodFromISR(TimerHandle_t xTimer, TickType_t xNewPeriod, BaseType_t *pxHigherPriorityTaskWoken)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xTimerChangePeriodFromISR
%-BW_METHOD_END xTimerChangePeriodFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTimerResetFromISR
%ifdef xTimerResetFromISR
%define! ParxTimer
%define! ParpxHigherPriorityTaskWoken
%define! RetVal
%include Common\FreeRTOSxTimerResetFromISR.Inc
/*
BaseType_t %'ModuleName'%.%xTimerResetFromISR(TimerHandle_t xTimer, BaseType_t *pxHigherPriorityTaskWoken)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xTimerResetFromISR
%-BW_METHOD_END xTimerResetFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN pvTimerGetTimerID
%ifdef pvTimerGetTimerID
%define! ParxTimer
%define! RetVal
%include Common\FreeRTOSpvTimerGetTimerID.Inc
/*
void* %'ModuleName'%.%pvTimerGetTimerID(TimerHandle_t xTimer)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- pvTimerGetTimerID
%-BW_METHOD_END pvTimerGetTimerID
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTimerGetTimerDaemonTaskHandle
%ifdef xTimerGetTimerDaemonTaskHandle
%define! RetVal
%include Common\FreeRTOSxTimerGetTimerDaemonTaskHandle.Inc
/*
TaskHandle_t %'ModuleName'%.%xTimerGetTimerDaemonTaskHandle(void)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xTimerGetTimerDaemonTaskHandle
%-BW_METHOD_END xTimerGetTimerDaemonTaskHandle
%-************************************************************************************************************
%-BW_METHOD_BEGIN pcTimerGetTimerName
%ifdef pcTimerGetTimerName
%define! ParxTimer
%define! RetVal
%include Common\FreeRTOSpcTimerGetTimerName.Inc
/*
char* %'ModuleName'%.%pcTimerGetTimerName(TimerHandle_t xTimer)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- pcTimerGetTimerName
%-BW_METHOD_END pcTimerGetTimerName
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTimerPendFunctionCall
%ifdef xTimerPendFunctionCall
%define! ParxFunctionToPend
%define! ParpvParameter1
%define! ParulParameter2
%define! ParxTicksToWait
%define! RetVal
%include Common\FreeRTOSxTimerPendFunctionCall.Inc
/*
BaseType_t %'ModuleName'%.%xTimerPendFunctionCall(PendedFunction_t xFunctionToPend, void* pvParameter1, uint32_t ulParameter2, TickType_t xTicksToWait)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xTimerPendFunctionCall
%-BW_METHOD_END xTimerPendFunctionCall
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTimerPendFunctionCallFromISR
%ifdef xTimerPendFunctionCallFromISR
%define! ParxFunctionToPend
%define! ParpvParameter1
%define! ParulParameter2
%define! ParpxHigherPriorityTaskWoken
%define! RetVal
%include Common\FreeRTOSxTimerPendFunctionCallFromISR.Inc
/*
BaseType_t %'ModuleName'%.%xTimerPendFunctionCallFromISR(PendedFunction_t xFunctionToPend, void* pvParameter1, uint32_t ulParameter2, BaseType_t *pxHigherPriorityTaskWoken)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xTimerPendFunctionCallFromISR
%-BW_METHOD_END xTimerPendFunctionCallFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTaskNotifyGive
%ifdef xTaskNotifyGive
%define! ParxTaskToNotify
%define! RetVal
%include Common\FreeRTOSxTaskNotifyGive.Inc
/*
BaseType_t %'ModuleName'%.%xTaskNotifyGive(TaskHandle_t xTaskToNotify)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xTaskNotifyGive
%-BW_METHOD_END xTaskNotifyGive
%-************************************************************************************************************
%-BW_METHOD_BEGIN ulTaskNotifyTake
%ifdef ulTaskNotifyTake
%define! ParxClearCountOnExit
%define! ParxTicksToWait
%define! RetVal
%include Common\FreeRTOSulTaskNotifyTake.Inc
/*
uint32_t %'ModuleName'%.%ulTaskNotifyTake(BaseType_t xClearCountOnExit, TickType_t xTicksToWait)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- ulTaskNotifyTake
%-BW_METHOD_END ulTaskNotifyTake
%-************************************************************************************************************
%-BW_METHOD_BEGIN vTaskNotifyGiveFromISR
%ifdef vTaskNotifyGiveFromISR
%define! ParxTaskToNotify
%define! ParpxHigherPriorityTaskWoken
%include Common\FreeRTOSvTaskNotifyGiveFromISR.Inc
/*
void %'ModuleName'%.%vTaskNotifyGiveFromISR(TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- vTaskNotifyGiveFromISR
%-BW_METHOD_END vTaskNotifyGiveFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTaskNotify
%ifdef xTaskNotify
%define! ParxTaskToNotify
%define! ParulValue
%define! PareAction
%define! RetVal
%include Common\FreeRTOSxTaskNotify.Inc
/*
BaseType_t %'ModuleName'%.%xTaskNotify(TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xTaskNotify
%-BW_METHOD_END xTaskNotify
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTaskNotifyFromISR
%ifdef xTaskNotifyFromISR
%define! ParxTaskToNotify
%define! ParulValue
%define! PareAction
%define! ParpxHigherPriorityTaskWoken
%define! RetVal
%include Common\FreeRTOSxTaskNotifyFromISR.Inc
/*
BaseType_t %'ModuleName'%.%xTaskNotifyFromISR(TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, BaseType_t *pxHigherPriorityTaskWoken)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xTaskNotifyFromISR
%-BW_METHOD_END xTaskNotifyFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTaskNotifyWait
%ifdef xTaskNotifyWait
%define! ParulBitsToClearOnEntry
%define! ParulBitsToClearOnExit
%define! ParpulNotificationValue
%define! ParxTicksToWait
%define! RetVal
%include Common\FreeRTOSxTaskNotifyWait.Inc
/*
BaseType_t %'ModuleName'%.%xTaskNotifyWait(uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xTaskNotifyWait
%-BW_METHOD_END xTaskNotifyWait
%-************************************************************************************************************
%-BW_METHOD_BEGIN vTaskSetThreadLocalStoragePointer
%ifdef vTaskSetThreadLocalStoragePointer
%define! ParxTaskToSet
%define! ParxIndex
%define! ParpvValue
%include Common\FreeRTOSvTaskSetThreadLocalStoragePointer.Inc
/*
void %'ModuleName'%.%vTaskSetThreadLocalStoragePointer(TaskHandle_t xTaskToSet, BaseType_t xIndex, void *pvValue)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- vTaskSetThreadLocalStoragePointer
%-BW_METHOD_END vTaskSetThreadLocalStoragePointer
%-************************************************************************************************************
%-BW_METHOD_BEGIN pvTaskGetThreadLocalStoragePointer
%ifdef pvTaskGetThreadLocalStoragePointer
%define! ParxTaskToQuery
%define! ParxIndex
%define! RetVal
%include Common\FreeRTOSpvTaskGetThreadLocalStoragePointer.Inc
/*
void* %'ModuleName'%.%pvTaskGetThreadLocalStoragePointer(TaskHandle_t xTaskToQuery, BaseType_t xIndex)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- pvTaskGetThreadLocalStoragePointer
%-BW_METHOD_END pvTaskGetThreadLocalStoragePointer
%-************************************************************************************************************
%-BW_METHOD_BEGIN xSemaphoreCreateBinary
%ifdef xSemaphoreCreateBinary
%define! RetVal
%include Common\FreeRTOSxSemaphoreCreateBinary.Inc
/*
SemaphoreHandle_t %'ModuleName'%.%xSemaphoreCreateBinary(void)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xSemaphoreCreateBinary
%-BW_METHOD_END xSemaphoreCreateBinary
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTaskNotifyAndQuery
%ifdef xTaskNotifyAndQuery
%define! ParxTaskToNotify
%define! ParulValue
%define! PareAction
%define! ParpulPreviousNotifyValue
%define! RetVal
%include Common\FreeRTOSxTaskNotifyAndQuery.Inc
/*
BaseType_t %'ModuleName'%.%xTaskNotifyAndQuery(TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotifyValue)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xTaskNotifyAndQuery
%-BW_METHOD_END xTaskNotifyAndQuery
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTaskNotifyAndQueryFromISR
%ifdef xTaskNotifyAndQueryFromISR
%define! ParxTaskToNotify
%define! ParulValue
%define! PareAction
%define! ParpulPreviousNotifyValue
%define! ParpxHigherPriorityTaskWoken
%define! RetVal
%include Common\FreeRTOSxTaskNotifyAndQueryFromISR.Inc
/*
BaseType_t %'ModuleName'%.%xTaskNotifyAndQueryFromISR(TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotifyValue, BaseType_t *pxHigherPriorityTaskWoken)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xTaskNotifyAndQueryFromISR
%-BW_METHOD_END xTaskNotifyAndQueryFromISR
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTaskNotifyStateClear
%ifdef xTaskNotifyStateClear
%define! ParxTask
%define! RetVal
%include Common\FreeRTOSxTaskNotifyStateClear.Inc
/*
BaseType_t %'ModuleName'%.%xTaskNotifyStateClear(TaskHandle_t xTask)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xTaskNotifyStateClear
%-BW_METHOD_END xTaskNotifyStateClear
%-************************************************************************************************************
%-BW_METHOD_BEGIN Deinit
%ifdef Deinit
%include Common\FreeRTOSDeinit.Inc
void %'ModuleName'%.%Deinit(void)
{
  /* nothing needed */
}

%endif %- Deinit
%-BW_METHOD_END Deinit
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTaskGetHandle
%ifdef xTaskGetHandle
%define! ParpcNameToQuery
%define! RetVal
%include Common\FreeRTOSxTaskGetHandle.Inc
/*
TaskHandle_t %'ModuleName'%.%xTaskGetHandle(const char *pcNameToQuery )
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xTaskGetHandle
%-BW_METHOD_END xTaskGetHandle
%-************************************************************************************************************
%-BW_METHOD_BEGIN pcTaskGetName
%ifdef pcTaskGetName
%define! ParxTaskToQuery
%define! RetVal
%include Common\FreeRTOSpcTaskGetName.Inc
/*
char* %'ModuleName'%.%pcTaskGetName(TaskHandle_t xTaskToQuery)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- pcTaskGetName
%-BW_METHOD_END pcTaskGetName
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTaskCreateStatic
%ifdef xTaskCreateStatic
%define! ParpvTaskCode
%define! ParpcName
%define! ParusStackDepth
%define! ParpvParameters
%define! ParuxPriority
%define! ParpuxStackBuffer
%define! ParpxTaskBuffer
%define! RetVal
%include Common\FreeRTOSxTaskCreateStatic.Inc
/*
TaskHandle_t %'ModuleName'%.%xTaskCreateStatic(pdTASK_CODE pvTaskCode, const portCHAR * const pcName, unsigned portSHORT usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, StackType_t * const puxStackBuffer, StaticTask_t * const pxTaskBuffer)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xTaskCreateStatic
%-BW_METHOD_END xTaskCreateStatic
%-************************************************************************************************************
%-BW_METHOD_BEGIN xQueueCreateStatic
%ifdef xQueueCreateStatic
%define! ParuxQueueLength
%define! ParuxItemSize
%define! ParpucQueueStorageBuffer
%define! ParpxQueueBuffer
%define! RetVal
%include Common\FreeRTOSxQueueCreateStatic.Inc
/*
xQueueHandle %'ModuleName'%.%xQueueCreateStatic(unsigned_portBASE_TYPE uxQueueLength, unsigned_portBASE_TYPE uxItemSize, uint8_t *pucQueueStorageBuffer, StaticQueue_t *pxQueueBuffer)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xQueueCreateStatic
%-BW_METHOD_END xQueueCreateStatic
%-************************************************************************************************************
%-BW_METHOD_BEGIN xEventGroupCreateStatic
%ifdef xEventGroupCreateStatic
%define! ParpxEventGroupBuffer
%define! RetVal
%include Common\FreeRTOSxEventGroupCreateStatic.Inc
/*
EventGroupHandle_t %'ModuleName'%.%xEventGroupCreateStatic(StaticEventGroup_t *pxEventGroupBuffer)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xEventGroupCreateStatic
%-BW_METHOD_END xEventGroupCreateStatic
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTimerCreateStatic
%ifdef xTimerCreateStatic
%define! ParpcTimerName
%define! ParxTimerPeriod
%define! ParuxAutoReload
%define! ParpvTimerID
%define! ParpxCallbackFunction
%define! ParpxTimerBuffer
%define! RetVal
%include Common\FreeRTOSxTimerCreateStatic.Inc
/*
TimerHandle_t %'ModuleName'%.%xTimerCreateStatic(const char * const pcTimerName, const TickType_t xTimerPeriod, const UBaseType_t uxAutoReload, void *const pvTimerID, TimerCallbackFunction_t pxCallbackFunction, StaticTimer_t *pxTimerBuffer)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xTimerCreateStatic
%-BW_METHOD_END xTimerCreateStatic
%-************************************************************************************************************
%-BW_METHOD_BEGIN xSemaphoreCreateBinaryStatic
%ifdef xSemaphoreCreateBinaryStatic
%define! ParpxSemaphoreBuffer
%define! RetVal
%include Common\FreeRTOSxSemaphoreCreateBinaryStatic.Inc
/*
SemaphoreHandle_t %'ModuleName'%.%xSemaphoreCreateBinaryStatic(StaticSemaphore_t *pxSemaphoreBuffer)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xSemaphoreCreateBinaryStatic
%-BW_METHOD_END xSemaphoreCreateBinaryStatic
%-************************************************************************************************************
%-BW_METHOD_BEGIN xSemaphoreCreateCountingStatic
%ifdef xSemaphoreCreateCountingStatic
%define! ParuxMaxCount
%define! ParuxInitialCount
%define! ParpxSempahoreBuffer
%define! RetVal
%include Common\FreeRTOSxSemaphoreCreateCountingStatic.Inc
/*
xSemaphoreHandle %'ModuleName'%.%xSemaphoreCreateCountingStatic(unsigned_portBASE_TYPE uxMaxCount, unsigned_portBASE_TYPE uxInitialCount, StaticSemaphore_t pxSempahoreBuffer)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xSemaphoreCreateCountingStatic
%-BW_METHOD_END xSemaphoreCreateCountingStatic
%-************************************************************************************************************
%-BW_METHOD_BEGIN xSemaphoreCreateMutexStatic
%ifdef xSemaphoreCreateMutexStatic
%define! ParVariable_1
%define! RetVal
%include Common\FreeRTOSxSemaphoreCreateMutexStatic.Inc
/*
xSemaphoreHandle %'ModuleName'%.%xSemaphoreCreateMutexStatic(StaticSemaphore_t *pxMutexBuffer)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xSemaphoreCreateMutexStatic
%-BW_METHOD_END xSemaphoreCreateMutexStatic
%-************************************************************************************************************
%-BW_METHOD_BEGIN xTaskAbortDelay
%ifdef xTaskAbortDelay
%define! ParxTask
%define! RetVal
%include Common\FreeRTOSxTaskAbortDelay.Inc
/*
BaseType_t %'ModuleName'%.%xTaskAbortDelay(TaskHandle_t xTask)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xTaskAbortDelay
%-BW_METHOD_END xTaskAbortDelay
%-************************************************************************************************************
%-BW_METHOD_BEGIN vTaskGetInfo
%ifdef vTaskGetInfo
%define! ParxTask
%define! ParpxTaskStatus
%define! ParxGetFreeStackSpace
%define! PareState
%include Common\FreeRTOSvTaskGetInfo.Inc
/*
void %'ModuleName'%.%vTaskGetInfo(TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- vTaskGetInfo
%-BW_METHOD_END vTaskGetInfo
%-************************************************************************************************************
%-BW_METHOD_BEGIN uxSemaphoreGetCount
%ifdef uxSemaphoreGetCount
%define! ParxSemaphore
%define! RetVal
%include Common\FreeRTOSuxSemaphoreGetCount.Inc
/*
UBaseType_t %'ModuleName'%.%uxSemaphoreGetCount(SemaphoreHandle_t xSemaphore)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- uxSemaphoreGetCount
%-BW_METHOD_END uxSemaphoreGetCount
%-************************************************************************************************************
%-BW_METHOD_BEGIN xSemaphoreCreateRecursiveMutexStatic
%ifdef xSemaphoreCreateRecursiveMutexStatic
%define! ParVariable_1
%define! RetVal
%include Common\FreeRTOSxSemaphoreCreateRecursiveMutexStatic.Inc
/*
xSemaphoreHandle %'ModuleName'%.%xSemaphoreCreateRecursiveMutexStatic(StaticSemaphore_t *pxMutexBuffer)
{
  *** Implemented as macro in the header file %'ModuleName'.h
}
*/

%endif %- xSemaphoreCreateRecursiveMutexStatic
%-BW_METHOD_END xSemaphoreCreateRecursiveMutexStatic
%-************************************************************************************************************
%-BW_METHOD_BEGIN AppConfigureTimerForRuntimeStats
%ifdef AppConfigureTimerForRuntimeStats
%include Common\FreeRTOSAppConfigureTimerForRuntimeStats.Inc
#if configGENERATE_RUN_TIME_STATS
void %'ModuleName'%.%AppConfigureTimerForRuntimeStats(void)
{
#if configGENERATE_RUN_TIME_STATS_USE_TICKS
  /* nothing needed, the RTOS will initialize the tick counter */
#else
  extern uint32_t %'ModuleName'%.RunTimeCounter; /* runtime counter, used for configGENERATE_RUNTIME_STATS */
  %'ModuleName'%.RunTimeCounter = 0;
%if defined(RuntimeCntr)
  (void)%@RuntimeCntr@'ModuleName'%.Enable();
%elif defined(RuntimeCntrLDD)
  %'ModuleName'%.RunTimeCounterHandle = %@RuntimeCntrLDD@'ModuleName'%.Init(NULL);
  (void)%@RuntimeCntrLDD@'ModuleName'%.Enable(%'ModuleName'%.RunTimeCounterHandle);
%endif
#endif
}

%endif %- AppConfigureTimerForRuntimeStats
#endif /* configGENERATE_RUN_TIME_STATS */
%-BW_METHOD_END AppConfigureTimerForRuntimeStats
%-************************************************************************************************************
%-BW_METHOD_BEGIN AppGetRuntimeCounterValueFromISR
%ifdef AppGetRuntimeCounterValueFromISR
%define! RetVal
%include Common\FreeRTOSAppGetRuntimeCounterValueFromISR.Inc
uint32_t %'ModuleName'%.%AppGetRuntimeCounterValueFromISR(void)
{
#if configGENERATE_RUN_TIME_STATS
  #if configGENERATE_RUN_TIME_STATS_USE_TICKS
  return xTaskGetTickCountFromISR(); /* using RTOS tick counter */
  #else /* using timer counter */
  extern uint32_t %'ModuleName'%.RunTimeCounter; /* runtime counter, used for configGENERATE_RUNTIME_STATS */
  return %'ModuleName'%.RunTimeCounter;
  #endif
#else
  return 0; /* dummy value */
#endif
}

%endif %- AppGetRuntimeCounterValueFromISR
%-BW_METHOD_END AppGetRuntimeCounterValueFromISR
%-BW_IMPLEMENT_END
#endif /* %@KinetisSDK@'ModuleName'%.CONFIG_SDK_USE_FREERTOS */
/* END %ModuleName. */

%include Common\Header.End
%-
%-
%-BW_EVENT_IMPLEMENT_START
%-BW_METHOD_BEGIN vApplicationStackOverflowHook
%ifdef vApplicationStackOverflowHook
%IMPLEMENTATION vApplicationStackOverflowHook
%define! ParpxTask
%define! ParpcTaskName
%include Common\FreeRTOSvApplicationStackOverflowHook.Inc
void %vApplicationStackOverflowHook(TaskHandle_t pxTask, char *pcTaskName)
{
  /* This will get called if a stack overflow is detected during the context
     switch.  Set configCHECK_FOR_STACK_OVERFLOWS to 2 to also check for stack
     problems within nested interrupts, but only do this for debug purposes as
     it will increase the context switch time. */
  (void)pxTask;
  (void)pcTaskName;
  taskDISABLE_INTERRUPTS();
#if %@KinetisSDK@'ModuleName'%.CONFIG_CPU_IS_ARM_CORTEX_M
    __asm volatile("bkpt #0");
#elif %@KinetisSDK@'ModuleName'%.CONFIG_CPU_IS_RISC_V
    __asm volatile( "ebreak" );
#endif
  /* Write your code here ... */
  for(;;) {}
}

%endif %- vApplicationStackOverflowHook
%-BW_METHOD_END vApplicationStackOverflowHook
%-BW_METHOD_BEGIN vApplicationTickHook
%ifdef vApplicationTickHook
%IMPLEMENTATION vApplicationTickHook
%include Common\FreeRTOSvApplicationTickHook.Inc
void %vApplicationTickHook(void)
{
  /* Called for every RTOS tick. */
  /* Write your code here ... */
}

%endif %- vApplicationTickHook
%-BW_METHOD_END vApplicationTickHook
%-BW_METHOD_BEGIN vApplicationIdleHook
%ifdef vApplicationIdleHook
%IMPLEMENTATION vApplicationIdleHook
%include Common\FreeRTOSvApplicationIdleHook.Inc
void %vApplicationIdleHook(void)
{
  /* Called whenever the RTOS is idle (from the IDLE task).
     Here would be a good place to put the CPU into low power mode. */
%if (CPUfamily = "HCS08") | (CPUfamily = "HC08") | (CPUfamily = "ColdFireV1")
#if 0
  /* To put the CPU into lower power WAIT mode:
     - Make sure that in the CPU component the method 'SetWaitMode()' is enabled
     - Enable this code block (change '#if 0' to '#if 1')
   */
    %'ProcessorModule'%.SetWaitMode();
#endif
%elif (CPUfamily = "MCF")
#if 0
  /* To put the ColdFire V2 CPU into low power WAIT mode:
     - In the CPU component, go to 'Properties > Internal peripherals > PowerManagement > Low-power mode'
       - Set 'Low-power stop mode' to 'Enabled'
       - Set 'Low-power mode select' to 'WAIT'
     - Enable this code block (change '#if 0' to '#if 1')
     - Note: if you are using USB then putting the CPU into lower power mode might impact USB communication.
   */
    __asm("stop #0x2000"); /* put CPU into stop mode */
#endif
%endif
  /* Write your code here ... */
}

%endif %- vApplicationIdleHook
%-BW_METHOD_END vApplicationIdleHook
%-BW_METHOD_BEGIN vApplicationMallocFailedHook
%ifdef vApplicationMallocFailedHook
%IMPLEMENTATION vApplicationMallocFailedHook
%include Common\FreeRTOSvApplicationMallocFailedHook.Inc
void %vApplicationMallocFailedHook(void)
{
  /* Called if a call to pvPortMalloc() fails because there is insufficient
     free memory available in the FreeRTOS heap.  pvPortMalloc() is called
     internally by FreeRTOS API functions that create tasks, queues, software
     timers, and semaphores.  The size of the FreeRTOS heap is set by the
     configTOTAL_HEAP_SIZE configuration constant in FreeRTOSConfig.h. */
  taskDISABLE_INTERRUPTS();
  /* Write your code here ... */
#if %@KinetisSDK@'ModuleName'%.CONFIG_CPU_IS_ARM_CORTEX_M
    __asm volatile("bkpt #0");
#elif %@KinetisSDK@'ModuleName'%.CONFIG_CPU_IS_RISC_V
    __asm volatile( "ebreak" );
#endif
  for(;;) {}
}

%endif %- vApplicationMallocFailedHook
%-BW_METHOD_END vApplicationMallocFailedHook
%-BW_METHOD_BEGIN vOnPostSleepProcessing
%ifdef vOnPostSleepProcessing
%IMPLEMENTATION vOnPostSleepProcessing
%define! ParexpectedIdleTicks
%include Common\FreeRTOSvOnPostSleepProcessing.Inc
void %vOnPostSleepProcessing(TickType_t expectedIdleTicks)
{
  (void)expectedIdleTicks; /* not used (yet?) */
  /* Write your code here ... */
}

%endif %- vOnPostSleepProcessing
%-BW_METHOD_END vOnPostSleepProcessing
%-BW_METHOD_BEGIN vOnPreSleepProcessing
%ifdef vOnPreSleepProcessing
%IMPLEMENTATION vOnPreSleepProcessing
%define! ParexpectedIdleTicks
%include Common\FreeRTOSvOnPreSleepProcessing.Inc
void %vOnPreSleepProcessing(TickType_t expectedIdleTicks)
{
  (void)expectedIdleTicks; /* not used */
%if (CPUfamily = "Kinetis")
#if 1
%else
#if 0
%endif
  /* example for Kinetis (enable SetOperationMode() in CPU component): */
  /* Cpu_SetOperationMode(DOM_WAIT, NULL, NULL); */ /* Processor Expert way to get into WAIT mode */
  /* or to wait for interrupt: */
    __asm volatile("dsb");
    __asm volatile("wfi");
    __asm volatile("isb");
%if (CPUfamily = "HCS08") | (CPUfamily = "HC08") | (CPUfamily = "ColdFireV1")
#elif 1
%else
#elif 0
%endif
  /* example for S08/S12/ColdFire V1 (enable SetWaitMode() in CPU): */
  Cpu_SetWaitMode();
%if (CPUfamily = "MCF")
#elif 1
%else
#elif 0
%endif
  /* example for ColdFire V2: */
   __asm("stop #0x2000"); */
#else
  #error "you *must* enter low power mode (wait for interrupt) here!"
#endif
  /* Write your code here ... */
}

%endif %- vOnPreSleepProcessing
%-BW_METHOD_END vOnPreSleepProcessing
%-BW_EVENT_IMPLEMENT_END
%INITIALIZATION
%CODE_BEGIN
%if (CPUfamily = "S32K")
#ifdef CPU_INIT_MCUONECLIPSE_DRIVERS
%endif
  /* PEX_RTOS_INIT() is a macro should already have been called either from main()
     or Processor Expert startup code. So we don't call it here again. */
  /* PEX_RTOS_INIT(); */ /* ### %DeviceType "%DeviceName" init code ... */
%if (CPUfamily = "S32K")
#endif
%endif
%CODE_END
%-
%ENABLE
%CODE_BEGIN
%CODE_END
%-
%-----------------------------------------------------------------------------------------
%if defined(KinetisSDK) & %@KinetisSDK@ConfigFilesFolderName <> ""
  %define  ConfigSrcDirFolder %%@KinetisSDK@ConfigFilesFolderName/
%else
  %define  ConfigSrcDirFolder
%endif
%----------------------------
%FILE %'DirRel_Code'%'ConfigSrcDirFolder'%'RtosComponentConfigHeaderFileName'
/**
 * \file
 * \brief Configuration header file for FreeRTOS component
 * Copyright (c) 2020, Erich Styger
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * This header file is used to configure settings of the FreeRTOS module.
 */
 #ifndef __%'ModuleName'_CONFIG_H
#define __%'ModuleName'_CONFIG_H

#include "%@KinetisSDK@ModuleName.h" /* SDK and API used */

%if (CPUfamily = "ColdFireV1") | (CPUfamily = "HCS08") | (CPUfamily = "HC08")
#include <hidef.h>
%endif
/* -------------------------------------------------------------------- */
/* Macros to identify the compiler used: */
#define configCOMPILER_ARM_GCC                                   %>50 1 /* GNU ARM gcc compiler */
#define configCOMPILER_ARM_IAR                                   %>50 2 /* IAR ARM compiler */
#define configCOMPILER_ARM_FSL                                   %>50 3 /* Legacy Freescale ARM compiler */
#define configCOMPILER_ARM_KEIL                                  %>50 4 /* ARM/Keil compiler */
#define configCOMPILER_S08_FSL                                   %>50 5 /* Freescale HCS08 compiler */
#define configCOMPILER_S12_FSL                                   %>50 6 /* Freescale HCS12(X) compiler */
#define configCOMPILER_CF1_FSL                                   %>50 7 /* Freescale ColdFire V1 compiler */
#define configCOMPILER_CF2_FSL                                   %>50 8 /* Freescale ColdFire V2 compiler */
#define configCOMPILER_DSC_FSL                                   %>50 9 /* Freescale DSC compiler */

%if (%configCOMPILER='automatic')
%if (%Compiler = "IARARM")
#define configCOMPILER                                           %>50 configCOMPILER_ARM_IAR
%elif (%Compiler = "GNUC")
#define configCOMPILER                                           %>50 configCOMPILER_ARM_GCC
%elif (%Compiler = "CodeWarriorARM")
#define configCOMPILER                                           %>50 configCOMPILER_ARM_FSL
%elif (%Compiler = "ARM_CC")
#define configCOMPILER                                           %>50 configCOMPILER_ARM_KEIL
%elif (%Compiler = "MetrowerksHC08CC") | (%Compiler = "MetrowerksHCS08CC")
#define configCOMPILER                                           %>50 configCOMPILER_S08_FSL
%elif (%Compiler = "MetrowerksHC12CC") | (%Compiler = "MetrowerksHC12XCC")
#define configCOMPILER                                           %>50 configCOMPILER_S12_FSL
%elif (%Compiler = "CodeWarriorColdFireV1")
#define configCOMPILER                                           %>50 configCOMPILER_CF1_FSL
%elif (%Compiler = "CodeWarriorMCF")
#define configCOMPILER                                           %>50 configCOMPILER_CF2_FSL
%elif (%Compiler = "MetrowerksDSP")
#define configCOMPILER                                           %>50 configCOMPILER_DSC_FSL
%else
#define configCOMPILER                                           %>50 0
#error "unknown compiler %Compiler?"
%endif
%else %- non-automatic compiler selection
#define configCOMPILER                                           %>50 %configCompiler
%endif
/* -------------------------------------------------------------------- */
/* CPU family identification */
#define configCPU_FAMILY_S08                                     %>50 1   /* S08 core */
#define configCPU_FAMILY_S12                                     %>50 2   /* S12(X) core */
#define configCPU_FAMILY_CF1                                     %>50 3   /* ColdFire V1 core */
#define configCPU_FAMILY_CF2                                     %>50 4   /* ColdFire V2 core */
#define configCPU_FAMILY_DSC                                     %>50 5   /* 56800/DSC */
#define configCPU_FAMILY_ARM_M0P                                 %>50 6   /* ARM Cortex-M0+ */
#define configCPU_FAMILY_ARM_M3                                  %>50 7   /* ARM Cortex-M3 */
#define configCPU_FAMILY_ARM_M4                                  %>50 8   /* ARM Cortex-M4 */
#define configCPU_FAMILY_ARM_M4F                                 %>50 9   /* ARM Cortex-M4F (with floating point unit) */
#define configCPU_FAMILY_ARM_M7                                  %>50 10  /* ARM Cortex-M7 */
#define configCPU_FAMILY_ARM_M7F                                 %>50 11  /* ARM Cortex-M7F (with floating point unit) */
#define configCPU_FAMILY_ARM_M33                                 %>50 12  /* ARM Cortex-M33 */
#define configCPU_FAMILY_ARM_M33F                                %>50 13  /* ARM Cortex-M33F (with floating point unit) */
#define configCPU_FAMILY_RISC_V                                  %>50 14  /* RISC-V */

/* Macros to identify set of core families */
#define configCPU_FAMILY_IS_ARM_M0(fam)                          %>50 ((fam)==configCPU_FAMILY_ARM_M0P)
#define configCPU_FAMILY_IS_ARM_M3(fam)                          %>50 ((fam)==configCPU_FAMILY_ARM_M3)
#define configCPU_FAMILY_IS_ARM_M4(fam)                          %>50 (((fam)==configCPU_FAMILY_ARM_M4)  || ((fam)==configCPU_FAMILY_ARM_M4F))
#define configCPU_FAMILY_IS_ARM_M7(fam)                          %>50 (((fam)==configCPU_FAMILY_ARM_M7)  || ((fam)==configCPU_FAMILY_ARM_M7F))
#define configCPU_FAMILY_IS_ARM_M4_M7(fam)                       %>50 (configCPU_FAMILY_IS_ARM_M4(fam)   || configCPU_FAMILY_IS_ARM_M7(fam))
#define configCPU_FAMILY_IS_ARM_M33(fam)                         %>50 (((fam)==configCPU_FAMILY_ARM_M33) || ((fam)==configCPU_FAMILY_ARM_M33F))
#define configCPU_FAMILY_IS_ARM_FPU(fam)                         %>50 (((fam)==configCPU_FAMILY_ARM_M4F) || ((fam)==configCPU_FAMILY_ARM_M7F) || ((fam)==configCPU_FAMILY_ARM_M33F))
#define configCPU_FAMILY_IS_ARM(fam)                             %>50 (configCPU_FAMILY_IS_ARM_M0(fam) || configCPU_FAMILY_IS_ARM_M4(fam) || configCPU_FAMILY_IS_ARM_M7(fam) || configCPU_FAMILY_IS_ARM_M33(fam))

#if %@KinetisSDK@'ModuleName'%.CONFIG_CPU_IS_ARM_CORTEX_M
  /* determine core based on library configuration */
  #if %@KinetisSDK@'ModuleName'%.CONFIG_CORTEX_M==0
    #define configCPU_FAMILY                                     %>50 configCPU_FAMILY_ARM_M0P
  #elif %@KinetisSDK@'ModuleName'%.CONFIG_CORTEX_M==3
    #define configCPU_FAMILY                                     %>50 configCPU_FAMILY_ARM_M3
  #elif %@KinetisSDK@'ModuleName'%.CONFIG_CORTEX_M==4 && %@KinetisSDK@'ModuleName'%.CONFIG_FPU_PRESENT
    #define configCPU_FAMILY                                     %>50 configCPU_FAMILY_ARM_M4F
  #elif %@KinetisSDK@'ModuleName'%.CONFIG_CORTEX_M==4
    #define configCPU_FAMILY                                     %>50 configCPU_FAMILY_ARM_M4
  #elif %@KinetisSDK@'ModuleName'%.CONFIG_CORTEX_M==7 && %@KinetisSDK@'ModuleName'%.CONFIG_FPU_PRESENT
    #define configCPU_FAMILY                                     %>50 configCPU_FAMILY_ARM_M7F
  #elif %@KinetisSDK@'ModuleName'%.CONFIG_CORTEX_M==7
    #define configCPU_FAMILY                                     %>50 configCPU_FAMILY_ARM_M7
  #elif %@KinetisSDK@'ModuleName'%.CONFIG_CORTEX_M==33 && %@KinetisSDK@'ModuleName'%.CONFIG_FPU_PRESENT
    #define configCPU_FAMILY                                     %>50 configCPU_FAMILY_ARM_M33F
  #elif %@KinetisSDK@'ModuleName'%.CONFIG_CORTEX_M==33
    #define configCPU_FAMILY                                     %>50 configCPU_FAMILY_ARM_M33
  #else
    #error "unsupported configuaration!"
  #endif
#elif %@KinetisSDK@'ModuleName'%.CONFIG_CPU_IS_RISC_V
  #define configCPU_FAMILY                                       %>50 configCPU_FAMILY_RISC_V
#else /* default CPU family */
%if (CPUfamily = "HCS08") | (CPUfamily = "HC08")
  #define configCPU_FAMILY                                       %>50 configCPU_FAMILY_S08
%elif (CPUfamily = "HCS12") | (CPUfamily = "HCS12X")
  #define configCPU_FAMILY                                       %>50 configCPU_FAMILY_S12
%elif (CPUfamily = "ColdFireV1")
  #define configCPU_FAMILY                                       %>50 configCPU_FAMILY_CF1
%elif (CPUfamily = "MCF")
  #define configCPU_FAMILY                                       %>50 configCPU_FAMILY_CF2
%elif (CPUfamily = "56800")
  #define configCPU_FAMILY                                       %>50 configCPU_FAMILY_DSC
%elif (CPUfamily = "Kinetis")
%if %CPUDB_prph_has_feature(CPU,ARM_CORTEX_M0P) = 'yes' %- Note: for IAR this is defined in portasm.s too!
  #define configCPU_FAMILY                                       %>50 configCPU_FAMILY_ARM_M0P
%elif %ARMFamilyType="M7"
  #define configCPU_FAMILY                                       %>50 configCPU_FAMILY_ARM_M7
%elif %ARMFamilyType="M7F"
  #define configCPU_FAMILY                                       %>50 configCPU_FAMILY_ARM_M7F
%else %-M4, M4F or M7
 %if %CPUDB_prph_has_feature(CPU, FPU) = 'no'
  #define configCPU_FAMILY                                       %>50 configCPU_FAMILY_ARM_M4
 %else
  #define configCPU_FAMILY                                       %>50 configCPU_FAMILY_ARM_M4F
 %endif
%endif
%else
  #define configCPU_FAMILY                                       %>50 0
  #error "Unknown CPU family %CPUfamily?"
%endif
#endif

#ifndef configENABLE_MPU
%if defined(useMPUsupport) & %useMPUsupport='yes'
  #define configENABLE_MPU                                       %>50 (1 && (configCPU_FAMILY_IS_ARM_M4(configCPU_FAMILY)||configCPU_FAMILY_IS_ARM_M33(configCPU_FAMILY)))
%else
  #define configENABLE_MPU                                       %>50 (0 && (configCPU_FAMILY_IS_ARM_M4(configCPU_FAMILY)||configCPU_FAMILY_IS_ARM_M33(configCPU_FAMILY)))
%endif
  /*!< 1: enable MPU support; 0: MPU support is disabled */
#endif

#ifndef configENABLE_FPU
  #define configENABLE_FPU                                       %>50 (1 && %@KinetisSDK@'ModuleName'%.CONFIG_FPU_PRESENT)
    /*!< 1: enable FPU support; 0: FPU support is disabled */
#endif

#ifndef configENABLE_TRUSTZONE
  #define configENABLE_TRUSTZONE                                 %>50 (0 && configCPU_FAMILY_IS_ARM_M33(configCPU_FAMILY))
    /*!< 1: enable ARM TrustZone support; 0: TrustZone support is disabled */
#endif

/*-----------------------------------------------------------
 * GDB backtrace handler support
 * See http://interactive.freertos.org/entries/23468301-Tasks-backtrace-switcher-viewer-snippet-for-debugger-gcc-gdb-ARM-Cortex-M3-MPU-port-Eclipse-support-
 *----------------------------------------------------------*/
#ifndef configGDB_HELPER
%if defined(EnableGDBDebugHelper) & %EnableGDBDebugHelper='yes'
  #define configGDB_HELPER                                       %>50 (1 && configCPU_FAMILY_IS_ARM(configCPU_FAMILY) && (configCOMPILER==configCOMPILER_ARM_GCC))
%else
  #define configGDB_HELPER                                       %>50 (0 && configCPU_FAMILY_IS_ARM(configCPU_FAMILY) && (configCOMPILER==configCOMPILER_ARM_GCC))
%endif
   /*!< 1: enable special GDB stack backtrace debug helper; 0: disabled */
#endif

#ifndef configLTO_HELPER
%if defined(EnableLTODebugHelper) & %EnableLTODebugHelper='yes'
  #define configLTO_HELPER                                       %>50 (1 && configCPU_FAMILY_IS_ARM(configCPU_FAMILY) && (configCOMPILER==configCOMPILER_ARM_GCC))
%else
  #define configLTO_HELPER                                       %>50 (0 && configCPU_FAMILY_IS_ARM(configCPU_FAMILY) && (configCOMPILER==configCOMPILER_ARM_GCC))
%endif
   /*!< 1: enable special GNU Link Time Optimizer (-lto) debug helper code; 0: disabled */
#endif

#ifndef configHEAP_SCHEME_IDENTIFICATION
%if defined(freeRTOSMemorySchemeConstant) & %freeRTOSMemorySchemeConstant='yes'
  #define configHEAP_SCHEME_IDENTIFICATION                       %>50 (1 && configCPU_FAMILY_IS_ARM(configCPU_FAMILY))
%else
  #define configHEAP_SCHEME_IDENTIFICATION                       %>50 (0 && configCPU_FAMILY_IS_ARM(configCPU_FAMILY))
%endif
   /*!< 1: use constant freeRTOSMemoryScheme to identify memory scheme; 0: no constant used */
#endif

#ifndef configUSE_TOP_USED_PRIORITY
%if defined(uxTopUsedPriority) & %uxTopUsedPriority='yes'
  #define configUSE_TOP_USED_PRIORITY                            %>50 (1 && configCPU_FAMILY_IS_ARM(configCPU_FAMILY))
%else
  #define configUSE_TOP_USED_PRIORITY                            %>50 (0 && configCPU_FAMILY_IS_ARM(configCPU_FAMILY))
%endif
   /*!< 1: Makes sure uxTopUsedPriority is present (needed for SEGGER and OpenOCD thread aware debugging); 0: no special reference to uxTopUsedPriority */
#endif

#ifndef configLINKER_HEAP_BASE_SYMBOL
#if %@KinetisSDK@'ModuleName'%.CONFIG_NXP_SDK_USED
  #define configLINKER_HEAP_BASE_SYMBOL                          %>50 _pvHeapStart
#else
%if defined(LinkerHeapBaseSymbolName)
  #define configLINKER_HEAP_BASE_SYMBOL                          %>50 %LinkerHeapBaseSymbolName
%else
  #define configLINKER_HEAP_BASE_SYMBOL                          %>50 __HeapBase
%endif
#endif
    /*!< Linker symbol used to denote the base address of the heap, used for heap memory scheme 6 (newlib). (KDS: __HeapBase, MCUXpresso: _pvHeapStart)  */
#endif

#ifndef configLINKER_HEAP_LIMIT_SYMBOL
#if %@KinetisSDK@'ModuleName'%.CONFIG_NXP_SDK_USED
  #define configLINKER_HEAP_LIMIT_SYMBOL                         %>50 _pvHeapLimit
#else
%if defined(LinkerHeapLimitSymbolName)
  #define configLINKER_HEAP_LIMIT_SYMBOL                         %>50 %LinkerHeapLimitSymbolName
%else
  #define configLINKER_HEAP_LIMIT_SYMBOL                         %>50 __HeapLimit
%endif
#endif
    /*!< Linker symbol used to denote the limit address of the heap, used for heap memory scheme 6 (newlib). (KDS: __HeapLimit, MCUXpresso: _pvHeapLimit)  */
#endif

#ifndef configLINKER_HEAP_SIZE_SYMBOL
#if %@KinetisSDK@'ModuleName'%.CONFIG_NXP_SDK_USED
  #define configLINKER_HEAP_SIZE_SYMBOL                          %>50 _HeapSize
#else
%if defined(LinkerHeapSizeSymbolName)
  #define configLINKER_HEAP_SIZE_SYMBOL                          %>50 %LinkerHeapSizeSymbolName
%else
  #define configLINKER_HEAP_SIZE_SYMBOL                          %>50 __heap_size
%endif
#endif
    /*!< Linker symbol used to denote the size of the heap, used for heap memory scheme 6 (newlib). (KDS: __heap_size, MCUXpresso: _HeapSize) */
#endif

#ifndef configUSE_SHELL
%if defined(Shell)
  #define configUSE_SHELL                                        %>50 (1)
%else
  #define configUSE_SHELL                                        %>50 (0)
%endif
   /*!< 1: enable Shell and command line support; 0: disabled */
#endif

#ifndef configRESET_MSP
%if defined(ResetMSP) & %ResetMSP='yes'
  #define configRESET_MSP                                        %>50 (1)
%else
  #define configRESET_MSP                                        %>50 (0)
%endif
   /*!< 1: reset MSP at scheduler start (Cortex M3/M4/M7 only); 0: do not reset MSP */
#endif

/*-----------------------------------------------------------
 * FreeRTOS Trace hook support
 *----------------------------------------------------------- */
#ifndef configUSE_PERCEPIO_TRACE_HOOKS
%if defined(UseTraceHooksGroup) & %UseTraceHooksGroup='yes' & defined(FRTrace)
  #define configUSE_PERCEPIO_TRACE_HOOKS                         %>50 1 /* 1: Percepio Trace hooks, 0: not using Percepio Trace hooks */
%else
  #define configUSE_PERCEPIO_TRACE_HOOKS                         %>50 0 /* 1: Percepio Trace hooks, 0: not using Percepio Trace hooks */
%endif
#endif
#define configUSE_TRACE_HOOKS                                    %>50 configUSE_PERCEPIO_TRACE_HOOKS /* legacy configUSE_TRACE_HOOKS should not be used any more */

#ifndef configUSE_SEGGER_SYSTEM_VIEWER_HOOKS
%if defined(SeggerSystemViewerGroup) & %SeggerSystemViewerGroup='yes' & defined(SeggerSystemViewer)
  #define configUSE_SEGGER_SYSTEM_VIEWER_HOOKS                   %>50 1 /* 1: Segger System Viewer hooks, 0: not using Segger System Viewer hooks */
%else
  #define configUSE_SEGGER_SYSTEM_VIEWER_HOOKS                   %>50 0 /* 1: Segger System Viewer hooks, 0: not using Segger System Viewer hooks */
%endif
#endif

#ifndef configUSE_SEGGER_SYSTEM_VIEWER_HEAP_EVENTS
  #define configUSE_SEGGER_SYSTEM_VIEWER_HEAP_EVENTS             %>50 (1 && configUSE_SEGGER_SYSTEM_VIEWER_HOOKS)
    /*!< 1: Generate heap events for Segger SystemView, 0: not generate heap events */
#endif

#if configUSE_SEGGER_SYSTEM_VIEWER_HOOKS && configUSE_PERCEPIO_TRACE_HOOKS
  #error "only one trace method can be active!"
#endif
/*----------------------------------------------------------- */

#endif /* __%'ModuleName'_CONFIG_H */
%-----------------------------------------------------------------------------------------
%else %- Language (& Compiler)
  %error^ This bean is not implemented in selected language & compiler !
%endif %- Language (& Compiler)
%DEBUG
%ALL_SYMBOLS
%-
