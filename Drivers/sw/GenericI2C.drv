%-Driver generated by the Component Wizard
%-
%- WARNING !
%-
%- Do not make changes to these lines (if you make some changes, you damage this driver)
%- which begins with:
%-
%-  %-STARTUSERTYPES
%-  %-ENDUSRTYPES
%-  /* END %ModuleName. */
%-  /* MODULE %ModuleName. */
%-  %-INTERNAL_METHOD_BEG
%-  %-INTERNAL_METHOD_END
%-  %-INHERITED_EVENT_BEGIN
%-  %-INHERITED_EVENT_END
%-  %-BW_METHOD_BEGIN
%-  %-BW_METHOD_END
%-  %-BW_DEFINITION_START
%-  %-BW_DEFINITION_END
%-  %-BW_IMPLEMENT_START
%-  %-BW_IMPLEMENT_END
%-  %-BW_EVENT_DEFINITION_START
%-  %-BW_EVENT_DEFINITION_END
%-  %-BW_EVENT_IMPLEMENT_START
%-  %-BW_EVENT_IMPLEMENT_END
%-  %-BW_METHOD_MACROS_START
%-  %-BW_METHOD_MACROS_END
%-  %-BW_SECTIONS_INSERT
%-  %-BW_INTERN_COMMENTS_START
%-  %-BW_INTERN_COMMENTS_END
%-  %-BW_BEAN_CONSTANTS_START
%-  %-BW_BEAN_CONSTANTS_END
%-
%-
%- These lines are not comments, but they are necessary for Component Wizard
%- If you change these lines, Component Wizard will not be responsible for loosing or damaging your code!
%-
%-
%- readyCPU ...
%- readyDEVICE ...
%-
%define DriverAuthor  Author
%define DriverVersion 01.00
%define DriverDate    26.11.2012
%-
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END
%-
%-BW_INTERN_COMMENTS_START
%- List of descriptions of internal methods
%ifdef LDD_I2C
  %ifdef @LDD_I2C@OnMasterBlockSent
    %define! Description_%@LDD_I2C@OnMasterBlockSent This event is called when I2C in master mode finishes the transmission of the data successfully. This event is not available for the SLAVE mode and if MasterSendBlock is disabled.  The event services the event of the inherited component and eventually invokes other events.
  %endif %- @LDD_I2C@OnMasterBlockSent
%endif %- LDD_I2C
%ifdef LDD_I2C
  %ifdef @LDD_I2C@OnMasterBlockReceived
    %define! Description_%@LDD_I2C@OnMasterBlockReceived This event is called when I2C is in master mode and finishes the reception of the data successfully. This event is not available for the SLAVE mode and if MasterReceiveBlock is disabled. The event services the event of the inherited component and eventually invokes other events.
  %endif %- @LDD_I2C@OnMasterBlockReceived
%endif %- LDD_I2C
%-BW_INTERN_COMMENTS_END
%-
%-BW_SECTIONS_INSERT
%if Language='ANSIC'
%-
%-
%INTERFACE
%define! Settings Common\GenericI2CSettings.Inc
%define! Abstract Common\GenericI2CAbstract.Inc
%include Common\Header.h

#ifndef __%'ModuleName'_H
#define __%'ModuleName'_H

/* MODULE %ModuleName. */
#include "%@sdk@ModuleName.h" /* SDK and API used */
#include "%'ModuleName'config.h" /* configuration */
%-BW_CUSTOM_INCLUDE_START_H
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
%-BW_CUSTOM_INCLUDE_END_H
%-
%-BW_METHOD_MACROS_START
%-BW_METHOD_MACROS_END

%-STARTUSERTYPES - Do not make changes between lines (included this lines) marked with %-STARTUSERTYPES and %-ENDUSRTYPES

%-ENDUSRTYPES
%-BW_BEAN_CONSTANTS_START  - Do not make changes between lines (included this lines) marked with %-BW_BEAN_CONSTANTS_START and %-BW_BEAN_CONSTANTS_END
%- No constants defined in the BeanWizard for this bean
%-BW_BEAN_CONSTANTS_END
%-BW_CUSTOM_USERTYPE_START
%- Write your own types here ...
%-  Example:
%-    typedef int TMyInteger;
#ifdef __cplusplus
extern "C" {
#endif

#define %'ModuleName'%.WRITE_BUFFER_SIZE %WriteBufferSize /* size of internal buffer used, set in the component properties */

typedef enum %'ModuleName'_EnumSendFlags_ {
  %'ModuleName'_SEND_STOP,        /* STOP is sent */
  %'ModuleName'_DO_NOT_SEND_STOP, /* STOP is not sent */
  %'ModuleName'_STOP_NOSTART      /* send STOP without START condition */
} %'ModuleName'_EnumSendFlags;

typedef enum %'ModuleName'_EnumStartFlags_ {
  %'ModuleName'_SEND_START,        /* Start is sent */
  %'ModuleName'_DO_NOT_SEND_START  /* Start is not sent */
} %'ModuleName'_EnumStartFlags;

typedef enum %'ModuleName'_EnumAckFlags_ {
  %'ModuleName'_SEND_LAST_ACK,   /* Nack after last received byte is sent */
  %'ModuleName'_DO_NOT_LAST_ACK  /* Nack after last received byte is not sent */
} %'ModuleName'_EnumAckFlags;

%-
%-BW_CUSTOM_USERTYPE_END
%-BW_DEFINITION_START
%-************************************************************************************************************
%-INHERITED_EVENT_BEGIN LDD_I2C OnMasterBlockSent
%if defined(LDD_I2C) & defined(@LDD_I2C@OnMasterBlockSent)
void %@LDD_I2C@OnMasterBlockSent(LDD_TUserData *UserDataPtr);

%endif %- @LDD_I2C@OnMasterBlockSent
%-INHERITED_EVENT_END LDD_I2C OnMasterBlockSent
%-INHERITED_EVENT_BEGIN LDD_I2C OnMasterBlockReceived
%if defined(LDD_I2C) & defined(@LDD_I2C@OnMasterBlockReceived)
void %@LDD_I2C@OnMasterBlockReceived(LDD_TUserData *UserDataPtr);

%endif %- @LDD_I2C@OnMasterBlockReceived
%-INHERITED_EVENT_END LDD_I2C OnMasterBlockReceived
%-************************************************************************************************************
%-BW_METHOD_BEGIN Init
%ifdef Init
void %'ModuleName'%.%Init(void);
%include Common\GenericI2CInit.Inc

%endif %- Init
%-BW_METHOD_END Init
%-************************************************************************************************************
%-BW_METHOD_BEGIN Deinit
%ifdef Deinit
void %'ModuleName'%.%Deinit(void);
%include Common\GenericI2CDeinit.Inc

%endif %- Deinit
%-BW_METHOD_END Deinit
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadAddress
%ifdef ReadAddress
uint8_t %'ModuleName'%.%ReadAddress(uint8_t i2cAddr, uint8_t *memAddr, uint8_t memAddrSize, uint8_t *data, uint16_t dataSize);
%define! Pari2cAddr
%define! ParmemAddr
%define! ParmemAddrSize
%define! Pardata
%define! PardataSize
%define! RetVal
%include Common\GenericI2CReadAddress.Inc

%endif %- ReadAddress
%-BW_METHOD_END ReadAddress
%-************************************************************************************************************
%-BW_METHOD_BEGIN WriteAddress
%ifdef WriteAddress
uint8_t %'ModuleName'%.%WriteAddress(uint8_t i2cAddr, uint8_t *memAddr, uint8_t memAddrSize, uint8_t *data, uint16_t dataSize);
%define! Pari2cAddr
%define! ParmemAddr
%define! ParmemAddrSize
%define! Pardata
%define! PardataSize
%define! RetVal
%include Common\GenericI2CWriteAddress.Inc

%endif %- WriteAddress
%-BW_METHOD_END WriteAddress
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetSemaphore
%ifdef GetSemaphore
void* %'ModuleName'%.%GetSemaphore(void);
%define! RetVal
%include Common\GenericI2CGetSemaphore.Inc

%endif %- GetSemaphore
%-BW_METHOD_END GetSemaphore
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadBlock
%ifdef ReadBlock
uint8_t %'ModuleName'%.%ReadBlock(void* data, uint16_t dataSize, %'ModuleName'_EnumSendFlags flags);
%define! Pardata
%define! PardataSize
%define! Parflags
%define! RetVal
%include Common\GenericI2CReadBlock.Inc

%endif %- ReadBlock
%-BW_METHOD_END ReadBlock
%-************************************************************************************************************
%-BW_METHOD_BEGIN WriteBlock
%ifdef WriteBlock
uint8_t %'ModuleName'%.%WriteBlock(void* data, uint16_t dataSize, %'ModuleName'_EnumSendFlags flags);
%define! Pardata
%define! PardataSize
%define! Parflags
%define! RetVal
%include Common\GenericI2CWriteBlock.Inc

%endif %- WriteBlock
%-BW_METHOD_END WriteBlock
%-************************************************************************************************************
%-BW_METHOD_BEGIN RequestBus
%ifdef RequestBus
void %'ModuleName'%.%RequestBus(void);
%include Common\GenericI2CRequestBus.Inc

%endif %- RequestBus
%-BW_METHOD_END RequestBus
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReleaseBus
%ifdef ReleaseBus
void %'ModuleName'%.%ReleaseBus(void);
%include Common\GenericI2CReleaseBus.Inc

%endif %- ReleaseBus
%-BW_METHOD_END ReleaseBus
%-************************************************************************************************************
%-BW_METHOD_BEGIN SelectSlave
%ifdef SelectSlave
uint8_t %'ModuleName'%.%SelectSlave(uint8_t i2cAddr);
%define! Pari2cAddr
%define! RetVal
%include Common\GenericI2CSelectSlave.Inc

%endif %- SelectSlave
%-BW_METHOD_END SelectSlave
%-************************************************************************************************************
%-BW_METHOD_BEGIN UnselectSlave
%ifdef UnselectSlave
uint8_t %'ModuleName'%.%UnselectSlave(void);
%define! RetVal
%include Common\GenericI2CUnselectSlave.Inc

%endif %- UnselectSlave
%-BW_METHOD_END UnselectSlave
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadByteAddress8
%ifdef ReadByteAddress8
uint8_t %'ModuleName'%.%ReadByteAddress8(uint8_t i2cAddr, uint8_t memAddr, uint8_t *data);
%define! Pari2cAddr
%define! ParmemAddr
%define! Pardata
%define! RetVal
%include Common\GenericI2CReadByteAddress8.Inc

%endif %- ReadByteAddress8
%-BW_METHOD_END ReadByteAddress8
%-************************************************************************************************************
%-BW_METHOD_BEGIN WriteByteAddress8
%ifdef WriteByteAddress8
uint8_t %'ModuleName'%.%WriteByteAddress8(uint8_t i2cAddr, uint8_t memAddr, uint8_t data);
%define! Pari2cAddr
%define! ParmemAddr
%define! Pardata
%define! RetVal
%include Common\GenericI2CWriteByteAddress8.Inc

%endif %- WriteByteAddress8
%-BW_METHOD_END WriteByteAddress8
%-************************************************************************************************************
%-BW_METHOD_BEGIN ScanDevice
%ifdef ScanDevice
uint8_t %'ModuleName'%.%ScanDevice(uint8_t i2cAddr);
%define! Pari2cAddr
%define! RetVal
%include Common\GenericI2CScanDevice.Inc

%endif %- ScanDevice
%-BW_METHOD_END ScanDevice
%-************************************************************************************************************
%-BW_METHOD_BEGIN ProbeACK
%ifdef ProbeACK
uint8_t %'ModuleName'%.%ProbeACK(void* data, uint16_t dataSize, %'ModuleName'_EnumSendFlags flags, uint16_t WaitTimeUS);
%define! Pardata
%define! PardataSize
%define! Parflags
%define! ParWaitTimeUS
%define! RetVal
%include Common\GenericI2CProbeACK.Inc

%endif %- ProbeACK
%-BW_METHOD_END ProbeACK
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadBlockGeneric
%ifdef ReadBlockGeneric
uint8_t %'ModuleName'%.%ReadBlockGeneric(void* data, uint16_t dataSize, %'ModuleName'_EnumSendFlags flags, %'ModuleName'_EnumStartFlags flagsStart, %'ModuleName'_EnumAckFlags flagsAck);
%define! Pardata
%define! PardataSize
%define! ParflagsSend
%define! ParflagsStart
%define! ParflagsAck
%define! RetVal
%include Common\GenericI2CReadBlockGeneric.Inc

%endif %- ReadBlockGeneric
%-BW_METHOD_END ReadBlockGeneric
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadWordAddress8
%ifdef ReadWordAddress8
uint8_t %'ModuleName'%.%ReadWordAddress8(uint8_t i2cAddr, uint8_t memAddr, uint16_t *data);
%define! Pari2cAddr
%define! ParmemAddr
%define! Pardata
%define! RetVal
%include Common\GenericI2CReadWordAddress8.Inc

%endif %- ReadWordAddress8
%-BW_METHOD_END ReadWordAddress8
%-************************************************************************************************************
%-BW_METHOD_BEGIN WriteWordAddress8
%ifdef WriteWordAddress8
uint8_t %'ModuleName'%.%WriteWordAddress8(uint8_t i2cAddr, uint8_t memAddr, uint16_t data);
%define! Pari2cAddr
%define! ParmemAddr
%define! Pardata
%define! RetVal
%include Common\GenericI2CWriteWordAddress8.Inc

%endif %- WriteWordAddress8
%-BW_METHOD_END WriteWordAddress8
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadByte
%ifdef ReadByte
uint8_t %'ModuleName'%.%ReadByte(uint8_t i2cAddr, uint8_t *data);
%define! Pari2cAddr
%define! Pardata
%define! RetVal
%include Common\GenericI2CReadByte.Inc

%endif %- ReadByte
%-BW_METHOD_END ReadByte
%-************************************************************************************************************
%-BW_METHOD_BEGIN WriteByte
%ifdef WriteByte
uint8_t %'ModuleName'%.%WriteByte(uint8_t i2cAddr, uint8_t data);
%define! Pari2cAddr
%define! Pardata
%define! RetVal
%include Common\GenericI2CWriteByte.Inc

%endif %- WriteByte
%-BW_METHOD_END WriteByte
%-BW_DEFINITION_END
/* END %ModuleName. */

#ifdef __cplusplus
}  /* extern "C" */
#endif

#endif
/* ifndef __%'ModuleName'_H */
%include Common\Header.End
%-
%-BW_EVENT_DEFINITION_START
%-BW_METHOD_BEGIN OnMasterBlockSent
%ifdef OnMasterBlockSent
%INTERFACE OnMasterBlockSent
void %OnMasterBlockSent(LDD_TUserData *UserDataPtr);
%define! ParUserDataPtr
%include Common\GenericI2COnMasterBlockSent.Inc

%endif %- OnMasterBlockSent
%-BW_METHOD_END OnMasterBlockSent
%-BW_METHOD_BEGIN OnMasterBlockReceived
%ifdef OnMasterBlockReceived
%INTERFACE OnMasterBlockReceived
void %OnMasterBlockReceived(LDD_TUserData *UserDataPtr);
%define! ParUserDataPtr
%include Common\GenericI2COnMasterBlockReceived.Inc

%endif %- OnMasterBlockReceived
%-BW_METHOD_END OnMasterBlockReceived
%-BW_METHOD_BEGIN OnRequestBus
%ifdef OnRequestBus
%INTERFACE OnRequestBus
void %OnRequestBus(void);
%include Common\GenericI2COnRequestBus.Inc

%endif %- OnRequestBus
%-BW_METHOD_END OnRequestBus
%-BW_METHOD_BEGIN OnReleaseBus
%ifdef OnReleaseBus
%INTERFACE OnReleaseBus
void %OnReleaseBus(void);
%include Common\GenericI2COnReleaseBus.Inc

%endif %- OnReleaseBus
%-BW_METHOD_END OnReleaseBus
%-BW_METHOD_BEGIN OnError
%ifdef OnError
%INTERFACE OnError
void %OnError(void);
%include Common\GenericI2COnError.Inc

%endif %- OnError
%-BW_METHOD_END OnError
%-BW_EVENT_DEFINITION_END
%IMPLEMENTATION
%define! Settings Common\GenericI2CSettings.Inc
%define! Abstract Common\GenericI2CAbstract.Inc
%include Common\Header.C

/* MODULE %ModuleName. */

#include "%'ModuleName'.h"
%if defined(Wait)
#include "%@Wait@ModuleName.h"
%endif
%if defined(RTOS)
#include "%@RTOS@ModuleName.h"
%endif
%if defined(I2C)
#include "%@I2C@ModuleName.h"
%endif
%if defined(LDD_I2C)
#include "%@LDD_I2C@ModuleName.h"
%endif

%-BW_CUSTOM_INCLUDE_START_M
%- Write your own includes here ...
%-   Example:
%-     #include "header_name.h"
%-
#ifndef NULL
  #define NULL 0L
#endif /* NULL */
%-BW_CUSTOM_INCLUDE_END_M

%-BW_CUSTOM_VARIABLE_START
%- Write your static variables here
%-   Example:
%-     static int counter1;
%-     int %'ModuleName'%.counter2;
%-
%if defined(LDD_I2C)
typedef struct {
  volatile bool dataReceivedFlg; /* set to TRUE by the interrupt if we have received data */
  volatile bool dataTransmittedFlg; /* set to TRUE by the interrupt if we have sent data */
  LDD_TDeviceData *handle; /* pointer to the device handle */
} %'ModuleName'%.TDataState;

static %'ModuleName'%.TDataState %'ModuleName'%.deviceData;

%if defined(Timeout)
#define %'ModuleName'%.TIMEOUT_US  ((uint32_t)%TimeoutUs)  /* number of microseconds as specified in properties */
#define %'ModuleName'%.TIMEOUT_NOF_TICKS(factor) ((%'ModuleName'%.TIMEOUT_US*(factor))/1000/%@Timeout@'ModuleName'%.TICK_PERIOD_MS)
#define %'ModuleName'%.TIMEOUT_TICKS(factor) (%'ModuleName'%.TIMEOUT_NOF_TICKS(factor)>0?%'ModuleName'%.TIMEOUT_NOF_TICKS(factor):1)  /* at least one tick */
%endif
%endif
#if %'ModuleName'%.CONFIG_USE_MUTEX
static xSemaphoreHandle %'ModuleName'%.busSem = NULL; /* Semaphore to protect I2C bus access */
#endif
%-BW_CUSTOM_VARIABLE_END
%-BW_INTERN_METHOD_DECL_START
%- List of internal methods headers
%-BW_INTERN_METHOD_DECL_END
%-BW_IMPLEMENT_START
%-************************************************************************************************************
%-BW_METHOD_BEGIN RequestBus
%ifdef RequestBus
%include Common\GenericI2CRequestBus.Inc
void %'ModuleName'%.%RequestBus(void)
{
  /*lint -save -e522 function lacks side effect  */
#if %'ModuleName'%.CONFIG_USE_ON_REQUEST_BUS_EVENT
  %'ModuleName'%.CONFIG_ON_REQUEST_BUS_EVENT();
#endif
  /*lint -restore */
#if %'ModuleName'%.CONFIG_USE_MUTEX
  (void)xSemaphoreTakeRecursive(%'ModuleName'%.busSem, portMAX_DELAY);
#endif
}

%endif %- RequestBus
%-BW_METHOD_END RequestBus
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReleaseBus
%ifdef ReleaseBus
%include Common\GenericI2CReleaseBus.Inc
void %'ModuleName'%.%ReleaseBus(void)
{
#if %'ModuleName'%.CONFIG_USE_MUTEX
  (void)xSemaphoreGiveRecursive(%'ModuleName'%.busSem);
#endif
  /*lint -save -e522 function lacks side effect  */
#if %'ModuleName'%.CONFIG_USE_ON_RELEASE_BUS_EVENT
  %'ModuleName'%.CONFIG_ON_RELEASE_BUS_EVENT();
#endif
  /*lint -restore */
}

%endif %- ReleaseBus
%-BW_METHOD_END ReleaseBus
%-************************************************************************************************************
%-BW_METHOD_BEGIN SelectSlave
%ifdef SelectSlave
%define! Pari2cAddr
%define! RetVal
%include Common\GenericI2CSelectSlave.Inc
uint8_t %'ModuleName'%.%SelectSlave(uint8_t i2cAddr)
{
  %'ModuleName'%.%RequestBus();
%if defined(LDD_I2C)
  if (%@LDD_I2C@'ModuleName'%.SelectSlaveDevice(%'ModuleName'%.deviceData.handle, LDD_I2C_ADDRTYPE_7BITS, i2cAddr)!=ERR_OK) {
    %'ModuleName'%.%ReleaseBus();
  #if %'ModuleName'%.CONFIG_USE_ON_ERROR_EVENT
    %'ModuleName'%.CONFIG_ON_ERROR_EVENT();
  #endif
    return ERR_FAILED;
  }
%endif
%if defined(I2C)
  if (%@I2C@'ModuleName'%.SelectSlave(i2cAddr)!=ERR_OK) {
    %'ModuleName'%.%ReleaseBus();
  #if %'ModuleName'%.CONFIG_USE_ON_ERROR_EVENT
    %'ModuleName'%.CONFIG_ON_ERROR_EVENT();
  #endif
    return ERR_FAILED;
  }
%endif
  return ERR_OK;
}

%endif %- SelectSlave
%-BW_METHOD_END SelectSlave
%-************************************************************************************************************
%-BW_METHOD_BEGIN UnselectSlave
%ifdef UnselectSlave
%define! RetVal
%include Common\GenericI2CUnselectSlave.Inc
uint8_t %'ModuleName'%.%UnselectSlave(void)
{
  %'ModuleName'%.%ReleaseBus();
  return ERR_OK;
}

%endif %- UnselectSlave
%-BW_METHOD_END UnselectSlave
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadBlockGeneric
%ifdef ReadBlockGeneric
%define! Pardata
%define! PardataSize
%define! ParflagsSend
%define! ParflagsStart
%define! ParflagsAck
%define! RetVal
%include Common\GenericI2CReadBlockGeneric.Inc
uint8_t %'ModuleName'%.%ReadBlockGeneric(void* data, uint16_t dataSize, %'ModuleName'_EnumSendFlags flags, %'ModuleName'_EnumStartFlags flagsStart, %'ModuleName'_EnumAckFlags flagsAck)
{
  uint8_t res = ERR_OK;
%if defined(LDD_I2C)
%if defined(Timeout)
  %@Timeout@'ModuleName'%.CounterHandle timeout;
  bool isTimeout=FALSE;
%endif
%else
  uint16_t nof;
%endif

%if defined(LDD_I2C)
  #warning "functionality not implemented yet for I2C LDD. Disable this function to disable warning."
  for(;;) { /* breaks */
    %'ModuleName'%.deviceData.dataReceivedFlg = FALSE;
    res = %@LDD_I2C@'ModuleName'%.MasterReceiveBlock(%'ModuleName'%.deviceData.handle, data, dataSize, flags==%'ModuleName'_SEND_STOP?LDD_I2C_SEND_STOP:LDD_I2C_NO_SEND_STOP);
    if (res!=ERR_OK) {
    #if %'ModuleName'%.CONFIG_USE_ON_ERROR_EVENT
      %'ModuleName'%.CONFIG_ON_ERROR_EVENT();
    #endif
      break; /* break for(;;) */
    }
%if defined(Timeout)
    timeout = %@Timeout@'ModuleName'%.GetCounter(%'ModuleName'%.TIMEOUT_TICKS(dataSize)); /* set up timeout counter */
    if (timeout==%@Timeout@'ModuleName'%.OUT_OF_HANDLE) {
      res = ERR_QFULL;
    #if %'ModuleName'%.CONFIG_USE_ON_ERROR_EVENT
      %'ModuleName'%.CONFIG_ON_ERROR_EVENT();
    #endif
      break; /* break for(;;) */
    }
%endif
    do { /* Wait until data is received */
%if defined(Timeout)
      isTimeout = %@Timeout@'ModuleName'%.CounterExpired(timeout);
      if (isTimeout) {
    #if %'ModuleName'%.CONFIG_USE_ON_ERROR_EVENT
      %'ModuleName'%.CONFIG_ON_ERROR_EVENT();
    #endif
        break; /* break while() */
      }
%endif
    } while (!%'ModuleName'%.deviceData.dataReceivedFlg);
%if defined(Timeout)
    %@Timeout@'ModuleName'%.LeaveCounter(timeout);
    if (isTimeout) {
      res = ERR_BUSY;
    #if %'ModuleName'%.CONFIG_USE_ON_ERROR_EVENT
      %'ModuleName'%.CONFIG_ON_ERROR_EVENT();
    #endif
      break; /* break for(;;) */
    }
%endif
    break; /* break for(;;) */
  } /* for(;;) */
%else
#if defined(%@I2C@'ModuleName'%.RecvBlockCustom) && %@I2C@'ModuleName'%.RecvBlockCustom==1
  for(;;) { /* breaks */
    res = %@I2C@'ModuleName'%.RecvBlockCustom(data, dataSize, &nof, flagsStart, flagsAck);
    if (res!=ERR_OK) {
    #if %'ModuleName'%.CONFIG_USE_ON_ERROR_EVENT
      %'ModuleName'%.CONFIG_ON_ERROR_EVENT();
    #endif
      break; /* break for(;;) */
    }
    if (flags==%'ModuleName'_SEND_STOP) {
      res = %@I2C@'ModuleName'%.SendStop();
      if (res!=ERR_OK) {
      #if %'ModuleName'%.CONFIG_USE_ON_ERROR_EVENT
        %'ModuleName'%.CONFIG_ON_ERROR_EVENT();
      #endif
        break; /* break for(;;) */
      }
    }
    break; /* break for(;;) */
  } /* for(;;) */
#else
  return ERR_FAILED; /* RecvBlockCustom() is not available (e.g. not available in the Hardware I2C component */
#endif
%endif
  return res;
}

%endif %- ReadBlockGeneric
%-BW_METHOD_END ReadBlockGeneric
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadBlock
%ifdef ReadBlock
%define! Pardata
%define! PardataSize
%define! Parflags
%define! RetVal
%include Common\GenericI2CReadBlock.Inc
uint8_t %'ModuleName'%.%ReadBlock(void* data, uint16_t dataSize, %'ModuleName'_EnumSendFlags flags)
{
  uint8_t res = ERR_OK;
%if defined(LDD_I2C)
%if defined(Timeout)
  %@Timeout@'ModuleName'%.CounterHandle timeout;
  bool isTimeout=FALSE;
%endif
%else
  uint16_t nof;
%endif

%if defined(LDD_I2C)
  for(;;) { /* breaks */
    %'ModuleName'%.deviceData.dataReceivedFlg = FALSE;
    res = %@LDD_I2C@'ModuleName'%.MasterReceiveBlock(%'ModuleName'%.deviceData.handle, data, dataSize, flags==%'ModuleName'_SEND_STOP?LDD_I2C_SEND_STOP:LDD_I2C_NO_SEND_STOP);
    if (res!=ERR_OK) {
    #if %'ModuleName'%.CONFIG_USE_ON_ERROR_EVENT
      %'ModuleName'%.CONFIG_ON_ERROR_EVENT();
    #endif
      break; /* break for(;;) */
    }
%if defined(Timeout)
    timeout = %@Timeout@'ModuleName'%.GetCounter(%'ModuleName'%.TIMEOUT_TICKS(dataSize)); /* set up timeout counter */
    if (timeout==%@Timeout@'ModuleName'%.OUT_OF_HANDLE) {
      res = ERR_QFULL;
    #if %'ModuleName'%.CONFIG_USE_ON_ERROR_EVENT
      %'ModuleName'%.CONFIG_ON_ERROR_EVENT();
    #endif
      break; /* break for(;;) */
    }
%endif
    do { /* Wait until data is received */
%if defined(Timeout)
      isTimeout = %@Timeout@'ModuleName'%.CounterExpired(timeout);
      if (isTimeout) {
      #if %'ModuleName'%.CONFIG_USE_ON_ERROR_EVENT
        %'ModuleName'%.CONFIG_ON_ERROR_EVENT();
    #endif
        break; /* break while() */
      }
%endif
    } while (!%'ModuleName'%.deviceData.dataReceivedFlg);
%if defined(Timeout)
    %@Timeout@'ModuleName'%.LeaveCounter(timeout);
    if (isTimeout) {
      res = ERR_BUSY;
      #if %'ModuleName'%.CONFIG_USE_ON_ERROR_EVENT
        %'ModuleName'%.CONFIG_ON_ERROR_EVENT();
      #endif
      break; /* break for(;;) */
    }
%endif
    break; /* break for(;;) */
  } /* for(;;) */
%else
  for(;;) { /* breaks */
    res = %@I2C@'ModuleName'%.RecvBlock(data, dataSize, &nof);
    if (res!=ERR_OK) {
    #if %'ModuleName'%.CONFIG_USE_ON_ERROR_EVENT
      %'ModuleName'%.CONFIG_ON_ERROR_EVENT();
    #endif
      break; /* break for(;;) */
    }
    if (flags==%'ModuleName'_SEND_STOP) {
      res = %@I2C@'ModuleName'%.SendStop();
      if (res!=ERR_OK) {
      #if %'ModuleName'%.CONFIG_USE_ON_ERROR_EVENT
        %'ModuleName'%.CONFIG_ON_ERROR_EVENT();
      #endif
        break; /* break for(;;) */
      }
    }
    break; /* break for(;;) */
  } /* for(;;) */
%endif
  return res;
}

%endif %- ReadBlock
%-BW_METHOD_END ReadBlock
%-************************************************************************************************************
%-BW_METHOD_BEGIN WriteBlock
%ifdef WriteBlock
%define! Pardata
%define! PardataSize
%define! Parflags
%define! RetVal
%include Common\GenericI2CWriteBlock.Inc
uint8_t %'ModuleName'%.%WriteBlock(void* data, uint16_t dataSize, %'ModuleName'_EnumSendFlags flags)
{
%if defined(I2C)
  uint16_t nof;
%endif
%if defined(Timeout)
  %@Timeout@'ModuleName'%.CounterHandle timeout;
  bool isTimeout=FALSE;
%endif
  uint8_t res = ERR_OK;

%if defined(LDD_I2C)
  for(;;) { /* breaks */
    %'ModuleName'%.deviceData.dataTransmittedFlg = FALSE;
    res = %@LDD_I2C@'ModuleName'%.MasterSendBlock(%'ModuleName'%.deviceData.handle, data, dataSize, flags==%'ModuleName'_SEND_STOP?LDD_I2C_SEND_STOP:LDD_I2C_NO_SEND_STOP);
    if (res!=ERR_OK) {
    #if %'ModuleName'%.CONFIG_USE_ON_ERROR_EVENT
      %'ModuleName'%.CONFIG_ON_ERROR_EVENT();
    #endif
      break; /* break for(;;) */
    }
%if defined(Timeout)
    timeout = %@Timeout@'ModuleName'%.GetCounter(%'ModuleName'%.TIMEOUT_TICKS(dataSize)); /* set up timeout counter */
    if (timeout==%@Timeout@'ModuleName'%.OUT_OF_HANDLE) {
      res = ERR_QFULL;
      #if %'ModuleName'%.CONFIG_USE_ON_ERROR_EVENT
        %'ModuleName'%.CONFIG_ON_ERROR_EVENT();
      #endif
      break; /* break for(;;) */
    }
%endif
    do { /* Wait until data is sent */
%if defined(Timeout)
      isTimeout = %@Timeout@'ModuleName'%.CounterExpired(timeout);
      if (isTimeout) {
      #if %'ModuleName'%.CONFIG_USE_ON_ERROR_EVENT
        %'ModuleName'%.CONFIG_ON_ERROR_EVENT();
      #endif
        break; /* break while loop */
      }
%endif
    } while (!%'ModuleName'%.deviceData.dataTransmittedFlg);
%if defined(Timeout)
    %@Timeout@'ModuleName'%.LeaveCounter(timeout);
    if (isTimeout) {
      res = ERR_BUSY;
      #if %'ModuleName'%.CONFIG_USE_ON_ERROR_EVENT
        %'ModuleName'%.CONFIG_ON_ERROR_EVENT();
      #endif
      break; /* break for(;;) */
    }
%endif
    break; /* break for(;;) */
  } /* for(;;) */
%else
  for(;;) { /* breaks */
%if %SupportStopNoStart='yes'
    if (%'ModuleName'_STOP_NOSTART==flags) {
      res = %@I2C@'ModuleName'%.SendBlockContinue(data, dataSize, &nof);
    } else {
      res = %@I2C@'ModuleName'%.SendBlock(data, dataSize, &nof);
    }
%else
    res = %@I2C@'ModuleName'%.SendBlock(data, dataSize, &nof);
%endif
    if (res!=ERR_OK) {
      (void)%@I2C@'ModuleName'%.SendStop();
      #if %'ModuleName'%.CONFIG_USE_ON_ERROR_EVENT
        %'ModuleName'%.CONFIG_ON_ERROR_EVENT();
      #endif
      break; /* break for(;;) */
    }
    if (flags==%'ModuleName'_SEND_STOP || (flags==%'ModuleName'_STOP_NOSTART)) {
      res = %@I2C@'ModuleName'%.SendStop();
      if (res!=ERR_OK) {
      #if %'ModuleName'%.CONFIG_USE_ON_ERROR_EVENT
        %'ModuleName'%.CONFIG_ON_ERROR_EVENT();
      #endif
        break; /* break for(;;) */
      }
    }
    break; /* break for(;;) */
  } /* for(;;) */
%endif
  return res;
}

%endif %- WriteBlock
%-BW_METHOD_END WriteBlock
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadAddress
%ifdef ReadAddress
%define! Pari2cAddr
%define! ParmemAddr
%define! ParmemAddrSize
%define! Pardata
%define! PardataSize
%define! RetVal
%include Common\GenericI2CReadAddress.Inc
uint8_t %'ModuleName'%.%ReadAddress(uint8_t i2cAddr, uint8_t *memAddr, uint8_t memAddrSize, uint8_t *data, uint16_t dataSize)
{
  uint8_t res = ERR_OK;
%if defined(LDD_I2C)
%if defined(Timeout)
  %@Timeout@'ModuleName'%.CounterHandle timeout;
  bool isTimeout=FALSE;
%endif
%else
  uint16_t nof;
%endif

  if (%'ModuleName'%.%SelectSlave(i2cAddr)!=ERR_OK) {
  #if %'ModuleName'%.CONFIG_USE_ON_ERROR_EVENT
    %'ModuleName'%.CONFIG_ON_ERROR_EVENT();
  #endif
    return ERR_FAILED;
  }
%if defined(LDD_I2C)
  for(;;) { /* breaks */
    if(memAddr!=NULL) { /* only if we want to send an address */
      /* send device address and memory address */
      %'ModuleName'%.deviceData.dataTransmittedFlg = FALSE;
      res = %@LDD_I2C@'ModuleName'%.MasterSendBlock(%'ModuleName'%.deviceData.handle, memAddr, memAddrSize, LDD_I2C_NO_SEND_STOP);
      if (res!=ERR_OK) {
      #if %'ModuleName'%.CONFIG_USE_ON_ERROR_EVENT
        %'ModuleName'%.CONFIG_ON_ERROR_EVENT();
      #endif
        break; /* break for(;;) */
      }
    }
%if defined(Timeout)
    timeout = %@Timeout@'ModuleName'%.GetCounter(%'ModuleName'%.TIMEOUT_TICKS(memAddrSize)); /* set up timeout counter */
    if (timeout==%@Timeout@'ModuleName'%.OUT_OF_HANDLE) {
      res = ERR_QFULL;
      #if %'ModuleName'%.CONFIG_USE_ON_ERROR_EVENT
        %'ModuleName'%.CONFIG_ON_ERROR_EVENT();
      #endif
      break; /* break for(;;) */
    }
%endif
    do { /* Wait until data is sent */
%if defined(Timeout)
      isTimeout = %@Timeout@'ModuleName'%.CounterExpired(timeout);
      if (isTimeout) {
      #if %'ModuleName'%.CONFIG_USE_ON_ERROR_EVENT
        %'ModuleName'%.CONFIG_ON_ERROR_EVENT();
      #endif
        break; /* break while() */
      }
%endif
    } while (!%'ModuleName'%.deviceData.dataTransmittedFlg);
%if defined(Timeout)
    %@Timeout@'ModuleName'%.LeaveCounter(timeout);
    if (isTimeout) {
      res = ERR_BUSY;
      #if %'ModuleName'%.CONFIG_USE_ON_ERROR_EVENT
        %'ModuleName'%.CONFIG_ON_ERROR_EVENT();
      #endif
      break; /* break for(;;) */
    }
%endif
    /* receive data */
    %'ModuleName'%.deviceData.dataReceivedFlg = FALSE;
    res = %@LDD_I2C@'ModuleName'%.MasterReceiveBlock(%'ModuleName'%.deviceData.handle, data, dataSize, LDD_I2C_SEND_STOP);
    if (res!=ERR_OK) {
    #if %'ModuleName'%.CONFIG_USE_ON_ERROR_EVENT
      %'ModuleName'%.CONFIG_ON_ERROR_EVENT();
    #endif
      break; /* break for(;;) */
    }
%if defined(Timeout)
    timeout = %@Timeout@'ModuleName'%.GetCounter(%'ModuleName'%.TIMEOUT_TICKS(dataSize)); /* set up timeout counter */
    if (timeout==%@Timeout@'ModuleName'%.OUT_OF_HANDLE) {
      res = ERR_QFULL;
    #if %'ModuleName'%.CONFIG_USE_ON_ERROR_EVENT
      %'ModuleName'%.CONFIG_ON_ERROR_EVENT();
    #endif
      break; /* break for(;;) */
    }
%endif
    do { /* Wait until data is received */
%if defined(Timeout)
      isTimeout = %@Timeout@'ModuleName'%.CounterExpired(timeout);
      if (isTimeout) {
      #if %'ModuleName'%.CONFIG_USE_ON_ERROR_EVENT
        %'ModuleName'%.CONFIG_ON_ERROR_EVENT();
      #endif
        break; /* break while() */
      }
%endif
    } while (!%'ModuleName'%.deviceData.dataReceivedFlg);
%if defined(Timeout)
    %@Timeout@'ModuleName'%.LeaveCounter(timeout);
    if (isTimeout) {
      res = ERR_BUSY;
    #if %'ModuleName'%.CONFIG_USE_ON_ERROR_EVENT
      %'ModuleName'%.CONFIG_ON_ERROR_EVENT();
    #endif
      break; /* break for(;;) */
    }
%endif
    break; /* break for(;;) */
  } /* for(;;) */
%else
  for(;;) { /* breaks */
    if(memAddr!=NULL) { /* only if we want to send an address */
      res = %@I2C@'ModuleName'%.SendBlock((void*)memAddr, memAddrSize, &nof);
      if (res!=ERR_OK) {
        (void)%@I2C@'ModuleName'%.SendStop();
      #if %'ModuleName'%.CONFIG_USE_ON_ERROR_EVENT
        %'ModuleName'%.CONFIG_ON_ERROR_EVENT();
      #endif
        break; /* break for(;;) */
      }
    }
    res = %@I2C@'ModuleName'%.RecvBlock(data, dataSize, &nof);
    if (res!=ERR_OK) {
      (void)%@I2C@'ModuleName'%.SendStop();
    #if %'ModuleName'%.CONFIG_USE_ON_ERROR_EVENT
      %'ModuleName'%.CONFIG_ON_ERROR_EVENT();
    #endif
      break; /* break for(;;) */
    }
    res = %@I2C@'ModuleName'%.SendStop();
    if (res!=ERR_OK) {
    #if %'ModuleName'%.CONFIG_USE_ON_ERROR_EVENT
      %'ModuleName'%.CONFIG_ON_ERROR_EVENT();
    #endif
      break; /* break for(;;) */
    }
    break; /* break for(;;) */
  } /* for(;;) */
%endif
  if (%'ModuleName'%.%UnselectSlave()!=ERR_OK) {
  #if %'ModuleName'%.CONFIG_USE_ON_ERROR_EVENT
    %'ModuleName'%.CONFIG_ON_ERROR_EVENT();
  #endif
    return ERR_FAILED;
  }
  return res;
}

%endif %- ReadAddress
%-BW_METHOD_END ReadAddress
%-************************************************************************************************************
%-BW_METHOD_BEGIN WriteAddress
%ifdef WriteAddress
%define! Pari2cAddr
%define! ParmemAddr
%define! ParmemAddrSize
%define! Pardata
%define! PardataSize
%define! RetVal
%include Common\GenericI2CWriteAddress.Inc
uint8_t %'ModuleName'%.%WriteAddress(uint8_t i2cAddr, uint8_t *memAddr, uint8_t memAddrSize, uint8_t *data, uint16_t dataSize)
{
  static uint8_t writeBuf[%'ModuleName'%.WRITE_BUFFER_SIZE];
  uint8_t *p;
  uint16_t i;
%if defined(I2C)
  uint16_t nof;
%endif
%if defined(Timeout)
  %@Timeout@'ModuleName'%.CounterHandle timeout;
  bool isTimeout=FALSE;
%endif
  uint8_t res = ERR_OK;

  if (%'ModuleName'%.%SelectSlave(i2cAddr)!=ERR_OK) {
  #if %'ModuleName'%.CONFIG_USE_ON_ERROR_EVENT
    %'ModuleName'%.CONFIG_ON_ERROR_EVENT();
  #endif
    return ERR_FAILED;
  }
  if (memAddrSize+dataSize>%'ModuleName'%.WRITE_BUFFER_SIZE) {
  #if %'ModuleName'%.CONFIG_USE_ON_ERROR_EVENT
    %'ModuleName'%.CONFIG_ON_ERROR_EVENT();
  #endif
    return ERR_FAILED;
  }
  i = 0; p = memAddr;
  while(i<%'ModuleName'%.WRITE_BUFFER_SIZE && memAddrSize>0) {
    writeBuf[i++] = *p++;
    memAddrSize--;
  }
  p = data;
  while(i<%'ModuleName'%.WRITE_BUFFER_SIZE && dataSize>0) {
    writeBuf[i++] = *p++;
    dataSize--;
  }
%if defined(LDD_I2C)
  for(;;) { /* breaks */
    /* send device address, memory address and data */
    %'ModuleName'%.deviceData.dataTransmittedFlg = FALSE;
    if (%@LDD_I2C@'ModuleName'%.MasterSendBlock(%'ModuleName'%.deviceData.handle, writeBuf, i, LDD_I2C_SEND_STOP)!=ERR_OK) {
    #if %'ModuleName'%.CONFIG_USE_ON_ERROR_EVENT
      %'ModuleName'%.CONFIG_ON_ERROR_EVENT();
    #endif
      break; /* break for(;;) */
    }
%if defined(Timeout)
    timeout = %@Timeout@'ModuleName'%.GetCounter(%'ModuleName'%.TIMEOUT_TICKS(i)); /* set up timeout counter */
    if (timeout==%@Timeout@'ModuleName'%.OUT_OF_HANDLE) {
      res = ERR_QFULL;
    #if %'ModuleName'%.CONFIG_USE_ON_ERROR_EVENT
      %'ModuleName'%.CONFIG_ON_ERROR_EVENT();
    #endif
      break; /* break for(;;) */
    }
%endif
    do { /* Wait until data is sent */
%if defined(Timeout)
      isTimeout = %@Timeout@'ModuleName'%.CounterExpired(timeout);
      if (isTimeout) {
    #if %'ModuleName'%.CONFIG_USE_ON_ERROR_EVENT
      %'ModuleName'%.CONFIG_ON_ERROR_EVENT();
    #endif
        break; /* break while loop */
      }
%endif
    } while (!%'ModuleName'%.deviceData.dataTransmittedFlg);
%if defined(Timeout)
    %@Timeout@'ModuleName'%.LeaveCounter(timeout);
    if (isTimeout) {
      res = ERR_BUSY;
    #if %'ModuleName'%.CONFIG_USE_ON_ERROR_EVENT
      %'ModuleName'%.CONFIG_ON_ERROR_EVENT();
    #endif
      break; /* break for(;;) */
    }
%endif
    break; /* break for(;;) */
  } /* for(;;) */
%else
  for(;;) { /* breaks */
    res = %@I2C@'ModuleName'%.SendBlock((void*)writeBuf, i, &nof);
    if (res!=ERR_OK) {
      (void)%@I2C@'ModuleName'%.SendStop();
    #if %'ModuleName'%.CONFIG_USE_ON_ERROR_EVENT
      %'ModuleName'%.CONFIG_ON_ERROR_EVENT();
    #endif
      break; /* break for(;;) */
    }
    res = %@I2C@'ModuleName'%.SendStop();
    if (res!=ERR_OK) {
    #if %'ModuleName'%.CONFIG_USE_ON_ERROR_EVENT
      %'ModuleName'%.CONFIG_ON_ERROR_EVENT();
    #endif
      break; /* break for(;;) */
    }
    break; /* break for(;;) */
  } /* for(;;) */
%endif
  if (%'ModuleName'%.%UnselectSlave()!=ERR_OK) {
  #if %'ModuleName'%.CONFIG_USE_ON_ERROR_EVENT
    %'ModuleName'%.CONFIG_ON_ERROR_EVENT();
  #endif
    return ERR_FAILED;
  }
  return res;
}

%endif %- WriteAddress
%-BW_METHOD_END WriteAddress
%-************************************************************************************************************
%-INHERITED_EVENT_BEGIN LDD_I2C OnMasterBlockSent
%if defined(LDD_I2C) & defined(@LDD_I2C@OnMasterBlockSent)
%include Common\GeneralInternal.inc (OnMasterBlockSent)
void %@LDD_I2C@OnMasterBlockSent(LDD_TUserData *UserDataPtr)
{
  if (UserDataPtr==&%'ModuleName'%.deviceData) { /* it is our own message */
    %'ModuleName'%.TDataState *devicePtr = (%'ModuleName'%.TDataState*)UserDataPtr;

    devicePtr->dataTransmittedFlg = TRUE;
%ifdef OnMasterBlockSent
  } else { /* call user or inherited component event */
    %OnMasterBlockSent(UserDataPtr);
%endif %- OnMasterBlockSent
  }
}

%endif %- @LDD_I2C@OnMasterBlockSent
%-INHERITED_EVENT_END LDD_I2C OnMasterBlockSent
%-INHERITED_EVENT_BEGIN LDD_I2C OnMasterBlockReceived
%if defined(LDD_I2C) & defined(@LDD_I2C@OnMasterBlockReceived)
%include Common\GeneralInternal.inc (OnMasterBlockReceived)
void %@LDD_I2C@OnMasterBlockReceived(LDD_TUserData *UserDataPtr)
{
  if (UserDataPtr==&%'ModuleName'%.deviceData) { /* it is our own message */
    %'ModuleName'%.TDataState *devicePtr = (%'ModuleName'%.TDataState*)UserDataPtr;

    devicePtr->dataReceivedFlg = TRUE;
%ifdef OnMasterBlockReceived
  } else { /* call user or inherited component event */
    %OnMasterBlockReceived(UserDataPtr);
%endif %- OnMasterBlockReceived
  }
}

%endif %- @LDD_I2C@OnMasterBlockReceived
%-INHERITED_EVENT_END LDD_I2C OnMasterBlockReceived
%-************************************************************************************************************
%-BW_METHOD_BEGIN Init
%ifdef Init
%include Common\GenericI2CInit.Inc
void %'ModuleName'%.%Init(void)
{
%if defined(LDD_I2C)
  %'ModuleName'%.deviceData.handle = %@LDD_I2C@'ModuleName'%.Init(&%'ModuleName'%.deviceData);
  if (%'ModuleName'%.deviceData.handle==NULL) {
  #if %'ModuleName'%.CONFIG_USE_ON_ERROR_EVENT
    %'ModuleName'%.CONFIG_ON_ERROR_EVENT();
  #endif
    for(;;){} /* failure! */
  }
%endif
#if %'ModuleName'%.CONFIG_USE_MUTEX
  %'ModuleName'%.busSem = xSemaphoreCreateRecursiveMutex();
  if (%'ModuleName'%.busSem==NULL) { /* semaphore creation failed */
  #if %'ModuleName'%.CONFIG_USE_ON_ERROR_EVENT
    %'ModuleName'%.CONFIG_ON_ERROR_EVENT();
  #endif
    for(;;) {} /* error, not enough memory? */
  }
  vQueueAddToRegistry(%'ModuleName'%.busSem, "%'ModuleName'_Mutex");
#endif
}

%endif %- Init
%-BW_METHOD_END Init
%-************************************************************************************************************
%-BW_METHOD_BEGIN Deinit
%ifdef Deinit
%include Common\GenericI2CDeinit.Inc
void %'ModuleName'%.%Deinit(void)
{
%if defined(LDD_I2C)
  %@LDD_I2C@'ModuleName'%.Deinit(&%'ModuleName'%.deviceData);
%endif
#if %'ModuleName'%.CONFIG_USE_MUTEX
  vQueueUnregisterQueue(%'ModuleName'%.busSem);
  vSemaphoreDelete(%'ModuleName'%.busSem);
  %'ModuleName'%.busSem = NULL;
#endif
}

%endif %- Deinit
%-BW_METHOD_END Deinit
%-************************************************************************************************************
%-BW_METHOD_BEGIN GetSemaphore
%ifdef GetSemaphore
%define! RetVal
%include Common\GenericI2CGetSemaphore.Inc
void* %'ModuleName'%.%GetSemaphore(void)
{
#if %'ModuleName'%.CONFIG_USE_MUTEX
  return %'ModuleName'%.busSem;
#else
  return NULL; /* RTOS and Semaphore enabled in properties */
#endif
}

%endif %- GetSemaphore
%-BW_METHOD_END GetSemaphore
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadByteAddress8
%ifdef ReadByteAddress8
%define! Pari2cAddr
%define! ParmemAddr
%define! Pardata
%define! RetVal
%include Common\GenericI2CReadByteAddress8.Inc
uint8_t %'ModuleName'%.%ReadByteAddress8(uint8_t i2cAddr, uint8_t memAddr, uint8_t *data)
{
  return %'ModuleName'%.ReadAddress(i2cAddr, &memAddr, sizeof(memAddr), data, 1);
}

%endif %- ReadByteAddress8
%-BW_METHOD_END ReadByteAddress8
%-************************************************************************************************************
%-BW_METHOD_BEGIN WriteByteAddress8
%ifdef WriteByteAddress8
%define! Pari2cAddr
%define! ParmemAddr
%define! Pardata
%define! RetVal
%include Common\GenericI2CWriteByteAddress8.Inc
uint8_t %'ModuleName'%.%WriteByteAddress8(uint8_t i2cAddr, uint8_t memAddr, uint8_t data)
{
  return %'ModuleName'%.WriteAddress(i2cAddr, &memAddr, sizeof(memAddr), &data, sizeof(data));
}

%endif %- WriteByteAddress8
%-BW_METHOD_END WriteByteAddress8
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadWordAddress8
%ifdef ReadWordAddress8
%define! Pari2cAddr
%define! ParmemAddr
%define! Pardata
%define! RetVal
%include Common\GenericI2CReadWordAddress8.Inc
uint8_t %'ModuleName'%.%ReadWordAddress8(uint8_t i2cAddr, uint8_t memAddr, uint16_t *data)
{
  return %'ModuleName'%.ReadAddress(i2cAddr, &memAddr, sizeof(memAddr), (uint8_t*)data, 2);
}

%endif %- ReadWordAddress8
%-BW_METHOD_END ReadWordAddress8
%-************************************************************************************************************
%-BW_METHOD_BEGIN WriteWordAddress8
%ifdef WriteWordAddress8
%define! Pari2cAddr
%define! ParmemAddr
%define! Pardata
%define! RetVal
%include Common\GenericI2CWriteWordAddress8.Inc
uint8_t %'ModuleName'%.%WriteWordAddress8(uint8_t i2cAddr, uint8_t memAddr, uint16_t data)
{
  return %'ModuleName'%.WriteAddress(i2cAddr, &memAddr, sizeof(memAddr), (uint8_t*)&data, sizeof(data));
}

%endif %- WriteWordAddress8
%-BW_METHOD_END WriteWordAddress8
%-************************************************************************************************************
%-BW_METHOD_BEGIN ScanDevice
%ifdef ScanDevice
%define! Pari2cAddr
%define! RetVal
%include Common\GenericI2CScanDevice.Inc
uint8_t %'ModuleName'%.%ScanDevice(uint8_t i2cAddr)
{
  uint8_t res = ERR_OK;
%if defined(LDD_I2C)
%if defined(Timeout)
  %@Timeout@'ModuleName'%.CounterHandle timeout;
  bool isTimeout=FALSE;
%endif
  LDD_I2C_TErrorMask errMask;
%else
  uint16_t nof;
%endif
  uint8_t dummy;

  if (%'ModuleName'%.%SelectSlave(i2cAddr)!=ERR_OK) {
    return ERR_FAILED;
  }
%if defined(LDD_I2C)
  for(;;) { /* breaks */
    /* send device address */
    %'ModuleName'%.deviceData.dataTransmittedFlg = FALSE;
    res = %@LDD_I2C@'ModuleName'%.MasterReceiveBlock(%'ModuleName'%.deviceData.handle, &dummy, 1, LDD_I2C_SEND_STOP);
    if (res!=ERR_OK) {
    #if %'ModuleName'%.CONFIG_USE_ON_ERROR_EVENT
      %'ModuleName'%.CONFIG_ON_ERROR_EVENT();
    #endif
      break; /* break for(;;) */
    }
%if defined(Timeout)
    timeout = %@Timeout@'ModuleName'%.GetCounter(%'ModuleName'%.TIMEOUT_TICKS(1)); /* set up timeout counter */
    if (timeout==%@Timeout@'ModuleName'%.OUT_OF_HANDLE) {
      res = ERR_QFULL;
    #if %'ModuleName'%.CONFIG_USE_ON_ERROR_EVENT
      %'ModuleName'%.CONFIG_ON_ERROR_EVENT();
    #endif
      break; /* break for(;;) */
    }
%endif
    do { /* Wait until data is sent */
%if defined(Timeout)
      isTimeout = %@Timeout@'ModuleName'%.CounterExpired(timeout);
      if (isTimeout) {
      #if %'ModuleName'%.CONFIG_USE_ON_ERROR_EVENT
        %'ModuleName'%.CONFIG_ON_ERROR_EVENT();
      #endif
        break; /* break while() */
      }
%endif
    } while (!%'ModuleName'%.deviceData.dataTransmittedFlg);
    errMask = 0;
    (void)%@LDD_I2C@'ModuleName'%.GetError(%'ModuleName'%.deviceData.handle, &errMask);
%if defined(Timeout)
    %@Timeout@'ModuleName'%.LeaveCounter(timeout);
%endif
    if (errMask&LDD_I2C_MASTER_NACK) { /* master did not receive ACK from slave */
      res = ERR_NOTAVAIL; /* device did not respond with ACK */
    #if %'ModuleName'%.CONFIG_USE_ON_ERROR_EVENT
      %'ModuleName'%.CONFIG_ON_ERROR_EVENT();
    #endif
    }
    break; /* break for(;;) */
  } /* for(;;) */
%else
  for(;;) { /* breaks */
    res = %@I2C@'ModuleName'%.RecvBlock((void*)&dummy, 1, &nof);
    if (res!=ERR_OK) {
      (void)%@I2C@'ModuleName'%.SendStop();
    #if %'ModuleName'%.CONFIG_USE_ON_ERROR_EVENT
      %'ModuleName'%.CONFIG_ON_ERROR_EVENT();
    #endif
      break; /* break for(;;) */
    }
    res = %@I2C@'ModuleName'%.SendStop();
    if (res!=ERR_OK) {
    #if %'ModuleName'%.CONFIG_USE_ON_ERROR_EVENT
      %'ModuleName'%.CONFIG_ON_ERROR_EVENT();
    #endif
      break; /* break for(;;) */
    }
    break; /* break for(;;) */
  } /* for(;;) */
%endif
  if (%'ModuleName'%.%UnselectSlave()!=ERR_OK) {
  #if %'ModuleName'%.CONFIG_USE_ON_ERROR_EVENT
    %'ModuleName'%.CONFIG_ON_ERROR_EVENT();
  #endif
    return ERR_FAILED;
  }
  return res;
}

%endif %- ScanDevice
%-BW_METHOD_END ScanDevice
%-************************************************************************************************************
%-BW_METHOD_BEGIN ProbeACK
%ifdef ProbeACK
%define! Pardata
%define! PardataSize
%define! Parflags
%define! ParWaitTimeUS
%define! RetVal
%include Common\GenericI2CProbeACK.Inc
uint8_t %'ModuleName'%.%ProbeACK(void* data, uint16_t dataSize, %'ModuleName'_EnumSendFlags flags, uint16_t WaitTimeUS)
{
%if defined(I2C)
  uint16_t nof;
%endif
  uint8_t res = ERR_OK;

%if defined(LDD_I2C)
  %'ModuleName'%.deviceData.dataTransmittedFlg = FALSE;
  res = %@LDD_I2C@'ModuleName'%.MasterSendBlock(%'ModuleName'%.deviceData.handle, data, dataSize, flags==%'ModuleName'_SEND_STOP?LDD_I2C_SEND_STOP:LDD_I2C_NO_SEND_STOP);
  if (res!=ERR_OK) {
  #if %'ModuleName'%.CONFIG_USE_ON_ERROR_EVENT
    %'ModuleName'%.CONFIG_ON_ERROR_EVENT();
  #endif
    return res;
  }
  /*lint -save -e522 Lacks side effect */
  %@Wait@'ModuleName'%.Waitus(WaitTimeUS);
  /*lint -restore */
  if (!%'ModuleName'%.deviceData.dataTransmittedFlg) {
  #if %'ModuleName'%.CONFIG_USE_ON_ERROR_EVENT
    %'ModuleName'%.CONFIG_ON_ERROR_EVENT();
  #endif
    return ERR_FAILED; /* no ACK received? */
  }
%else
  (void)WaitTimeUS; /* not used */
  for(;;) { /* breaks */
    res = %@I2C@'ModuleName'%.SendBlock(data, dataSize, &nof);
    if (res!=ERR_OK) {
      (void)%@I2C@'ModuleName'%.SendStop();
    #if %'ModuleName'%.CONFIG_USE_ON_ERROR_EVENT
      %'ModuleName'%.CONFIG_ON_ERROR_EVENT();
    #endif
      break; /* break for(;;) */
    }
    if (flags==%'ModuleName'_SEND_STOP) {
      res = %@I2C@'ModuleName'%.SendStop();
      if (res!=ERR_OK) {
      #if %'ModuleName'%.CONFIG_USE_ON_ERROR_EVENT
        %'ModuleName'%.CONFIG_ON_ERROR_EVENT();
      #endif
        break; /* break for(;;) */
      }
    }
    break; /* break for(;;) */
  } /* for(;;) */
%endif
  return res;
}

%endif %- ProbeACK
%-BW_METHOD_END ProbeACK
%-************************************************************************************************************
%-BW_METHOD_BEGIN ReadByte
%ifdef ReadByte
%define! Pari2cAddr
%define! Pardata
%define! RetVal
%include Common\GenericI2CReadByte.Inc
uint8_t %'ModuleName'%.%ReadByte(uint8_t i2cAddr, uint8_t *data)
{
  return %'ModuleName'%.ReadAddress(i2cAddr, NULL, 0, data, 1);
}

%endif %- ReadByte
%-BW_METHOD_END ReadByte
%-************************************************************************************************************
%-BW_METHOD_BEGIN WriteByte
%ifdef WriteByte
%define! Pari2cAddr
%define! Pardata
%define! RetVal
%include Common\GenericI2CWriteByte.Inc
uint8_t %'ModuleName'%.%WriteByte(uint8_t i2cAddr, uint8_t data)
{
  return %'ModuleName'%.WriteAddress(i2cAddr, NULL, 0, &data, 1);
}

%endif %- WriteByte
%-BW_METHOD_END WriteByte
%-BW_IMPLEMENT_END
/* END %ModuleName. */

%include Common\Header.End
%-
%-
%-BW_EVENT_IMPLEMENT_START
%-BW_METHOD_BEGIN OnRequestBus
%ifdef OnRequestBus
%IMPLEMENTATION OnRequestBus
%include Common\GenericI2COnRequestBus.Inc
void %OnRequestBus(void)
{
  /* Write your code here ... */
}

%endif %- OnRequestBus
%-BW_METHOD_END OnRequestBus
%-BW_METHOD_BEGIN OnReleaseBus
%ifdef OnReleaseBus
%IMPLEMENTATION OnReleaseBus
%include Common\GenericI2COnReleaseBus.Inc
void %OnReleaseBus(void)
{
  /* Write your code here ... */
}

%endif %- OnReleaseBus
%-BW_METHOD_END OnReleaseBus
%-BW_METHOD_BEGIN OnError
%ifdef OnError
%IMPLEMENTATION OnError
%include Common\GenericI2COnError.Inc
void %OnError(void)
{
  /* Write your code here ... */
}

%endif %- OnError
%-BW_METHOD_END OnError
%-BW_EVENT_IMPLEMENT_END
%INITIALIZATION
  /* ### %DeviceType "%DeviceName" init code ... */
%CODE_BEGIN
%if %initOnStartup='yes'
  %'ModuleName'%.%Init();
%endif
%CODE_END
%-
%ENABLE
%CODE_BEGIN
%CODE_END
%-
%-----------------------------------------------------------------------------------------
%if defined(sdk) & %@sdk@ConfigFilesFolderName <> ""
  %define  ConfigSrcDirFolder %%@sdk@ConfigFilesFolderName/
%else
  %define  ConfigSrcDirFolder
%endif
%----------------------------
%FILE %'DirRel_Code'%'ConfigSrcDirFolder'%'ModuleName'config.h
/**
 * \file
 * \brief Configuration header file for GenericI2C
 *
 * This header file is used to configure settings of the Generic I2C module.
 */

#ifndef __%'ModuleName'_CONFIG_H
#define __%'ModuleName'_CONFIG_H

#if !defined(%'ModuleName'%.CONFIG_USE_ON_REQUEST_BUS_EVENT)
  %if defined(OnRequestBus)
  #define %'ModuleName'%.CONFIG_USE_ON_REQUEST_BUS_EVENT    (1)
    /*!< 1: generate user events for requesting bus; 0: no user events */
  #define %'ModuleName'%.CONFIG_ON_REQUEST_BUS_EVENT   %OnRequestBus
  void %'ModuleName'%.CONFIG_ON_REQUEST_BUS_EVENT(void); /* prototype */
  %else
  #define %'ModuleName'%.CONFIG_USE_ON_REQUEST_BUS_EVENT    (0)
    /*!< 1: generate user events for requesting bus; 0: no user events */
  #define %'ModuleName'%.CONFIG_ON_REQUEST_BUS_EVENT   McuGenericI2C_OnRequestBus
  void %'ModuleName'%.CONFIG_ON_REQUEST_BUS_EVENT(void); /* prototype */
  %endif
#endif

#if !defined(%'ModuleName'%.CONFIG_USE_ON_RELEASE_BUS_EVENT)
  %if defined(OnReleaseBus)
  #define %'ModuleName'%.CONFIG_USE_ON_RELEASE_BUS_EVENT    (1)
    /*!< 1: generate user events for releasing bus; 0: no user events */
  #define %'ModuleName'%.CONFIG_ON_RELEASE_BUS_EVENT   %OnReleaseBus
  void %'ModuleName'%.CONFIG_ON_RELEASE_BUS_EVENT(void); /* prototype */
  %else
  #define %'ModuleName'%.CONFIG_USE_ON_RELEASE_BUS_EVENT    (0)
    /*!< 1: generate user events for releasing bus; 0: no user events */
  #define %'ModuleName'%.CONFIG_ON_RELEASE_BUS_EVENT   McuGenericI2C_DriverAuthorBus
  void %'ModuleName'%.CONFIG_ON_RELEASE_BUS_EVENT(void); /* prototype */
  %endif
#endif

#if !defined(%'ModuleName'%.CONFIG_USE_ON_ERROR_EVENT)
  %if defined(OnError)
  #define %'ModuleName'%.CONFIG_USE_ON_ERROR_EVENT    (1)
    /*!< 1: generate user events for errors; 0: no error events */
  #define %'ModuleName'%.CONFIG_ON_ERROR_EVENT   %OnError
  void %'ModuleName'%.CONFIG_ON_ERROR_EVENT(void); /* prototype */
  %else
  #define %'ModuleName'%.CONFIG_USE_ON_ERROR_EVENT    (0)
    /*!< 1: generate user events for errors; 0: no error events */
  #define %'ModuleName'%.CONFIG_ON_ERROR_EVENT   McuGenericI2C_OnRequestBus
  void %'ModuleName'%.CONFIG_ON_ERROR_EVENT(void); /* prototype */
  %endif
#endif

#if !defined(%'ModuleName'%.CONFIG_USE_MUTEX)
  %if defined(RTOS) & %UseSemaphore='yes'
  #define %'ModuleName'%.CONFIG_USE_MUTEX             (1)
    /*!< 1: Use a mutex to protect access to the bus; 0: no mutex used */
  %else
  #define %'ModuleName'%.CONFIG_USE_MUTEX             (0)
    /*!< 1: Use a mutex to protect access to the bus; 0: no mutex used */
  %endif
#endif


#endif /* __%'ModuleName'_CONFIG_H */
%-----------------------------------------------------------------------------------------
%else %- Language (& Compiler)
  %error^ This component is not implemented in selected language & compiler !
%endif %- Language (& Compiler)
%DEBUG
%ALL_SYMBOLS
%-
