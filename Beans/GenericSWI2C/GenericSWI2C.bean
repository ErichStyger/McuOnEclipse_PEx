<?xml version="1.0" encoding="UTF-8"?>
<Bean>
  <Header>
    <Name>GenericSWI2C</Name>
    <Description>Generic Software I2C</Description>
    <Author>Erich Styger, Marc Lindahl</Author>
    <Version>01.027</Version>
    <Icon>GenericSWI2C</Icon>
    <TypesFiles>PE,GenericSWI2C\GenericSWI2C</TypesFiles>
    <FileVersion>6</FileVersion>
  </Header>
  <Options>
    <BW_HelpType>Basic</BW_HelpType>
    <BW_HelpFiles>,Properties,Methods,Events</BW_HelpFiles>
    <BW_AutoSaveHelp>yes</BW_AutoSaveHelp>
    <BW_AutoSaveDriver>yes</BW_AutoSaveDriver>
    <BW_DetailedHelp>yes</BW_DetailedHelp>
    <BW_NeedTps>no</BW_NeedTps>
    <BW_NeedUst>2</BW_NeedUst>
    <BW_NeedCns>0</BW_NeedCns>
    <BeanStatus>PROPOSAL</BeanStatus>
    <Copyright> * Copyright (c) 2014-2023, Erich Styger\n * Web:         https://mcuoneclipse.com\n * SourceForge: https://sourceforge.net/projects/mcuoneclipse\n * Git:         https://github.com/ErichStyger/McuOnEclipse_PEx\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *\n * - Redistributions of source code must retain the above copyright notice, this list\n *   of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright notice, this\n *   list of conditions and the following disclaimer in the documentation and/or\n *   other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</Copyright>
    <Category>CPU External Devices-Communication</Category>
    <DemoDriver>no</DemoDriver>
    <BeanLevel>Low</BeanLevel>
    <Shortcut>I2C</Shortcut>
  </Options>
  <PropertyList>
    <Property>
      <TCompNameItem>
        <Name>Component name</Name>
        <Symbol>DeviceName</Symbol>
        <Hint>Name of the component.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>true</EditLine>
        <DefaultValue/>
      </TCompNameItem>
    </Property>
    <Property>
      <TIntgItem>
        <Name>Delay (ns)</Name>
        <Symbol>DelayNs</Symbol>
        <Hint>Delay (in nano seconds) used to slow down bit banging.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>true</EditLine>
        <DefaultValue>1250</DefaultValue>
        <MinValue>0</MinValue>
        <MaxValue>-1</MaxValue>
        <Bases>DEC</Bases>
        <DefaultBase>DEC</DefaultBase>
        <ExtraHintDisabled>false</ExtraHintDisabled>
        <ChangeValueIntoRange>false</ChangeValueIntoRange>
        <RuntimeProperty>false</RuntimeProperty>
      </TIntgItem>
    </Property>
    <Property>
      <TIntgItem>
        <Name>Trials</Name>
        <Symbol>NofTrials</Symbol>
        <Hint>How many times the driver shall try to get access to the bus, until it returnss an ERR_BUSY.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>true</EditLine>
        <DefaultValue>256</DefaultValue>
        <MinValue>1</MinValue>
        <MaxValue>-1</MaxValue>
        <Bases>DEC</Bases>
        <DefaultBase>DEC</DefaultBase>
        <ExtraHintDisabled>false</ExtraHintDisabled>
        <ChangeValueIntoRange>false</ChangeValueIntoRange>
        <RuntimeProperty>false</RuntimeProperty>
      </TIntgItem>
    </Property>
    <Property>
      <TInhrItem>
        <Name>SDA</Name>
        <Symbol>SDA</Symbol>
        <TypeSpec>GenericSWI2C\SDA</TypeSpec>
        <Hint>SDA pin</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>-1</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <InhrBeanBaseName>SDA</InhrBeanBaseName>
        <ShowInheritedMethodsEventsInPrjTree>true</ShowInheritedMethodsEventsInPrjTree>
      </TInhrItem>
    </Property>
    <Property>
      <TInhrItem>
        <Name>SCL</Name>
        <Symbol>SCL</Symbol>
        <TypeSpec>GenericSWI2C\SCL</TypeSpec>
        <Hint>SCL pin</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>-1</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <InhrBeanBaseName>SCL</InhrBeanBaseName>
        <ShowInheritedMethodsEventsInPrjTree>true</ShowInheritedMethodsEventsInPrjTree>
      </TInhrItem>
    </Property>
    <Property>
      <TInhrLinkItem>
        <Name>SDK</Name>
        <Symbol>sdk</Symbol>
        <TypeSpec>GenericSWI2C\sdk</TypeSpec>
        <Hint>Link to SDK used</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <DefaultValue/>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <SortStyle/>
      </TInhrLinkItem>
    </Property>
    <Property>
      <TInhrLinkItem>
        <Name>Wait</Name>
        <Symbol>Wait</Symbol>
        <TypeSpec>GenericSWI2C\Wait</TypeSpec>
        <Hint>Interface to waiting methods</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <DefaultValue/>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <SortStyle/>
      </TInhrLinkItem>
    </Property>
    <Property>
      <TBoolItem>
        <Name>Yield</Name>
        <Symbol>Yield</Symbol>
        <TypeSpec>typeYesNo</TypeSpec>
        <Hint>Yield if an RTOS is present during waiting. This avoids that the task using the driver starves other tasks.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
      </TBoolItem>
    </Property>
    <Property>
      <TIntgItem>
        <Name>Timeout Counter Value</Name>
        <Symbol>TimeoutCntrVal</Symbol>
        <Hint>Timeout counter which is counted down. The higher the value, the longer the timeout.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>true</EditLine>
        <DefaultValue>65535</DefaultValue>
        <MinValue>0</MinValue>
        <MaxValue>65535</MaxValue>
        <Bases>BIN DEC HEX</Bases>
        <DefaultBase>DEC</DefaultBase>
        <ExtraHintDisabled>false</ExtraHintDisabled>
        <ChangeValueIntoRange>false</ChangeValueIntoRange>
        <RuntimeProperty>false</RuntimeProperty>
      </TIntgItem>
    </Property>
  </PropertyList>
  <MethodList>
    <Method>
      <TMthdItem>
        <Name>Delay</Name>
        <Symbol>Delay</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>The method waits in delay loop.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>false</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>false</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>Read</Name>
        <Symbol>Read</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>The method reads one byte of data from the bus.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>false</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>false</InDefinition>
        <ReturnType>uint8_t</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>uint8_t #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>GetAck</Name>
        <Symbol>GetAck</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>The method reads ACK from the bus.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>false</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>false</InDefinition>
        <ReturnType>Boolean</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>bool #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>Write</Name>
        <Symbol>Write</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>The method sends one byte of data to the bus.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>false</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>false</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>Data</ParName>
          <ParType>uint8_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Data to be written</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(uint8_t Data)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>InternalStop</Name>
        <Symbol>InternalStop</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>The method generates the Stop condition on the bus.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>false</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>false</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>ResetBus</Name>
        <Symbol>ResetBus</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Reset bus if needed.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>Boolean</ReturnType>
        <RetHint>TRUE if bus is idle, FALSE if bus is busy/hung</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>bool #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>SendChar</Name>
        <Symbol>SendChar</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>When working as a MASTER, this method writes 7 bits of slave address plus R/W bit = 0 to the I2C bus and then writes one character (byte) to the bus. The slave address must be specified before by the "SelectSlave" method or in the  component initialization section of 'Slave address init' property. When working as the SLAVE, this method writes one character (byte) to the bus. If the ERR_NOTAVAIL error code returned, the char is successfully sent to master but the master device responds by an acknowledgment instead of no acknowledgment at the end of transfer. 'OnError' event is called in this case.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>uint8_t</ReturnType>
        <RetHint>Error code, possible codes:\nERR_OK - OK\nERR_SPEED - This device does not work in the active speed mode\nERR_BUSY - The slave device is busy, it does not respond by the acknowledgment  (MASTER mode only)\nERR_NOTAVAIL - The master device sends acknowledgment instead of no acknowledgment after the last byte transfer (SLAVE mode only)\nERR_DISABLED - Device is disabled\nERR_BUSOFF - Clock timeout elapsed (SLAVE mode only)</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>Chr</ParName>
          <ParType>uint8_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Character to send</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>uint8_t #M#_#C#(uint8_t Chr)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>RecvChar</Name>
        <Symbol>RecvChar</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>When working as a MASTER, this method writes 7 bits of slave address plus R/W bit = 1 to the I2C bus and then reads one character (byte) from the bus. The slave address must be specified before by the "SelectSlave" method or in the component initialization section of 'Slave address init' property. When working as a SLAVE, this method reads one character (byte) from the bus.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>uint8_t</ReturnType>
        <RetHint>Error code, possible codes:\nERR_OK - OK\nERR_SPEED - This device does not work in the active speed mode\nERR_BUSY - The slave device is busy, it does not respond by the acknowledgment (MASTER mode only)\nERR_DISABLED - Device is disabled\nERR_BUSOFF - Clock timeout elapsed (SLAVE mode only)</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>Chr</ParName>
          <ParType>uint8_t</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to received character</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>uint8_t #M#_#C#(uint8_t *Chr)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>SendBlock</Name>
        <Symbol>SendBlock</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>When working as a MASTER, this method writes 7 bits of slave address plus R/W bit = 0 to the I2C bus and then writes the block of characters to the bus. If the component is disabled (by the "Disable" method or initialization), the block is moved to the output buffer if the 'Output buffer size' property is different from zero. The content of the output buffer is sent immediately with the stop condition at the end when the component is enabled by the "Enable" method. After the output buffer transmission, the whole output buffer is cleared. The slave address must be specified before by the "SelectSlave" method or in component initialization section of 'Slave address init' property.  When working as a SLAVE, this method writes block of characters to the bus. If the ERR_NOTAVAIL error code is returned, the whole block is successfully sent to a master but the master device responds by an acknowledgment instead of no acknowledgment sent at the end of the last block byte transfer. 'OnError' event is called in this case.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>uint8_t</ReturnType>
        <RetHint>Error code, possible codes:\nERR_OK - OK\nERR_SPEED - This device does not work in the active speed mode\nERR_BUSY - The slave device is busy, it does not respond by the acknowledgment (MASTER mode only)\nERR_TXFULL - Output buffer is full (MASTER mode only)\nERR_NOTAVAIL - The master device sends acknowledgment instead of no acknowledgment after the last byte transfer (SLAVE mode only)\nERR_DISABLED - Device is disabled\nERR_BUSOFF - Clock timeout elapsed (SLAVE mode only)</RetHint>
        <ParamCount>3</ParamCount>
        <Parameter>
          <ParName>Ptr</ParName>
          <ParType>pointer</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>A pointer to the block of data to send</ParHint>
          <ParUserDeclaration>void *Ptr</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>Siz</ParName>
          <ParType>uint16_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The size of the block</ParHint>
        </Parameter>
        <Parameter>
          <ParName>Snt</ParName>
          <ParType>uint16_t</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>A pointer to the number of data that are sent (copied to buffer)</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>uint8_t #M#_#C#(void *Ptr, uint16_t Siz, uint16_t *Snt)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>SendBlockContinue</Name>
        <Symbol>SendBlockContinue</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Same is SendBlock() but does not send start condition. When working as a MASTER, this method writes 7 bits of slave address plus R/W bit = 0 to the I2C bus and then writes the block of characters to the bus. If the component is disabled (by the "Disable" method or initialization), the block is moved to the output buffer if the 'Output buffer size' property is different from zero. The content of the output buffer is sent immediately with the stop condition at the end when the component is enabled by the "Enable" method. After the output buffer transmission, the whole output buffer is cleared. The slave address must be specified before by the "SelectSlave" method or in component initialization section of 'Slave address init' property.  When working as a SLAVE, this method writes block of characters to the bus. If the ERR_NOTAVAIL error code is returned, the whole block is successfully sent to a master but the master device responds by an acknowledgment instead of no acknowledgment sent at the end of the last block byte transfer. 'OnError' event is called in this case.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>uint8_t</ReturnType>
        <RetHint>Error code, possible codes:\nERR_OK - OK\nERR_SPEED - This device does not work in the active speed mode\nERR_BUSY - The slave device is busy, it does not respond by the acknowledgment (MASTER mode only)\nERR_TXFULL - Output buffer is full (MASTER mode only)\nERR_NOTAVAIL - The master device sends acknowledgment instead of no acknowledgment after the last byte transfer (SLAVE mode only)\nERR_DISABLED - Device is disabled\nERR_BUSOFF - Clock timeout elapsed (SLAVE mode only)</RetHint>
        <ParamCount>3</ParamCount>
        <Parameter>
          <ParName>Ptr</ParName>
          <ParType>pointer</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>A pointer to the block of data to send</ParHint>
          <ParUserDeclaration>void *Ptr</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>Siz</ParName>
          <ParType>uint16_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The size of the block</ParHint>
        </Parameter>
        <Parameter>
          <ParName>Snt</ParName>
          <ParType>uint16_t</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>A pointer to the number of data that are sent (copied to buffer)</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>uint8_t #M#_#C#(void *Ptr, uint16_t Siz, uint16_t *Snt)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>RecvBlock</Name>
        <Symbol>RecvBlock</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>When working as a MASTER, this method writes 7 bits of slave address plus R/W bit = 1 to the I2C bus and then reads the block of characters from the bus. The slave address must be specified before by the "SelectSlave" method or in component initialization section of 'Slave address init' property.  When working as a SLAVE, this method reads the block of characters from the bus.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>uint8_t</ReturnType>
        <RetHint>Error code, possible codes:\nERR_OK - OK\nERR_SPEED - This device does not work in the active speed mode\nERR_BUSY - The slave device is busy, it does not respond by the acknowledgment (MASTER mode only)\nERR_DISABLED - Device is disabled\nERR_BUSOFF - Clock timeout elapsed (SLAVE mode only)</RetHint>
        <ParamCount>3</ParamCount>
        <Parameter>
          <ParName>Ptr</ParName>
          <ParType>pointer</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>A pointer to the block space for received data</ParHint>
          <ParUserDeclaration>void *Ptr</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>Siz</ParName>
          <ParType>uint16_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The size of the block</ParHint>
        </Parameter>
        <Parameter>
          <ParName>Rcv</ParName>
          <ParType>uint16_t</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>A pointer to the number of actually received data</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>uint8_t #M#_#C#(void *Ptr, uint16_t Siz, uint16_t *Rcv)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>RecvBlockCustom</Name>
        <Symbol>RecvBlockCustom</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Same as RecvBlock(), but with additional flags to control the bus transfer.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>uint8_t</ReturnType>
        <RetHint>Error code, possible codes:\nERR_OK - OK\nERR_SPEED - This device does not work in the active speed mode\nERR_BUSY - The slave device is busy, it does not respond by the acknowledgment (MASTER mode only)\nERR_DISABLED - Device is disabled\nERR_BUSOFF - Clock timeout elapsed (SLAVE mode only)</RetHint>
        <ParamCount>5</ParamCount>
        <Parameter>
          <ParName>Ptr</ParName>
          <ParType>pointer</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>A pointer to the block space for received data</ParHint>
          <ParUserDeclaration>void *Ptr</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>Siz</ParName>
          <ParType>uint16_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The size of the block</ParHint>
        </Parameter>
        <Parameter>
          <ParName>Rcv</ParName>
          <ParType>uint16_t</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>A pointer to the number of actually received data</ParHint>
        </Parameter>
        <Parameter>
          <ParName>flagsStart</ParName>
          <ParType>uint8_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Flags for start condition</ParHint>
          <ParUserDeclaration>%'ModuleName'%.EnumStartFlags flagsStart</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>flagsAck</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Flags for Ack after last byte</ParHint>
          <ParUserDeclaration>%'ModuleName'%.EnumAckFlags flagsAck</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>uint8_t #M#_#C#(void *Ptr, uint16_t Siz, uint16_t *Rcv, %'ModuleName'%.EnumStartFlags flagsStart, %'ModuleName'%.EnumAckFlags flagsAck)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>SendAck</Name>
        <Symbol>SendAck</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>The method sends ACK to the bus.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>false</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>Ack</ParName>
          <ParType>Boolean</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>If acknowledge is high or low</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(bool Ack)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>SendStop</Name>
        <Symbol>SendStop</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>When working as a MASTER, if the 'Automatic stop condition' property value is 'no', this method sends a valid stop  condition to the serial data line of the I2C bus to terminate the communication on the bus after using send methods. This method is enabled only if the component is in MASTER mode and 'Automatic stop condition' property value is 'no'</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>uint8_t</ReturnType>
        <RetHint>Error code, possible codes:\nERR_OK - OK\nERR_SPEED - This device does not work in the active speed mode\nERR_DISABLED - Device is disabled</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>uint8_t #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>SelectSlave</Name>
        <Symbol>SelectSlave</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>When working as a MASTER, this method selects a new slave for communication by its slave address value. Any send or receive method are directed to or from the selected device, until a new slave device is selected by this method. If the selected slave uses 10-bit slave addressing, as the parameter 7 bits must be passed, which involves 10-bit addressing (11110XX), including two MSBs of slave address (XX). The second byte of the 10-bit slave address must be sent to the slave as a general character of send methods. This method is available only if the component is in MASTER mode.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>uint8_t</ReturnType>
        <RetHint>Error code, possible codes:\nERR_OK - OK\nERR_SPEED - This device does not work in the active speed mode\nERR_DISABLED -  Device is disabled</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>Slv</ParName>
          <ParType>uint8_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Slave address value</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>uint8_t #M#_#C#(uint8_t Slv)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>GetSelected</Name>
        <Symbol>GetSelected</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>When working as a MASTER, this method returns the identification address value of the slave, which is currently selected for communication with the master. If the current slave uses 10-bit slave addressing, the method returns the first 7 bits only, which involves 10-bit addressing (11110XX), including two MSBs of the slave address (XX). This method is not able to return the rest value of 10-bit slave address. This method is available only if the component is in MASTER mode.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>uint8_t</ReturnType>
        <RetHint>Error code, possible codes:\nERR_OK - OK\nERR_SPEED - This device does not work in the active speed mode</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>Slv</ParName>
          <ParType>uint8_t</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>A pointer to the current selected slave address value</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>uint8_t #M#_#C#(uint8_t *Slv)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>Deinit</Name>
        <Symbol>Deinit</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Driver de-initialization method.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>Init</Name>
        <Symbol>Init</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Initializes the associated peripheral(s) and the components internal variables.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
  </MethodList>
  <EventList>
    <Event>
      <TStrgItem>
        <Name>Event module name</Name>
        <Symbol>EventModule</Symbol>
        <Hint>Name of the user module (without extension), where the events from this component are placed.</Hint>
        <ItemLevel>ADVANCED</ItemLevel>
        <EditLine>true</EditLine>
        <DefaultValue>Events</DefaultValue>
        <StrDefine>nothing</StrDefine>
        <MinLength>0</MinLength>
        <MaxLength>-1</MaxLength>
      </TStrgItem>
    </Event>
    <Event>
      <TEvntItem>
        <Name>OnNACK</Name>
        <Symbol>OnNACK</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Event called whenever we receive a wrong acknowledge (NACK)</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <BoldName>true</BoldName>
        <EditLine>false</EditLine>
        <Description>don't generate code</Description>
        <Expanded>No</Expanded>
        <DefaultValue>false</DefaultValue>
        <DefineSymbol>YES_NO</DefineSymbol>
        <IfDisabled>setNOTHING</IfDisabled>
        <IsAssembler>false</IsAssembler>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #C#(void)</ANSIC>
        </Declarations>
        <Children>
          <GrupItem>
            <TEvntName>
              <Name>Event procedure name</Name>
              <Symbol>Name</Symbol>
              <Hint>OnNACK procedure name</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue/>
              <StrDefine>nothing</StrDefine>
              <MinLength>0</MinLength>
              <MaxLength>-1</MaxLength>
              <ErrorIfNotSet>true</ErrorIfNotSet>
              <IdentType>EVNT</IdentType>
            </TEvntName>
          </GrupItem>
        </Children>
      </TEvntItem>
    </Event>
    <Event>
      <TEvntItem>
        <Name>OnTxChar</Name>
        <Symbol>OnTxChar</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Event called whenever we have sent a character</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <BoldName>true</BoldName>
        <EditLine>false</EditLine>
        <Description>don't generate code</Description>
        <Expanded>No</Expanded>
        <DefaultValue>false</DefaultValue>
        <DefineSymbol>YES_NO</DefineSymbol>
        <IfDisabled>setNOTHING</IfDisabled>
        <IsAssembler>false</IsAssembler>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #C#(void)</ANSIC>
        </Declarations>
        <Children>
          <GrupItem>
            <TEvntName>
              <Name>Event procedure name</Name>
              <Symbol>Name</Symbol>
              <Hint>OnTxChar procedure name</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue/>
              <StrDefine>nothing</StrDefine>
              <MinLength>0</MinLength>
              <MaxLength>-1</MaxLength>
              <ErrorIfNotSet>true</ErrorIfNotSet>
              <IdentType>EVNT</IdentType>
            </TEvntName>
          </GrupItem>
        </Children>
      </TEvntItem>
    </Event>
    <Event>
      <TEvntItem>
        <Name>OnRxChar</Name>
        <Symbol>OnRxChar</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Event called whenever we received a character</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <BoldName>true</BoldName>
        <EditLine>false</EditLine>
        <Description>don't generate code</Description>
        <Expanded>No</Expanded>
        <DefaultValue>false</DefaultValue>
        <DefineSymbol>YES_NO</DefineSymbol>
        <IfDisabled>setNOTHING</IfDisabled>
        <IsAssembler>false</IsAssembler>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #C#(void)</ANSIC>
        </Declarations>
        <Children>
          <GrupItem>
            <TEvntName>
              <Name>Event procedure name</Name>
              <Symbol>Name</Symbol>
              <Hint>OnRxChar procedure name</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue/>
              <StrDefine>nothing</StrDefine>
              <MinLength>0</MinLength>
              <MaxLength>-1</MaxLength>
              <ErrorIfNotSet>true</ErrorIfNotSet>
              <IdentType>EVNT</IdentType>
            </TEvntName>
          </GrupItem>
        </Children>
      </TEvntItem>
    </Event>
  </EventList>
  <Links>
    <EmptySection_DummyValue/>
  </Links>
  <Revisions>
    <RevisionVersion>2</RevisionVersion>
  </Revisions>
</Bean>
