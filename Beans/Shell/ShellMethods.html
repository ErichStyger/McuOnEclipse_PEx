<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head>
<meta http-equiv="content-type" content="text/html; charset=windows-1250">
<title>
Bean  documentation - Methods
</title>
<STYLE type="text/css">
body{
  background-color: white;
  margin:0px;
  font: 13px Helvetica Neue, Helvetica, Arial, sans-serif;
}
A:visited {
	COLOR: #2D8AA7; TEXT-DECORATION: none
}
A:link {
	COLOR: #2D8AA7; TEXT-DECORATION: none
}
A:active {
	COLOR: #2D8AA7; TEXT-DECORATION: none
}
A:hover {
	COLOR: #2D8AA7; TEXT-DECORATION: underline
}
.VSP {
	COLOR: #2D8AA7; FONT: bold italic 14px Helvetica Neue, Helvetica, Arial, sans-serif;
}
.reflink {
	FONT: 11px/18px Helvetica Neue, Helvetica, Arial, sans-serif;
 	COLOR: #2D8AA7;
}
.user_text {
	FONT: 12px/18px Helvetica Neue, Helvetica, Arial, sans-serif;
	COLOR: #000000;
}
.bluetext {
  COLOR: #695F52;
}
.versionspec {
  padding:5px; 
  background-color: RGB(243, 242, 230);
  margin-top:5px;
  margin-bottom:5px;  
}
.versionspecdetail {
  padding:5px; 
  background-color: RGB(243, 242, 230);
  margin-top:5px;
  margin-bottom:5px;  
}
.versionspeclabel {
  font-style: italic;
}
LI.DEF {
  list-style-image: url(DefaultLI.gif) ;
}
LI.BAS {
	list-style-image: url(BasicLI.gif) ;
}
LI.ADV {
	list-style-image: url(AdvancedLI.gif) ;
}
LI.EXP {
	list-style-image: url(ExpertLI.gif) ;
}
.titlebox {  
  font: bold 18px Helvetica Neue, Helvetica, Arial, sans-serif;
  color: #51626F;
  margin-bottom: 10px;
}
.lefttitlebox {
  background-color:#C3CFD1;  
}
.lefttitle {
  color:#51626F;
  font: bold 11px Helvetica Neue, Helvetica, Arial, sans-serif;   
}
.beanname {
  font: bold 14px/18px Helvetica Neue, Helvetica, Arial, sans-serif;
  padding-top:6px;
  padding-bottom:5px;
  margin-bottom: 5px;
  border-bottom-style: dotted;
  border-bottom-width: 1;  
}
.descrtext {
  font-style: italic;
  font: 14px/18px Helvetica Neue, Helvetica, Arial, sans-serif;  
  padding-bottom:9px;
}
.footer {
  color: #b0b0b0; 
  font: 9px Helvetica Neue, Helvetica, Arial, sans-serif;
  text-align: center;
  border-top-style: solid;
  border-top-color: #BOBOBO;
  border-top-width: 1px;  
  padding-top: 5px;
  margin-top: 20px;
}
.info_name {
  font: 9px Helvetica Neue, Helvetica, Arial, sans-serif;
  padding: 0px;
  color: black;
}
.info_text {
  font: 11px Helvetica Neue, Helvetica, Arial, sans-serif;
}
.text_title {
  COLOR: #000000; 
  FONT: bold 14px Helvetica Neue, Helvetica, Arial, sans-serif;
}
.descr_line {
  COLOR: gray; 
  FONT: 9px Helvetica Neue, Helvetica, Arial, sans-serif;
}
.code {
  background-color: RGB(243, 242, 230);
  padding: 10px;
  white-space: pre;
  font-family: Courier New, Monospace;
}
</STYLE>

</head>

<body>

<table border="0"  cellspacing="0" cellpadding="0">
  <tr>
    <td valign="top" width="150" >
      <table  width="150" height="160" cellpadding="3" cellspacing="0" border="0">
        <tbody>
        <tr class="lefttitlebox">
          <td width="4"></td>
          <td align="center" valign="middle" height="30" width="128">
            <span class="lefttitle">
<b>Shell</b>
            </span>
          </td>
        </tr>
        <tr height="700">
          <td width="4"></td>
          <td width="128" valign="top">
            &nbsp;<br />
            <div class="reflink">
<!---HTMLLISTBEG_SHORT DON'T CHANGE THIS LINE-->
<a href="Shell.html">General Info</a><br />
<a href="ShellApplication Notes.html">Application Notes</a><br />
<a href="ShellEvents.html">Events</a><br />
<i>Methods</i><br />
<a href="ShellProperties.html">Properties</a><br />
<a href="ShellUser Types.html">Types and constants</a><br />
<!---HTMLLISTEND DON'T CHANGE THIS LINE-->
<br /><br /><br />

<br /><br /><br />
<center>
<img src="Shell_b.gif" alt="Bean icon"/>


</center>
            </div>
          </td>
        </tr>
        </tbody>
      </table>
    </td>
    <td width="1" class="lefttitlebox" valign="top">
      <table class="lefttitlebox" width="1" cellpadding="0" cellspacing="0" height="100%" border="0">
        <tr class="lefttitlebox"><td width="1"></td></tr>
      </table>
    </td>
    <td style="padding-left:15px;padding-right:10px;" valign="top" align="left" width="100%" >

         <div class="titlebox">
            <div class="beanname">
              Bean
              
              
              Shell
            </div>
            <div class="descrtext">Command Line Shell</div>
            <div class="info_name">Component Level: <span class="info_text"><a href="../../DOCs/BeanCategoriesInfo.html#LevelAbstraction">High</a></span></div>
            <div class="info_name">Category: 
              <span class="info_text">
              <a href="../../DOCs/BeanCategoriesInfo.html">Software-User Components</a>
              
              </span>
            </div>
          </div>

         <div class="text_title">
              Methods:
    		 </div>		 
    		 <div class="descr_line">                  
              (Methods are user-callable functions/subroutines intended for
               the component functions control. Please see the <a href="../../DOCs/EmbeddedBeans.html#Methods">Embedded Components page</a> for more information.)                   
         </div>
                  
         <div class="user_text">
            <ul>
<!---USERBEG DON'T CHANGE THIS LINE-->

<!---USEREND DON'T CHANGE THIS LINE-->
<li><a name="PrintPrompt">
<b>PrintPrompt</b></a>
 - Prints the prompt to the stdOut channel
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void PrintPrompt(<i>ComponentName_</i>ConstStdIOType *io)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>io: Pointer to <a href="ShellUser Types.html#ConstStdIOType"><i>ComponentName_</i>ConstStdIOType</a></i> - Pointer to IO to be used</li>
</ul><br />
</li>
<li><a name="SendNum8u">
<b>SendNum8u</b></a>
 - Sends an 8bit unsigned number to the given I/O
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void SendNum8u(uint8_t val, <i>ComponentName_</i>StdIO_OutErr_FctType io)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>val:uint8_t</i> - number to print</li>
<li><i>io:<a href="ShellUser Types.html#StdIO_OutErr_FctType"><i>ComponentName_</i>StdIO_OutErr_FctType</a></i> - I/O callbacks to be used for printing.</li>
</ul><br />
</li>
<li><a name="SendNum8s">
<b>SendNum8s</b></a>
 - Sends an 8bit signed number to the given I/O
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void SendNum8s(int8_t val, <i>ComponentName_</i>StdIO_OutErr_FctType io)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>val:int8_t</i> - number to print</li>
<li><i>io:<a href="ShellUser Types.html#StdIO_OutErr_FctType"><i>ComponentName_</i>StdIO_OutErr_FctType</a></i> - I/O callbacks to be used for printing.</li>
</ul><br />
</li>
<li><a name="SendNum16u">
<b>SendNum16u</b></a>
 - Sends a 16bit unsigned number to the given I/O
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void SendNum16u(uint16_t val, <i>ComponentName_</i>StdIO_OutErr_FctType io)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>val:uint16_t</i> - number to print</li>
<li><i>io:<a href="ShellUser Types.html#StdIO_OutErr_FctType"><i>ComponentName_</i>StdIO_OutErr_FctType</a></i> - I/O callbacks to be used for printing.</li>
</ul><br />
</li>
<li><a name="SendNum16s">
<b>SendNum16s</b></a>
 - Sends a 16bit signed number to the given I/O
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void SendNum16s(int16_t val, <i>ComponentName_</i>StdIO_OutErr_FctType io)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>val:int16_t</i> - number to print</li>
<li><i>io:<a href="ShellUser Types.html#StdIO_OutErr_FctType"><i>ComponentName_</i>StdIO_OutErr_FctType</a></i> - I/O callbacks to be used for printing.</li>
</ul><br />
</li>
<li><a name="SendNum32u">
<b>SendNum32u</b></a>
 - Sends a 32bit unsigned number to the given I/O
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void SendNum32u(uint32_t val, <i>ComponentName_</i>StdIO_OutErr_FctType io)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>val:uint32_t</i> - number to print</li>
<li><i>io:<a href="ShellUser Types.html#StdIO_OutErr_FctType"><i>ComponentName_</i>StdIO_OutErr_FctType</a></i> - I/O callbacks to be used for printing.</li>
</ul><br />
</li>
<li><a name="SendNum32s">
<b>SendNum32s</b></a>
 - Sends a 32bit signed number to the given I/O
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void SendNum32s(int32_t val, <i>ComponentName_</i>StdIO_OutErr_FctType io)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>val:int32_t</i> - number to print</li>
<li><i>io:<a href="ShellUser Types.html#StdIO_OutErr_FctType"><i>ComponentName_</i>StdIO_OutErr_FctType</a></i> - I/O callbacks to be used for printing.</li>
</ul><br />
</li>
<li><a name="SendCh">
<b>SendCh</b></a>
 - Prints a character using an I/O function
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void SendCh(uint8_t ch, <i>ComponentName_</i>StdIO_OutErr_FctType io)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>ch:uint8_t</i> - Character to send</li>
<li><i>io:<a href="ShellUser Types.html#StdIO_OutErr_FctType"><i>ComponentName_</i>StdIO_OutErr_FctType</a></i> - I/O callbacks to be used for printing.</li>
</ul><br />
</li>
<li><a name="SendStr">
<b>SendStr</b></a>
 - Prints a string using an I/O function
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void SendStr(const uint8_t *str, <i>ComponentName_</i>StdIO_OutErr_FctType io)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>str: Pointer to uint8_t</i> - Pointer to string (zero terminated) to be printed.</li>
<li><i>io:<a href="ShellUser Types.html#StdIO_OutErr_FctType"><i>ComponentName_</i>StdIO_OutErr_FctType</a></i> - I/O callbacks to be used for printing.</li>
</ul><br />
</li>
<li><a name="PrintMemory">
<b>PrintMemory</b></a>
 - Prints a chunk of memory bytes in a formatted way.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> uint8_t PrintMemory(void *hndl, uint32_t startAddr, uint32_t endAddr, uint8_t addrSize, uint8_t bytesPerLine, uint8_t (*readfp)(void *, uint32_t, uint8_t*, size_t), <i>ComponentName_</i>ConstStdIOType *io)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>hndl: Pointer to void*</i> - Pointer to </li>
<li><i>startAddr:uint32_t</i> - Memory start address</li>
<li><i>endAddr:uint32_t</i> - Memory end address</li>
<li><i>addrSize:uint8_t</i> - Number of bytes for the address (1, 2, 3 or 4)</li>
<li><i>bytesPerLine:uint8_t</i> - Number of bytes per line</li>
<li><i>readfp:byte</i> - Function pointer to read the memory. Returns error code, uses a device handle, 32bit address with a pointer to a buffer and a buffer size.</li>
<li><i>io: Pointer to <a href="ShellUser Types.html#ConstStdIOType"><i>ComponentName_</i>ConstStdIOType</a></i> - Pointer to I/O to be used</li>
<li><i>Return value:uint8_t</i> - Error code
</li>
</ul><br />
</li>
<li><a name="printfIO">
<b>printfIO</b></a>
 - Printf() style function using XFormat component, using a custom I/O handler.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> unsigned printfIO(<i>ComponentName_</i>ConstStdIOType *io, const char *fmt, ...)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>io: Pointer to <a href="ShellUser Types.html#ConstStdIOType"><i>ComponentName_</i>ConstStdIOType</a></i> - Pointer to </li>
<li><i>fmt:byte</i> - printf style format string</li>
<li><i>Return value:unsigned</i> - number of characters written
</li>
</ul><br />
</li>
<li><a name="printf">
<b>printf</b></a>
 - Printf() style function using XFormat component, using the shell default I/O handler.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> unsigned printf(const char *fmt, ...)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>fmt:byte</i> - printf style format string</li>
<li><i>Return value:unsigned</i> - number of characters written
</li>
</ul><br />
</li>
<li><a name="SendData">
<b>SendData</b></a>
 - Sends data using an I/O function. Unlike SendStr(), with this method it is possible to send binary data, including zero bytes.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void SendData(const uint8_t *data, uint16_t dataSize, <i>ComponentName_</i>StdIO_OutErr_FctType io)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>data: Pointer to byte</i> - Pointer to data to be sent</li>
<li><i>dataSize:uint16_t</i> - Number of bytes to be sent.</li>
<li><i>io:<a href="ShellUser Types.html#StdIO_OutErr_FctType"><i>ComponentName_</i>StdIO_OutErr_FctType</a></i> - I/O callbacks to be used for printing.</li>
</ul><br />
</li>
<li><a name="PrintStatus">
<b>PrintStatus</b></a>
 - Prints various available system status information
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> uint8_t PrintStatus(<i>ComponentName_</i>ConstStdIOType *io)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>io: Pointer to <a href="ShellUser Types.html#ConstStdIOType"><i>ComponentName_</i>ConstStdIOType</a></i> - Pointer to I/O callbacks</li>
<li><i>Return value:uint8_t</i> - Error code
</li>
</ul><br />
</li>
<li><a name="ParseCommand">
<b>ParseCommand</b></a>
 - Parses a shell command. Use 'help' to get a list of supported commands.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> uint8_t ParseCommand(const uint8_t *cmd, bool *handled, <i>ComponentName_</i>ConstStdIOType *io)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>cmd: Pointer to uint8_t</i> - Pointer to command string</li>
<li><i>handled: Pointer to bool</i> - Pointer to variable to indicate if the command has been handled. The caller passes this variable to the command scanner to find out if the passed command has been handled. The variable is initialized by the caller.</li>
<li><i>io: Pointer to <a href="ShellUser Types.html#ConstStdIOType"><i>ComponentName_</i>ConstStdIOType</a></i> - Pointer to I/O callbacks</li>
<li><i>Return value:uint8_t</i> - Error code
</li>
</ul><br />
</li>
<li><a name="IsHistoryCharacter">
<b>IsHistoryCharacter</b></a>
 - Returns TRUE if character is a history character
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> bool IsHistoryCharacter(uint8_t ch, uint8_t *cmdBuf, size_t cmdBufIdx, bool *isPrev)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>ch:uint8_t</i> - current command character</li>
<li><i>cmdBuf: Pointer to uint8_t</i> - Pointer to command line buffer read so far</li>
<li><i>cmdBufIdx:uint8_t</i> - Index of character into cmdBuf</li>
<li><i>isPrev: Pointer to bool</i> - Pointer to return value, if it is 'previous' history or not</li>
<li><i>Return value:bool</i> - TRUE if it is an accepted history character
</li>
</ul><br />
</li>
<li><a name="ProcessConsoleInput">
<b>ProcessConsoleInput</b></a>
 - Processes a string received from a console which can include backspace characters.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> int ProcessConsoleInput(char *buf, size_t bufSize)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>buf: Pointer to char</i> - Pointer to character buffer</li>
<li><i>bufSize:size_t</i> - Size of buffer</li>
<li><i>Return value:int</i> - Number of characters in the buffer
</li>
</ul><br />
</li>
<li><a name="ReadLine">
<b>ReadLine</b></a>
 - Reads a line from stdIn and returns TRUE if we have a line, FALSE otherwise.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> bool ReadLine(uint8_t *bufStart, uint8_t *buf, size_t bufSize, <i>ComponentName_</i>ConstStdIOType *io)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>bufStart: Pointer to uint8_t</i> - Pointer to start of buffer</li>
<li><i>buf: Pointer to uint8_t</i> - Pointer to buffer where to read in the information</li>
<li><i>bufSize:uint16_t</i> - size of buffer</li>
<li><i>io: Pointer to <a href="ShellUser Types.html#ConstStdIOType"><i>ComponentName_</i>ConstStdIOType</a></i> - Pointer to I/O callbacks</li>
<li><i>Return value:bool</i> - TRUE if something has been read, FALSE otherwise
</li>
</ul><br />
</li>
<li><a name="PrintCommandFailed">
<b>PrintCommandFailed</b></a>
 - Prints a standard message for failed or unknown commands
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void PrintCommandFailed(const uint8_t *cmd, <i>ComponentName_</i>ConstStdIOType *io)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>cmd: Pointer to uint8_t</i> - Pointer to command which was failing</li>
<li><i>io: Pointer to <a href="ShellUser Types.html#ConstStdIOType"><i>ComponentName_</i>ConstStdIOType</a></i> - Pointer to I/O callbacks</li>
</ul><br />
</li>
<li><a name="IterateTable">
<b>IterateTable</b></a>
 - Parses a shell command. It handles first the internal commands and will call the provided callback.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> uint8_t IterateTable(const uint8_t *cmd, bool *handled, <i>ComponentName_</i>ConstStdIOType *io, <i>ComponentName_</i>ConstParseCommandCallback *parserTable)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>cmd: Pointer to uint8_t</i> - Pointer to command string</li>
<li><i>handled: Pointer to bool</i> - Pointer to boolean which is set to TRUE if a command parser has handled the command.</li>
<li><i>io: Pointer to <a href="ShellUser Types.html#ConstStdIOType"><i>ComponentName_</i>ConstStdIOType</a></i> - Pointer to I/O callbacks</li>
<li><i>parserTable: Pointer to <a href="ShellUser Types.html#ConstParseCommandCallback"><i>ComponentName_</i>ConstParseCommandCallback</a></i> - Pointer to callback which will be called to parse commands in the user application, or NULL if not used.</li>
<li><i>Return value:uint8_t</i> - Error code
</li>
</ul><br />
</li>
<li><a name="SetStdio">
<b>SetStdio</b></a>
 - Sets an StdIO structure which is returned by GetStdio()
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> uint8_t SetStdio(<i>ComponentName_</i>ConstStdIOTypePtr stdio)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>stdio:<a href="ShellUser Types.html#ConstStdIOTypePtr"><i>ComponentName_</i>ConstStdIOTypePtr</a></i> - New stdio structure to be used.</li>
<li><i>Return value:uint8_t</i> - Error code
</li>
</ul><br />
</li>
<li><a name="GetStdio">
<b>GetStdio</b></a>
 - Returns the default stdio channel. This method is only available if a shell is enabled in the component properties.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> <i>ComponentName_</i>ConstStdIOTypePtr GetStdio(void)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>Return value:<a href="ShellUser Types.html#ConstStdIOTypePtr"><i>ComponentName_</i>ConstStdIOTypePtr</a></i> - Pointer to the stdio descriptor
</li>
</ul><br />
</li>
<li><a name="RequestSerial">
<b>RequestSerial</b></a>
 - Used to get mutual access to the shell console. Only has an effect if using an RTOS with semaphore for the console access.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void RequestSerial(void)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
</ul><br />
</li>
<li><a name="ReleaseSerial">
<b>ReleaseSerial</b></a>
 - Used to release mutual access to the shell console. Only has an effect if using an RTOS with semaphore for the console access.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void ReleaseSerial(void)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
</ul><br />
</li>
<li><a name="ReadAndParseWithCommandTableExt">
<b>ReadAndParseWithCommandTableExt</b></a>
 - Reads characters from the default input channel and appends it to the buffer. Once a new line has been detected, the line will be parsed using the handlers in the table.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> uint8_t ReadAndParseWithCommandTableExt(uint8_t *cmdBuf, size_t cmdBufSize, <i>ComponentName_</i>ConstStdIOType *io, <i>ComponentName_</i>ConstParseCommandCallback *parseCallback, bool silent)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>cmdBuf: Pointer to uint8_t</i> - Pointer to buffer provided by the caller where to store the command to read in. Characters will be appended, so make sure string buffer is initialized with a zero byte at the beginning.</li>
<li><i>cmdBufSize:uint8_t</i> - Size of buffer</li>
<li><i>io: Pointer to <a href="ShellUser Types.html#ConstStdIOType"><i>ComponentName_</i>ConstStdIOType</a></i> - Pointer to I/O channels to be used</li>
<li><i>parseCallback: Pointer to <a href="ShellUser Types.html#ConstParseCommandCallback"><i>ComponentName_</i>ConstParseCommandCallback</a></i> - Pointer to callback table provided by the user application to parse commands. The table has a NULL sentinel.</li>
<li><i>silent:bool</i> - If handling shall be silent, i.e. no command prompt printed</li>
<li><i>Return value:uint8_t</i> - Error code
</li>
</ul><br />
</li>
<li><a name="ReadCommandLine">
<b>ReadCommandLine</b></a>
 - Similar to ReadAndParseWithCommandTableExt, but does not call the parser. Reads characters from the default input channel and appends it to the buffer. Once a new line has been detected, it  removes it and returns ERR_OK
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> uint8_t ReadCommandLine(uint8_t *cmdBuf, size_t cmdBufSize, <i>ComponentName_</i>ConstStdIOType *io)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>cmdBuf: Pointer to uint8_t</i> - Pointer to buffer provided by the caller where to store the command to read in. Characters will be appended, so make sure string buffer is initialized with a zero byte at the beginning.</li>
<li><i>cmdBufSize:uint8_t</i> - Size of buffer</li>
<li><i>io: Pointer to <a href="ShellUser Types.html#ConstStdIOType"><i>ComponentName_</i>ConstStdIOType</a></i> - Pointer to I/O channels to be used</li>
<li><i>Return value:uint8_t</i> - Error code, ERR_OK if a complete line has been detected
</li>
</ul><br />
</li>
<li><a name="ReadAndParseWithCommandTable">
<b>ReadAndParseWithCommandTable</b></a>
 - Reads characters from the default input channel and appends it to the buffer. Once a new line has been detected, the line will be parsed using the handlers in the table.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> uint8_t ReadAndParseWithCommandTable(uint8_t *cmdBuf, size_t cmdBufSize, <i>ComponentName_</i>ConstStdIOType *io, <i>ComponentName_</i>ConstParseCommandCallback *parseCallback)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>cmdBuf: Pointer to uint8_t</i> - Pointer to buffer provided by the caller where to store the command to read in. Characters will be appended, so make sure string buffer is initialized with a zero byte at the beginning.</li>
<li><i>cmdBufSize:uint8_t</i> - Size of buffer</li>
<li><i>io: Pointer to <a href="ShellUser Types.html#ConstStdIOType"><i>ComponentName_</i>ConstStdIOType</a></i> - Pointer to I/O channels to be used</li>
<li><i>parseCallback: Pointer to <a href="ShellUser Types.html#ConstParseCommandCallback"><i>ComponentName_</i>ConstParseCommandCallback</a></i> - Pointer to callback table provided by the user application to parse commands. The table has a NULL sentinel.</li>
<li><i>Return value:uint8_t</i> - Error code
</li>
</ul><br />
</li>
<li><a name="ParseWithCommandTableExt">
<b>ParseWithCommandTableExt</b></a>
 - Parses a shell command. It handles first the internal commands and will call the provided callback.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> uint8_t ParseWithCommandTableExt(const uint8_t *cmd, <i>ComponentName_</i>ConstStdIOType *io, <i>ComponentName_</i>ConstParseCommandCallback *parseCallback, bool silent)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>cmd: Pointer to uint8_t</i> - Pointer to command string</li>
<li><i>io: Pointer to <a href="ShellUser Types.html#ConstStdIOType"><i>ComponentName_</i>ConstStdIOType</a></i> - Pointer to I/O callbacks</li>
<li><i>parseCallback: Pointer to <a href="ShellUser Types.html#ConstParseCommandCallback"><i>ComponentName_</i>ConstParseCommandCallback</a></i> - Pointer to callback which will be called to parse commands in the user application, or NULL if not used.</li>
<li><i>silent:bool</i> - If handling shall be silent, i.e. no command prompt printed</li>
<li><i>Return value:uint8_t</i> - Error code
</li>
</ul><br />
</li>
<li><a name="ParseWithCommandTable">
<b>ParseWithCommandTable</b></a>
 - Parses a shell command. It handles first the internal commands and will call the provided callback.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> uint8_t ParseWithCommandTable(const uint8_t *cmd, <i>ComponentName_</i>ConstStdIOType *io, <i>ComponentName_</i>ConstParseCommandCallback *parseCallback)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>cmd: Pointer to uint8_t</i> - Pointer to command string</li>
<li><i>io: Pointer to <a href="ShellUser Types.html#ConstStdIOType"><i>ComponentName_</i>ConstStdIOType</a></i> - Pointer to I/O callbacks</li>
<li><i>parseCallback: Pointer to <a href="ShellUser Types.html#ConstParseCommandCallback"><i>ComponentName_</i>ConstParseCommandCallback</a></i> - Pointer to callback which will be called to parse commands in the user application, or NULL if not used.</li>
<li><i>Return value:uint8_t</i> - Error code
</li>
</ul><br />
</li>
<li><a name="GetSemaphore">
<b>GetSemaphore</b></a>
 - Return the semaphore of the shell.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void* GetSemaphore(void)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>Return value:void*</i> - semaphore, or NULL if not used or not allocated.
</li>
</ul><br />
</li>
<li><a name="SendStatusStr">
<b>SendStatusStr</b></a>
 - Prints a status string using an I/O function, formated for the 'status' command
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void SendStatusStr(const uint8_t *strItem, const uint8_t *strStatus, <i>ComponentName_</i>StdIO_OutErr_FctType io)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>strItem: Pointer to char</i> - Pointer to string of the command</li>
<li><i>strStatus: Pointer to char</i> - Pointer to help text string</li>
<li><i>io:<a href="ShellUser Types.html#StdIO_OutErr_FctType"><i>ComponentName_</i>StdIO_OutErr_FctType</a></i> - I/O callbacks to be used for printing.</li>
</ul><br />
</li>
<li><a name="SendHelpStr">
<b>SendHelpStr</b></a>
 - Prints a string using an I/O function, formated for the 'help' command
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void SendHelpStr(const uint8_t *strCmd, const uint8_t *strHelp, <i>ComponentName_</i>StdIO_OutErr_FctType io)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>strCmd: Pointer to char</i> - Pointer to string of the command</li>
<li><i>strHelp: Pointer to char</i> - Pointer to help text string</li>
<li><i>io:<a href="ShellUser Types.html#StdIO_OutErr_FctType"><i>ComponentName_</i>StdIO_OutErr_FctType</a></i> - I/O callbacks to be used for printing.</li>
</ul><br />
</li>
<li><a name="ReadChar">
<b>ReadChar</b></a>
 - Reads a character (blocking)
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void ReadChar(uint8_t *c)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>c: Pointer to uint8_t</i> - Pointer to character to be used to store the result</li>
</ul><br />
</li>
<li><a name="SendChar">
<b>SendChar</b></a>
 - Sends a character (blocking)
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void SendChar(uint8_t ch)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>ch:uint8_t</i> - character to be sent</li>
</ul><br />
</li>
<li><a name="KeyPressed">
<b>KeyPressed</b></a>
 - Checks if a key has been pressed (a character is present in the input buffer)
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> bool KeyPressed(void)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>Return value:bool</i> - Error code
</li>
</ul><br />
</li>
<li><a name="SendCharFct">
<b>SendCharFct</b></a>
 - Method to send a character using a standard I/O handle.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void SendCharFct(uint8_t ch, uint8_t (*fct)(uint8_t ch))<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>ch:uint8_t</i> - character to be sent</li>
<li><i>fct:void*</i> - Function pointer to output function: takes a byte to write and returns error code.</li>
</ul><br />
</li>
<li><a name="Init">
<b>Init</b></a>
 - Initializes the module, especially creates the mutex semaphore if an RTOS is used.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void Init(void)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
</ul><br />
</li>
<li><a name="Deinit">
<b>Deinit</b></a>
 - De-Initializes the module, especially frees the mutex semaphore if an RTOS is used.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void Deinit(void)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
</ul><br />
</li>

           </ul>
<!---USERBEG DON'T CHANGE THIS LINE-->

<!---USEREND DON'T CHANGE THIS LINE-->
<p>
<br />
Note: Some methods can be implemented as macros.
</p>
          </div>
          <p class="footer">
            PROCESSOR EXPERT is trademark of Freescale Semiconductor, Inc.
            <br />
            
          </p>
    </td>
  </tr>

</table>

</body>
</html>
