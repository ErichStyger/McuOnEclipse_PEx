<?xml version="1.0" encoding="UTF-8"?>
<Bean>
  <Header>
    <Name>Shell</Name>
    <Description>Command Line Shell</Description>
    <Author>Erich Styger</Author>
    <Version>01.111</Version>
    <Icon>Shell</Icon>
    <TypesFiles>PE,Shell\Shell</TypesFiles>
    <FileVersion>6</FileVersion>
  </Header>
  <Options>
    <BW_HelpType>&lt;none&gt;</BW_HelpType>
    <BW_HelpFiles>,"Application Notes",Events,Methods,Properties,"User Types"</BW_HelpFiles>
    <BW_AutoSaveHelp>yes</BW_AutoSaveHelp>
    <BW_AutoSaveDriver>yes</BW_AutoSaveDriver>
    <BW_DetailedHelp>yes</BW_DetailedHelp>
    <BW_NeedUst>14</BW_NeedUst>
    <BeanStatus>PROPOSAL</BeanStatus>
    <Copyright> * Copyright (c) 2014-2021, Erich Styger\n * Web:         https://mcuoneclipse.com\n * SourceForge: https://sourceforge.net/projects/mcuoneclipse\n * Git:         https://github.com/ErichStyger/McuOnEclipse_PEx\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *\n * - Redistributions of source code must retain the above copyright notice, this list\n *   of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright notice, this\n *   list of conditions and the following disclaimer in the documentation and/or\n *   other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</Copyright>
    <Category>Software-User Components</Category>
    <DemoDriver>no</DemoDriver>
    <BeanLevel>High</BeanLevel>
    <Shortcut>CLS</Shortcut>
    <SaveInspectorTabsViewUIStyle>true</SaveInspectorTabsViewUIStyle>
    <BW_NeedTps>no</BW_NeedTps>
    <BW_NeedCns>0</BW_NeedCns>
  </Options>
  <PropertyList>
    <Property>
      <TCompNameItem>
        <Name>Component name</Name>
        <Symbol>DeviceName</Symbol>
        <Hint>Name of the component.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>true</EditLine>
        <DefaultValue/>
      </TCompNameItem>
    </Property>
    <Property>
      <TBoolItem>
        <Name>Echo</Name>
        <Symbol>EchoEnabled</Symbol>
        <TypeSpec>typeYesNo</TypeSpec>
        <Hint>If enabled, the shell will echo characters read on the terminal. The shell offers the echo command to turn echo on and off.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>1</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>false</DefaultValue>
        <Popup>false</Popup>
      </TBoolItem>
    </Property>
    <Property>
      <TStrgItem>
        <Name>Prompt</Name>
        <Symbol>Prompt</Symbol>
        <Hint>Prompt string to be used. Make sure the string is in double quotes. You can use normal C escape characters like \\r or \n






 as well.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>true</EditLine>
        <DefaultValue>"CMD&gt; "</DefaultValue>
        <StrDefine>nothing</StrDefine>
        <MinLength>0</MinLength>
        <MaxLength>-1</MaxLength>
      </TStrgItem>
    </Property>
    <Property>
      <TStrgItem>
        <Name>Project Name</Name>
        <Symbol>ProjectNameStr</Symbol>
        <Hint>Here you can specify a project name which is shown if you use the help command.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>true</EditLine>
        <DefaultValue>My Project Name</DefaultValue>
        <StrDefine>nothing</StrDefine>
        <MinLength>0</MinLength>
        <MaxLength>-1</MaxLength>
      </TStrgItem>
    </Property>
    <Property>
      <TStrgItem>
        <Name>Silent Mode Prefix</Name>
        <Symbol>SilentModePrefixChar</Symbol>
        <Hint>If commands start with this prefix character, the command will be executed and no prompt will be written. To disable silent support (for better code efficiency), use an empty char.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>true</EditLine>
        <DefaultValue>#</DefaultValue>
        <StrDefine>nothing</StrDefine>
        <MinLength>0</MinLength>
        <MaxLength>-1</MaxLength>
      </TStrgItem>
    </Property>
    <Property>
      <TIntgItem>
        <Name>Buffer Size</Name>
        <Symbol>ShellDefaultBufferSize</Symbol>
        <Hint>Default buffer size for parsing</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>true</EditLine>
        <DefaultValue>48</DefaultValue>
        <MinValue>4</MinValue>
        <MaxValue>-1</MaxValue>
        <Bases>DEC</Bases>
        <DefaultBase>DEC</DefaultBase>
        <ExtraHintDisabled>false</ExtraHintDisabled>
        <ChangeValueIntoRange>false</ChangeValueIntoRange>
        <RuntimeProperty>false</RuntimeProperty>
      </TIntgItem>
    </Property>
    <Property>
      <TBoolGrupItem>
        <Name>Blocking Send</Name>
        <Symbol>BlockingSend</Symbol>
        <TypeSpec>typeEnaDis</TypeSpec>
        <Hint>Configures the blocking and timeouts for sending data.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <BoldName>true</BoldName>
        <EditLine>false</EditLine>
        <Description>Disabled</Description>
        <Expanded>No</Expanded>
        <DefaultValue>false</DefaultValue>
        <DefineSymbol>YES_NO</DefineSymbol>
        <IfDisabled>setNOTHING</IfDisabled>
        <Children>
          <GrupItem>
            <TInhrLinkItem>
              <Name>Wait</Name>
              <Symbol>Wait</Symbol>
              <TypeSpec>Wait_I</TypeSpec>
              <Hint>Interface to waiting routine</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>false</EditLine>
              <DefaultValue/>
              <CanDelete>false</CanDelete>
              <IconPopup>false</IconPopup>
              <SortStyle/>
            </TInhrLinkItem>
          </GrupItem>
          <GrupItem>
            <TIntgItem>
              <Name>Timeout (ms)</Name>
              <Symbol>ShellBlockingSendTimeoutMs</Symbol>
              <Hint>Timeout used to wait. Use zero for blocking send.</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue>20</DefaultValue>
              <MinValue>0</MinValue>
              <MaxValue>-1</MaxValue>
              <Bases>DEC</Bases>
              <DefaultBase>DEC</DefaultBase>
              <ExtraHintDisabled>false</ExtraHintDisabled>
              <ChangeValueIntoRange>false</ChangeValueIntoRange>
              <RuntimeProperty>false</RuntimeProperty>
            </TIntgItem>
          </GrupItem>
          <GrupItem>
            <TIntgItem>
              <Name>Wait Time (ms)</Name>
              <Symbol>WaitTimeMs</Symbol>
              <Hint>Waiting time in milli seconds if sending was blocked (output buffer full). Use 0 for polling mode.</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue>5</DefaultValue>
              <MinValue>0</MinValue>
              <MaxValue>-1</MaxValue>
              <Bases>DEC</Bases>
              <DefaultBase>DEC</DefaultBase>
              <ExtraHintDisabled>false</ExtraHintDisabled>
              <ChangeValueIntoRange>false</ChangeValueIntoRange>
              <RuntimeProperty>false</RuntimeProperty>
            </TIntgItem>
          </GrupItem>
          <GrupItem>
            <TBoolItem>
              <Name>RTOS Wait</Name>
              <Symbol>RTOSWait</Symbol>
              <TypeSpec>typeYesNo</TypeSpec>
              <Hint>If set to yes, then it uses the RTOS waiting/delay instead of busy waiting if RTOS is present.</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>false</EditLine>
              <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
              <DefaultIndex>0</DefaultIndex>
              <TextValueIndex>false</TextValueIndex>
              <RuntimeProperty>false</RuntimeProperty>
              <CanDelete>false</CanDelete>
              <IconPopup>false</IconPopup>
              <DefaultValue>true</DefaultValue>
              <Popup>false</Popup>
            </TBoolItem>
          </GrupItem>
        </Children>
      </TBoolGrupItem>
    </Property>
    <Property>
      <TIntgItem>
        <Name>Status Colon Pos</Name>
        <Symbol>StatusColonPos</Symbol>
        <Hint>Position of the ':' for the status commands. Used for SendStatusString().</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>true</EditLine>
        <DefaultValue>13</DefaultValue>
        <MinValue>0</MinValue>
        <MaxValue>-1</MaxValue>
        <Bases>DEC</Bases>
        <DefaultBase>DEC</DefaultBase>
        <ExtraHintDisabled>false</ExtraHintDisabled>
        <ChangeValueIntoRange>false</ChangeValueIntoRange>
        <RuntimeProperty>false</RuntimeProperty>
      </TIntgItem>
    </Property>
    <Property>
      <TIntgItem>
        <Name>Help Semicolon Pos</Name>
        <Symbol>HelpSemicolonPos</Symbol>
        <Hint>Position of the ';' in the help commands. Used for SendHelpString().</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>true</EditLine>
        <DefaultValue>26</DefaultValue>
        <MinValue>0</MinValue>
        <MaxValue>-1</MaxValue>
        <Bases>DEC</Bases>
        <DefaultBase>DEC</DefaultBase>
        <ExtraHintDisabled>false</ExtraHintDisabled>
        <ChangeValueIntoRange>false</ChangeValueIntoRange>
        <RuntimeProperty>false</RuntimeProperty>
      </TIntgItem>
    </Property>
    <Property>
      <TBoolGrupItem>
        <Name>Multi Command</Name>
        <Symbol>MultiCommandEnabled</Symbol>
        <TypeSpec>typeEnaDis</TypeSpec>
        <Hint>Enables execution of multiple commands in a single command, separated with a separation char.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <BoldName>true</BoldName>
        <EditLine>false</EditLine>
        <Description>Disabled</Description>
        <Expanded>No</Expanded>
        <DefaultValue>false</DefaultValue>
        <DefineSymbol>YES_NO</DefineSymbol>
        <IfDisabled>setNOTHING</IfDisabled>
        <Children>
          <GrupItem>
            <TIntgItem>
              <Name>Length</Name>
              <Symbol>MaxSubCommandStringSize</Symbol>
              <Hint>Length of possible sub command string. Used as buffer on the stack, so should not be choosen too large</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue>32</DefaultValue>
              <MinValue>2</MinValue>
              <MaxValue>-1</MaxValue>
              <Bases>DEC</Bases>
              <DefaultBase>DEC</DefaultBase>
              <ExtraHintDisabled>false</ExtraHintDisabled>
              <ChangeValueIntoRange>false</ChangeValueIntoRange>
              <RuntimeProperty>false</RuntimeProperty>
            </TIntgItem>
          </GrupItem>
          <GrupItem>
            <TStrgItem>
              <Name>Separator</Name>
              <Symbol>MultiCmdSeparationChar</Symbol>
              <Hint>Multiple commands can be separated using this separation character</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue>;</DefaultValue>
              <StrDefine>nothing</StrDefine>
              <MinLength>0</MinLength>
              <MaxLength>-1</MaxLength>
            </TStrgItem>
          </GrupItem>
        </Children>
      </TBoolGrupItem>
    </Property>
    <Property>
      <TBoolGrupItem>
        <Name>History</Name>
        <Symbol>HistoryEnabled</Symbol>
        <TypeSpec>typeYesNo</TypeSpec>
        <Hint>If enabled, the component will store up to four entered commands. Recall them by enter a non-alphanumeric key.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <BoldName>true</BoldName>
        <EditLine>false</EditLine>
        <Description>no</Description>
        <Expanded>No</Expanded>
        <DefaultValue>false</DefaultValue>
        <DefineSymbol>YES_NO</DefineSymbol>
        <IfDisabled>setNOTHING</IfDisabled>
        <Children>
          <GrupItem>
            <TIntgItem>
              <Name>Number of History Items</Name>
              <Symbol>NofHistoryItems</Symbol>
              <Hint>Defines the number of history items.</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue>4</DefaultValue>
              <MinValue>1</MinValue>
              <MaxValue>-1</MaxValue>
              <Bases>DEC</Bases>
              <DefaultBase>DEC</DefaultBase>
              <ExtraHintDisabled>false</ExtraHintDisabled>
              <ChangeValueIntoRange>false</ChangeValueIntoRange>
              <RuntimeProperty>false</RuntimeProperty>
            </TIntgItem>
          </GrupItem>
          <GrupItem>
            <TIntgItem>
              <Name>Stored Characters</Name>
              <Symbol>HistLength</Symbol>
              <Hint>Stored caracters for each history line.</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue>32</DefaultValue>
              <MinValue>8</MinValue>
              <MaxValue>128</MaxValue>
              <Bases>DEC</Bases>
              <DefaultBase>DEC</DefaultBase>
              <ExtraHintDisabled>false</ExtraHintDisabled>
              <ChangeValueIntoRange>false</ChangeValueIntoRange>
              <RuntimeProperty>false</RuntimeProperty>
            </TIntgItem>
          </GrupItem>
          <GrupItem>
            <TStrgItem>
              <Name>Char for Next</Name>
              <Symbol>NextHistoryChar</Symbol>
              <Hint>Character key for previous item in history.  Use \\t for TAB and \\e for SHIFT+TAB</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue>\t</DefaultValue>
              <StrDefine>nothing</StrDefine>
              <MinLength>0</MinLength>
              <MaxLength>-1</MaxLength>
            </TStrgItem>
          </GrupItem>
          <GrupItem>
            <TStrgItem>
              <Name>Char for Previous</Name>
              <Symbol>PrevHistoryChar</Symbol>
              <Hint>Character key for previous item in history. Use \\t for TAB and \\e for SHIFT+TAB</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue>\e</DefaultValue>
              <StrDefine>nothing</StrDefine>
              <MinLength>0</MinLength>
              <MaxLength>-1</MaxLength>
            </TStrgItem>
          </GrupItem>
        </Children>
      </TBoolGrupItem>
    </Property>
    <Property>
      <TBoolItem>
        <Name>Mutex</Name>
        <Symbol>ConsoleSempahore</Symbol>
        <TypeSpec>typeYesNo</TypeSpec>
        <Hint>If enabled and an RTOS is present, a mutex is used to grant mutual access to the console/serial/SCI hardware. Useful if multiple tasks needs to write to the shell console. Make sure you call the Init() routine of the componenent first in order to create the semaphore.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>1</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>false</DefaultValue>
        <Popup>false</Popup>
      </TBoolItem>
    </Property>
    <Property>
      <TInhrLinkItem>
        <Name>SDK</Name>
        <Symbol>sdk</Symbol>
        <TypeSpec>Shell\KinetisSDK</TypeSpec>
        <Hint>Interface to SDK used.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <DefaultValue/>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <SortStyle/>
      </TInhrLinkItem>
    </Property>
    <Property>
      <TBoolGrupItem>
        <Name>Default Serial</Name>
        <Symbol>DefaultSerialEnabled</Symbol>
        <TypeSpec>typeEnaDis</TypeSpec>
        <Hint>If enabled, the Shell implements a default internal serial interface. Otherwise the SetStdIO() function can be used to set one.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <BoldName>true</BoldName>
        <EditLine>false</EditLine>
        <Description>Disabled</Description>
        <Expanded>No</Expanded>
        <DefaultValue>false</DefaultValue>
        <DefineSymbol>YES_NO</DefineSymbol>
        <IfDisabled>setNOTHING</IfDisabled>
        <Children>
          <GrupItem>
            <TInhrLinkItem>
              <Name>Console Interface</Name>
              <Symbol>Serial</Symbol>
              <TypeSpec>Shell\Serial</TypeSpec>
              <Hint>Interface to low level asynchroserial component</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>false</EditLine>
              <DefaultValue/>
              <CanDelete>false</CanDelete>
              <IconPopup>false</IconPopup>
              <SortStyle/>
            </TInhrLinkItem>
          </GrupItem>
        </Children>
      </TBoolGrupItem>
    </Property>
    <Property>
      <TInhrLinkItem>
        <Name>Utility</Name>
        <Symbol>Utility</Symbol>
        <TypeSpec>Utility_I</TypeSpec>
        <Hint>Interface to utility</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <DefaultValue/>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <SortStyle/>
      </TInhrLinkItem>
    </Property>
    <Property>
      <TInhrLinkItem>
        <Name>XFormat</Name>
        <Symbol>XFormat</Symbol>
        <TypeSpec>Shell\XFormat</TypeSpec>
        <Hint>Interface to XFormat for printf() style support</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <DefaultValue/>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <SortStyle/>
      </TInhrLinkItem>
    </Property>
    <Property>
      <TInhrLinkItem>
        <Name>Critical Section</Name>
        <Symbol>CriticalSection</Symbol>
        <TypeSpec>CriticalSection_I</TypeSpec>
        <Hint>Interface to critical section handling</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <DefaultValue/>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <SortStyle/>
      </TInhrLinkItem>
    </Property>
  </PropertyList>
  <MethodList>
    <Method>
      <TMthdItem>
        <Name>PrintPrompt</Name>
        <Symbol>PrintPrompt</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Prints the prompt to the stdOut channel</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>io</ParName>
          <ParType>ConstStdIOType</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to IO to be used</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(%'ModuleName'_ConstStdIOType *io)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>SendNum8u</Name>
        <Symbol>SendNum8u</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Sends an 8bit unsigned number to the given I/O</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>val</ParName>
          <ParType>uint8_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>number to print</ParHint>
        </Parameter>
        <Parameter>
          <ParName>io</ParName>
          <ParType>StdIO_OutErr_FctType</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>I/O callbacks to be used for printing.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(uint8_t val, %'ModuleName'_StdIO_OutErr_FctType io)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>SendNum8s</Name>
        <Symbol>SendNum8s</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Sends an 8bit signed number to the given I/O</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>val</ParName>
          <ParType>int8_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>number to print</ParHint>
        </Parameter>
        <Parameter>
          <ParName>io</ParName>
          <ParType>StdIO_OutErr_FctType</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>I/O callbacks to be used for printing.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(int8_t val, %'ModuleName'_StdIO_OutErr_FctType io)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>SendNum16u</Name>
        <Symbol>SendNum16u</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Sends a 16bit unsigned number to the given I/O</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>val</ParName>
          <ParType>uint16_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>number to print</ParHint>
        </Parameter>
        <Parameter>
          <ParName>io</ParName>
          <ParType>StdIO_OutErr_FctType</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>I/O callbacks to be used for printing.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(uint16_t val, %'ModuleName'_StdIO_OutErr_FctType io)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>SendNum16s</Name>
        <Symbol>SendNum16s</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Sends a 16bit signed number to the given I/O</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>val</ParName>
          <ParType>int16_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>number to print</ParHint>
        </Parameter>
        <Parameter>
          <ParName>io</ParName>
          <ParType>StdIO_OutErr_FctType</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>I/O callbacks to be used for printing.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(int16_t val, %'ModuleName'_StdIO_OutErr_FctType io)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>SendNum32u</Name>
        <Symbol>SendNum32u</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Sends a 32bit unsigned number to the given I/O</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>val</ParName>
          <ParType>uint32_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>number to print</ParHint>
        </Parameter>
        <Parameter>
          <ParName>io</ParName>
          <ParType>StdIO_OutErr_FctType</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>I/O callbacks to be used for printing.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(uint32_t val, %'ModuleName'_StdIO_OutErr_FctType io)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>SendNum32s</Name>
        <Symbol>SendNum32s</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Sends a 32bit signed number to the given I/O</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>val</ParName>
          <ParType>int32_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>number to print</ParHint>
        </Parameter>
        <Parameter>
          <ParName>io</ParName>
          <ParType>StdIO_OutErr_FctType</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>I/O callbacks to be used for printing.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(int32_t val, %'ModuleName'_StdIO_OutErr_FctType io)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>SendCh</Name>
        <Symbol>SendCh</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Prints a character using an I/O function</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>ch</ParName>
          <ParType>uint8_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Character to send</ParHint>
        </Parameter>
        <Parameter>
          <ParName>io</ParName>
          <ParType>StdIO_OutErr_FctType</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>I/O callbacks to be used for printing.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(uint8_t ch, %'ModuleName'_StdIO_OutErr_FctType io)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>SendStr</Name>
        <Symbol>SendStr</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Prints a string using an I/O function</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>str</ParName>
          <ParType>uint8_t</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to string (zero terminated) to be printed.</ParHint>
          <ParUserDeclaration>const uint8_t *str</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>io</ParName>
          <ParType>StdIO_OutErr_FctType</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>I/O callbacks to be used for printing.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(const uint8_t *str, %'ModuleName'_StdIO_OutErr_FctType io)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>PrintMemory</Name>
        <Symbol>PrintMemory</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Prints a chunk of memory bytes in a formatted way.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>uint8_t</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>7</ParamCount>
        <Parameter>
          <ParName>hndl</ParName>
          <ParType>pointer</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to </ParHint>
          <ParUserDeclaration>void *hndl</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>startAddr</ParName>
          <ParType>uint32_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Memory start address</ParHint>
        </Parameter>
        <Parameter>
          <ParName>endAddr</ParName>
          <ParType>uint32_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Memory end address</ParHint>
        </Parameter>
        <Parameter>
          <ParName>addrSize</ParName>
          <ParType>uint8_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Number of bytes for the address (1, 2, 3 or 4)</ParHint>
        </Parameter>
        <Parameter>
          <ParName>bytesPerLine</ParName>
          <ParType>uint8_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Number of bytes per line</ParHint>
        </Parameter>
        <Parameter>
          <ParName>readfp</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Function pointer to read the memory. Returns error code, uses a device handle, 32bit address with a pointer to a buffer and a buffer size.</ParHint>
          <ParUserDeclaration>uint8_t (*readfp)(void *, uint32_t, uint8_t*, size_t)</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>io</ParName>
          <ParType>ConstStdIOType</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to I/O to be used</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>uint8_t #M#_#C#(void *hndl, uint32_t startAddr, uint32_t endAddr, uint8_t addrSize, uint8_t bytesPerLine, uint8_t (*readfp)(void *, uint32_t, uint8_t*, size_t), %'ModuleName'_ConstStdIOType *io)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>printfPutChar</Name>
        <Symbol>printfPutChar</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Helper routine for printf</Hint>
        <ItemLevel>@ HIDDEN @</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>false</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>arg</ParName>
          <ParType>pointer</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>argument</ParHint>
          <ParUserDeclaration>void *arg</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>c</ParName>
          <ParType>char</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>character to print</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(void *arg, char c)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>printfIO</Name>
        <Symbol>printfIO</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Printf() style function using XFormat component, using a custom I/O handler.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>unsigned</ReturnType>
        <RetHint>number of characters written</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>io</ParName>
          <ParType>ConstStdIOType</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to </ParHint>
        </Parameter>
        <Parameter>
          <ParName>fmt</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>printf style format string</ParHint>
          <ParUserDeclaration>const char *fmt, ...</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>unsigned #M#_#C#(%'ModuleName'_ConstStdIOType *io, const char *fmt, ...)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>printf</Name>
        <Symbol>printf</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Printf() style function using XFormat component, using the shell default I/O handler.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>unsigned</ReturnType>
        <RetHint>number of characters written</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>fmt</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>printf style format string</ParHint>
          <ParUserDeclaration>const char *fmt, ...</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>unsigned #M#_#C#(const char *fmt, ...)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>SendData</Name>
        <Symbol>SendData</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Sends data using an I/O function. Unlike SendStr(), with this method it is possible to send binary data, including zero bytes.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>3</ParamCount>
        <Parameter>
          <ParName>data</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to data to be sent</ParHint>
          <ParUserDeclaration>const uint8_t *data</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>dataSize</ParName>
          <ParType>uint16_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Number of bytes to be sent.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>io</ParName>
          <ParType>StdIO_OutErr_FctType</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>I/O callbacks to be used for printing.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(const uint8_t *data, uint16_t dataSize, %'ModuleName'_StdIO_OutErr_FctType io)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>PrintStatus</Name>
        <Symbol>PrintStatus</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Prints various available system status information</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>uint8_t</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>io</ParName>
          <ParType>ConstStdIOType</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to I/O callbacks</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>uint8_t #M#_#C#(%'ModuleName'_ConstStdIOType *io)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>ParseCommand</Name>
        <Symbol>ParseCommand</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Parses a shell command. Use 'help' to get a list of supported commands.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>uint8_t</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>3</ParamCount>
        <Parameter>
          <ParName>cmd</ParName>
          <ParType>uint8_t</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to command string</ParHint>
          <ParUserDeclaration>const uint8_t *cmd</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>handled</ParName>
          <ParType>Boolean</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to variable to indicate if the command has been handled. The caller passes this variable to the command scanner to find out if the passed command has been handled. The variable is initialized by the caller.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>io</ParName>
          <ParType>ConstStdIOType</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to I/O callbacks</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>uint8_t #M#_#C#(const uint8_t *cmd, bool *handled, %'ModuleName'_ConstStdIOType *io)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>IsHistoryCharacter</Name>
        <Symbol>IsHistoryCharacter</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Returns TRUE if character is a history character</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>Boolean</ReturnType>
        <RetHint>TRUE if it is an accepted history character</RetHint>
        <ParamCount>4</ParamCount>
        <Parameter>
          <ParName>ch</ParName>
          <ParType>uint8_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>current command character</ParHint>
        </Parameter>
        <Parameter>
          <ParName>cmdBuf</ParName>
          <ParType>uint8_t</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to command line buffer read so far</ParHint>
        </Parameter>
        <Parameter>
          <ParName>cmdBufIdx</ParName>
          <ParType>uint8_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Index of character into cmdBuf</ParHint>
          <ParUserDeclaration>size_t cmdBufIdx</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>isPrev</ParName>
          <ParType>Boolean</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to return value, if it is 'previous' history or not</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>bool #M#_#C#(uint8_t ch, uint8_t *cmdBuf, size_t cmdBufIdx, bool *isPrev)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>ReadLine</Name>
        <Symbol>ReadLine</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Reads a line from stdIn and returns TRUE if we have a line, FALSE otherwise.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>Boolean</ReturnType>
        <RetHint>TRUE if something has been read, FALSE otherwise</RetHint>
        <ParamCount>4</ParamCount>
        <Parameter>
          <ParName>bufStart</ParName>
          <ParType>uint8_t</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to start of buffer</ParHint>
        </Parameter>
        <Parameter>
          <ParName>buf</ParName>
          <ParType>uint8_t</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to buffer where to read in the information</ParHint>
        </Parameter>
        <Parameter>
          <ParName>bufSize</ParName>
          <ParType>uint16_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>size of buffer</ParHint>
          <ParUserDeclaration>size_t bufSize</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>io</ParName>
          <ParType>ConstStdIOType</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to I/O callbacks</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>bool #M#_#C#(uint8_t *bufStart, uint8_t *buf, size_t bufSize, %'ModuleName'_ConstStdIOType *io)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>PrintCommandFailed</Name>
        <Symbol>PrintCommandFailed</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Prints a standard message for failed or unknown commands</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>cmd</ParName>
          <ParType>uint8_t</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to command which was failing</ParHint>
          <ParUserDeclaration>const uint8_t *cmd</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>io</ParName>
          <ParType>ConstStdIOType</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to I/O callbacks</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(const uint8_t *cmd, %'ModuleName'_ConstStdIOType *io)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>IterateTable</Name>
        <Symbol>IterateTable</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Parses a shell command. It handles first the internal commands and will call the provided callback.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>uint8_t</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>4</ParamCount>
        <Parameter>
          <ParName>cmd</ParName>
          <ParType>uint8_t</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to command string</ParHint>
          <ParUserDeclaration>const uint8_t *cmd</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>handled</ParName>
          <ParType>Boolean</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to boolean which is set to TRUE if a command parser has handled the command.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>io</ParName>
          <ParType>ConstStdIOType</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to I/O callbacks</ParHint>
        </Parameter>
        <Parameter>
          <ParName>parserTable</ParName>
          <ParType>ConstParseCommandCallback</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to callback which will be called to parse commands in the user application, or NULL if not used.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>uint8_t #M#_#C#(const uint8_t *cmd, bool *handled, %'ModuleName'_ConstStdIOType *io, %'ModuleName'_ConstParseCommandCallback *parserTable)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>SetStdio</Name>
        <Symbol>SetStdio</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Sets an StdIO structure which is returned by GetStdio()</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>uint8_t</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>stdio</ParName>
          <ParType>ConstStdIOTypePtr</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>New stdio structure to be used.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>uint8_t #M#_#C#(%'ModuleName'_ConstStdIOTypePtr stdio)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>GetStdio</Name>
        <Symbol>GetStdio</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Returns the default stdio channel. This method is only available if a shell is enabled in the component properties.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>ConstStdIOTypePtr</ReturnType>
        <RetHint>Pointer to the stdio descriptor</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>%'ModuleName'_ConstStdIOTypePtr #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>RequestSerial</Name>
        <Symbol>RequestSerial</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Used to get mutual access to the shell console. Only has an effect if using an RTOS with semaphore for the console access.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>ReleaseSerial</Name>
        <Symbol>ReleaseSerial</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Used to release mutual access to the shell console. Only has an effect if using an RTOS with semaphore for the console access.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>ReadAndParseWithCommandTableExt</Name>
        <Symbol>ReadAndParseWithCommandTableExt</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Reads characters from the default input channel and appends it to the buffer. Once a new line has been detected, the line will be parsed using the handlers in the table.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>uint8_t</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>5</ParamCount>
        <Parameter>
          <ParName>cmdBuf</ParName>
          <ParType>uint8_t</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to buffer provided by the caller where to store the command to read in. Characters will be appended, so make sure string buffer is initialized with a zero byte at the beginning.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>cmdBufSize</ParName>
          <ParType>uint8_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Size of buffer</ParHint>
          <ParUserDeclaration>size_t cmdBufSize</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>io</ParName>
          <ParType>ConstStdIOType</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to I/O channels to be used</ParHint>
        </Parameter>
        <Parameter>
          <ParName>parseCallback</ParName>
          <ParType>ConstParseCommandCallback</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to callback table provided by the user application to parse commands. The table has a NULL sentinel.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>silent</ParName>
          <ParType>Boolean</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>If handling shall be silent, i.e. no command prompt printed</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>uint8_t #M#_#C#(uint8_t *cmdBuf, size_t cmdBufSize, %'ModuleName'_ConstStdIOType *io, %'ModuleName'_ConstParseCommandCallback *parseCallback, bool silent)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>ReadCommandLine</Name>
        <Symbol>ReadCommandLine</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Similar to ReadAndParseWithCommandTableExt, but does not call the parser. Reads characters from the default input channel and appends it to the buffer. Once a new line has been detected, it  removes it and returns ERR_OK</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>uint8_t</ReturnType>
        <RetHint>Error code, ERR_OK if a complete line has been detected</RetHint>
        <ParamCount>3</ParamCount>
        <Parameter>
          <ParName>cmdBuf</ParName>
          <ParType>uint8_t</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to buffer provided by the caller where to store the command to read in. Characters will be appended, so make sure string buffer is initialized with a zero byte at the beginning.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>cmdBufSize</ParName>
          <ParType>uint8_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Size of buffer</ParHint>
          <ParUserDeclaration>size_t cmdBufSize</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>io</ParName>
          <ParType>ConstStdIOType</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to I/O channels to be used</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>uint8_t #M#_#C#(uint8_t *cmdBuf, size_t cmdBufSize, %'ModuleName'_ConstStdIOType *io)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>ReadAndParseWithCommandTable</Name>
        <Symbol>ReadAndParseWithCommandTable</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Reads characters from the default input channel and appends it to the buffer. Once a new line has been detected, the line will be parsed using the handlers in the table.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>uint8_t</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>4</ParamCount>
        <Parameter>
          <ParName>cmdBuf</ParName>
          <ParType>uint8_t</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to buffer provided by the caller where to store the command to read in. Characters will be appended, so make sure string buffer is initialized with a zero byte at the beginning.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>cmdBufSize</ParName>
          <ParType>uint8_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Size of buffer</ParHint>
          <ParUserDeclaration>size_t cmdBufSize</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>io</ParName>
          <ParType>ConstStdIOType</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to I/O channels to be used</ParHint>
        </Parameter>
        <Parameter>
          <ParName>parseCallback</ParName>
          <ParType>ConstParseCommandCallback</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to callback table provided by the user application to parse commands. The table has a NULL sentinel.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>uint8_t #M#_#C#(uint8_t *cmdBuf, size_t cmdBufSize, %'ModuleName'_ConstStdIOType *io, %'ModuleName'_ConstParseCommandCallback *parseCallback)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>ParseWithCommandTableExt</Name>
        <Symbol>ParseWithCommandTableExt</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Parses a shell command. It handles first the internal commands and will call the provided callback.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>uint8_t</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>4</ParamCount>
        <Parameter>
          <ParName>cmd</ParName>
          <ParType>uint8_t</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to command string</ParHint>
          <ParUserDeclaration>const uint8_t *cmd</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>io</ParName>
          <ParType>ConstStdIOType</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to I/O callbacks</ParHint>
        </Parameter>
        <Parameter>
          <ParName>parseCallback</ParName>
          <ParType>ConstParseCommandCallback</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to callback which will be called to parse commands in the user application, or NULL if not used.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>silent</ParName>
          <ParType>Boolean</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>If handling shall be silent, i.e. no command prompt printed</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>uint8_t #M#_#C#(const uint8_t *cmd, %'ModuleName'_ConstStdIOType *io, %'ModuleName'_ConstParseCommandCallback *parseCallback, bool silent)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>ParseWithCommandTable</Name>
        <Symbol>ParseWithCommandTable</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Parses a shell command. It handles first the internal commands and will call the provided callback.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>uint8_t</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>3</ParamCount>
        <Parameter>
          <ParName>cmd</ParName>
          <ParType>uint8_t</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to command string</ParHint>
          <ParUserDeclaration>const uint8_t *cmd</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>io</ParName>
          <ParType>ConstStdIOType</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to I/O callbacks</ParHint>
        </Parameter>
        <Parameter>
          <ParName>parseCallback</ParName>
          <ParType>ConstParseCommandCallback</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to callback which will be called to parse commands in the user application, or NULL if not used.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>uint8_t #M#_#C#(const uint8_t *cmd, %'ModuleName'_ConstStdIOType *io, %'ModuleName'_ConstParseCommandCallback *parseCallback)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>GetSemaphore</Name>
        <Symbol>GetSemaphore</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Return the semaphore of the shell.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>pointer</ReturnType>
        <RetHint>semaphore, or NULL if not used or not allocated.</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void* #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>SendSeparatedStrings</Name>
        <Symbol>SendSeparatedStrings</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Prints a string using an I/O function, formated for the 'help' command</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>false</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>false</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>5</ParamCount>
        <Parameter>
          <ParName>strA</ParName>
          <ParType>char</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to first string</ParHint>
          <ParUserDeclaration>const uint8_t *strA</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>strB</ParName>
          <ParType>char</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to second string</ParHint>
          <ParUserDeclaration>const uint8_t *strB</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>tabChar</ParName>
          <ParType>uint8_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Character to be used as separator</ParHint>
        </Parameter>
        <Parameter>
          <ParName>tabPos</ParName>
          <ParType>uint8_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Position of the tab character</ParHint>
        </Parameter>
        <Parameter>
          <ParName>io</ParName>
          <ParType>StdIO_OutErr_FctType</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>I/O callbacks to be used for printing.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(const uint8_t *strA, const uint8_t *strB, uint8_t tabChar, uint8_t tabPos, %'ModuleName'_StdIO_OutErr_FctType io)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>SendStatusStr</Name>
        <Symbol>SendStatusStr</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Prints a status string using an I/O function, formated for the 'status' command</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>3</ParamCount>
        <Parameter>
          <ParName>strItem</ParName>
          <ParType>char</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to string of the command</ParHint>
          <ParUserDeclaration>const uint8_t *strItem</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>strStatus</ParName>
          <ParType>char</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to help text string</ParHint>
          <ParUserDeclaration>const uint8_t *strStatus</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>io</ParName>
          <ParType>StdIO_OutErr_FctType</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>I/O callbacks to be used for printing.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(const uint8_t *strItem, const uint8_t *strStatus, %'ModuleName'_StdIO_OutErr_FctType io)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>SendHelpStr</Name>
        <Symbol>SendHelpStr</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Prints a string using an I/O function, formated for the 'help' command</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>3</ParamCount>
        <Parameter>
          <ParName>strCmd</ParName>
          <ParType>char</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to string of the command</ParHint>
          <ParUserDeclaration>const uint8_t *strCmd</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>strHelp</ParName>
          <ParType>char</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to help text string</ParHint>
          <ParUserDeclaration>const uint8_t *strHelp</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>io</ParName>
          <ParType>StdIO_OutErr_FctType</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>I/O callbacks to be used for printing.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(const uint8_t *strCmd, const uint8_t *strHelp, %'ModuleName'_StdIO_OutErr_FctType io)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>ReadChar</Name>
        <Symbol>ReadChar</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Reads a character (blocking)</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>c</ParName>
          <ParType>uint8_t</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to character to be used to store the result</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(uint8_t *c)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>SendChar</Name>
        <Symbol>SendChar</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Sends a character (blocking)</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>ch</ParName>
          <ParType>uint8_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>character to be sent</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(uint8_t ch)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>KeyPressed</Name>
        <Symbol>KeyPressed</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Checks if a key has been pressed (a character is present in the input buffer)</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>Boolean</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>bool #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>SendCharFct</Name>
        <Symbol>SendCharFct</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Method to send a character using a standard I/O handle.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>ch</ParName>
          <ParType>uint8_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>character to be sent</ParHint>
        </Parameter>
        <Parameter>
          <ParName>fct</ParName>
          <ParType>pointer</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Function pointer to output function: takes a byte to write and returns error code.</ParHint>
          <ParUserDeclaration>uint8_t (*fct)(uint8_t ch)</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(uint8_t ch, uint8_t (*fct)(uint8_t ch))</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>Init</Name>
        <Symbol>Init</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Initializes the module, especially creates the mutex semaphore if an RTOS is used.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>Deinit</Name>
        <Symbol>Deinit</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>De-Initializes the module, especially frees the mutex semaphore if an RTOS is used.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
  </MethodList>
  <EventList>
    <Event>
      <TStrgItem>
        <Name>Event module name</Name>
        <Symbol>EventModule</Symbol>
        <Hint>Name of the user module (without extension), where the events from this component are placed.</Hint>
        <ItemLevel>ADVANCED</ItemLevel>
        <EditLine>true</EditLine>
        <DefaultValue>Events</DefaultValue>
        <StrDefine>nothing</StrDefine>
        <MinLength>0</MinLength>
        <MaxLength>-1</MaxLength>
      </TStrgItem>
    </Event>
    <Event>
      <TEvntItem>
        <Name>OnBeforeIterateCmd</Name>
        <Symbol>OnBeforeIterateCmd</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Hook called before parsing a command in IterateTable().</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <BoldName>true</BoldName>
        <EditLine>false</EditLine>
        <Description>don't generate code</Description>
        <Expanded>No</Expanded>
        <DefaultValue>false</DefaultValue>
        <DefineSymbol>YES_NO</DefineSymbol>
        <IfDisabled>setNOTHING</IfDisabled>
        <IsAssembler>false</IsAssembler>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>cmd</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>command parsed</ParHint>
          <ParUserDeclaration>const uint8_t *cmd</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #C#(const uint8_t *cmd)</ANSIC>
        </Declarations>
        <Children>
          <GrupItem>
            <TEvntName>
              <Name>Event procedure name</Name>
              <Symbol>Name</Symbol>
              <Hint>OnBeforeIterateCmd procedure name</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue/>
              <StrDefine>nothing</StrDefine>
              <MinLength>0</MinLength>
              <MaxLength>-1</MaxLength>
              <ErrorIfNotSet>true</ErrorIfNotSet>
              <IdentType>EVNT</IdentType>
            </TEvntName>
          </GrupItem>
        </Children>
      </TEvntItem>
    </Event>
    <Event>
      <TEvntItem>
        <Name>OnAfterIterateCmd</Name>
        <Symbol>OnAfterIterateCmd</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Hook called after parsing a command in IterateTable().</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <BoldName>true</BoldName>
        <EditLine>false</EditLine>
        <Description>don't generate code</Description>
        <Expanded>No</Expanded>
        <DefaultValue>false</DefaultValue>
        <DefineSymbol>YES_NO</DefineSymbol>
        <IfDisabled>setNOTHING</IfDisabled>
        <IsAssembler>false</IsAssembler>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>cmd</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>command parsed</ParHint>
          <ParUserDeclaration>const uint8_t *cmd</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #C#(const uint8_t *cmd)</ANSIC>
        </Declarations>
        <Children>
          <GrupItem>
            <TEvntName>
              <Name>Event procedure name</Name>
              <Symbol>Name</Symbol>
              <Hint>OnAfterIterateCmd procedure name</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue/>
              <StrDefine>nothing</StrDefine>
              <MinLength>0</MinLength>
              <MaxLength>-1</MaxLength>
              <ErrorIfNotSet>true</ErrorIfNotSet>
              <IdentType>EVNT</IdentType>
            </TEvntName>
          </GrupItem>
        </Children>
      </TEvntItem>
    </Event>
  </EventList>
  <Links>
    <EmptySection_DummyValue/>
  </Links>
  <Revisions>
    <RevisionVersion>2</RevisionVersion>
  </Revisions>
</Bean>
