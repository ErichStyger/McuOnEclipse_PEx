<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head>
<meta http-equiv="content-type" content="text/html; charset=windows-1250">
<title>
Component  documentation - Methods
</title>
<STYLE type="text/css">
body{
  background-color: white;
  margin:0px;
  font: 13px Helvetica Neue, Helvetica, Arial, sans-serif;
}
A:visited {
	COLOR: #2D8AA7; TEXT-DECORATION: none
}
A:link {
	COLOR: #2D8AA7; TEXT-DECORATION: none
}
A:active {
	COLOR: #2D8AA7; TEXT-DECORATION: none
}
A:hover {
	COLOR: #2D8AA7; TEXT-DECORATION: underline
}
.VSP {
	COLOR: #2D8AA7; FONT: bold italic 14px Helvetica Neue, Helvetica, Arial, sans-serif;
}
.reflink {
	FONT: 11px/18px Helvetica Neue, Helvetica, Arial, sans-serif;
 	COLOR: #2D8AA7;
}
.user_text {
	FONT: 12px/18px Helvetica Neue, Helvetica, Arial, sans-serif;
	COLOR: #000000;
}
.bluetext {
  COLOR: #695F52;
}
.versionspec {
  padding:5px; 
  background-color: RGB(243, 242, 230);
  margin-top:5px;
  margin-bottom:5px;  
}
.versionspecdetail {
  padding:5px; 
  background-color: RGB(243, 242, 230);
  margin-top:5px;
  margin-bottom:5px;  
}
.versionspeclabel {
  font-style: italic;
}
LI.DEF {
  list-style-image: url(DefaultLI.gif) ;
}
LI.BAS {
	list-style-image: url(BasicLI.gif) ;
}
LI.ADV {
	list-style-image: url(AdvancedLI.gif) ;
}
LI.EXP {
	list-style-image: url(ExpertLI.gif) ;
}
.titlebox {  
  font: bold 18px Helvetica Neue, Helvetica, Arial, sans-serif;
  color: #51626F;
  margin-bottom: 10px;
}
.lefttitlebox {
  background-color:#C3CFD1;  
}
.lefttitle {
  color:#51626F;
  font: bold 11px Helvetica Neue, Helvetica, Arial, sans-serif;   
}
.beanname {
  font: bold 14px/18px Helvetica Neue, Helvetica, Arial, sans-serif;
  padding-top:6px;
  padding-bottom:5px;
  margin-bottom: 5px;
  border-bottom-style: dotted;
  border-bottom-width: 1;  
}
.descrtext {
  font-style: italic;
  font: 14px/18px Helvetica Neue, Helvetica, Arial, sans-serif;  
  padding-bottom:9px;
}
.footer {
  color: #b0b0b0; 
  font: 9px Helvetica Neue, Helvetica, Arial, sans-serif;
  text-align: center;
  border-top-style: solid;
  border-top-color: #BOBOBO;
  border-top-width: 1px;  
  padding-top: 5px;
  margin-top: 20px;
}
.info_name {
  font: 9px Helvetica Neue, Helvetica, Arial, sans-serif;
  padding: 0px;
  color: black;
}
.info_text {
  font: 11px Helvetica Neue, Helvetica, Arial, sans-serif;
}
.text_title {
  COLOR: #000000; 
  FONT: bold 14px Helvetica Neue, Helvetica, Arial, sans-serif;
}
.descr_line {
  COLOR: gray; 
  FONT: 9px Helvetica Neue, Helvetica, Arial, sans-serif;
}
.code {
  background-color: RGB(243, 242, 230);
  padding: 10px;
  white-space: pre;
  font-family: Courier New, Monospace;
}
</STYLE>

</head>

<body>

<table border="0"  cellspacing="0" cellpadding="0">
  <tr>
    <td valign="top" width="150" >
      <table  width="150" height="160" cellpadding="3" cellspacing="0" border="0">
        <tbody>
        <tr class="lefttitlebox">
          <td width="4"></td>
          <td align="center" valign="middle" height="30" width="128">
            <span class="lefttitle">
<b>FreeRTOS</b>
            </span>
          </td>
        </tr>
        <tr height="700">
          <td width="4"></td>
          <td width="128" valign="top">
            &nbsp;<br />
            <div class="reflink">
<!---HTMLLISTBEG_SHORT DON'T CHANGE THIS LINE-->
<a href="FreeRTOS.html">General Info</a><br />
<a href="FreeRTOSProperties.html">Properties</a><br />
<i>Methods</i><br />
<a href="FreeRTOSEvents.html">Events</a><br />
<a href="FreeRTOSTypical Usage.html">Typical Usage</a><br />
<a href="FreeRTOSApplication Notes.html">Application Notes</a><br />
<!---HTMLLISTEND DON'T CHANGE THIS LINE-->
<br /><br /><br />
<a href="../../DOCs/PredefSymbols.html">Types &amp; definitions</a><br/>
<a href="../../DOCs/BEANindex.html">Component Index</a><br/>
<a href="../../DOCs/CPUindex.html">CPU Component Index</a><br/>
<a href="../../DOCs/EmbeddedBeans.html">Embedded Components</a><br/>
<a href="../../DOCs/BeanCategories.html">Component Categories</a><br/>

<br /><br /><br />
<center>
<img src="FreeRTOS_b.gif" alt="Component icon"/>


</center>
            </div>
          </td>
        </tr>
        </tbody>
      </table>
    </td>
    <td width="1" class="lefttitlebox" valign="top">
      <table class="lefttitlebox" width="1" cellpadding="0" cellspacing="0" height="100%" border="0">
        <tr class="lefttitlebox"><td width="1"></td></tr>
      </table>
    </td>
    <td style="padding-left:15px;padding-right:10px;" valign="top" align="left" width="100%" >

         <div class="titlebox">
            <div class="beanname">
              Component
              
              
              FreeRTOS
            </div>
            <div class="descrtext">FreeRTOS</div>
            <div class="info_name">Component Level: <span class="info_text"><a href="../../DOCs/BeanCategoriesInfo.html#LevelAbstraction">High</a></span></div>
            <div class="info_name">Category: 
              <span class="info_text">
              <a href="../../DOCs/BeanCategoriesInfo.html">Operating Systems</a>
              
              </span>
            </div>
          </div>

         <div class="text_title">
              Methods:
    		 </div>		 
    		 <div class="descr_line">                  
              (Methods are user-callable functions/subroutines intended for
               the component functions control. Please see the <a href="../../DOCs/EmbeddedBeans.html#Methods">Embedded Components page</a> for more information.)                   
         </div>
                  
         <div class="user_text">
            <ul>
<!---USERBEG DON'T CHANGE THIS LINE-->

<!---USEREND DON'T CHANGE THIS LINE-->
<li><a name="xTaskCreate">
<b>xTaskCreate</b></a>
 - Create a new task and add it to the list of tasks that are ready to run.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> portBASE_TYPE xTaskCreate(pdTASK_CODE pvTaskCode, const portCHAR * const pcName, unsigned portSHORT usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pvCreatedTask)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>pvTaskCode:byte</i> - Pointer to the task entry function. Tasks must be implemented to never return (i.e. continuous loop).</li>
<li><i>pcName:byte</i> - A descriptive name for the task. This is mainly used to facilitate debugging. Max length defined by configMAX_TASK_NAME_LEN.</li>
<li><i>usStackDepth:byte</i> - The size of the task stack specified as the number of variables the stack can hold - not the number of bytes. For example, if the stack is 16 bits wide and usStackDepth is defined as 100, 200 bytes will be allocated for stack storage. The stack depth multiplied by the stack width must not exceed the maximum value that can be contained in a variable of type size_t.</li>
<li><i>pvParameters:byte</i> - Pointer that will be used as the parameter for the task being created.</li>
<li><i>uxPriority:byte</i> - The priority at which the task should run.</li>
<li><i>pvCreatedTask:byte</i> - Used to pass back a handle by which the created task can be referenced.</li>
<li><i>Return value:portBASE_TYPE</i> - pdPASS if the task was successfully created and added to a ready list, otherwise an error code defined in the file projdefs.h
</li>
</ul><br />
</li>
<li><a name="vTaskDelete">
<b>vTaskDelete</b></a>
 - Remove a task from the RTOS real time kernels management. The task being deleted will be removed from all ready, blocked, suspended and event lists.<br />NOTE: The idle task is responsible for freeing the kernel allocated memory from tasks that have been deleted. It is therefore important that the idle task is not starved of microcontroller processing time if your application makes any calls to vTaskDelete (). Memory allocated by the task code is not automatically freed, and should be freed before the task is deleted.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void vTaskDelete(xTaskHandle pxTask)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>pxTask:xTaskHandle</i> - The handle of the task to be deleted. Passing NULL will cause the calling task to be deleted.</li>
</ul><br />
</li>
<li><a name="vTaskStartScheduler">
<b>vTaskStartScheduler</b></a>
 - Starts the real time kernel tick processing. After calling the kernel has control over which tasks are executed and when.<br />The idle task is created automatically when vTaskStartScheduler() is called.<br />If vTaskStartScheduler() is successful the function will not return until an executing task calls vTaskEndScheduler(). The function might fail and return immediately if there is insufficient RAM available for the idle task to be created.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void vTaskStartScheduler(void)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
</ul><br />
</li>
<li><a name="vTaskEndScheduler">
<b>vTaskEndScheduler</b></a>
 - Stops the real time kernel tick. All created tasks will be automatically deleted and multitasking (either preemptive or cooperative) will stop. Execution then resumes from the point where vTaskStartScheduler() was called, as if vTaskStartScheduler() had just returned.<br /><br />See the demo application file main. c in the demo/PC directory for an example that uses vTaskEndScheduler ().<br /><br />vTaskEndScheduler () requires an exit function to be defined within the portable layer (see vPortEndScheduler () in port. c for the PC port). This performs hardware specific operations such as stopping the kernel tick.<br /><br />vTaskEndScheduler () will cause all of the resources allocated by the kernel to be freed - but will not free resources allocated by application tasks.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void vTaskEndScheduler(void)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
</ul><br />
</li>
<li><a name="vTaskSuspend">
<b>vTaskSuspend</b></a>
 - Suspend any task. When suspended a task will never get any microcontroller processing time, no matter what its priority. Calls to vTaskSuspend are not accumulative - i.e. calling vTaskSuspend() twice on the same task still only requires one call to vTaskResume() to ready the suspended task.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void vTaskSuspend(xTaskHandle pxTaskToSuspend)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>pxTaskToSuspend:xTaskHandle</i> - Handle to the task being suspended. Passing a NULL handle will cause the calling task to be suspended.</li>
</ul><br />
</li>
<li><a name="vTaskSuspendAll">
<b>vTaskSuspendAll</b></a>
 - Suspends all real time kernel activity while keeping interrupts (including the kernel tick) enabled.<br />After calling vTaskSuspendAll () the calling task will continue to execute without risk of being swapped out until a call to xTaskResumeAll () has been made.<br />API functions that have the potential to cause a context switch (for example, vTaskDelayUntil(), xQueueSend(), etc.) must not be called while the scheduler is suspended.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void vTaskSuspendAll(void)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
</ul><br />
</li>
<li><a name="vTaskResume">
<b>vTaskResume</b></a>
 - Resumes a suspended task. A task that has been suspended by one of more calls to vTaskSuspend() will be made available for running again by a single call to vTaskResume().
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void vTaskResume(xTaskHandle pxTaskToResume)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>pxTaskToResume:xTaskHandle</i> - Handle to the task being readied.</li>
</ul><br />
</li>
<li><a name="xTaskResumeAll">
<b>xTaskResumeAll</b></a>
 - Resumes real time kernel activity following a call to vTaskSuspendAll (). After a call to xTaskSuspendAll () the kernel will take control of which task is executing at any time.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> portBASE_TYPE xTaskResumeAll(void)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>Return value:portBASE_TYPE</i> - If resuming the scheduler caused a context switch then pdTRUE is returned, otherwise pdFALSE is returned.
</li>
</ul><br />
</li>
<li><a name="xTaskResumeFromISR">
<b>xTaskResumeFromISR</b></a>
 - An implementation of vTaskResume() that can be called from within an ISR. A task that has been suspended by one of more calls to vTaskSuspend() will be made available for running again by a single call to xTaskResumeFromISR().
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> portBASE_TYPE xTaskResumeFromISR(xTaskHandle pxTaskToResume)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>pxTaskToResume:xTaskHandle</i> - Handle to the task being readied.</li>
<li><i>Return value:portBASE_TYPE</i> - Error code
</li>
</ul><br />
</li>
<li><a name="vTaskStepTick">
<b>vTaskStepTick</b></a>
 -  If the RTOS is configured to use tickless idle functionality then the tick interrupt will be stopped, and the microcontroller placed into a low power state, whenever the Idle task is the only task able to execute. Upon exiting the low power state the tick count value must be corrected to account for the time that passed while it was stopped.<br /><br />If a FreeRTOS port includes a default portSUPPRESS_TICKS_AND_SLEEP() implementation, then vTaskStepTick() is used internally to ensure the correct tick count value is maintained. vTaskStepTick() is a public API function to allow the default portSUPPRESS_TICKS_AND_SLEEP() implementation to be overridden, and for a portSUPPRESS_TICKS_AND_SLEEP() to be provided if the port being used does not provide a default. 
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void vTaskStepTick(portTickType xTicksToJump)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xTicksToJump:portTickType</i> - The number of RTOS ticks that have passed since the tick interrupt was stopped. For correct operation the parameter must be less than or equal to the portSUPPRESS_TICKS_AND_SLEEP() parameter. </li>
</ul><br />
</li>
<li><a name="taskYIELD">
<b>taskYIELD</b></a>
 - Macro for forcing a context switch.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void taskYIELD(void)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
</ul><br />
</li>
<li><a name="taskENTER_CRITICAL">
<b>taskENTER_CRITICAL</b></a>
 - Macro to mark the start of a critical code region. Preemptive context switches cannot occur when in a critical region.<br /><br />NOTE: This may alter the stack (depending on the portable implementation) so must be used with care!
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void taskENTER_CRITICAL(void)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
</ul><br />
</li>
<li><a name="taskEXIT_CRITICAL">
<b>taskEXIT_CRITICAL</b></a>
 - Macro to mark the end of a critical code region. Preemptive context switches cannot occur when in a critical region.<br /><br />NOTE: This may alter the stack (depending on the portable implementation) so must be used with care!
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void taskEXIT_CRITICAL(void)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
</ul><br />
</li>
<li><a name="taskDISABLE_INTERRUPTS">
<b>taskDISABLE_INTERRUPTS</b></a>
 - Macro to disable all maskable interrupts.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void taskDISABLE_INTERRUPTS(void)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
</ul><br />
</li>
<li><a name="taskENABLE_INTERRUPTS">
<b>taskENABLE_INTERRUPTS</b></a>
 - Macro to enable microcontroller interrupts.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void taskENABLE_INTERRUPTS(void)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
</ul><br />
</li>
<li><a name="vTaskDelay">
<b>vTaskDelay</b></a>
 - Delay a task for a given number of ticks. The actual time that the task remains blocked depends on the tick rate. The constant portTICK_RATE_MS can be used to calculate real time from the tick rate - with the resolution of one tick period.<br /><br />vTaskDelay() specifies a time at which the task wishes to unblock relative to the time at which vTaskDelay() is called. For example, specifying a block period of 100 ticks will cause the task to unblock 100 ticks after vTaskDelay() is called. vTaskDelay() does not therefore provide a good method of controlling the frequency of a cyclical task as the path taken through the code, as well as other task and interrupt activity, will effect the frequency at which vTaskDelay() gets called and therefore the time at which the task next executes. See vTaskDelayUntil() for an alternative API function designed to facilitate fixed frequency execution. It does this by specifying an absolute time (rather than a relative time) at which the calling task should unblock. 
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void vTaskDelay(portTickType xTicksToDelay)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xTicksToDelay:byte</i> - The amount of time, in tick periods, that the calling task should block.</li>
</ul><br />
</li>
<li><a name="vTaskDelayUntil">
<b>vTaskDelayUntil</b></a>
 - Delay a task until a specified time. This function can be used by cyclical tasks to ensure a constant execution frequency.<br /><br />This function differs from vTaskDelay() in one important aspect: vTaskDelay() specifies a time at which the task wishes to unblock relative to the time at which vTaskDelay() is called, whereas vTaskDelayUntil() specifies an absolute time at which the task wishes to unblock.<br /><br />vTaskDelay() will cause a task to block for the specified number of ticks from the time vTaskDelay() is called. It is therefore difficult to use vTaskDelay() by itself to generate a fixed execution frequency as the time between a task unblocking following a call to vTaskDelay() and that task next calling vTaskDelay() may not be fixed [the task may take a different path though the code between calls, or may get interrupted or preempted a different number of times each time it executes].<br /><br />Whereas vTaskDelay() specifies a wake time relative to the time at which the function is called, vTaskDelayUntil() specifies the absolute (exact) time at which it wishes to unblock.<br /><br />It should be noted that vTaskDelayUntil() will return immediately (without blocking) if it is used to specify a wake time that is already in the past. Therefore a task using vTaskDelayUntil() to execute periodically will have to re-calculate its required wake time if the periodic execution is halted for any reason (for example, the task is temporarily placed into the Suspended state) causing the task to miss one or more periodic executions. This can be detected by checking the variable passed by reference as the pxPreviousWakeTime parameter against the current tick count. This is however not necessary under most usage scenarios.<br /><br />The constant portTICK_RATE_MS can be used to calculate real time from the tick rate - with the resolution of one tick period.<br /><br />This function must not be called while the scheduler has been suspended by a call to vTaskSuspendAll(). 
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void vTaskDelayUntil(portTickType *pxPreviousWakeTime, portTickType xTimeIncrement)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>pxPreviousWakeTime:byte</i> - Pointer to a variable that holds the time at which the task was last unblocked. The variable must be initialised with the current time prior to its first use (see the example below). Following this the variable is automatically updated within vTaskDelayUntil(). </li>
<li><i>xTimeIncrement:byte</i> - The cycle time period. The task will be unblocked at time (*pxPreviousWakeTime + xTimeIncrement). Calling vTaskDelayUntil with the same xTimeIncrement parameter value will cause the task to execute with a fixed interval period. </li>
</ul><br />
</li>
<li><a name="uxTaskPriorityGet">
<b>uxTaskPriorityGet</b></a>
 - Obtain the priority of any task.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> unsigned_portBASE_TYPE uxTaskPriorityGet(xTaskHandle pxTask)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>pxTask:byte</i> - Handle of the task to be queried. Passing a NULL handle results in the priority of the calling task being returned.</li>
<li><i>Return value:unsigned_portBASE_TYPE</i> - The priority of pxTask.
</li>
</ul><br />
</li>
<li><a name="vTaskPrioritySet">
<b>vTaskPrioritySet</b></a>
 - Set the priority of any task.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void vTaskPrioritySet(xTaskHandle pxTask, unsigned_portBASE_TYPE uxNewPriority)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>pxTask:xTaskHandle</i> - Handle to the task for which the priority is being set. Passing a NULL handle results in the priority of the calling task being set.</li>
<li><i>uxNewPriority:unsigned_portBASE_TYPE</i> - The priority to which the task will be set.</li>
</ul><br />
</li>
<li><a name="xTaskGetTickCount">
<b>xTaskGetTickCount</b></a>
 - Return the count of ticks since vTaskStartScheduler was called.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> portTickType xTaskGetTickCount(void)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>Return value:portTickType</i> - tick count
</li>
</ul><br />
</li>
<li><a name="xTaskGetTickCountFromISR">
<b>xTaskGetTickCountFromISR</b></a>
 - A version of xTaskGetTickCount() that can be called from an ISR. 
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> portTickType xTaskGetTickCountFromISR(void)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>Return value:portTickType</i> - The count of ticks since vTaskStartScheduler was called. 
</li>
</ul><br />
</li>
<li><a name="xSemaphoreCreateRecursiveMutex">
<b>xSemaphoreCreateRecursiveMutex</b></a>
 - Macro that implements a recursive mutex by using the existing queue mechanism.<br />Mutexes created using this macro can be accessed using the xSemaphoreTakeRecursive() and xSemaphoreGiveRecursive() macros.  The  xSemaphoreTake() and xSemaphoreGive() macros should not be used.<br />A mutex used recursively can be 'taken' repeatedly by the owner. The mutex doesn't become available again until the owner has called xSemaphoreGiveRecursive() for each successful 'take' request.  For example, if a task successfully 'takes' the same mutex 5 times then the mutex will not be available to any other task until it has also  'given' the mutex back exactly five times.<br />This type of semaphore uses a priority inheritance mechanism so a task 'taking' a semaphore MUST ALWAYS 'give' the semaphore back once the semaphore it is no longer required. Mutex type semaphores cannot be used from within interrupt service routines.<br />See vSemaphoreCreateBinary() for an alternative implementation that can be used for pure synchronisation (where one task or interrupt always 'gives' the semaphore and another always 'takes' the semaphore) and from within interrupt service routines.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> xSemaphoreHandle xSemaphoreCreateRecursiveMutex(void)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>Return value:xSemaphoreHandle</i> - Handle to the created mutex semaphore.  Should be of type  xSemaphoreHandle.
</li>
</ul><br />
</li>
<li><a name="xSemaphoreTakeRecursive">
<b>xSemaphoreTakeRecursive</b></a>
 - Macro to recursively obtain, or 'take', a mutex type semaphore. The mutex must have previously been created using a call to xSemaphoreCreateRecursiveMutex();<br />This macro must not be used on mutexes created using xSemaphoreCreateMutex(). A mutex used recursively can be 'taken' repeatedly by the owner. The mutex doesn't become available again until the owner has called xSemaphoreGiveRecursive() for each successful 'take' request.  For example, if a task successfully 'takes' the same mutex 5 times then the mutex will not be available to any other task until it has also  'given' the mutex back exactly five times.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> bool xSemaphoreTakeRecursive(xSemaphoreHandle xMutex, portTickType xBlockTime)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xMutex:xSemaphoreHandle</i> - A handle to the mutex being obtained.  This is the handle returned by xSemaphoreCreateRecursiveMutex();</li>
<li><i>xBlockTime:byte</i> - The time in ticks to wait for the semaphore to become available.  The macro portTICK_RATE_MS can be used to convert this to a real time.  A block time of zero can be used to poll the semaphore.  If the task already owns the semaphore then xSemaphoreTakeRecursive() will return immediately no matter what the value of xBlockTime.</li>
<li><i>Return value:bool</i> - Returns pdTRUE if the semaphore was obtained.  pdFALSE if xBlockTime expired without the semaphore becoming available.
</li>
</ul><br />
</li>
<li><a name="xSemaphoreGiveRecursive">
<b>xSemaphoreGiveRecursive</b></a>
 - Macro to recursively release, or 'give', a mutex type semaphore. The mutex must have previously been created using a call to xSemaphoreCreateRecursiveMutex();<br />This macro must not be used on mutexes created using xSemaphoreCreateMutex(). A mutex used recursively can be 'taken' repeatedly by the owner. The mutex doesn't become available again until the owner has called xSemaphoreGiveRecursive() for each successful 'take' request.  For example, if a task successfully 'takes' the same mutex 5 times then the mutex will not be available to any other task until it has also  'given' the mutex back exactly five times.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> bool xSemaphoreGiveRecursive(xSemaphoreHandle xMutex)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xMutex:xSemaphoreHandle</i> - A handle to the mutex being released, or 'given'.  This is the handle returned by xSemaphoreCreateMutex();</li>
<li><i>Return value:bool</i> - Returns pdTRUE if the semaphore was given.
</li>
</ul><br />
</li>
<li><a name="xSemaphoreCreateMutex">
<b>xSemaphoreCreateMutex</b></a>
 - Macro that creates a mutex semaphore by using the existing queue mechanism.<br /><br />Mutexes created using this macro can be accessed using the xSemaphoreTake() and xSemaphoreGive() macros. The xSemaphoreTakeRecursive() and xSemaphoreGiveRecursive() macros should not be used.<br /><br />Mutexes and binary semaphores are very similar but have some subtle differences: Mutexes include a priority inheritance mechanism, binary semaphores do not. This makes binary semaphores the better choice for implementing synchronisation (between tasks or between tasks and an interrupt), and mutexes the better choice for implementing simple mutual exclusion.<br /><br />The priority of a task that 'takes' a mutex can potentially be raised if another task of higher priority attempts to obtain the same mutex. The task that owns the mutex 'inherits' the priority of the task attempting to 'take' the same mutex. This means the mutex must always be 'given' back - otherwise the higher priority task will never be able to obtain the mutex, and the lower priority task will never 'disinherit' the priority. An example of a mutex being used to implement mutual exclusion is provided on the xSemaphoreTake() documentation page.<br /><br />A binary semaphore need not be given back once obtained, so task synchronisation can be implemented by one task/interrupt continuously 'giving' the semaphore while another continuously 'takes' the semaphore. This is demonstrated by the sample code on the xSemaphoreGiveFromISR() documentation page.<br /><br />Both mutex and binary semaphores are assigned to variables of type xSemaphoreHandle and can be used in any API function that takes a parameter of this type. 
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> xSemaphoreHandle xSemaphoreCreateMutex(void)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>Return value:xSemaphoreHandle</i> - Handle to the created mutex semaphore.  Should be of type  xSemaphoreHandle.
</li>
</ul><br />
</li>
<li><a name="xSemaphoreTake">
<b>xSemaphoreTake</b></a>
 - Macro to obtain a semaphore. The semaphore must have previously been created with a call to vSemaphoreCreateBinary(), xSemaphoreCreateMutex() or xSemaphoreCreateCounting().<br /><br />This macro must not be called from an ISR. xQueueReceiveFromISR() can be used to take a semaphore from within an interrupt if required, although this would not be a normal operation. Semaphores use queues as their underlying mechanism, so functions are to some extent interoperable.<br /><br />xSemaphoreTake() is part of the fully featured intertask communications API. xSemaphoreAltTake() is the alternative API equivalent. Both versions require the same parameters and return the same values.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> bool xSemaphoreTake(xSemaphoreHandle xMutex, portTickType xBlockTime)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xMutex:xSemaphoreHandle</i> - A handle to the mutex being obtained.  This is the handle returned by xSemaphoreCreateMutex();</li>
<li><i>xBlockTime:byte</i> - The time in ticks to wait for the semaphore to become available.  The macro portTICK_RATE_MS can be used to convert this to a real time.  A block time of zero can be used to poll the semaphore.  If the task already owns the semaphore then xSemaphoreTakeRecursive() will return immediately no matter what the value of xBlockTime. Specifying the block time as portMAX_DELAY will cause the task to block indefinitely (without a timeout).</li>
<li><i>Return value:bool</i> - Returns pdTRUE if the semaphore was obtained.  pdFALSE if xBlockTime expired without the semaphore becoming available.
</li>
</ul><br />
</li>
<li><a name="xSemaphoreGive">
<b>xSemaphoreGive</b></a>
 - Macro to release a semaphore. The semaphore must have previously been created with a call to vSemaphoreCreateBinary(), xSemaphoreCreateMutex() or xSemaphoreCreateCounting(), and obtained using sSemaphoreTake().<br /><br />This must not be used from an ISR. See xSemaphoreGiveFromISR() for an alternative which can be used from an ISR.<br /><br />This macro must also not be used on semaphores created using xSemaphoreCreateRecursiveMutex().<br /><br />xSemaphoreGive() is part of the fully featured intertask communications API. xSemaphoreAltGive() is the alternative API equivalent. Both versions require the same parameters and return the same values. 
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> bool xSemaphoreGive(xSemaphoreHandle xMutex)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xMutex:xSemaphoreHandle</i> - A handle to the mutex being released, or 'given'.  This is the handle returned by xSemaphoreCreateMutex();</li>
<li><i>Return value:bool</i> - Returns pdTRUE if the semaphore was given.
</li>
</ul><br />
</li>
<li><a name="vSemaphoreCreateBinary">
<b>vSemaphoreCreateBinary</b></a>
 - Macro that creates a semaphore by using the existing queue mechanism. The queue length is 1 as this is a binary semaphore. The data size is 0 as we don't want to actually store any data - we just want to know if the queue is empty or full.<br /><br />Binary semaphores and mutexes are very similar but have some subtle differences: Mutexes include a priority inheritance mechanism, binary semaphores do not. This makes binary semaphores the better choice for implementing synchronisation (between tasks or between tasks and an interrupt), and mutexes the better choice for implementing simple mutual exclusion.<br /><br />A binary semaphore need not be given back once obtained, so task synchronisation can be implemented by one task/interrupt continuously 'giving' the semaphore while another continuously 'takes' the semaphore. This is demonstrated by the sample code on the xSemaphoreGiveFromISR() documentation page.<br /><br />The priority of a task that 'takes' a mutex can potentially be raised if another task of higher priority attempts to obtain the same mutex. The task that owns the mutex 'inherits' the priority of the task attempting to 'take' the same mutex. This means the mutex must always be 'given' back - otherwise the higher priority task will never be able to obtain the mutex, and the lower priority task will never 'disinherit' the priority. An example of a mutex being used to implement mutual exclusion is provided on the xSemaphoreTake() documentation page.<br /><br />Both mutex and binary semaphores are assigned to variables of type xSemaphoreHandle and can be used in any API function that takes a parameter of this type. 
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void vSemaphoreCreateBinary(xSemaphoreHandle xSemaphore)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xSemaphore:xSemaphoreHandle</i> - Handle to the created semaphore. Should be of type xSemaphoreHandle.</li>
</ul><br />
</li>
<li><a name="xSemaphoreCreateCounting">
<b>xSemaphoreCreateCounting</b></a>
 - Macro that creates a counting semaphore by using the existing queue mechanism.<br /><br />Counting semaphores are typically used for two things:<br /><br />1. Counting events.<br />In this usage scenario an event handler will 'give' a semaphore each time an event occurs (incrementing the semaphore count value), and a handler task will 'take' a semaphore each time it processes an event (decrementing the semaphore count value). The count value is therefore the difference between the number of events that have occurred and the number that have been processed. In this case it is desirable for the initial count value to be zero.<br /><br />2. Resource management.<br />In this usage scenario the count value indicates the number of resources available. To obtain control of a resource a task must first obtain a semaphore - decrementing the semaphore count value. When the count value reaches zero there are no free resources. When a task finishes with the resource it 'gives' the semaphore back - incrementing the semaphore count value. In this case it is desirable for the initial count value to be equal to the maximum count value, indicating that all resources are free.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> xSemaphoreHandle xSemaphoreCreateCounting(unsigned_portBASE_TYPE uxMaxCount, unsigned_portBASE_TYPE uxInitialCount)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>uxMaxCount:unsigned_portBASE_TYPE</i> - The maximum count value that can be reached. When the semaphore reaches this value it can no longer be 'given'.</li>
<li><i>uxInitialCount:unsigned_portBASE_TYPE</i> - The count value assigned to the semaphore when it is created.</li>
<li><i>Return value:xSemaphoreHandle</i> - xSemaphoreHandle handle
</li>
</ul><br />
</li>
<li><a name="xSemaphoreGiveFromISR">
<b>xSemaphoreGiveFromISR</b></a>
 - Macro to release a semaphore. The semaphore must have previously been created with a call to vSemaphoreCreateBinary() or xSemaphoreCreateCounting().<br /><br />Mutex type semaphores (those created using a call to xSemaphoreCreateMutex()) must not be used with this macro.<br /><br />This macro can be used from an ISR.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> bool xSemaphoreGiveFromISR(xSemaphoreHandle xSemaphore, signed_portBASE_TYPE *pxHigherPriorityTaskWoken)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xSemaphore:xSemaphoreHandle</i> - A handle to the semaphore being released. This is the handle returned when the semaphore was created.</li>
<li><i>pxHigherPriorityTaskWoken: Pointer to signed_portBASE_TYPE</i> - xSemaphoreGiveFromISR() will set *pxHigherPriorityTaskWoken to pdTRUE if giving the semaphoree caused a task to unblock, and the unblocked task has a priority higher than the currently running task. If xSemaphoreGiveFromISR() sets this value to pdTRUE then a context switch should be requested before the interrupt is exited.</li>
<li><i>Return value:bool</i> - Returns pdTRUE if the semaphore was given.
</li>
</ul><br />
</li>
<li><a name="xSemaphoreTakeFromISR">
<b>xSemaphoreTakeFromISR</b></a>
 - Macro to take a semaphore from an ISR. The semaphore must have previously been created with a call to vSemaphoreCreateBinary() or xSemaphoreCreateCounting().<br /><br />Mutex type semaphores (those created using a call to xSemaphoreCreateMutex()) must not be used with this macro.<br /><br />This macro can be used from an ISR, however taking a semaphore from an ISR is not a common operation.  It is likely to only be useful when taking a counting semaphore when an interrupt is obtaining an object from a resource pool (when the semaphore count indicates the number of resources available).
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> bool xSemaphoreTakeFromISR(xSemaphoreHandle xSemaphore, signed_portBASE_TYPE *pxHigherPriorityTaskWoken)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xSemaphore:xSemaphoreHandle</i> - A handle to the semaphore being taken. This is the handle returned when the semaphore was created.</li>
<li><i>pxHigherPriorityTaskWoken: Pointer to signed_portBASE_TYPE</i> - xSemaphoreTakeFromISR() will set *pxHigherPriorityTaskWoken to pdTRUE if taking the semaphore caused a task to unblock, and the unblocked task has a priority higher than the currently running task.  If xSemaphoreTakeFromISR() sets this value to pdTRUE then a context switch should be requested before the interrupt is exited.</li>
<li><i>Return value:bool</i> - Returns pdTRUE if the semaphore was given.
</li>
</ul><br />
</li>
<li><a name="vSemaphoreDelete">
<b>vSemaphoreDelete</b></a>
 - Delete a semaphore.  This function must be used with care.  For example, do not delete a mutex type semaphore if the mutex is held by a task.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void vSemaphoreDelete(xSemaphoreHandle xSemaphore)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xSemaphore:xSemaphoreHandle</i> - A handle to the semaphore to be deleted.</li>
</ul><br />
</li>
<li><a name="xSemaphoreGetMutexHolder">
<b>xSemaphoreGetMutexHolder</b></a>
 - Returns the holder of a mutex or semaphore. If xMutex is indeed a mutex type semaphore, return the current mutex holder. If xMutex is not a mutex type semaphore, or the mutex is available (not held by a task), return NULL. Note: This Is is a good way of determining if the calling task is the mutex holder, but not a good way of determining the identity of the mutex holder as the holder may change between the function exiting and the returned value being tested.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void* xSemaphoreGetMutexHolder(xSemaphoreHandle xSemaphore)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xSemaphore:xSemaphoreHandle</i> - A handle to the semaphore.</li>
<li><i>Return value:void*</i> - Not NULL if the calling task is the holder of the mutex, NULL otherwise.
</li>
</ul><br />
</li>
<li><a name="pvPortMalloc">
<b>pvPortMalloc</b></a>
 - Allocates a memory block using the port pvPortMalloc() function
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> pVoid pvPortMalloc(size_t xWantedSize)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xWantedSize:byte</i> - size of memory block requested</li>
<li><i>Return value:pVoid</i> - memory block or NULL if failed
</li>
</ul><br />
</li>
<li><a name="vPortFree">
<b>vPortFree</b></a>
 - Frees a memory block previously allocated with pvPortMalloc()
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void vPortFree(void *pv)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>pv: Pointer to bool</i> - Pointer to data</li>
</ul><br />
</li>
<li><a name="xPortGetFreeHeapSize">
<b>xPortGetFreeHeapSize</b></a>
 - Returns the actual free size of the heap
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> Tsize_t xPortGetFreeHeapSize(void)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>Return value:Tsize_t</i> - Error code
</li>
</ul><br />
</li>
<li><a name="vTaskSetApplicationTaskTag">
<b>vTaskSetApplicationTaskTag</b></a>
 - A 'tag' value can be assigned to each task. This value is for the use of the application only - the RTOS kernel itself does not make use of it in any way.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void vTaskSetApplicationTaskTag(xTaskHandle xTask, pdTASK_HOOK_CODE pxHookFunction, byte Variable_1)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xTask:xTaskHandle</i> - The handle of the task to which a tag value is being assigned. Passing xTask as NULL causes the tag to be assigned to the calling task.</li>
<li><i>pxHookFunction:pdTASK_HOOK_CODE</i> - The value being assigned to the task tag. This is of type pdTASK_HOOK_CODE to permit a function pointer to be assigned as the tag, although any value can actually be assigned. See the example below.</li>
<li><i>Variable_1:byte</i> - no hint</li>
</ul><br />
</li>
<li><a name="xTaskGetApplicationTaskTag">
<b>xTaskGetApplicationTaskTag</b></a>
 - Returns the ‘tag’ value associated with a task. The meaning and use of the tag value is defined by the application writer. The RTOS kernel itself will not normally access the tag value. 
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> pdTASK_HOOK_CODE xTaskGetApplicationTaskTag(xTaskHandle xTask)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xTask:xTaskHandle</i> - The handle of the task being queried. A task can query its own tag value by using NULL as the parameter value.</li>
<li><i>Return value:pdTASK_HOOK_CODE</i> - Error code
</li>
</ul><br />
</li>
<li><a name="xTaskCallApplicationTaskHook">
<b>xTaskCallApplicationTaskHook</b></a>
 -  A 'tag' value can be assigned to each task. Normally this value is for the use of the application only and the RTOS kernel does not access it. However, it is possible to use the tag to assign a hook (or callback) function to a task - the hook function being executed by calling xTaskCallApplicationTaskHook(). Each task can define its own callback, or simply not define a callback at all.<br /><br />Although it is possible to use the first function parameter to call the hook function of any task, the most common use of task hook function is with the trace hook macros, as per the example given below.<br /><br />Task hook functions must have type pdTASK_HOOK_CODE, that is take a void * parameter, and return a value of type portBASE_TYPE. The void * parameter can be used to pass any information into the hook function. 
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> portBASE_TYPE xTaskCallApplicationTaskHook(xTaskHandle xTask, void* pvParameter)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xTask:xTaskHandle</i> - The handle of the task whose hook function is being called. Passing NULL as xTask will call the hook function associated with the currently executing task.</li>
<li><i>pvParameter:void*</i> - The value to pass to the hook function. This can be a pointer to a structure, or simply a numeric value.</li>
<li><i>Return value:portBASE_TYPE</i> - return value
</li>
</ul><br />
</li>
<li><a name="xTaskGetCurrentTaskHandle">
<b>xTaskGetCurrentTaskHandle</b></a>
 - The handle of the currently running (calling) task.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> xTaskHandle xTaskGetCurrentTaskHandle(void)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>Return value:xTaskHandle</i> - The handle of the currently running (calling) task.
</li>
</ul><br />
</li>
<li><a name="xTaskGetIdleTaskHandle">
<b>xTaskGetIdleTaskHandle</b></a>
 - The task handle associated with the Idle task. The Idle task is created automatically when the RTOS scheduler is started.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> xTaskHandle xTaskGetIdleTaskHandle(void)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>Return value:xTaskHandle</i> - The task handle associated with the Idle task. The Idle task is created automatically when the RTOS scheduler is started.
</li>
</ul><br />
</li>
<li><a name="pcTaskGetTaskName">
<b>pcTaskGetTaskName</b></a>
 - Returns the name of the task.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> signed char pcTaskGetTaskName(xTaskHandle xTaskToQuery)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xTaskToQuery:xTaskHandle</i> - The handle of the task being queried. xTaskToQuery can be set to NULL to query the name of the calling task.</li>
<li><i>Return value:signed char</i> - A pointer to the subject tasks name, which is a standard NULL terminated C string
</li>
</ul><br />
</li>
<li><a name="eTaskGetState">
<b>eTaskGetState</b></a>
 - Returns as an enumerated type the state in which a task existed at the time eTaskGetState() was executed. 
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> eTaskState eTaskGetState(xTaskHandle xTask)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xTask:xTaskHandle</i> - The handle of the subject task (the task being queried).</li>
<li><i>Return value:eTaskState</i> - task state (eReady, eRunning, eBlocked, eSuspended, eDeleted)
</li>
</ul><br />
</li>
<li><a name="xTaskGetSchedulerState">
<b>xTaskGetSchedulerState</b></a>
 - Returns the state of the scheduler
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> portBASE_TYPE xTaskGetSchedulerState(void)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>Return value:portBASE_TYPE</i> - One of the following constants (defined within task.h): taskSCHEDULER_NOT_STARTED, taskSCHEDULER_RUNNING, taskSCHEDULER_SUSPENDED.
</li>
</ul><br />
</li>
<li><a name="vTaskList">
<b>vTaskList</b></a>
 - configUSE_TRACE_FACILITY, INCLUDE_vTaskDelete and INCLUDE_vTaskSuspend must all be defined as 1 for this function to be available. See the configuration section for more information.<br />NOTE: This function will disable interrupts for its duration.  It is not intended for normal application runtime use but as a debug aid. Lists all the current tasks, along with their current state and stack usage high water mark.<br />Tasks are reported as blocked ('B'), ready ('R'), deleted ('D') or suspended ('S').
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void vTaskList(signed portCHAR *pcWriteBuffer, size_t bufSize)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>pcWriteBuffer: Pointer to signed char</i> - Pointer to buffer. A buffer into which the above mentioned details will be written, in ascii form.  This buffer is assumed to be large enough to contain the generated report.  Approximately 40 bytes per task should be sufficient.</li>
<li><i>bufSize:uint16_t</i> - size of buffer</li>
</ul><br />
</li>
<li><a name="uxTaskGetStackHighWaterMark">
<b>uxTaskGetStackHighWaterMark</b></a>
 - The stack used by a task will grow and shrink as the task executes and interrupts are processed. uxTaskGetStackHighWaterMark() returns the minimum amount of remaining stack space that was available to the task since the task started executing - that is the amount of stack that remained unused when the task stack was at its greatest (deepest) value. This is what is referred to as the stack 'high water mark'.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> unsigned_portBASE_TYPE uxTaskGetStackHighWaterMark(xTaskHandle xTask)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xTask:xTaskHandle</i> - The handle of the task being queried. A task may query its own high water mark by passing NULL as the xTask parameter.</li>
<li><i>Return value:unsigned_portBASE_TYPE</i> - Error code
</li>
</ul><br />
</li>
<li><a name="uxTaskGetNumberOfTasks">
<b>uxTaskGetNumberOfTasks</b></a>
 - Returns the number of tasks
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> unsigned_portBASE_TYPE uxTaskGetNumberOfTasks(void)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>Return value:unsigned_portBASE_TYPE</i> - number of tasks
</li>
</ul><br />
</li>
<li><a name="vTaskGetRunTimeStats">
<b>vTaskGetRunTimeStats</b></a>
 - configGENERATE_RUN_TIME_STATS must be defined as 1 for this function to be available. The application must also then provide definitions for portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() and portGET_RUN_TIME_COUNTER_VALUE to configure a peripheral timer/counter and return the timers current count value respectively. The counter should be at least 10 times the frequency of the tick count.<br />NOTE: This function will disable interrupts for its duration. It is not intended for normal application runtime use but as a debug aid.<br />Setting configGENERATE_RUN_TIME_STATS to 1 will result in a total accumulated execution time being stored for each task. The resolution of the accumulated time value depends on the frequency of the timer configured by the portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() macro. Calling vTaskGetRunTimeStats() writes the total execution time of each task into a buffer, both as an absolute count value and as a percentage of the total system execution time. 
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void vTaskGetRunTimeStats(portCHAR *pcWriteBuffer, size_t bufSize)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>pcWriteBuffer:byte</i> - A buffer into which the execution times will be written, in ascii form. This buffer is assumed to be large enough to contain the generated report. Approximately 40 bytes per task should be sufficient. </li>
<li><i>bufSize:word</i> - size of buffer</li>
</ul><br />
</li>
<li><a name="uxQueueMessagesWaiting">
<b>uxQueueMessagesWaiting</b></a>
 - Queries the number of items that are currently held within a queue.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> unsigned_portBASE_TYPE uxQueueMessagesWaiting(xQueueHandle xQueue)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xQueue:xQueueHandle</i> - The handle of the queue being queried.</li>
<li><i>Return value:unsigned_portBASE_TYPE</i> - The number of items that are held within the queue being queried.
</li>
</ul><br />
</li>
<li><a name="uxQueueMessagesWaitingfromISR">
<b>uxQueueMessagesWaitingfromISR</b></a>
 - A version of uxQueueMessagesWaiting() that can be used from inside an interrupt service routine.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> unsigned_portBASE_TYPE uxQueueMessagesWaitingfromISR(xQueueHandle xQueue)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xQueue:xQueueHandle</i> - The handle of the queue being queried.</li>
<li><i>Return value:unsigned_portBASE_TYPE</i> - The number of items that are held within the queue being queried.
</li>
</ul><br />
</li>
<li><a name="xQueueCreate">
<b>xQueueCreate</b></a>
 - Creates a queue.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> xQueueHandle xQueueCreate(unsigned_portBASE_TYPE uxQueueLength, unsigned_portBASE_TYPE uxItemSize)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>uxQueueLength:unsigned_portBASE_TYPE</i> - The maximum number of items the queue can hold at any time.</li>
<li><i>uxItemSize:unsigned_portBASE_TYPE</i> - The size in bytes of each item the queue will hold.</li>
<li><i>Return value:xQueueHandle</i> - A handle to the created queue is returned provided the queue was created successfully. NULL is returned if the queue cannot be created because there is too little heap RAM available.
</li>
</ul><br />
</li>
<li><a name="vQueueDelete">
<b>vQueueDelete</b></a>
 - Deletes a queue that was previously created using a call to xQueueCreate(). vQueueDelete() can also be used to delete a semaphore.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void vQueueDelete(xQueueHandle pxQueueToDelete)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>pxQueueToDelete:xQueueHandle</i> - The handle of the queue being deleted. Semaphore handles can also be used. Queues are used to pass data between tasks and between tasks and interrupts. A queue/semaphore must not be deleted if there are any tasks that are blocked on the queue/semaphore waiting for events (sends or receives).</li>
</ul><br />
</li>
<li><a name="xQueueReset">
<b>xQueueReset</b></a>
 - Reset a queue back to its original empty state.  pdPASS is returned if the queue is successfully reset.  pdFAIL is returned if the queue could not be reset because there are tasks blocked on the queue waiting to either receive from the queue or send to the queue.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> portBASE_TYPE xQueueReset(xQueueHandle xQueue)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xQueue:xQueueHandle</i> - The handle of the queue to reset.</li>
<li><i>Return value:portBASE_TYPE</i> - pdPASS is returned if the queue is successfully reset. pdFAIL is returned if the queue could not be reset because there are tasks blocked on the queue waiting to either receive from the queue or send to the queue.
</li>
</ul><br />
</li>
<li><a name="xQueueSendToBack">
<b>xQueueSendToBack</b></a>
 - Sends an item to the back of a queue.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> portBASE_TYPE xQueueSendToBack(xQueueHandle xQueue, const void *pvItemToQueue, portTickType xTicksToWait)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xQueue:xQueueHandle</i> - The handle of the queue to which the data is to be sent.</li>
<li><i>pvItemToQueue:byte</i> - A pointer to the data to be sent to the queue. The size of the data that can be sent to a queue was defined when the queue was created.</li>
<li><i>xTicksToWait:portTickType</i> - The number of ticks for which the calling task should be held in the Blocked state to wait for space to become available on the queue should the queue already be full.<br />A value of zero will prevent the calling task from entering the Blocked state.<br />If INCLUDE_vTaskSuspend is set to 1 then a value of portMAX_DELAY will hold the task in the Blocked state indefinitely to wait for space to become available on the queue.</li>
<li><i>Return value:portBASE_TYPE</i> - pdPASS: Data was successfully sent to the queue. If a block time was specified then the calling task may have been temporarily placed into the Blocked state to wait for space to become available and space did become available before the block time expired.<br />errQUEUE_FULL: The queue is already full so no data could be sent to the queue. If a block time was specified then the calling task may have been temporarily placed into the Blocked state to wait for space to become available, but no space became available before the block time expired.
</li>
</ul><br />
</li>
<li><a name="xQueueSendToFront">
<b>xQueueSendToFront</b></a>
 - Sends an item to the front of a queue.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> portBASE_TYPE xQueueSendToFront(xQueueHandle xQueue, const void *pvItemToQueue, portTickType xTicksToWait)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xQueue:xQueueHandle</i> - The handle of the queue to which the data is to be sent.</li>
<li><i>pvItemToQueue:byte</i> - A pointer to the data to be sent to the queue. The size of the data that can be sent to a queue was defined when the queue was created.</li>
<li><i>xTicksToWait:portTickType</i> - The number of ticks for which the calling task should be held in the Blocked state to wait for space to become available on the queue should the queue already be full.<br />A value of zero will prevent the calling task from entering the Blocked state.<br />If INCLUDE_vTaskSuspend is set to 1 then a value of portMAX_DELAY will hold the task in the Blocked state indefinitely to wait for space to become available on the queue.</li>
<li><i>Return value:portBASE_TYPE</i> - pdPASS: Data was successfully sent to the queue. If a block time was specified then the calling task may have been temporarily placed into the Blocked state to wait for space to become available and space did become available before the block time expired.<br />errQUEUE_FULL: The queue is already full so no data could be sent to the queue. If a block time was specified then the calling task may have been temporarily placed into the Blocked state to wait for space to become available, but no space became available before the block time expired.
</li>
</ul><br />
</li>
<li><a name="xQueueReceive">
<b>xQueueReceive</b></a>
 - Receives an item from a queue.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> portBASE_TYPE xQueueReceive(xQueueHandle xQueue, void *pvBuffer, portTickType xTicksToWait)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xQueue:xQueueHandle</i> - The handle of the queue from which the data is to be received.</li>
<li><i>pvBuffer:byte</i> - A pointer to the memory into which the data received from the queue will be copied.<br />The length of the buffer must be at least equal to the queue item size (set when the queue was created).</li>
<li><i>xTicksToWait:portTickType</i> - The number of ticks for which the calling task should be held in the Blocked state to wait for data to become available from the queue should the queue already be empty.<br />A value of zero will prevent the calling task from entering the Blocked state.<br />If INCLUDE_vTaskSuspend is set to 1 then a value of portMAX_DELAY will hold the task in the Blocked state indefinitely to wait for data.</li>
<li><i>Return value:portBASE_TYPE</i> - pdPASS: Data was successfully read from the queue. If a block time was specified then the calling task may have been temporarily placed into the Blocked state to wait for data to become available and data did become available before the block time expired.<br />errQUEUE_EMPTY: The queue was empty so no date could be read form the queue. If a block time was specified then the calling task may have been temporarily placed into the Blocked state to wait for data to become available, but no data became available before the block time expired.
</li>
</ul><br />
</li>
<li><a name="xQueueOverwrite">
<b>xQueueOverwrite</b></a>
 - This is a macro that calls the xQueueGenericSend() function. A version of xQueueSendToBack() that will write to the queue even if the queue is full, overwriting data that is already held in the queue. xQueueOverwrite() is intended for use with queues that have a length of one, meaning the queue is either empty or full. This function must not be called from an interrupt service routine (ISR). See xQueueOverwriteFromISR() for an alternative which may be used in an ISR. 
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> portBASE_TYPE xQueueOverwrite(xQueueHandle xQueue, const void *pvItemToQueue)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xQueue:xQueueHandle</i> - The handle of the queue to which the data is to be sent.</li>
<li><i>pvItemToQueue:byte</i> - A pointer to the data to be sent to the queue. The size of the data that can be sent to a queue was defined when the queue was created.</li>
<li><i>Return value:portBASE_TYPE</i> - pdPASS: Data was successfully sent to the queue. If a block time was specified then the calling task may have been temporarily placed into the Blocked state to wait for space to become available and space did become available before the block time expired.<br />errQUEUE_FULL: The queue is already full so no data could be sent to the queue. If a block time was specified then the calling task may have been temporarily placed into the Blocked state to wait for space to become available, but no space became available before the block time expired.
</li>
</ul><br />
</li>
<li><a name="xQueueOverwriteFromISR">
<b>xQueueOverwriteFromISR</b></a>
 - This is a macro that calls the xQueueGenericSendFromISR() function. A version of xQueueOverwrite() that can be used in an ISR. xQueueOverwriteFromISR() is similar to xQueueSendToBackFromISR(), but will write to the queue even if the queue is full, overwriting data that is already held in the queue. xQueueOverwriteFromISR() is intended for use with queues that have a length of one, meaning the queue is either empty or full. 
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> portBASE_TYPE xQueueOverwriteFromISR(xQueueHandle xQueue, const void *pvItemToQueue, portBASE_TYPE *pxHigherPriorityTaskWoken)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xQueue:xQueueHandle</i> - The handle of the queue to which the data is to be sent.</li>
<li><i>pvItemToQueue:byte</i> - A pointer to the data to be sent to the queue. The size of the data that can be sent to a queue was defined when the queue was created.</li>
<li><i>pxHigherPriorityTaskWoken: Pointer to portBASE_TYPE</i> - xQueueSendFromISR() will set *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task to unblock, and the unblocked task has a priority higher than the currently running task. If xQueueSendFromISR() sets this value to pdTRUE then a context switch should be performed before the interrupt is exited.</li>
<li><i>Return value:portBASE_TYPE</i> - pdTRUE Data was successfully sent to the queue.<br />errQUEUE_FULL Data could not be sent to the queue because the queue was already full.
</li>
</ul><br />
</li>
<li><a name="xQueuePeek">
<b>xQueuePeek</b></a>
 - Reads an item from a queue, but does not remove the item from the queue. Therefore the same item would be returned the next time xQueueReceive() or xQueuePeek() was called on the same queue.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> portBASE_TYPE xQueuePeek(xQueueHandle xQueue, void *pvBuffer, portTickType xTicksToWait)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xQueue:xQueueHandle</i> - The handle of the queue from which the data is to be read.</li>
<li><i>pvBuffer:byte</i> - A pointer to the memory into which the data read from the queue will be copied. The length of the buffer must be at least equal to the queue item size (set when the queue was created).</li>
<li><i>xTicksToWait:portTickType</i> - The number of ticks for which the calling task should be held in the Blocked state to wait for data to become available from the queue should the queue already be empty.<br />A value of zero will prevent the calling task from entering the Blocked state.<br />If INCLUDE_vTaskSuspend is set to 1 then a value of portMAX_DELAY will hold the task in the Blocked state indefinitely to wait for data.</li>
<li><i>Return value:portBASE_TYPE</i> - pdPASS: Data was successfully read from the queue. If a block time was specified then the calling task may have been temporarily placed into the Blocked state to wait for data to become available and data did become available before the block time expired.<br />errQUEUE_EMPTY: The queue was empty so no date could be read form the queue. If a block time was specified then the calling task may have been temporarily placed into the Blocked state to wait for data to become available, but no data became available before the block time expired.
</li>
</ul><br />
</li>
<li><a name="xQueuePeekFromISR">
<b>xQueuePeekFromISR</b></a>
 - A version of xQueuePeek() that can be used from an interrupt service routine (ISR). Reads an item from a queue, but does not remove the item from the queue. Therefore the same item would be returned the next time xQueueReceive() or xQueuePeek() was called on the same queue.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> portBASE_TYPE xQueuePeekFromISR(xQueueHandle xQueue, void *pvBuffer, portTickType xTicksToWait)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xQueue:xQueueHandle</i> - The handle of the queue from which the data is to be read.</li>
<li><i>pvBuffer:byte</i> - A pointer to the memory into which the data read from the queue will be copied. The length of the buffer must be at least equal to the queue item size (set when the queue was created).</li>
<li><i>xTicksToWait:portTickType</i> - The number of ticks for which the calling task should be held in the Blocked state to wait for data to become available from the queue should the queue already be empty.<br />A value of zero will prevent the calling task from entering the Blocked state.<br />If INCLUDE_vTaskSuspend is set to 1 then a value of portMAX_DELAY will hold the task in the Blocked state indefinitely to wait for data.</li>
<li><i>Return value:portBASE_TYPE</i> - pdPASS: Data was successfully read from the queue. If a block time was specified then the calling task may have been temporarily placed into the Blocked state to wait for data to become available and data did become available before the block time expired.<br />errQUEUE_EMPTY: The queue was empty so no date could be read form the queue. If a block time was specified then the calling task may have been temporarily placed into the Blocked state to wait for data to become available, but no data became available before the block time expired.
</li>
</ul><br />
</li>
<li><a name="xQueueSendToBackFromISR">
<b>xQueueSendToBackFromISR</b></a>
 - Versions of xQueueSendToBack() API functions that can be called from an ISR. Unlike xQueueSendToBack() these functions do not permit a block time to be specified.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> portBASE_TYPE xQueueSendToBackFromISR(xQueueHandle xQueue, const void *pvItemToQueue, portBASE_TYPE *pxHigherPriorityTaskWoken)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xQueue:xQueueHandle</i> - The handle of the queue to which the data is to be sent.</li>
<li><i>pvItemToQueue:byte</i> - A pointer to the data to be sent to the queue. The size of the data that can be sent to a queue was defined when the queue was created.</li>
<li><i>pxHigherPriorityTaskWoken: Pointer to portBASE_TYPE</i> - xQueueSendFromISR() will set *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task to unblock, and the unblocked task has a priority higher than the currently running task. If xQueueSendFromISR() sets this value to pdTRUE then a context switch should be performed before the interrupt is exited.</li>
<li><i>Return value:portBASE_TYPE</i> - pdTRUE Data was successfully sent to the queue.<br />errQUEUE_FULL Data could not be sent to the queue because the queue was already full.
</li>
</ul><br />
</li>
<li><a name="xQueueSendToFrontFromISR">
<b>xQueueSendToFrontFromISR</b></a>
 - Versions of xQueueSendToFront() API functions that can be called from an ISR. Unlike xQueueSendToFront() these functions do not permit a block time to be specified.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> portBASE_TYPE xQueueSendToFrontFromISR(xQueueHandle xQueue, const void *pvItemToQueue, portBASE_TYPE *pxHigherPriorityTaskWoken)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xQueue:xQueueHandle</i> - The handle of the queue to which the data is to be sent.</li>
<li><i>pvItemToQueue:byte</i> - A pointer to the data to be sent to the queue. The size of the data that can be sent to a queue was defined when the queue was created.</li>
<li><i>pxHigherPriorityTaskWoken: Pointer to portBASE_TYPE</i> - xQueueSendFromISR() will set *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task to unblock, and the unblocked task has a priority higher than the currently running task. If xQueueSendFromISR() sets this value to pdTRUE then a context switch should be performed before the interrupt is exited.</li>
<li><i>Return value:portBASE_TYPE</i> - pdTRUE Data was successfully sent to the queue.<br />errQUEUE_FULL Data could not be sent to the queue because the queue was already full.
</li>
</ul><br />
</li>
<li><a name="xQueueReceiveFromISR">
<b>xQueueReceiveFromISR</b></a>
 - A version of xQueueReceive() that can be called from an ISR. Unlike xQueueReceive(), xQueueReceiveFromISR() does not permit a block time to be specified.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> portBASE_TYPE xQueueReceiveFromISR(xQueueHandle xQueue, void *pvBuffer, portBASE_TYPE *pxHigherPriorityTaskWoken)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xQueue:xQueueHandle</i> - The handle of the queue from which the data is to be received.</li>
<li><i>pvBuffer:byte</i> - A pointer to the memory into which the data received from the queue will be copied.The length of the buffer must be at least equal to the queue item size (set when the queue was created).</li>
<li><i>pxHigherPriorityTaskWoken: Pointer to portBASE_TYPE</i> - Pointer to A task may be blocked waiting for space to become available on the queue. If xQueueReceiveFromISR() causes such a task to unblock then *pxHigherPriorityTaskWoken will get set to pdTRUE, otherwise *pxHigherPriorityTaskWoken will remain unchanged.</li>
<li><i>Return value:portBASE_TYPE</i> - pdPASS: Data was successfully read from the queue. If a block time was specified then the calling task may have been temporarily placed into the Blocked state to wait for data to become available and data did become available before the block time expired.<br />errQUEUE_EMPTY: The queue was empty so no date could be read form the queue. If a block time was specified then the calling task may have been temporarily placed into the Blocked state to wait for data to become available, but no data became available before the block time expired.
</li>
</ul><br />
</li>
<li><a name="vQueueAddToRegistry">
<b>vQueueAddToRegistry</b></a>
 - Assigns a name to a queue and adds the queue to the registry. 
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void vQueueAddToRegistry(xQueueHandle xQueue, char *pcQueueName)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xQueue:xQueueHandle</i> - The handle of the queue being added to the registry.</li>
<li><i>pcQueueName: Pointer to char</i> - Pointer to the name to be assigned to the queue. This is just a text string used to facilitate debugging.</li>
</ul><br />
</li>
<li><a name="vQueueUnregisterQueue">
<b>vQueueUnregisterQueue</b></a>
 - Removes a queue from the queue registry. 
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void vQueueUnregisterQueue(xQueueHandle xQueue)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xQueue:xQueueHandle</i> - The handle of the queue being removed from the registry.</li>
</ul><br />
</li>
<li><a name="xQueueIsQueueFullFromISR">
<b>xQueueIsQueueFullFromISR</b></a>
 - Queries a queue to determine if the queue is full. This function should only be used in an ISR. 
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> portBASE_TYPE xQueueIsQueueFullFromISR(xQueueHandle xQueue)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xQueue:xQueueHandle</i> - The handle of the queue being queried.</li>
<li><i>Return value:portBASE_TYPE</i> - pdFALSE if the queue is not full, or any other value if the queue is full. 
</li>
</ul><br />
</li>
<li><a name="xQueueIsQueueEmptyFromISR">
<b>xQueueIsQueueEmptyFromISR</b></a>
 - Queries a queue to determine if the queue is empty. This function should only be used in an ISR. 
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> portBASE_TYPE xQueueIsQueueEmptyFromISR(xQueueHandle xQueue)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xQueue:xQueueHandle</i> - The handle of the queue being queried.</li>
<li><i>Return value:portBASE_TYPE</i> - pdFALSE if the queue is not empty, or any other value if the queue is empty. 
</li>
</ul><br />
</li>
<li><a name="xQueueCreateSet">
<b>xQueueCreateSet</b></a>
 - Queue sets provide a mechanism to allow an RTOS task to block (pend) on a read operation from multiple RTOS queues or semaphores simultaneously. Note that there are simpler alternatives to using queue sets. See the Blocking on Multiple Objects page for more information.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> xQueueSetHandle xQueueCreateSet(unsigned portBASE_TYPE uxEventQueueLength)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>uxEventQueueLength:byte</i> - no hint</li>
<li><i>Return value:xQueueSetHandle</i> - If the queue set is created successfully then a handle to the created queue set is returned. Otherwise NULL is returned. 
</li>
</ul><br />
</li>
<li><a name="xQueueAddToSet">
<b>xQueueAddToSet</b></a>
 -  Adds an RTOS queue or semaphore to a queue set that was previously created by a call to xQueueCreateSet().
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> portBASE_TYPE xQueueAddToSet(xQueueSetMemberHandle xQueueOrSemaphore, xQueueSetHandle xQueueSet)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xQueueOrSemaphore:xQueueSetMemberHandle</i> - The handle of the queue or semaphore being added to the queue set (cast to an xQueueSetMemberHandle type). </li>
<li><i>xQueueSet:xQueueSetHandle</i> - The handle of the queue set to which the queue or semaphore is being added. </li>
<li><i>Return value:portBASE_TYPE</i> - If the queue or semaphore was successfully added to the queue set then pdPASS is returned. If the queue could not be successfully added to the queue set because it is already a member of a different queue set then pdFAIL is returned. 
</li>
</ul><br />
</li>
<li><a name="xQueueRemoveFromSet">
<b>xQueueRemoveFromSet</b></a>
 - Remove an RTOS queue or semaphore from a queue set. An RTOS queue or semaphore can only be removed from a queue set if the queue or semaphore is empty. 
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> portBASE_TYPE xQueueRemoveFromSet(xQueueSetMemberHandle xQueueOrSemaphore, xQueueSetHandle xQueueSet)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xQueueOrSemaphore:xQueueSetMemberHandle</i> - The handle of the queue or semaphore being removed from the queue set (cast to an xQueueSetMemberHandle type). </li>
<li><i>xQueueSet:xQueueSetHandle</i> - The handle of the queue set in which the queue or semaphore is included.</li>
<li><i>Return value:portBASE_TYPE</i> - If the queue or semaphore was successfully added to the queue set then pdPASS is returned. If the queue could not be successfully added to the queue set because it is already a member of a different queue set then pdFAIL is returned. 
</li>
</ul><br />
</li>
<li><a name="xQueueSelectFromSet">
<b>xQueueSelectFromSet</b></a>
 - xQueueSelectFromSet() selects from the members of a queue set a queue or semaphore that either contains data (in the case of a queue) or is available to take (in the case of a semaphore). xQueueSelectFromSet() effectively allows a task to block (pend) on a read operation on all the queues and semaphores in a queue set simultaneously. 
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> xQueueSetMemberHandle xQueueSelectFromSet(xQueueSetHandle xQueueSet, portTickType xBlockTimeTicks)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xQueueSet:xQueueSetHandle</i> - The queue set on which the task will (potentially) block. </li>
<li><i>xBlockTimeTicks:portTickType</i> - The maximum time, in ticks, that the calling task will remain in the Blocked state (with other tasks executing) to wait for a member of the queue set to be ready for a successful queue read or semaphore take operation. </li>
<li><i>Return value:xQueueSetMemberHandle</i> - xQueueSelectFromSet() will return the handle of a queue (cast to a xQueueSetMemberHandle type) contained in the queue set that contains data, or the handle of a semaphore (cast to a xQueueSetMemberHandle type) contained in the queue set that is available, or NULL if no such queue or semaphore exists before before the specified block time expires. 
</li>
</ul><br />
</li>
<li><a name="xQueueSelectFromSetFromISR">
<b>xQueueSelectFromSetFromISR</b></a>
 - A version of xQueueSelectFromSet() that can be used from an interrupt service routine (ISR). 
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> xQueueSetMemberHandle xQueueSelectFromSetFromISR(xQueueSetHandle xQueueSet)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xQueueSet:xQueueSetHandle</i> - The queue set being queried. It is not possible to block on a read as this function is designed to be used from an interrupt. </li>
<li><i>Return value:xQueueSetMemberHandle</i> - xQueueSelectFromSet() will return the handle of a queue (cast to a xQueueSetMemberHandle type) contained in the queue set that contains data, or the handle of a semaphore (cast to a xQueueSetMemberHandle type) contained in the queue set that is available, or NULL if no such queue or semaphore exists before before the specified block time expires. 
</li>
</ul><br />
</li>
<li><a name="xEventGroupCreate">
<b>xEventGroupCreate</b></a>
 -  Create a new RTOS event group. This function cannot be called from an interrupt.<br /><br />Event groups are stored in variables of type EventGroupHandle_t. The number of bits (or flags) implemented within an event group is 8 if configUSE_16_BIT_TICKS is set to 1, or 24 if configUSE_16_BIT_TICKS is set to 0. The dependency on configUSE_16_BIT_TICKS results from the data type used for thread local storage in the internal implementation of RTOS tasks. 
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> EventGroupHandle_t xEventGroupCreate(void)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>Return value:EventGroupHandle_t</i> - Event Group Handle. If the event group was created then a handle to the event group is returned. If there was insufficient FreeRTOS heap available to create the event group then NULL is returned. 
</li>
</ul><br />
</li>
<li><a name="xEventGroupWaitBits">
<b>xEventGroupWaitBits</b></a>
 -  Read bits within an RTOS event group, optionally entering the Blocked state (with a timeout) to wait for a bit or group of bits to become set. This function cannot be called from an interrupt. 
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> byte xEventGroupWaitBits(const EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xEventGroup:byte</i> - The event group in which the bits are being tested. The event group must have previously been created using a call to xEventGroupCreate(). </li>
<li><i>uxBitsToWaitFor:byte</i> - A bitwise value that indicates the bit or bits to test inside the event group. For example, to wait for bit 0 and/or bit 2 set uxBitsToWaitFor to 0x05. To wait for bits 0 and/or bit 1 and/or bit 2 set uxBitsToWaitFor to 0x07. Etc.<br /><br />uxBitsToWaitFor must not be set to 0. </li>
<li><i>xClearOnExit:byte</i> - If xClearOnExit is set to pdTRUE then any bits set in the value passed as the uxBitsToWaitFor parameter will be cleared in the event group before xEventGroupWaitBits() returns if xEventGroupWaitBits() returns for any reason other than a timeout. The timeout value is set by the xTicksToWait parameter.<br /><br />If xClearOnExit is set to pdFALSE then the bits set in the event group are not altered when the call to xEventGroupWaitBits() returns. </li>
<li><i>xWaitForAllBits:byte</i> - xWaitForAllBits is used to create either a logical AND test (where all bits must be set) or a logical OR test (where one or more bits must be set) as follows:<br /><br />If xWaitForAllBits is set to pdTRUE then xEventGroupWaitBits() will return when either all the bits set in the value passed as the uxBitsToWaitFor parameter are set in the event group or the specified block time expires.<br /><br />If xWaitForAllBits is set to pdFALSE then xEventGroupWaitBits() will return when any of the bits set in the value passed as the uxBitsToWaitFor parameter are set in the event group or the specified block time expires. </li>
<li><i>xTicksToWait:TickType_t</i> - The maximum amount of time (specified in 'ticks') to wait for one/all (depending on the xWaitForAllBits value) of the bits specified by uxBitsToWaitFor to become set. </li>
<li><i>Return value:byte</i> - EventBits_t: The value of the event group at the time either the event bits being waited for became set, or the block time expired. The current value of the event bits in an event group will be different to the returned value if a higher priority task or interrupt changed the value of an event bit between the calling task leaving the Blocked state and exiting the xEventGroupWaitBits() function.<br /><br />Test the return value to know which bits were set. If xEventGroupWaitBits() returned because its timeout expired then not all the bits being waited for will be set. If xEventGroupWaitBits() returned because the bits it was waiting for were set then the returned value is the event group value before any bits were automatically cleared because the xClearOnExit parameter was set to pdTRUE. 
</li>
</ul><br />
</li>
<li><a name="xEventGroupSetBits">
<b>xEventGroupSetBits</b></a>
 -  Set bits (flags) within an RTOS event group. This function cannot be called from an interrupt. xEventGroupSetBitsFromISR() is a version that can be called from an interrupt.<br /><br />Setting bits in an event group will automatically unblock tasks that are blocked waiting for the bits. 
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> EventBits_t xEventGroupSetBits(EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xEventGroup:EventGroupHandle_t</i> - The event group in which the bits are to be set. The event group must have previously been created using a call to xEventGroupCreate(). </li>
<li><i>uxBitsToSet:byte</i> - A bitwise value that indicates the bit or bits to set in the event group. For example, set uxBitsToSet to 0x08 to set only bit 3. Set uxBitsToSet to 0x09 to set bit 3 and bit 0. </li>
<li><i>Return value:EventBits_t</i> - The value of the event group at the time the call to xEventGroupSetBits() returns.<br /><br />There are two reasons why the returned value might have the bits specified by the uxBitsToSet parameter cleared:<br /><br />    If setting a bit results in a task that was waiting for the bit leaving the blocked state then it is possible the bit will have been cleared automatically (see the xClearBitOnExit parameter of xEventGroupWaitBits()).<br /><br />    Any unblocked (or otherwise Ready state) task that has a priority above that of the task that called xEventGroupSetBits() will execute and may change the event group value before the call to xEventGroupSetBits() returns.
</li>
</ul><br />
</li>
<li><a name="xEventGroupSetBitsFromISR">
<b>xEventGroupSetBitsFromISR</b></a>
 -  Set bits (flags) within an RTOS event group. A version of xEventGroupSetBits() that can be called from an interrupt service routine (ISR).<br /><br />Setting bits in an event group will automatically unblock tasks that are blocked waiting for the bits.<br /><br />Setting bits in an event group is not a deterministic operation because there are an unknown number of tasks that may be waiting for the bit or bits being set. FreeRTOS does not allow non-deterministic operations to be performed in interrupts or from critical sections. Therefore xEventGroupSetBitFromISR() sends a message to the RTOS daemon task to have the set operation performed in the context of the daemon task - where a scheduler lock is used in place of a critical section.<br /><br />INCLUDE_xEventGroupSetBitFromISR, configUSE_TIMERS and INCLUDE_xTimerPendFunctionCall must all be set to 1 in FreeRTOSConfig.h for the xEventGroupSetBitsFromISR() function to be available. 
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> EventBits_t xEventGroupSetBitsFromISR(EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet , BaseType_t *pxHigherPriorityTaskWoken)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xEventGroup:EventGroupHandle_t</i> - The event group in which the bits are to be set. The event group must have previously been created using a call to xEventGroupCreate(). </li>
<li><i>uxBitsToSet:byte</i> - A bitwise value that indicates the bit or bits to set in the event group. For example, set uxBitsToSet to 0x08 to set only bit 3. Set uxBitsToSet to 0x09 to set bit 3 and bit 0. </li>
<li><i>pxHigherPriorityTaskWoken:byte</i> - Calling this function will result in a message being sent to the RTOS daemon task. If the priority of the daemon task is higher than the priority of the currently running task (the task the interrupt interrupted) then *pxHigherPriorityTaskWoken will be set to pdTRUE by xEventGroupSetBitsFromISR(), indicating that a context switch should be requested before the interrupt exits. For that reason *pxHigherPriorityTaskWoken must be initialised to pdFALSE. See the example code below. </li>
<li><i>Return value:EventBits_t</i> - The value of the event group at the time the call to xEventGroupSetBits() returns.<br /><br />There are two reasons why the returned value might have the bits specified by the uxBitsToSet parameter cleared:<br /><br />    If setting a bit results in a task that was waiting for the bit leaving the blocked state then it is possible the bit will have been cleared automatically (see the xClearBitOnExit parameter of xEventGroupWaitBits()).<br /><br />    Any unblocked (or otherwise Ready state) task that has a priority above that of the task that called xEventGroupSetBits() will execute and may change the event group value before the call to xEventGroupSetBits() returns.
</li>
</ul><br />
</li>
<li><a name="xEventGroupClearBits">
<b>xEventGroupClearBits</b></a>
 - Clear bits (flags) within an RTOS event group. This function cannot be called from an interrupt. See xEventGroupClearBitsFromISR() for a version that can be called from an interrupt. 
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> EventBits_t xEventGroupClearBits(EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xEventGroup:EventGroupHandle_t</i> - The event group in which the bits are to be cleared. The event group must have previously been created using a call to xEventGroupCreate(). </li>
<li><i>uxBitsToSet:byte</i> - A bitwise value that indicates the bit or bits to clear in the event group. For example set uxBitsToClear to 0x08 to clear just bit 3. Set uxBitsToClear to 0x09 to clear bit 3 and bit 0. </li>
<li><i>Return value:EventBits_t</i> - The value of the event group at the time the call to xEventGroupSetBits() returns.<br /><br />There are two reasons why the returned value might have the bits specified by the uxBitsToSet parameter cleared:<br /><br />    If setting a bit results in a task that was waiting for the bit leaving the blocked state then it is possible the bit will have been cleared automatically (see the xClearBitOnExit parameter of xEventGroupWaitBits()).<br /><br />    Any unblocked (or otherwise Ready state) task that has a priority above that of the task that called xEventGroupSetBits() will execute and may change the event group value before the call to xEventGroupSetBits() returns.
</li>
</ul><br />
</li>
<li><a name="xEventGroupClearBitsFromISR">
<b>xEventGroupClearBitsFromISR</b></a>
 -  A version of xEventGroupClearBits() that can be called from an interrupt. 
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> EventBits_t xEventGroupClearBitsFromISR(EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xEventGroup:EventGroupHandle_t</i> - The event group in which the bits are to be set. The event group must have previously been created using a call to xEventGroupCreate(). </li>
<li><i>uxBitsToSet:byte</i> - A bitwise value that indicates the bit or bits to set in the event group. For example, set uxBitsToSet to 0x08 to set only bit 3. Set uxBitsToSet to 0x09 to set bit 3 and bit 0. </li>
<li><i>Return value:EventBits_t</i> - The value of the event group at the time the call to xEventGroupSetBits() returns.<br /><br />There are two reasons why the returned value might have the bits specified by the uxBitsToSet parameter cleared:<br /><br />    If setting a bit results in a task that was waiting for the bit leaving the blocked state then it is possible the bit will have been cleared automatically (see the xClearBitOnExit parameter of xEventGroupWaitBits()).<br /><br />    Any unblocked (or otherwise Ready state) task that has a priority above that of the task that called xEventGroupSetBits() will execute and may change the event group value before the call to xEventGroupSetBits() returns.
</li>
</ul><br />
</li>
<li><a name="xEventGroupGetBits">
<b>xEventGroupGetBits</b></a>
 - Returns the current value of the event bits (event flags) in an RTOS event group. This function cannot be used from an interrupt. See xEventGroupsGetBitsFromISR() for a version that can be used in an interrupt. 
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> EventBits_t xEventGroupGetBits(EventGroupHandle_t xEventGroup)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xEventGroup:EventGroupHandle_t</i> - The event group being queried. The event group must have previously been created using a call to xEventGroupCreate().</li>
<li><i>Return value:EventBits_t</i> - The value of the event bits in the event group at the time xEventGroupGetBits() was called. 
</li>
</ul><br />
</li>
<li><a name="xEventGroupGetBitsFromISR">
<b>xEventGroupGetBitsFromISR</b></a>
 - A version of xEventGroupGetBits() that can be called from an interrupt. 
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> EventBits_t xEventGroupGetBitsFromISR(EventGroupHandle_t xEventGroup)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xEventGroup:EventGroupHandle_t</i> - The event group being queried. The event group must have previously been created using a call to xEventGroupCreate().</li>
<li><i>Return value:EventBits_t</i> - The value of the event bits in the event group at the time xEventGroupGetBits() was called. 
</li>
</ul><br />
</li>
<li><a name="xEventGroupSync">
<b>xEventGroupSync</b></a>
 -  Atomically set bits (flags) within an RTOS event group, then wait for a combination of bits to be set within the same event group. This functionality is typically used to synchronise multiple tasks (often called a task rendezvous), where each task has to wait for the other tasks to reach a synchronisation point before proceeding.<br /><br />This function cannot be used from an interrupt.<br /><br />The function will return before its block time expires if the bits specified by the uxBitsToWait parameter are set, or become set within that time. In this case all the bits specified by uxBitsToWait will be automatically cleared before the function returns. 
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> EventBits_t xEventGroupSync(EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xEventGroup:EventGroupHandle_t</i> - The event group in which the bits are being set and tested. The event group must have previously been created using a call to xEventGroupCreate().</li>
<li><i>uxBitsToSet:byte</i> - The bit or bits to set in the event group before determining if (and possibly waiting for), all the bits specified by the uxBitsToWait parameter are set. For example, set uxBitsToSet to 0x04 to set bit 2 within the event group. </li>
<li><i>uxBitsToWaitFor:byte</i> - A bitwise value that indicates the bit or bits to test inside the event group. For example, set uxBitsToWaitFor to 0x05 to wait for bits 0 and bit 2. Set uxBitsToWaitFor to 0x07 to wait for bit 0 and bit 1 and bit 2. Etc. </li>
<li><i>xTicksToWait:TickType_t</i> - The maximum amount of time (specified in 'ticks') to wait for all the bits specified by the uxBitsToWaitFor parameter value to become set. </li>
<li><i>Return value:EventBits_t</i> - Error code
</li>
</ul><br />
</li>
<li><a name="xTimerCreate">
<b>xTimerCreate</b></a>
 -  Creates a new software timer instance. This allocates the storage required by the new timer, initialises the new timers internal state, and returns a handle by which the new timer can be referenced.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> TimerHandle_t xTimerCreate(const char * const pcTimerName, const TickType_t xTimerPeriod, const UBaseType_t uxAutoReload, void *const pvTimerID, TimerCallbackFunction_t pxCallbackFunction)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>pcTimerName:byte</i> - Atextnamethatisassignedtothetimer_Thisisdonepurelytoassistdebugging_TheRTOSkernelitselfonlyeverreferencesatimerbyitshandle_andneverbyitsname_</li>
<li><i>xTimerPeriod:byte</i> - The timer period. The time is defined in tick periods so the constant portTICK_PERIOD_MS can be used to convert a time that has been specified in milliseconds. For example, if the timer must expire after 100 ticks, then xTimerPeriod should be set to 100. Alternatively, if the timer must expire after 500ms, then xPeriod can be set to ( 500 / portTICK_PERIOD_MS ) provided configTICK_RATE_HZ is less than or equal to 1000. </li>
<li><i>uxAutoReload:byte</i> - If uxAutoReload is set to pdTRUE, then the timer will expire repeatedly with a frequency set by the xTimerPeriod parameter. If uxAutoReload is set to pdFALSE, then the timer will be a one-shot and enter the dormant state after it expires. </li>
<li><i>pvTimerID:byte</i> - An identifier that is assigned to the timer being created. Typically this would be used in the timer callback function to identify which timer expired when the same callback function is assigned to more than one timer. </li>
<li><i>pxCallbackFunction:byte</i> - The function to call when the timer expires. Callback functions must have the prototype defined by TimerCallbackFunction_t, which is &quot;void vCallbackFunction( TimerHandle_t xTimer );&quot;. </li>
<li><i>Return value:TimerHandle_t</i> - Timer handle. If the timer is successfully created then a handle to the newly created timer is returned. If the timer cannot be created (because either there is insufficient FreeRTOS heap remaining to allocate the timer structures, or the timer period was set to 0) then NULL is returned. 
</li>
</ul><br />
</li>
<li><a name="xTimerIsTimerActive">
<b>xTimerIsTimerActive</b></a>
 - Queries a timer to see if it is active or dormant.<br /> A timer will be dormant if:<br /><br />    It has been created but not started, or<br />    It is an expired one-shot timer that has not been restarted.<br /><br />Timers are created in the dormant state. The xTimerStart(), xTimerReset(), xTimerStartFromISR(), xTimerResetFromISR(), xTimerChangePeriod() and xTimerChangePeriodFromISR() API functions can all be used to transition a timer into the active state. 
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> BaseType_t xTimerIsTimerActive(TimerHandle_t xTimer)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xTimer:TimerHandle_t</i> - The timer being queried. </li>
<li><i>Return value:BaseType_t</i> - Error code
</li>
</ul><br />
</li>
<li><a name="xTimerStart">
<b>xTimerStart</b></a>
 -  Timer functionality is provided by a timer service/daemon task. Many of the public FreeRTOS timer API functions send commands to the timer service task through a queue called the timer command queue. The timer command queue is private to the RTOS kernel itself and is not directly accessible to application code. The length of the timer command queue is set by the configTIMER_QUEUE_LENGTH configuration constant.<br /><br />xTimerStart() starts a timer that was previously created using the xTimerCreate() API function. If the timer had already been started and was already in the active state, then xTimerStart() has equivalent functionality to the xTimerReset() API function.<br /><br />Starting a timer ensures the timer is in the active state. If the timer is not stopped, deleted, or reset in the mean time, the callback function associated with the timer will get called 'n 'ticks after xTimerStart() was called, where 'n' is the timers defined period.<br /><br />It is valid to call xTimerStart() before the RTOS scheduler has been started, but when this is done the timer will not actually start until the RTOS scheduler is started, and the timers expiry time will be relative to when the RTOS scheduler is started, not relative to when xTimerStart() was called.<br /><br />The configUSE_TIMERS configuration constant must be set to 1 for xTimerStart() to be available. 
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> BaseType_t xTimerStart(TimerHandle_t xTimer, TickType_t xBlockTime)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xTimer:TimerHandle_t</i> - The handle of the timer being started/restarted. </li>
<li><i>xBlockTime:TickType_t</i> - Specifies the time, in ticks, that the calling task should be held in the Blocked state to wait for the start command to be successfully sent to the timer command queue, should the queue already be full when xTimerStart() was called. xBlockTime is ignored if xTimerStart() is called before the RTOS scheduler is started.</li>
<li><i>Return value:BaseType_t</i> - pdFAIL will be returned if the start command could not be sent to the timer command queue even after xBlockTime ticks had passed. pdPASS will be returned if the command was successfully sent to the timer command queue. When the command is actually processed will depend on the priority of the timer service/daemon task relative to other tasks in the system, although the timers expiry time is relative to when xTimerStart() is actually called. The timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY configuration constant.
</li>
</ul><br />
</li>
<li><a name="xTimerStop">
<b>xTimerStop</b></a>
 -  Timer functionality is provided by a timer service/daemon task. Many of the public FreeRTOS timer API functions send commands to the timer service task through a queue called the timer command queue. The timer command queue is private to the RTOS kernel itself and is not directly accessible to application code. The length of the timer command queue is set by the configTIMER_QUEUE_LENGTH configuration constant.<br /><br />xTimerStop() stops a timer that was previously started using either of the xTimerStart(), xTimerReset(), xTimerStartFromISR(), xTimerResetFromISR(), xTimerChangePeriod() and xTimerChangePeriodFromISR() API functions.<br /><br />Stopping a timer ensures the timer is not in the active state.<br /><br />The configUSE_TIMERS configuration constant must be set to 1 for xTimerStop() to be available. 
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> BaseType_t xTimerStop(TimerHandle_t xTimer, TickType_t xBlockTime)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xTimer:TimerHandle_t</i> - The handle of the timer being stopped. </li>
<li><i>xBlockTime:TickType_t</i> - Specifies the time, in ticks, that the calling task should be held in the Blocked state to wait for the stop command to be successfully sent to the timer command queue, should the queue already be full when xTimerStop() was called. xBlockTime is ignored if xTimerStop() is called before the RTOS scheduler is started. </li>
<li><i>Return value:BaseType_t</i> - pdFAIL will be returned if the stop command could not be sent to the timer command queue even after xBlockTime ticks had passed. pdPASS will be returned if the command was successfully sent to the timer command queue. When the command is actually processed will depend on the priority of the timer service/daemon task relative to other tasks in the system. The timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY configuration constant. 
</li>
</ul><br />
</li>
<li><a name="xTimerChangePeriod">
<b>xTimerChangePeriod</b></a>
 -  Timer functionality is provided by a timer service/daemon task. Many of the public FreeRTOS timer API functions send commands to the timer service task through a queue called the timer command queue. The timer command queue is private to the RTOS kernel itself and is not directly accessible to application code. The length of the timer command queue is set by the configTIMER_QUEUE_LENGTH configuration constant.<br /><br />xTimerChangePeriod() changes the period of a timer that was previously created using the xTimerCreate() API function.<br /><br />xTimerChangePeriod() can be called to change the period of an active or dormant state timer.<br /><br />The configUSE_TIMERS configuration constant must be set to 1 for xTimerChangePeriod() to be available. 
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> BaseType_t xTimerChangePeriod(TimerHandle_t xTimer, TickType_t xNewPeriod, TickType_t xBlockTime)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xTimer:TimerHandle_t</i> - The handle of the timer that is having its period changed. </li>
<li><i>xNewPeriod:TickType_t</i> - The new period for xTimer. Timer periods are specified in tick periods, so the constant portTICK_PERIOD_MS can be used to convert a time that has been specified in milliseconds. For example, if the timer must expire after 100 ticks, then xNewPeriod should be set to 100. Alternatively, if the timer must expire after 500ms, then xNewPeriod can be set to ( 500 / portTICK_PERIOD_MS ) provided configTICK_RATE_HZ is less than or equal to 1000. </li>
<li><i>xBlockTime:TickType_t</i> - Specifies the time, in ticks, that the calling task should be held in the Blocked state to wait for the change period command to be successfully sent to the timer command queue, should the queue already be full when xTimerChangePeriod() was called. xBlockTime is ignored if xTimerChangePeriod() is called before the RTOS scheduler is started. </li>
<li><i>Return value:BaseType_t</i> - pdFAIL will be returned if the change period command could not be sent to the timer command queue even after xBlockTime ticks had passed. pdPASS will be returned if the command was successfully sent to the timer command queue. When the command is actually processed will depend on the priority of the timer service/daemon task relative to other tasks in the system. The timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY configuration constant. 
</li>
</ul><br />
</li>
<li><a name="xTimerDelete">
<b>xTimerDelete</b></a>
 -  Timer functionality is provided by a timer service/daemon task. Many of the public FreeRTOS timer API functions send commands to the timer service task through a queue called the timer command queue. The timer command queue is private to the RTOS kernel itself and is not directly accessible to application code. The length of the timer command queue is set by the configTIMER_QUEUE_LENGTH configuration constant.<br /><br />xTimerDelete() deletes a timer that was previously created using the xTimerCreate() API function.<br /><br />The configUSE_TIMERS configuration constant must be set to 1 for xTimerDelete() to be available. 
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> BaseType_t xTimerDelete(TickType_t xTimer, TickType_t xBlockTime)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xTimer:TickType_t</i> - The handle of the timer being deleted. </li>
<li><i>xBlockTime:TickType_t</i> - Specifies the time, in ticks, that the calling task should be held in the Blocked state to wait for the delete command to be successfully sent to the timer command queue, should the queue already be full when xTimerDelete() was called. xBlockTime is ignored if xTimerDelete() is called before the RTOS scheduler is started. </li>
<li><i>Return value:BaseType_t</i> - pdFAIL will be returned if the delete command could not be sent to the timer command queue even after xBlockTime ticks had passed. pdPASS will be returned if the command was successfully sent to the timer command queue. When the command is actually processed will depend on the priority of the timer service/daemon task relative to other tasks in the system. The timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY configuration constant. 
</li>
</ul><br />
</li>
<li><a name="xTimerReset">
<b>xTimerReset</b></a>
 -  Timer functionality is provided by a timer service/daemon task. Many of the public FreeRTOS timer API functions send commands to the timer service task through a queue called the timer command queue. The timer command queue is private to the RTOS kernel itself and is not directly accessible to application code. The length of the timer command queue is set by the configTIMER_QUEUE_LENGTH configuration constant.<br /><br />xTimerReset() re-starts a timer that was previously created using the xTimerCreate() API function. If the timer had already been started and was already in the active state, then xTimerReset() will cause the timer to re-evaluate its expiry time so that it is relative to when xTimerReset() was called. If the timer was in the dormant state then xTimerReset() has equivalent functionality to the xTimerStart() API function.<br /><br />Resetting a timer ensures the timer is in the active state. If the timer is not stopped, deleted, or reset in the mean time, the callback function associated with the timer will get called 'n' ticks after xTimerReset() was called, where 'n' is the timers defined period.<br /><br />It is valid to call xTimerReset() before the RTOS scheduler has been started, but when this is done the timer will not actually start until the RTOS scheduler is started, and the timers expiry time will be relative to when the RTOS scheduler is started, not relative to when xTimerReset() was called.<br /><br />The configUSE_TIMERS configuration constant must be set to 1 for xTimerReset() to be available. 
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> BaseType_t xTimerReset(TimerHandle_t xTimer, TickType_t xBlockTime)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xTimer:TimerHandle_t</i> - The handle of the timer being reset/started/restarted. </li>
<li><i>xBlockTime:TickType_t</i> - Specifies the time, in ticks, that the calling task should be held in the Blocked state to wait for the reset command to be successfully sent to the timer command queue, should the queue already be full when xTimerReset() was called. xBlockTime is ignored if xTimerReset() is called before the RTOS scheduler is started. </li>
<li><i>Return value:BaseType_t</i> - pdFAIL will be returned if the reset command could not be sent to the timer command queue even after xBlockTime ticks had passed. pdPASS will be returned if the command was successfully sent to the timer command queue. When the command is actually processed will depend on the priority of the timer service/daemon task relative to other tasks in the system, although the timers expiry time is relative to when xTimerReset() is actually called. The timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY configuration constant. 
</li>
</ul><br />
</li>
<li><a name="xTimerStartFromISR">
<b>xTimerStartFromISR</b></a>
 - A version of xTimerStart() that can be called from an interrupt service routine. 
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> BaseType_t xTimerStartFromISR(TimerHandle_t xTimer, BaseType_t *pxHigherPriorityTaskWoken)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xTimer:TimerHandle_t</i> - The handle of the timer being started/restarted. </li>
<li><i>pxHigherPriorityTaskWoken: Pointer to BaseType_t</i> - The timer service/daemon task spends most of its time in the Blocked state, waiting for messages to arrive on the timer command queue. Calling xTimerStartFromISR() writes a message to the timer command queue, so has the potential to transition the timer service/daemon task out of the Blocked state. If calling xTimerStartFromISR() causes the timer service/daemon task to leave the Blocked state, and the timer service/ daemon task has a priority equal to or greater than the currently executing task (the task that was interrupted), then *pxHigherPriorityTaskWoken will get set to pdTRUE internally within the xTimerStartFromISR() function. If xTimerStartFromISR() sets this value to pdTRUE, then a context switch should be performed before the interrupt exits. </li>
<li><i>Return value:BaseType_t</i> - pdFAIL will be returned if the start command could not be sent to the timer command queue. pdPASS will be returned if the command was successfully sent to the timer command queue. When the command is actually processed will depend on the priority of the timer service/daemon task relative to other tasks in the system, although the timers expiry time is relative to when xTimerStartFromISR() is actually called. The timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY configuration constant. 
</li>
</ul><br />
</li>
<li><a name="xTimerStopFromISR">
<b>xTimerStopFromISR</b></a>
 - A version of xTimerStop() that can be called from an interrupt service routine.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> BaseType_t xTimerStopFromISR(TimerHandle_t xTimer, BaseType_t *pxHigherPriorityTaskWoken)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xTimer:TimerHandle_t</i> - The handle of the timer being stopped. </li>
<li><i>pxHigherPriorityTaskWoken: Pointer to BaseType_t</i> - The timer service/daemon task spends most of its time in the Blocked state, waiting for messages to arrive on the timer command queue. Calling xTimerStopFromISR() writes a message to the timer command queue, so has the potential to transition the timer service/daemon task out of the Blocked state. If calling xTimerStopFromISR() causes the timer service/daemon task to leave the Blocked state, and the timer service/ daemon task has a priority equal to or greater than the currently executing task (the task that was interrupted), then *pxHigherPriorityTaskWoken will get set to pdTRUE internally within the xTimerStopFromISR() function. If xTimerStopFromISR() sets this value to pdTRUE, then a context switch should be performed before the interrupt exits. </li>
<li><i>Return value:BaseType_t</i> - pdFAIL will be returned if the stop command could not be sent to the timer command queue. pdPASS will be returned if the command was successfully sent to the timer command queue. When the command is actually processed will depend on the priority of the timer service/daemon task relative to other tasks in the system. The timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY configuration constant. 
</li>
</ul><br />
</li>
<li><a name="xTimerChangePeriodFromISR">
<b>xTimerChangePeriodFromISR</b></a>
 - A version of xTimerChangePeriod() that can be called from an interrupt service routine. 
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> BaseType_t xTimerChangePeriodFromISR(TimerHandle_t xTimer, TickType_t xNewPeriod, BaseType_t *pxHigherPriorityTaskWoken)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xTimer:TimerHandle_t</i> - The handle of the timer that is having its period changed. </li>
<li><i>xNewPeriod:TickType_t</i> - The new period for xTimer. Timer periods are specified in tick periods, so the constant portTICK_PERIOD_MS can be used to convert a time that has been specified in milliseconds. For example, if the timer must expire after 100 ticks, then xNewPeriod should be set to 100. Alternatively, if the timer must expire after 500ms, then xNewPeriod can be set to ( 500 / portTICK_PERIOD_MS ) provided configTICK_RATE_HZ is less than or equal to 1000. </li>
<li><i>pxHigherPriorityTaskWoken: Pointer to BaseType_t</i> - The timer service/daemon task spends most of its time in the Blocked state, waiting for messages to arrive on the timer command queue. Calling xTimerChangePeriodFromISR() writes a message to the timer command queue, so has the potential to transition the timer service/ daemon task out of the Blocked state. If calling xTimerChangePeriodFromISR() causes the timer service/daemon task to leave the Blocked state, and the timer service/daemon task has a priority equal to or greater than the currently executing task (the task that was interrupted), then *pxHigherPriorityTaskWoken will get set to pdTRUE internally within the xTimerChangePeriodFromISR() function. If xTimerChangePeriodFromISR() sets this value to pdTRUE, then a context switch should be performed before the interrupt exits. </li>
<li><i>Return value:BaseType_t</i> - pdFAIL will be returned if the command to change the timers period could not be sent to the timer command queue. pdPASS will be returned if the command was successfully sent to the timer command queue. When the command is actually processed will depend on the priority of the timer service/daemon task relative to other tasks in the system. The timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY configuration constant. 
</li>
</ul><br />
</li>
<li><a name="xTimerResetFromISR">
<b>xTimerResetFromISR</b></a>
 - A version of xTimerReset() that can be called from an interrupt service routine.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> BaseType_t xTimerResetFromISR(TimerHandle_t xTimer, BaseType_t *pxHigherPriorityTaskWoken)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xTimer:TimerHandle_t</i> - The handle of the timer that is to be started, reset, or restarted. </li>
<li><i>pxHigherPriorityTaskWoken: Pointer to BaseType_t</i> - The timer service/daemon task spends most of its time in the Blocked state, waiting for messages to arrive on the timer command queue. Calling xTimerResetFromISR() writes a message to the timer command queue, so has the potential to transition the timer service/daemon task out of the Blocked state. If calling xTimerResetFromISR() causes the timer service/daemon task to leave the Blocked state, and the timer service/ daemon task has a priority equal to or greater than the currently executing task (the task that was interrupted), then *pxHigherPriorityTaskWoken will get set to pdTRUE internally within the xTimerResetFromISR() function. If xTimerResetFromISR() sets this value to pdTRUE then a context switch should be performed before the interrupt exits. </li>
<li><i>Return value:BaseType_t</i> - pdFAIL will be returned if the reset command could not be sent to the timer command queue. pdPASS will be returned if the command was successfully sent to the timer command queue. When the command is actually processed will depend on the priority of the timer service/daemon task relative to other tasks in the system, although the timers expiry time is relative to when xTimerResetFromISR() is actually called. The timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY configuration constant. 
</li>
</ul><br />
</li>
<li><a name="pvTimerGetTimerID">
<b>pvTimerGetTimerID</b></a>
 -  Returns the ID assigned to the timer.<br /><br />IDs are assigned to timers using the pvTimerID parameter of the call to xTimerCreate() that was used to create the timer.<br /><br />If the same callback function is assigned to multiple timers then the timer ID can be used within the callback function to identify which timer actually expired. 
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void* pvTimerGetTimerID(TimerHandle_t xTimer)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xTimer:TimerHandle_t</i> - The timer being queried. </li>
<li><i>Return value:void*</i> - The ID assigned to the timer being queried. 
</li>
</ul><br />
</li>
<li><a name="xTimerGetTimerDaemonTaskHandle">
<b>xTimerGetTimerDaemonTaskHandle</b></a>
 - INCLUDE_xTimerGetTimerDaemonTaskHandle and configUSE_TIMERS must both be set to 1 in FreeRTOSConfig.h for xTimerGetTimerDaemonTaskHandle() to be available. 
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> TaskHandle_t xTimerGetTimerDaemonTaskHandle(void)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>Return value:TaskHandle_t</i> - Returns the task handle associated with the software timer daemon (or service) task. If configUSE_TIMERS is set to 1 in FreeRTOSConfig.h, then the timer daemon task is created automatically when the RTOS scheduler is started. 
</li>
</ul><br />
</li>
<li><a name="pcTimerGetTimerName">
<b>pcTimerGetTimerName</b></a>
 - no hint
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> char* pcTimerGetTimerName(TimerHandle_t xTimer)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xTimer:TimerHandle_t</i> - The handle of the timer being queried. </li>
<li><i>Return value:char*</i> - A pointer to the timer's name, which is a standard NULL terminated C string. 
</li>
</ul><br />
</li>
<li><a name="xTimerPendFunctionCall">
<b>xTimerPendFunctionCall</b></a>
 -  Used to pend the execution of a function to the RTOS daemon task (the timer service task, hence this function is pre-fixed with 'Timer').<br /><br />Functions that can be deferred to the RTOS daemon task must have the following prototype:<br /><br />void vPendableFunction( void * pvParameter1, uint32_t ulParameter2 );<br /><br />The pvParameter1 and ulParameter2 are provided for use by the application code.<br /><br />INCLUDE_xTimerPendFunctionCall() and configUSE_TIMERS must both be set to 1 for xTimerPendFunctionCall() to be available. 
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> BaseType_t xTimerPendFunctionCall(PendedFunction_t xFunctionToPend, void* pvParameter1, uint32_t ulParameter2, TickType_t xTicksToWait)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xFunctionToPend:byte</i> - The function to execute from the timer service/ daemon task. The function must conform to the PendedFunction_t prototype as shown above. </li>
<li><i>pvParameter1:void*</i> - The value of the callback function's first parameter. The parameter has a void * type to allow it to be used to pass any type. For example, integer types can be cast to a void *, or the void * can be used to point to a structure. </li>
<li><i>ulParameter2:uint32_t</i> - The value of the callback function's second parameter. </li>
<li><i>xTicksToWait:TickType_t</i> -  	Calling this function will result in a message being sent to the timer daemon task on a queue. xTicksToWait is the amount of time the calling task should remain in the Blocked state (so not using any processing time) for space to become available on the timer queue if the queue is found to be full. The length of the queue is set by the value of configTIMER_QUEUE_LENGTH in FreeRTOSConfig.h. </li>
<li><i>Return value:BaseType_t</i> - pdPASS is returned if the message was successfully sent to the RTOS timer daemon task, otherwise pdFALSE is returned. 
</li>
</ul><br />
</li>
<li><a name="xTimerPendFunctionCallFromISR">
<b>xTimerPendFunctionCallFromISR</b></a>
 -  Used from application interrupt service routines to defer the execution of a function to the RTOS daemon task (the timer service task, hence this function is implemented in timers.c and is prefixed with 'Timer').<br /><br />Ideally an interrupt service routine (ISR) is kept as short as possible, but sometimes an ISR either has a lot of processing to do, or needs to perform processing that is not deterministic. In these cases xTimerPendFunctionCallFromISR() can be used to defer processing of a function to the RTOS daemon task.<br /><br />A mechanism is provided that allows the interrupt to return directly to the task that will subsequently execute the pended function. This allows the callback function to execute contiguously in time with the interrupt - just as if the callback had executed in the interrupt itself.<br /><br />Functions that can be deferred to the RTOS daemon task must have the following prototype:<br /><br />void vPendableFunction( void * pvParameter1, uint32_t ulParameter2 );<br /><br />The pvParameter1 and ulParameter2 are provided for use by the application code.<br /><br />INCLUDE_xTimerPendFunctionCall() and configUSE_TIMERS must both be set to 1 for xTimerPendFunctionCallFromISR() to be available. 
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> BaseType_t xTimerPendFunctionCallFromISR(PendedFunction_t xFunctionToPend, void* pvParameter1, uint32_t ulParameter2, BaseType_t *pxHigherPriorityTaskWoken)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xFunctionToPend:byte</i> - The function to execute from the timer service/ daemon task. The function must conform to the PendedFunction_t prototype as shown above. </li>
<li><i>pvParameter1:void*</i> -  	The value of the callback function's first parameter. The parameter has a void * type to allow it to be used to pass any type. For example, integer types can be cast to a void *, or the void * can be used to point to a structure. </li>
<li><i>ulParameter2:uint32_t</i> - The value of the callback function's second parameter. </li>
<li><i>pxHigherPriorityTaskWoken: Pointer to BaseType_t</i> - As mentioned above, calling xTimerPendFunctionCallFromISR() will result in a message being sent to the RTOS timer daemon task. If the priority of the daemon task (which is set using configTIMER_TASK_PRIORITY in FreeRTOSConfig.h) is higher than the priority of the currently running task (the task the interrupt interrupted) then *pxHigherPriorityTaskWoken will be set to pdTRUE within xTimerPendFunctionCallFromISR(), indicating that a context switch should be requested before the interrupt exits. For that reason *pxHigherPriorityTaskWoken must be initialised to pdFALSE. See the example code below. </li>
<li><i>Return value:BaseType_t</i> - pdPASS is returned if the message was successfully sent to the RTOS timer daemon task, otherwise pdFALSE is returned. 
</li>
</ul><br />
</li>
<li><a name="xTaskNotifyGive">
<b>xTaskNotifyGive</b></a>
 -  Each RTOS task has a 32-bit notification value which is initialised to zero when the RTOS task is created. An RTOS task notification is an event sent directly to a task that can unblock the receiving task, and optionally update the receiving task's notification value.<br /><br />xTaskNotifyGive() is a macro intended for use when an RTOS task notification value is being used as a light weight and faster binary or counting semaphore alternative. FreeRTOS semaphores are given using the xSemaphoreGive() API function, xTaskNotifyGive() is the equivalent that instead uses the receiving RTOS task's notification value.<br /><br />When a task notification value is being used as a binary or counting semaphore equivalent then the task being notified should wait for the notification using the ulTaskNotifyTake() API function rather than the xTaskNotifyWait() API function.<br /><br />xTaskNotifyGive() must not be called from an interrupt service routine. Use vTaskNotifyGiveFromISR() instead. 
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> BaseType_t xTaskNotifyGive(TaskHandle_t xTaskToNotify)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xTaskToNotify:TaskHandle_t</i> - The handle of the RTOS task being notified, and having its notification value incremented.<br />RTOS task handles are obtained using the pvCreatedTask parameter of the xTaskCreate() call used to create the task.<br />The handle of the currently executing RTOS task is returned by the xTaskGetCurrentTaskHandle() API function. </li>
<li><i>Return value:BaseType_t</i> - xTaskNotifyGive() is a macro that calls xTaskNotify() with the eAction parameter set to eIncrement resulting in all calls returning pdPASS. 
</li>
</ul><br />
</li>
<li><a name="vTaskNotifyGiveFromISR">
<b>vTaskNotifyGiveFromISR</b></a>
 -  A version of xTaskNotifyGive() that can be called from an interrupt service routine (ISR).<br /><br />Each RTOS task has a 32-bit notification value which is initialised to zero when the RTOS task is created. An RTOS task notification is an event sent directly to a task that can unblock the receiving task, and optionally update the receiving task's notification value.<br /><br />vTaskNotifyGiveFromISR() is a function intended for use when an RTOS task notification value is being used as a light weight and faster binary or counting semaphore alternative. FreeRTOS semaphores are given from an interrupt using the xSemaphoreGiveFromISR() API function, vTaskNotifyGiveFromISR() is the equivalent that instead uses the receiving RTOS task's notification value.<br /><br />When a task notification value is being used as a binary or counting semaphore equivalent then the task being notified should wait for the notification using the ulTaskNotifyTake() API function rather than the xTaskNotifyWait() API function. 
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void vTaskNotifyGiveFromISR(TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xTaskToNotify:TaskHandle_t</i> - The handle of the RTOS task being notified, and having its notification value incremented.<br /><br />RTOS task handles are obtained using the pvCreatedTask parameter of the xTaskCreate() call used to create the task.<br /><br />The handle of the currently executing RTOS task is returned by the xTaskGetCurrentTaskHandle() API function. </li>
<li><i>pxHigherPriorityTaskWoken: Pointer to BaseType_t</i> - *pxHigherPriorityTaskWoken must be initialised to 0.<br /><br />vTaskNotifyGiveFromISR() will set *pxHigherPriorityTaskWoken to pdTRUE if sending the notification caused a task to unblock, and the unblocked task has a priority higher than the currently running task.<br /><br />If vTaskNotifyGiveFromISR() sets this value to pdTRUE then a context switch should be requested before the interrupt is exited. See the example below.<br /><br />pxHigherPriorityTaskWoken is an optional parameter and can be set to NULL. </li>
</ul><br />
</li>
<li><a name="ulTaskNotifyTake">
<b>ulTaskNotifyTake</b></a>
 -  Each RTOS task has a 32-bit notification value which is initialised to zero when the RTOS task is created. An RTOS task notification is an event sent directly to a task that can unblock the receiving task, and optionally update the receiving task's notification value.<br /><br />ulTaskNotifyTake() is intended for use when a task notification is used as a faster and lighter weight binary or counting semaphore alternative. FreeRTOS semaphores are taken using the xSemaphoreTake() API function, ulTaskNotifyTake() is the equivalent that instead uses a task notification.<br /><br />When a task is using its notification value as a binary or counting semaphore other tasks and interrupts should send notifications to it using either the xTaskNotifyGive() macro, or the xTaskNotify() function with the function's eAction parameter set to eIncrement (the two are equivalent).<br /><br />ulTaskNotifyTake() can either clear the task's notification value to zero on exit, in which case the notification value acts like a binary semaphore, or decrement the task's notification value on exit, in which case the notification value acts more like a counting semaphore.<br /><br />An RTOS task can use ulTaskNotifyTake() to [optionally] block to wait for a the task's notification value to be non-zero. The task does not consume any CPU time while it is in the Blocked state.<br /><br />Where as xTaskNotifyWait() will return when a notification is pending, ulTaskNotifyTake() will return when the task's notification value is not zero, decrementing the task's notification value before it returns. 
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> uint32_t ulTaskNotifyTake(BaseType_t xClearCountOnExit, TickType_t xTicksToWait)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xClearCountOnExit:BaseType_t</i> - If an RTOS task notification is received and xClearCountOnExit is set to pdFALSE then the RTOS task's notification value is decremented before ulTaskNotifyTake() exits. This is equivalent to the value of a counting semaphore being decremented by a successful call to xSemaphoreTake().<br /><br />If an RTOS task notification is received and xClearCountOnExit is set to pdTRUE then the RTOS task's notification value is reset to 0 before ulTaskNotifyTake() exits. This is equivalent to the value of a binary semaphore being left at zero (or empty, or 'not available') after a successful call to xSemaphoreTake(). </li>
<li><i>xTicksToWait:TickType_t</i> - The maximum time to wait in the Blocked state for a notification to be received if a notification is not already pending when ulTaskNotifyTake() is called.<br /><br />The RTOS task does not consume any CPU time when it is in the Blocked state.<br /><br />The time is specified in RTOS tick periods. The pdMS_TO_TICKS() macro can be used to convert a time specified in milliseconds into a time specified in ticks. </li>
<li><i>Return value:uint32_t</i> - The value of the task's notification value before it is decremented or cleared (see the description of xClearCountOnExit). 
</li>
</ul><br />
</li>
<li><a name="xTaskNotify">
<b>xTaskNotify</b></a>
 -  [If you are using RTOS task notifications to implement binary or counting semaphore type behaviour then use the simpler xTaskNotifyGive() API function instead of xTaskNotify()]<br /><br />Each RTOS task has a 32-bit notification value which is initialised to zero when the RTOS task is created. xTaskNotify() is used to send an event directly to and potentially unblock an RTOS task, and optionally update the receiving task's notification value in one of the following ways:<br /><br />    - Write a 32-bit number to the notification value<br />    - Add one (increment) the notification value<br />    - Set one or more bits in the notification value<br />    - Leave the notification value unchanged<br /><br />This function must not be called from an interrupt service routine (ISR). Use xTaskNotifyFromISR() instead. 
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> BaseType_t xTaskNotify(TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xTaskToNotify:TaskHandle_t</i> - The handle of the RTOS task being notified. This is the subject task.<br /><br />RTOS task handles are obtained using the pvCreatedTask parameter of the xTaskCreate() call used to create the task.<br /><br />The handle of the currently executing RTOS task is returned by the xTaskGetCurrentTaskHandle() API function. </li>
<li><i>ulValue:uint32_t</i> - Used to update the notification value of the subject task. See the description of the eAction parameter below. </li>
<li><i>eAction:eNotifyAction</i> - An enumerated type that can take one of the values documented in the table below in order to perform the associated action. <br />- eNoAction: 	The subject task receives the event, but its notification value is not updated. In this case ulValue is not used.<br />- eSetBits: 	The notification value of the subject task will be bitwise ORed with ulValue. For example, if ulValue is set to 0x01, then bit 0 will get set within the subject task's notification value. Likewise if ulValue is 0x04 then bit 2 will get set in the subject task's notification value. In this way the RTOS task notification mechanism can be used as a light weight alternative to an event group.<br />- eIncrement: 	The notification value of the subject task will be incremented by one, making the call to xTaskNotify() equivalent to a call to xTaskNotifyGive(). In this case ulValue is not used.<br />- eSetValueWithOverwrite: 	The notification value of the subject task is unconditionally set to ulValue. In this way the RTOS task notification mechanism is being used as a light weight alternative to xQueueOverwrite().<br />- eSetValueWithoutOverwrite: 	If the subject task does not already have a notification pending then its notification value will be set to ulValue. If the subject task already has a notification pending then its notification value is not updated as to do so would overwrite the previous value before it was used. In this case the call to xTaskNotify() fails and pdFALSE is returned. In this way the RTOS task notification mechanism is being used as a light weight alternative to xQueueSend() on a queue of length 1. </li>
<li><i>Return value:BaseType_t</i> - pdPASS is returned in all cases other than when eAction is set to eSetValueWithoutOverwrite and the subject task's notification value cannot be updated because the subject task already had a notification pending. 
</li>
</ul><br />
</li>
<li><a name="xTaskNotifyFromISR">
<b>xTaskNotifyFromISR</b></a>
 -  [If you are using RTOS task notifications to implement binary or counting semaphore type behaviour then use the simpler xTaskNotifyGive() API function instead of xTaskNotify()]<br /><br />A version of xTaskNotify() that can be called from an ISR. <br /><br />Each RTOS task has a 32-bit notification value which is initialised to zero when the RTOS task is created. xTaskNotify() is used to send an event directly to and potentially unblock an RTOS task, and optionally update the receiving task's notification value in one of the following ways:<br /><br />    - Write a 32-bit number to the notification value<br />    - Add one (increment) the notification value<br />    - Set one or more bits in the notification value<br />    - Leave the notification value unchanged<br /><br />This function must not be called from an interrupt service routine (ISR). Use xTaskNotifyFromISR() instead. 
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> BaseType_t xTaskNotifyFromISR(TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, BaseType_t *pxHigherPriorityTaskWoken)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>xTaskToNotify:TaskHandle_t</i> - The handle of the RTOS task being notified. This is the subject task.<br /><br />RTOS task handles are obtained using the pvCreatedTask parameter of the xTaskCreate() call used to create the task.<br /><br />The handle of the currently executing RTOS task is returned by the xTaskGetCurrentTaskHandle() API function. </li>
<li><i>ulValue:uint32_t</i> - Used to update the notification value of the subject task. See the description of the eAction parameter below. </li>
<li><i>eAction:eNotifyAction</i> - An enumerated type that can take one of the values documented in the table below in order to perform the associated action. <br />- eNoAction: 	The subject task receives the event, but its notification value is not updated. In this case ulValue is not used.<br />- eSetBits: 	The notification value of the subject task will be bitwise ORed with ulValue. For example, if ulValue is set to 0x01, then bit 0 will get set within the subject task's notification value. Likewise if ulValue is 0x04 then bit 2 will get set in the subject task's notification value. In this way the RTOS task notification mechanism can be used as a light weight alternative to an event group.<br />- eIncrement: 	The notification value of the subject task will be incremented by one, making the call to xTaskNotify() equivalent to a call to xTaskNotifyGive(). In this case ulValue is not used.<br />- eSetValueWithOverwrite: 	The notification value of the subject task is unconditionally set to ulValue. In this way the RTOS task notification mechanism is being used as a light weight alternative to xQueueOverwrite().<br />- eSetValueWithoutOverwrite: 	If the subject task does not already have a notification pending then its notification value will be set to ulValue. If the subject task already has a notification pending then its notification value is not updated as to do so would overwrite the previous value before it was used. In this case the call to xTaskNotify() fails and pdFALSE is returned. In this way the RTOS task notification mechanism is being used as a light weight alternative to xQueueSend() on a queue of length 1. </li>
<li><i>pxHigherPriorityTaskWoken: Pointer to BaseType_t</i> - *pxHigherPriorityTaskWoken must be initialised to 0.<br /><br />xTaskNotifyFromISR() will set *pxHigherPriorityTaskWoken to pdTRUE if sending the notification caused a task to unblock, and the unblocked task has a priority higher than the currently running task.<br /><br />If xTaskNotifyFromISR() sets this value to pdTRUE then a context switch should be requested before the interrupt is exited. See the example below.<br /><br />pxHigherPriorityTaskWoken is an optional parameter and can be set to NULL. </li>
<li><i>Return value:BaseType_t</i> - pdPASS is returned in all cases other than when eAction is set to eSetValueWithoutOverwrite and the subject task's notification value cannot be updated because the subject task already had a notification pending. 
</li>
</ul><br />
</li>
<li><a name="xTaskNotifyWait">
<b>xTaskNotifyWait</b></a>
 -  [If you are using RTOS task notifications to implement binary or counting semaphore type behaviour then use the simpler ulTaskNotifyTake() API function instead of xTaskNotifyWait()]<br /><br />Each RTOS task has a 32-bit notification value which is initialised to zero when the RTOS task is created. An RTOS task notification is an event sent directly to a task that can unblock the receiving task, and optionally update the receiving task's notification value in a number of different ways. For example, a notification may overwrite the receiving task's notification value, or just set one or more bits in the receiving task's notification value. See the RTOS task notifications use case documentation for examples.<br /><br />xTaskNotifyWait() waits, with an optional timeout, for the calling task to receive a notification.<br /><br />If the receiving RTOS task was already Blocked waiting for a notification when one arrives the receiving RTOS task will be removed from the Blocked state and the notification cleared. 
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> BaseType_t xTaskNotifyWait(uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>ulBitsToClearOnEntry:uint32_t</i> - Any bits set in ulBitsToClearOnEntry will be cleared in the calling RTOS task's notification value on entry to the xTaskNotifyWait() function (before the task waits for a new notification) provided a notification is not already pending when xTaskNotifyWait() is called.<br /><br />For example, if ulBitsToClearOnEntry is 0x01, then bit 0 of the task's notification value will be cleared on entry to the function.<br /><br />Setting ulBitsToClearOnEntry to 0xffffffff (ULONG_MAX) will clear all the bits in the task's notification value, effectively clearing the value to 0. </li>
<li><i>ulBitsToClearOnExit:uint32_t</i> - Any bits set in ulBitsToClearOnExit will be cleared in the calling RTOS task's notification value before xTaskNotifyWait() function exits if a notification was received.<br /><br />The bits are cleared after the RTOS task's notification value has been saved in *pulNotificationValue (see the description of pulNotificationValue below).<br /><br />For example, if ulBitsToClearOnExit is 0x03, then bit 0 and bit 1 of the task's notification value will be cleared before the function exits.<br /><br />Setting ulBitsToClearOnExit to 0xffffffff (ULONG_MAX) will clear all the bits in the task's notification value, effectively clearing the value to 0. </li>
<li><i>pulNotificationValue: Pointer to uint32_t</i> - Used to pass out the RTOS task's notification value. The value copied to *pulNotificationValue is the RTOS task's notification value as it was before any bits were cleared due to the ulBitsToClearOnExit setting.<br /><br />If the notification value is not required then set pulNotificationValue to NULL. </li>
<li><i>xTicksToWait:TickType_t</i> - The maximum time to wait in the Blocked state for a notification to be received if a notification is not already pending when xTaskNotifyWait() is called.<br /><br />The RTOS task does not consume any CPU time when it is in the Blocked state.<br /><br />The time is specified in RTOS tick periods. The pdMS_TO_TICKS() macro can be used to convert a time specified in milliseconds into a time specified in ticks. </li>
<li><i>Return value:BaseType_t</i> - pdTRUE if a notification was received, or a notification was already pending when xTaskNotifyWait() was called.<br /><br />pdFALSE if the call to xTaskNotifyWait() timed out before a notification was received. 
</li>
</ul><br />
</li>
<li><a name="ParseCommand">
<b>ParseCommand</b></a>
 - Shell Command Line Parser
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> byte ParseCommand(const unsigned char *cmd, bool *handled, const %@Shell@'ModuleName'%.StdIOType *io)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
<li><i>cmd: Pointer to byte</i> - Pointer to command string</li>
<li><i>handled: Pointer to bool</i> - Pointer to variable which tells if the command has been handled or not</li>
<li><i>io: Pointer to byte</i> - Pointer to I/O structure</li>
<li><i>Return value:byte</i> - Error code
</li>
</ul><br />
</li>
<li><a name="Init">
<b>Init</b></a>
 - Low level initialization routine called from startup code. This method ensures that the tick timer is  not enabled.
<ul>
<!---VER_SPEC #ANSIC#  DON'T CHANGE THIS LINE-->
<br /><i>ANSIC prototype:</i> void Init(void)<br />
<!---VER_SPEC_END  DON'T CHANGE THIS LINE-->
</ul><br />
</li>

           </ul>
<!---USERBEG DON'T CHANGE THIS LINE-->

<!---USEREND DON'T CHANGE THIS LINE-->
<p>
<br />
Note: Some methods can be implemented as macros.
</p>
          </div>
          <p class="footer">
            PROCESSOR EXPERT is trademark of Freescale Semiconductor, Inc.
            <br />
            
          </p>
    </td>
  </tr>

</table>

</body>
</html>
