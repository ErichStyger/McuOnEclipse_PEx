<?xml version="1.0" encoding="UTF-8"?>
<Bean>
  <Header>
    <Name>FreeRTOS</Name>
    <Description>FreeRTOS McuOnEclipse Port with FreeRTOS+Trace</Description>
    <Author>Erich Styger</Author>
    <Version>01.585</Version>
    <Icon>FreeRTOS</Icon>
    <TypesFiles>PE,FreeRTOS\FreeRTOS</TypesFiles>
    <FileVersion>6</FileVersion>
  </Header>
  <Options>
    <Category>Operating Systems</Category>
    <OperatingSystemId>FreeRTOS</OperatingSystemId>
    <BW_HelpType>BasicPlusUsageAppNote</BW_HelpType>
    <BW_HelpFiles>,Properties,Methods,Events,"Typical Usage","Application Notes"</BW_HelpFiles>
    <BW_AutoSaveHelp>yes</BW_AutoSaveHelp>
    <BW_AutoSaveDriver>yes</BW_AutoSaveDriver>
    <BW_DetailedHelp>yes</BW_DetailedHelp>
    <BW_NeedTps>yes</BW_NeedTps>
    <BW_NeedUst>23</BW_NeedUst>
    <BW_NeedCns>0</BW_NeedCns>
    <BeanStatus>PROPOSAL</BeanStatus>
    <Copyright> * FreeRTOS (c) Copyright 2003-2023 Richard Barry/Amazon, http: www.FreeRTOS.org\n * See separate FreeRTOS licensing terms.\n *\n * FreeRTOS Processor Expert Component: (c) Copyright Erich Styger, 2013-2023\n * Web:         https://mcuoneclipse.com\n * SourceForge: https://sourceforge.net/projects/mcuoneclipse\n * Git:         https://github.com/ErichStyger/McuOnEclipse_PEx\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *\n * - Redistributions of source code must retain the above copyright notice, this list\n *   of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright notice, this\n *   list of conditions and the following disclaimer in the documentation and/or\n *   other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</Copyright>
    <Shortcut>FRTOS</Shortcut>
    <DemoDriver>no</DemoDriver>
    <BeanLevel>High</BeanLevel>
    <OneBeanInstance>There can be only one FreeRTOS active in the project, as the RTOS files need to have different names.</OneBeanInstance>
  </Options>
  <PropertyList>
    <Property>
      <TCompNameItem>
        <Name>Component name</Name>
        <Symbol>DeviceName</Symbol>
        <Hint>Name of the component.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>true</EditLine>
        <DefaultValue/>
      </TCompNameItem>
    </Property>
    <Property>
      <TStrgItem>
        <Name>RTOS Version</Name>
        <Symbol>FreeRTOSVersion</Symbol>
        <Hint>Identifies the RTOS version</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>true</EditLine>
        <DefaultValue>V10.5.1</DefaultValue>
        <StrDefine>nothing</StrDefine>
        <MinLength>0</MinLength>
        <MaxLength>-1</MaxLength>
      </TStrgItem>
    </Property>
    <Property>
      <TInhrLinkItem>
        <Name>SDK</Name>
        <Symbol>KinetisSDK</Symbol>
        <TypeSpec>FreeRTOS\KinetisSDK</TypeSpec>
        <Hint>Link to the SDK used.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <DefaultValue/>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <SortStyle/>
      </TInhrLinkItem>
    </Property>
    <Property>
      <TBoolGrupItem>
        <Name>Kinetis SDK</Name>
        <Symbol>KinetisSDKGroup</Symbol>
        <TypeSpec>typeEnaDis</TypeSpec>
        <Hint>Group used to configure the component if used with the Kinetis SDK.</Hint>
        <ItemLevel>EXPERT</ItemLevel>
        <BoldName>true</BoldName>
        <EditLine>false</EditLine>
        <Description>Disabled</Description>
        <Expanded>No</Expanded>
        <DefaultValue>false</DefaultValue>
        <DefineSymbol>YES_NO</DefineSymbol>
        <IfDisabled>setNOTHING</IfDisabled>
        <Children>
          <GrupItem>
            <TBoolItem>
              <Name>Generate PEX_RTOS Macros</Name>
              <Symbol>GenerateRTOSPExMacros</Symbol>
              <TypeSpec>typeYesNo</TypeSpec>
              <Hint>If enabled, the component creates PEX_RTOS_INIT() and PEX_RTOS_START() macros in the component header file. As the Kinetis SDK does generate them, the default setting is 'no', otherwise macros will be defined twice.</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>false</EditLine>
              <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
              <DefaultIndex>0</DefaultIndex>
              <TextValueIndex>false</TextValueIndex>
              <RuntimeProperty>false</RuntimeProperty>
              <CanDelete>false</CanDelete>
              <IconPopup>false</IconPopup>
              <DefaultValue>true</DefaultValue>
              <Popup>false</Popup>
            </TBoolItem>
          </GrupItem>
          <GrupItem>
            <TBoolItem>
              <Name>Generate OSA Functions</Name>
              <Symbol>GenerateOSAFunctions</Symbol>
              <TypeSpec>typeYesNo</TypeSpec>
              <Hint>If enabled, the component creates OSA_Init() and OSA_Start() functions which are needed for the OS Adaption layer of the Kinetis SDK.</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>false</EditLine>
              <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
              <DefaultIndex>0</DefaultIndex>
              <TextValueIndex>false</TextValueIndex>
              <RuntimeProperty>false</RuntimeProperty>
              <CanDelete>false</CanDelete>
              <IconPopup>false</IconPopup>
              <DefaultValue>true</DefaultValue>
              <Popup>false</Popup>
            </TBoolItem>
          </GrupItem>
        </Children>
      </TBoolGrupItem>
    </Property>
    <Property>
      <TGrupItem>
        <Name>Custom Port</Name>
        <Symbol>CustomPortGroup</Symbol>
        <Hint>Allows custom settings for FreeRTOS port. Only necessary to generate RTOS source code and then use it without Processor Expert project.</Hint>
        <ItemLevel>EXPERT</ItemLevel>
        <BoldName>true</BoldName>
        <EditLine>false</EditLine>
        <Description>Custom port settings</Description>
        <Expanded>Yes</Expanded>
        <Children>
          <GrupItem>
            <TEnumItem>
              <Name>Compiler</Name>
              <Symbol>configCOMPILER</Symbol>
              <TypeSpec>type_configCOMPILER</TypeSpec>
              <Hint>Compiler to be used for code generation</Hint>
              <ItemLevel>EXPERT</ItemLevel>
              <EditLine>true</EditLine>
              <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
              <DefaultIndex>0</DefaultIndex>
              <TextValueIndex>true</TextValueIndex>
              <RuntimeProperty>false</RuntimeProperty>
              <CanDelete>false</CanDelete>
              <IconPopup>false</IconPopup>
            </TEnumItem>
          </GrupItem>
          <GrupItem>
            <TBoolGrupItem>
              <Name>Source Folders</Name>
              <Symbol>StaticSourcesEnabled</Symbol>
              <TypeSpec>typeEnaDis</TypeSpec>
              <Hint>Source Code Generation Option for the RTOS. With this, the source file generation can be configured so they can be easily used outside of Processor Expert.</Hint>
              <ItemLevel>EXPERT</ItemLevel>
              <BoldName>true</BoldName>
              <EditLine>false</EditLine>
              <Description>Disabled</Description>
              <Expanded>No</Expanded>
              <DefaultValue>false</DefaultValue>
              <DefineSymbol>YES_NO</DefineSymbol>
              <IfDisabled>setNOTHING</IfDisabled>
              <Children>
                <GrupItem>
                  <TStrgItem>
                    <Name>Source Folder</Name>
                    <Symbol>RTOSSrcFolderName</Symbol>
                    <Hint>RTOS source files are generated into this sub folder name. The name can be empty.</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <EditLine>true</EditLine>
                    <DefaultValue>FreeRTOS/Source</DefaultValue>
                    <StrDefine>nothing</StrDefine>
                    <MinLength>0</MinLength>
                    <MaxLength>-1</MaxLength>
                  </TStrgItem>
                </GrupItem>
                <GrupItem>
                  <TStrgItem>
                    <Name>Header Folder</Name>
                    <Symbol>RTOSHeaderFolderName</Symbol>
                    <Hint>RTOS header files are generated into this sub folder name. The name can be empty.</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <EditLine>true</EditLine>
                    <DefaultValue>FreeRTOS/Source/include</DefaultValue>
                    <StrDefine>nothing</StrDefine>
                    <MinLength>0</MinLength>
                    <MaxLength>-1</MaxLength>
                  </TStrgItem>
                </GrupItem>
                <GrupItem>
                  <TStrgItem>
                    <Name>Port Folder</Name>
                    <Symbol>RTOSPortFolderName</Symbol>
                    <Hint>RTOS port depending sources files are generated into this sub folder name. The name can be empty.</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <EditLine>true</EditLine>
                    <DefaultValue>FreeRTOS/Source/portable/GCC/ARM_CM4F</DefaultValue>
                    <StrDefine>nothing</StrDefine>
                    <MinLength>0</MinLength>
                    <MaxLength>-1</MaxLength>
                  </TStrgItem>
                </GrupItem>
                <GrupItem>
                  <TStrgItem>
                    <Name>MemMang Folder</Name>
                    <Symbol>RTOSMemMangFolderName</Symbol>
                    <Hint>RTOS port depending sources files are generated into this sub folder name. The name can be empty.</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <EditLine>true</EditLine>
                    <DefaultValue>FreeRTOS/Source/portable/MemMang</DefaultValue>
                    <StrDefine>nothing</StrDefine>
                    <MinLength>0</MinLength>
                    <MaxLength>-1</MaxLength>
                  </TStrgItem>
                </GrupItem>
                <GrupItem>
                  <TStrgItem>
                    <Name>Common Folder</Name>
                    <Symbol>RTOSCommonFolderName</Symbol>
                    <Hint>This defines the RTOS common folder name</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <EditLine>true</EditLine>
                    <DefaultValue>FreeRTOS/Source/portable/Common</DefaultValue>
                    <StrDefine>nothing</StrDefine>
                    <MinLength>0</MinLength>
                    <MaxLength>-1</MaxLength>
                  </TStrgItem>
                </GrupItem>
                <GrupItem>
                  <TStrgItem>
                    <Name>Config Folder</Name>
                    <Symbol>RTOSConfigFolderName</Symbol>
                    <Hint>The RTOS FreeRTOSConfig.h wilf will be generated into this sub folder name. The name can be empty.</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <EditLine>true</EditLine>
                    <DefaultValue>FreeRTOS/config/gcc</DefaultValue>
                    <StrDefine>nothing</StrDefine>
                    <MinLength>0</MinLength>
                    <MaxLength>-1</MaxLength>
                  </TStrgItem>
                </GrupItem>
                <GrupItem>
                  <TBoolGrupItem>
                    <Name>Manual Clock Values</Name>
                    <Symbol>UseManualClockValues</Symbol>
                    <TypeSpec>typeEnaDis</TypeSpec>
                    <Hint>If enabled, it is using predefined clock values instead of the values from the Processor Expert Cpu.h</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <BoldName>true</BoldName>
                    <EditLine>false</EditLine>
                    <Description>Disabled</Description>
                    <Expanded>No</Expanded>
                    <DefaultValue>false</DefaultValue>
                    <DefineSymbol>YES_NO</DefineSymbol>
                    <IfDisabled>setNOTHING</IfDisabled>
                    <Children>
                      <GrupItem>
                        <TStrgItem>
                          <Name>configCPU_CLOCK_HZ</Name>
                          <Symbol>configCPU_CLOCK_HZ</Symbol>
                          <Hint>Clock speed of CPU, default is CPU_CORE_CLK_HZ with Processor Expert</Hint>
                          <ItemLevel>BASIC</ItemLevel>
                          <EditLine>true</EditLine>
                          <DefaultValue>CPU_CORE_CLK_HZ</DefaultValue>
                          <StrDefine>nothing</StrDefine>
                          <MinLength>0</MinLength>
                          <MaxLength>-1</MaxLength>
                        </TStrgItem>
                      </GrupItem>
                      <GrupItem>
                        <TStrgItem>
                          <Name>configBUS_CLOCK_HZ</Name>
                          <Symbol>configBUS_CLOCK_HZ</Symbol>
                          <Hint>Bus clock speed, default is CPU_BUS_CLK_HZ with Processor Expert</Hint>
                          <ItemLevel>BASIC</ItemLevel>
                          <EditLine>true</EditLine>
                          <DefaultValue>CPU_BUS_CLK_HZ</DefaultValue>
                          <StrDefine>nothing</StrDefine>
                          <MinLength>0</MinLength>
                          <MaxLength>-1</MaxLength>
                        </TStrgItem>
                      </GrupItem>
                    </Children>
                  </TBoolGrupItem>
                </GrupItem>
              </Children>
            </TBoolGrupItem>
          </GrupItem>
          <GrupItem>
            <TBoolGrupItem>
              <Name>Custom portBASE_TYPE</Name>
              <Symbol>Custom_portBASE_TYPE</Symbol>
              <TypeSpec>typeEnaDis</TypeSpec>
              <Hint>portBASE_TYPE\n
This is defined to be the most efficient, natural, type for the architecture. For example, on a 32-bit architecture portBASE_TYPE will be defined to be a 32-bit type. On a 16-bit architecture portBASE_TYPE will be defined to be a 16-bit type. If portBASE_TYPE is define to char then particular care must be taken to ensure signed chars are used for function return values that can be negative to indicate an error. </Hint>
              <ItemLevel>BASIC</ItemLevel>
              <BoldName>true</BoldName>
              <EditLine>false</EditLine>
              <Description>Disabled</Description>
              <Expanded>No</Expanded>
              <DefaultValue>false</DefaultValue>
              <DefineSymbol>YES_NO</DefineSymbol>
              <IfDisabled>setNOTHING</IfDisabled>
              <Children>
                <GrupItem>
                  <TEnumItem>
                    <Name>portBASE_TYPE</Name>
                    <Symbol>portBASE_TYPE</Symbol>
                    <TypeSpec>typePortBASE_TYPE</TypeSpec>
                    <Hint>Custom portBASE_TYPE</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <EditLine>true</EditLine>
                    <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
                    <DefaultIndex>-1</DefaultIndex>
                    <TextValueIndex>true</TextValueIndex>
                    <RuntimeProperty>false</RuntimeProperty>
                    <CanDelete>false</CanDelete>
                    <IconPopup>false</IconPopup>
                  </TEnumItem>
                </GrupItem>
              </Children>
            </TBoolGrupItem>
          </GrupItem>
        </Children>
      </TGrupItem>
    </Property>
    <Property>
      <TBoolItem>
        <Name>Classic CodeWarrior</Name>
        <Symbol>IsClassicCW</Symbol>
        <TypeSpec>typeYesNo</TypeSpec>
        <Hint>If you are using this component in classic (non-eclipse based) CodeWarrior, then this setting has to be set to 'yes'. If you want to know why: The reason is that classic CodeWarrior does not come with the common_RTOSAdaptor.prg file. As such a test has to be present  in FreeRTOS.ts2.</Hint>
        <ItemLevel>EXPERT</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>1</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>false</DefaultValue>
        <Popup>false</Popup>
      </TBoolItem>
    </Property>
    <Property>
      <TBoolItem>
        <Name>Disabled Interrupts in Startup</Name>
        <Symbol>DisabledInterruptsInStartup</Symbol>
        <TypeSpec>typeYesNo</TypeSpec>
        <Hint>If set to 'yes', then interrupts will be disabled in PE_low_level_init() using the PEX_RTOS_INIT() macro.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
      </TBoolItem>
    </Property>
    <Property>
      <TBoolItem>
        <Name>configASSERT</Name>
        <Symbol>configASSERTdefined</Symbol>
        <TypeSpec>typeYesNo</TypeSpec>
        <Hint>If set to 'yes', FreeRTOSConfig.h will have the configASSERT() macro defined. lt is used in different places in the Kernel to verify proper operation. For better code density/speed you might set this option to 'no'.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
      </TBoolItem>
    </Property>
    <Property>
      <TBoolItem>
        <Name>Application Task Tags</Name>
        <Symbol>UseApplicationTaskTags</Symbol>
        <TypeSpec>typeYesNo</TypeSpec>
        <Hint>This configures configUSE_APPLICATION_TASK_TAG. If enabled, the methodsxTaskGetApplicationTaskTag(), vTaskSetApplicationTaskTag() and xTaskCallApplicationTaskHook() are enabled.</Hint>
        <ItemLevel>EXPERT</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>1</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>false</DefaultValue>
        <Popup>false</Popup>
      </TBoolItem>
    </Property>
    <Property>
      <TIntgItem>
        <Name>Thread Local Storage Pointers</Name>
        <Symbol>NumThreadLocalStoragePointers</Symbol>
        <Hint>Number of thread local storage pointers, zero to disable functionality. Defines configNUM_THREAD_LOCAL_STORAGE_POINTERS</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>true</EditLine>
        <DefaultValue>0</DefaultValue>
        <MinValue>0</MinValue>
        <MaxValue>-1</MaxValue>
        <Bases>DEC</Bases>
        <DefaultBase>DEC</DefaultBase>
        <ExtraHintDisabled>false</ExtraHintDisabled>
        <ChangeValueIntoRange>false</ChangeValueIntoRange>
        <RuntimeProperty>false</RuntimeProperty>
      </TIntgItem>
    </Property>
    <Property>
      <TBoolItem>
        <Name>Use Trace Facility</Name>
        <Symbol>UseTraceFacility</Symbol>
        <TypeSpec>typeYesNo</TypeSpec>
        <Hint>Configures configUSE_TRACE_FACILITY. Set to 1 if you wish the trace visualisation functionality to be available, or 0 if the trace functionality is not going to be used. If you use the trace functionality a trace buffer must also be provided. If using Trace Hooks, this property is automatically enabled..</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>1</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>false</DefaultValue>
        <Popup>false</Popup>
      </TBoolItem>
    </Property>
    <Property>
      <TGrupItem>
        <Name>Debug Helpers</Name>
        <Symbol>DebugHelpersGrop</Symbol>
        <Hint>Several helpers to make debugging easier. For smaller footprint, turn them off.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <BoldName>true</BoldName>
        <EditLine>false</EditLine>
        <Description/>
        <Expanded>Yes</Expanded>
        <Children>
          <GrupItem>
            <TBoolItem>
              <Name>Enable GDB Debug Helper</Name>
              <Symbol>EnableGDBDebugHelper</Symbol>
              <TypeSpec>typeYesNo</TypeSpec>
              <Hint>If enabled, a debug helper for GDB is enabled to do thread stack debugging with a special vPortPendSVHandler(). This setting configures the configGDB_HELPER macro. </Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>false</EditLine>
              <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
              <DefaultIndex>1</DefaultIndex>
              <TextValueIndex>false</TextValueIndex>
              <RuntimeProperty>false</RuntimeProperty>
              <CanDelete>false</CanDelete>
              <IconPopup>false</IconPopup>
              <DefaultValue>false</DefaultValue>
              <Popup>false</Popup>
            </TBoolItem>
          </GrupItem>
          <GrupItem>
            <TBoolItem>
              <Name>Backward Compatibility</Name>
              <Symbol>enabledBackwardCompatibility</Symbol>
              <TypeSpec>typeYesNo</TypeSpec>
              <Hint>Configures configENABLE_BACKWARD_COMPATIBILITY. If turned on, older Kernel names are used. The older names might produce issues with the debug kernel awareness, so it is recommended to have this setting set to 'no'</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>false</EditLine>
              <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
              <DefaultIndex>1</DefaultIndex>
              <TextValueIndex>false</TextValueIndex>
              <RuntimeProperty>false</RuntimeProperty>
              <CanDelete>false</CanDelete>
              <IconPopup>false</IconPopup>
              <DefaultValue>false</DefaultValue>
              <Popup>false</Popup>
            </TBoolItem>
          </GrupItem>
          <GrupItem>
            <TBoolItem>
              <Name>LinkTimeOptimizer Helper</Name>
              <Symbol>EnableLTODebugHelper</Symbol>
              <TypeSpec>typeYesNo</TypeSpec>
              <Hint>This setting configures the configLTO_HELPER macro. With -LTO (GNU Link Time Optimizer), certain symbols might be optimized which affect kernel aware debugging. This setting disables optimization so debugging is still possible.</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>false</EditLine>
              <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
              <DefaultIndex>0</DefaultIndex>
              <TextValueIndex>false</TextValueIndex>
              <RuntimeProperty>false</RuntimeProperty>
              <CanDelete>false</CanDelete>
              <IconPopup>false</IconPopup>
              <DefaultValue>true</DefaultValue>
              <Popup>false</Popup>
            </TBoolItem>
          </GrupItem>
          <GrupItem>
            <TBoolItem>
              <Name>uxTopUsedPriority</Name>
              <Symbol>uxTopUsedPriority</Symbol>
              <TypeSpec>typeYesNo</TypeSpec>
              <Hint>Configures configUSE_TOP_USED_PRIORITY. OpenOCD and SEGGER Thread Aware debugging needs the variable uxTopUsedPriority present.</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>false</EditLine>
              <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
              <DefaultIndex>0</DefaultIndex>
              <TextValueIndex>false</TextValueIndex>
              <RuntimeProperty>false</RuntimeProperty>
              <CanDelete>false</CanDelete>
              <IconPopup>false</IconPopup>
              <DefaultValue>true</DefaultValue>
              <Popup>false</Popup>
            </TBoolItem>
          </GrupItem>
          <GrupItem>
            <TBoolItem>
              <Name>Heap Indication Constant</Name>
              <Symbol>freeRTOSMemorySchemeConstant</Symbol>
              <TypeSpec>typeYesNo</TypeSpec>
              <Hint>Configures configHEAP_SCHEME_IDENTIFICATION. If enabled, a constant named 'freeRTOSMemoryScheme' is added to indicate the heap scheme used. This variable can be used by the NXP FreeRTOS Kernel Awareness plugin to identify the heap scheme used.</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>false</EditLine>
              <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
              <DefaultIndex>0</DefaultIndex>
              <TextValueIndex>false</TextValueIndex>
              <RuntimeProperty>false</RuntimeProperty>
              <CanDelete>false</CanDelete>
              <IconPopup>false</IconPopup>
              <DefaultValue>true</DefaultValue>
              <Popup>false</Popup>
            </TBoolItem>
          </GrupItem>
          <GrupItem>
            <TBoolItem>
              <Name>Task C Additions</Name>
              <Symbol>TaskCAdditions</Symbol>
              <TypeSpec>typeYesNo</TypeSpec>
              <Hint>Configures configINCLUDE_FREERTOS_TASK_C_ADDITIONS_H which is used to help the debugger to find all the symbols and RTOS information, configUSE_TRACE_FACILITY should be enabled too. If enabled, it includes the file  freertos_tasks_c_additions.h at the end of task.c. That extra information is for example used by the debugger to locate RTOS releated information. Make sure 'use trace facility' (configUSE_TRACE_FACILITY) is enabled too.</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>false</EditLine>
              <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
              <DefaultIndex>0</DefaultIndex>
              <TextValueIndex>false</TextValueIndex>
              <RuntimeProperty>false</RuntimeProperty>
              <CanDelete>false</CanDelete>
              <IconPopup>false</IconPopup>
              <DefaultValue>true</DefaultValue>
              <Popup>false</Popup>
            </TBoolItem>
          </GrupItem>
          <GrupItem>
            <TBoolItem>
              <Name>Record Stack High Address</Name>
              <Symbol>RecordStackHighAddress</Symbol>
              <TypeSpec>typeYesNo</TypeSpec>
              <Hint>This configures configRECORD_STACK_HIGH_ADDRESS. If enabled, gives the FreeRTOS Kernel Awareness access to the stack high address. Disable for better code efficiency and less RAM usage.</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>false</EditLine>
              <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
              <DefaultIndex>0</DefaultIndex>
              <TextValueIndex>false</TextValueIndex>
              <RuntimeProperty>false</RuntimeProperty>
              <CanDelete>false</CanDelete>
              <IconPopup>false</IconPopup>
              <DefaultValue>true</DefaultValue>
              <Popup>false</Popup>
            </TBoolItem>
          </GrupItem>
        </Children>
      </TGrupItem>
    </Property>
    <Property>
      <TBoolGrupItem>
        <Name>Segger System Viewer Trace</Name>
        <Symbol>SeggerSystemViewerGroup</Symbol>
        <TypeSpec>typeEnaDis</TypeSpec>
        <Hint>Enables Segger System Viewer Trace. Percepio Trace has to be disabled, and 'Use Trace Facility' has to be enabled.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <BoldName>true</BoldName>
        <EditLine>false</EditLine>
        <Description>Disabled</Description>
        <Expanded>No</Expanded>
        <DefaultValue>false</DefaultValue>
        <DefineSymbol>YES_NO</DefineSymbol>
        <IfDisabled>setNOTHING</IfDisabled>
        <Children>
          <GrupItem>
            <TInhrLinkItem>
              <Name>Segger System Viewer</Name>
              <Symbol>SeggerSystemViewer</Symbol>
              <TypeSpec>FreeRTOS\SeggerSystemView</TypeSpec>
              <Hint>Link to Segger System Viewer component</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>false</EditLine>
              <DefaultValue/>
              <CanDelete>false</CanDelete>
              <IconPopup>false</IconPopup>
              <SortStyle/>
            </TInhrLinkItem>
          </GrupItem>
        </Children>
      </TBoolGrupItem>
    </Property>
    <Property>
      <TBoolGrupItem>
        <Name>Percepio Trace</Name>
        <Symbol>UseTraceHooksGroup</Symbol>
        <TypeSpec>typeEnaDis</TypeSpec>
        <Hint>If enabled, you can condfigure trace hooks to collect information about the RTOS behaviour. Segger System Viewer has to be disabled.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <BoldName>true</BoldName>
        <EditLine>false</EditLine>
        <Description>Disabled</Description>
        <Expanded>No</Expanded>
        <DefaultValue>false</DefaultValue>
        <DefineSymbol>YES_NO</DefineSymbol>
        <IfDisabled>setNOTHING</IfDisabled>
        <Children>
          <GrupItem>
            <TInhrLinkItem>
              <Name>Percepio FreeRTOS+Trace</Name>
              <Symbol>FRTrace</Symbol>
              <TypeSpec>FreeRTOS\FRTrace</TypeSpec>
              <Hint>Link to Percepio Trace component. Only one trace method (Segger or Percepio) can be used.</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>false</EditLine>
              <DefaultValue/>
              <CanDelete>false</CanDelete>
              <IconPopup>false</IconPopup>
              <SortStyle/>
            </TInhrLinkItem>
          </GrupItem>
        </Children>
      </TBoolGrupItem>
    </Property>
    <Property>
      <TStrgItem>
        <Name>Custom FreeRTOSConfig.h</Name>
        <Symbol>CustomFreeRTOSConfig</Symbol>
        <Hint>The content is added to the end of FreeRTOSConfig.h. Useful to include your own special header file or similar.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>true</EditLine>
        <DefaultValue>// #include "CustomFreeRTOSSettings.h</DefaultValue>
        <StrDefine>nothing</StrDefine>
        <MinLength>0</MinLength>
        <MaxLength>-1</MaxLength>
      </TStrgItem>
    </Property>
    <Property>
      <TBoolGrupItem>
        <Name>Generate Runtime Statistics</Name>
        <Symbol>CollectRuntimeStatisticsGroup</Symbol>
        <TypeSpec>typeEnaDis</TypeSpec>
        <Hint>If enabled, runtime statistics are collected. This setting configures configGENERATE_RUN_TIME_STATS. A timer with at least  least 10 times faster than the tick counter needs to be provided)</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <BoldName>true</BoldName>
        <EditLine>false</EditLine>
        <Description>Disabled</Description>
        <Expanded>No</Expanded>
        <DefaultValue>false</DefaultValue>
        <DefineSymbol>YES_NO</DefineSymbol>
        <IfDisabled>setNOTHING</IfDisabled>
        <Children>
          <GrupItem>
            <TBoolItem>
              <Name>Use Tick Counter</Name>
              <Symbol>RuntimeCounterUseTickCounter</Symbol>
              <TypeSpec>typeYesNo</TypeSpec>
              <Hint>Configures configGENERATE_RUN_TIME_STATS_USE_TICKS. If enabled, it uses the Tick counter for the performance measurement. This is less accurate than using a timer with 10x frequency of the tick counter, but does not need an additional hardware timer.</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>false</EditLine>
              <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
              <DefaultIndex>0</DefaultIndex>
              <TextValueIndex>false</TextValueIndex>
              <RuntimeProperty>false</RuntimeProperty>
              <CanDelete>false</CanDelete>
              <IconPopup>false</IconPopup>
              <DefaultValue>true</DefaultValue>
              <Popup>false</Popup>
            </TBoolItem>
          </GrupItem>
          <GrupItem>
            <TBoolGrupItem>
              <Name>LDD</Name>
              <Symbol>LDDRuntimeCounterGroup</Symbol>
              <TypeSpec>typeEnaDis</TypeSpec>
              <Hint>Logical Device Driver</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <BoldName>true</BoldName>
              <EditLine>false</EditLine>
              <Description>Disabled</Description>
              <Expanded>No</Expanded>
              <DefaultValue>false</DefaultValue>
              <DefineSymbol>YES_NO</DefineSymbol>
              <IfDisabled>setNOTHING</IfDisabled>
              <Children>
                <GrupItem>
                  <TInhrItem>
                    <Name>Runtime Counter LDD</Name>
                    <Symbol>RuntimeCntrLDD</Symbol>
                    <TypeSpec>FreeRTOS\RuntimeCntrLDD</TypeSpec>
                    <Hint>Logical Device Driver implementing the runtime counter. Counter to be used to collect run time statistics. portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() and  portGET_RUN_TIME_COUNTER_VALUE() will be created to access the counter value. The counter frequency should be about 10 times the frequency of the tick timer.</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <EditLine>false</EditLine>
                    <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
                    <DefaultIndex>-1</DefaultIndex>
                    <TextValueIndex>false</TextValueIndex>
                    <RuntimeProperty>false</RuntimeProperty>
                    <CanDelete>false</CanDelete>
                    <IconPopup>false</IconPopup>
                    <InhrBeanBaseName>RTOSCNTRLDD</InhrBeanBaseName>
                    <ShowInheritedMethodsEventsInPrjTree>true</ShowInheritedMethodsEventsInPrjTree>
                  </TInhrItem>
                </GrupItem>
              </Children>
            </TBoolGrupItem>
          </GrupItem>
          <GrupItem>
            <TBoolGrupItem>
              <Name>non-LDD</Name>
              <Symbol>NonLDDRuntimeCounterGroup</Symbol>
              <TypeSpec>typeEnaDis</TypeSpec>
              <Hint>Using a traditional (non Logical Device Driver) component</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <BoldName>true</BoldName>
              <EditLine>false</EditLine>
              <Description>Enabled</Description>
              <Expanded>Yes</Expanded>
              <DefaultValue>true</DefaultValue>
              <DefineSymbol>YES_NO</DefineSymbol>
              <IfDisabled>setNOTHING</IfDisabled>
              <Children>
                <GrupItem>
                  <TInhrItem>
                    <Name>Runtime Counter</Name>
                    <Symbol>RuntimeCntr</Symbol>
                    <TypeSpec>FreeRTOS\RuntimeCntr</TypeSpec>
                    <Hint>Counter to be used to collect run time statistics. portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() and  portGET_RUN_TIME_COUNTER_VALUE() will be created to access the counter value. The counter frequency should be about 10 times the frequency of the tick timer.</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <EditLine>false</EditLine>
                    <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
                    <DefaultIndex>-1</DefaultIndex>
                    <TextValueIndex>false</TextValueIndex>
                    <RuntimeProperty>false</RuntimeProperty>
                    <CanDelete>false</CanDelete>
                    <IconPopup>false</IconPopup>
                    <InhrBeanBaseName>RTOSCNTR</InhrBeanBaseName>
                    <ShowInheritedMethodsEventsInPrjTree>true</ShowInheritedMethodsEventsInPrjTree>
                  </TInhrItem>
                </GrupItem>
              </Children>
            </TBoolGrupItem>
          </GrupItem>
        </Children>
      </TBoolGrupItem>
    </Property>
    <Property>
      <TGrupItem>
        <Name>Scheduler</Name>
        <Symbol>SchedulerGroup</Symbol>
        <Hint>Settings for the scheduler</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <BoldName>true</BoldName>
        <EditLine>false</EditLine>
        <Description>Settings for the scheduler</Description>
        <Expanded>Yes</Expanded>
        <Children>
          <GrupItem>
            <TBoolGrupItem>
              <Name>ColdFire V1</Name>
              <Symbol>ColdFireV1CPUSpecific</Symbol>
              <TypeSpec>typeEnaDis</TypeSpec>
              <Hint>This group is used to configure the RTOS for the ColdFire V1 cores</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <BoldName>true</BoldName>
              <EditLine>false</EditLine>
              <Description>Enabled</Description>
              <Expanded>Yes</Expanded>
              <DefaultValue>true</DefaultValue>
              <DefineSymbol>YES_NO</DefineSymbol>
              <IfDisabled>setNOTHING</IfDisabled>
              <Children>
                <GrupItem>
                  <TEnumItem>
                    <Name>CPU</Name>
                    <Symbol>FreeRTOSColdFireCPU</Symbol>
                    <TypeSpec>typeCFcpu</TypeSpec>
                    <Hint>Specify which ColdFire CPU is used (ColdFire V1 only). This is affecting the portCF_INTC_VALUE macro in portmacro.h</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <EditLine>true</EditLine>
                    <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
                    <DefaultIndex>0</DefaultIndex>
                    <TextValueIndex>true</TextValueIndex>
                    <RuntimeProperty>false</RuntimeProperty>
                    <CanDelete>false</CanDelete>
                    <IconPopup>false</IconPopup>
                  </TEnumItem>
                </GrupItem>
                <GrupItem>
                  <TEnumItem>
                    <Name>SWI</Name>
                    <Symbol>ColdFireSWI</Symbol>
                    <TypeSpec>typeCFswi</TypeSpec>
                    <Hint>Specify which software interrupt shall be used for task switching (ColdFire only)</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <EditLine>true</EditLine>
                    <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
                    <DefaultIndex>0</DefaultIndex>
                    <TextValueIndex>true</TextValueIndex>
                    <RuntimeProperty>false</RuntimeProperty>
                    <CanDelete>false</CanDelete>
                    <IconPopup>false</IconPopup>
                  </TEnumItem>
                </GrupItem>
              </Children>
            </TBoolGrupItem>
          </GrupItem>
          <GrupItem>
            <TBoolGrupItem>
              <Name>ColdFire V2</Name>
              <Symbol>ColdFireV2CPUSpecific</Symbol>
              <TypeSpec>typeEnaDis</TypeSpec>
              <Hint>This group is used to configure the RTOS for the ColdFire V2 cores</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <BoldName>true</BoldName>
              <EditLine>false</EditLine>
              <Description>Enabled</Description>
              <Expanded>Yes</Expanded>
              <DefaultValue>true</DefaultValue>
              <DefineSymbol>YES_NO</DefineSymbol>
              <IfDisabled>setNOTHING</IfDisabled>
              <Children>
                <GrupItem>
                  <TEnumItem>
                    <Name>CPU</Name>
                    <Symbol>FreeRTOSColdFireV2CPU</Symbol>
                    <TypeSpec>typeCF2cpu</TypeSpec>
                    <Hint>CPU</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <EditLine>true</EditLine>
                    <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
                    <DefaultIndex>0</DefaultIndex>
                    <TextValueIndex>true</TextValueIndex>
                    <RuntimeProperty>false</RuntimeProperty>
                    <CanDelete>false</CanDelete>
                    <IconPopup>false</IconPopup>
                  </TEnumItem>
                </GrupItem>
                <GrupItem>
                  <TIntgItem>
                    <Name>Library Lowest Interrupt Priority</Name>
                    <Symbol>ColdFireV2LibraryLowestInterruptPriority</Symbol>
                    <Hint>Used for configLIBRARY_LOWEST_INTERRUPT_PRIORITY. The RTOS will disable interrupts equal or lower than this priority. So for example if you set it to 5, then interrupts with level 6 can happen while the RTOS is running. This means as well that you shall *not* call any RTOS functions with an interrupt priority higher than this value! Keep in mind that for the ColdFire V2, the interrupts of level 7 can *not* be masked.</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <EditLine>true</EditLine>
                    <DefaultValue>7</DefaultValue>
                    <MinValue>0</MinValue>
                    <MaxValue>7</MaxValue>
                    <Bases>DEC</Bases>
                    <DefaultBase>DEC</DefaultBase>
                    <ExtraHintDisabled>false</ExtraHintDisabled>
                    <ChangeValueIntoRange>false</ChangeValueIntoRange>
                    <RuntimeProperty>false</RuntimeProperty>
                  </TIntgItem>
                </GrupItem>
                <GrupItem>
                  <TIntgItem>
                    <Name>SWI Number</Name>
                    <Symbol>ColdFireV2SWInumber</Symbol>
                    <Hint>Software Interrupt Vector number.\n
Mapping for number to vector for the MCF52259:\n
     0: 0x40  0x00000100 Reserved64    \n
     1: 0x41  0x00000104 INT_EPORT_EPF1\n
     2: 0x42  0x00000108 INT_EPORT_EPF2\n
     3: 0x43  0x0000010C INT_EPORT_EPF3\n
     4: 0x44  0x00000110 INT_EPORT_EPF4\n
     5: 0x45  0x00000114 INT_EPORT_EPF5\n
     6: 0x46  0x00000118 INT_EPORT_EPF6\n
     7: 0x47  0x0000011C INT_EPORT_EPF7\n
     8: 0x48  0x00000120 INT_SCM_SWTI  \n
     9: 0x49  0x00000124 INT_DMA0_DONE \n
    10: 0x4A  0x00000128 INT_DMA1_DONE \n
    11: 0x4B  0x0000012C INT_DMA2_DONE \n
    12: 0x4C  0x00000130 INT_DMA3_DONE \n
    13: 0x4D  0x00000134 INT_UART0     \n
    14: 0x4E  0x00000138 INT_UART1     \n
    15: 0x4F  0x0000013C INT_UART2     \n
    16: 0x50  0x00000140 Reserved80    </Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <EditLine>true</EditLine>
                    <DefaultValue>1</DefaultValue>
                    <MinValue>0</MinValue>
                    <MaxValue>-1</MaxValue>
                    <Bases>DEC</Bases>
                    <DefaultBase>DEC</DefaultBase>
                    <ExtraHintDisabled>false</ExtraHintDisabled>
                    <ChangeValueIntoRange>false</ChangeValueIntoRange>
                    <RuntimeProperty>false</RuntimeProperty>
                  </TIntgItem>
                </GrupItem>
              </Children>
            </TBoolGrupItem>
          </GrupItem>
          <GrupItem>
            <TBoolGrupItem>
              <Name>ARM Cortex-M</Name>
              <Symbol>KinetisCPUSpecific</Symbol>
              <TypeSpec>typeEnaDis</TypeSpec>
              <Hint>This group is used to configure the RTOS for the Kinetis/ARM cores</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <BoldName>true</BoldName>
              <EditLine>false</EditLine>
              <Description>Enabled</Description>
              <Expanded>Yes</Expanded>
              <DefaultValue>true</DefaultValue>
              <DefineSymbol>YES_NO</DefineSymbol>
              <IfDisabled>setNOTHING</IfDisabled>
              <Children>
                <GrupItem>
                  <TEnumItem>
                    <Name>ARM Family</Name>
                    <Symbol>ARMFamilyType</Symbol>
                    <TypeSpec>typeARMFamily</TypeSpec>
                    <Hint>Specifies the ARM family used</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <EditLine>true</EditLine>
                    <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
                    <DefaultIndex>1</DefaultIndex>
                    <TextValueIndex>true</TextValueIndex>
                    <RuntimeProperty>false</RuntimeProperty>
                    <CanDelete>false</CanDelete>
                    <IconPopup>false</IconPopup>
                  </TEnumItem>
                </GrupItem>
                <GrupItem>
                  <TIntgItem>
                    <Name>Max SysCall Interrupt Priority</Name>
                    <Symbol>KinetisLibraryMaxInterruptPriority</Symbol>
                    <Hint>Used for configMAX_SYSCALL_INTERRUPT_PRIORITY. \n
The highest interrupt priority that can be used by any interrupt service routine that makes calls to interrupt safe FreeRTOS API functions.  DO NOT CALL INTERRUPT SAFE FREERTOS API FUNCTIONS FROM ANY INTERRUPT THAT HAS A HIGHER PRIORITY THAN THIS! (higher priorities are lower numeric values). configMAX_SYSCALL_INTERRUPT_PRIORITY must not be set to zero! See  http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html. Note that 0 is the highest priority for Kinetis.</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <EditLine>true</EditLine>
                    <DefaultValue>5</DefaultValue>
                    <MinValue>1</MinValue>
                    <MaxValue>15</MaxValue>
                    <Bases>DEC</Bases>
                    <DefaultBase>DEC</DefaultBase>
                    <ExtraHintDisabled>false</ExtraHintDisabled>
                    <ChangeValueIntoRange>false</ChangeValueIntoRange>
                    <RuntimeProperty>false</RuntimeProperty>
                  </TIntgItem>
                </GrupItem>
                <GrupItem>
                  <TIntgItem>
                    <Name>RTOS Interrupt Priority</Name>
                    <Symbol>KinetisLibraryLowestInterruptPriority</Symbol>
                    <Hint>Used for configLIBRARY_LOWEST_INTERRUPT_PRIORITY. The lowest interrupt priority that can be used in a call to a "set priority" function. This priority is used for the kernel port itself too. Note that 0 is the highest priority for ARM/Kinetis. Note that FreeRTOS has to run with the lowest interrupt priority!</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <EditLine>true</EditLine>
                    <DefaultValue>15</DefaultValue>
                    <MinValue>0</MinValue>
                    <MaxValue>15</MaxValue>
                    <Bases>DEC</Bases>
                    <DefaultBase>DEC</DefaultBase>
                    <ExtraHintDisabled>false</ExtraHintDisabled>
                    <ChangeValueIntoRange>false</ChangeValueIntoRange>
                    <RuntimeProperty>false</RuntimeProperty>
                  </TIntgItem>
                </GrupItem>
                <GrupItem>
                  <TIntgItem>
                    <Name>Lowest Interrupt Priority</Name>
                    <Symbol>ARMLowestInterruptPriority</Symbol>
                    <Hint>Lowest possible interrupt priority as defined by the CPU, with zero the *highest* priority. This property is informal only.</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <ReadOnly>true</ReadOnly>
                    <EditLine>true</EditLine>
                    <DefaultValue>0</DefaultValue>
                    <MinValue>0</MinValue>
                    <MaxValue>-1</MaxValue>
                    <Bases>DEC</Bases>
                    <DefaultBase>DEC</DefaultBase>
                    <ExtraHintDisabled>false</ExtraHintDisabled>
                    <ChangeValueIntoRange>false</ChangeValueIntoRange>
                    <RuntimeProperty>false</RuntimeProperty>
                  </TIntgItem>
                </GrupItem>
                <GrupItem>
                  <TEnumItem>
                    <Name>Compiler Optimization Level</Name>
                    <Symbol>CompilerOptimizationLevel</Symbol>
                    <TypeSpec>typeOptimizationLevel</TypeSpec>
                    <Hint>Not applicable for gcc. Optimization level of the compiler as in the build tools settings. Depending on the optimization level, the stack frame of the Processor Expert functions and consequently the xPortPendSVHandler() and vPortSVCHandler() functions need to be different, and the port needs to be aware about it. With the MCU10.2 compiler (after Jan 1st 2012) the compiler defines a macro (__optlevel0, etc) for the optimization level used which is checked in the generated code. If the settings do not match, then the source code will raise an #error at compilation time.</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <EditLine>true</EditLine>
                    <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
                    <DefaultIndex>0</DefaultIndex>
                    <TextValueIndex>true</TextValueIndex>
                    <RuntimeProperty>false</RuntimeProperty>
                    <CanDelete>false</CanDelete>
                    <IconPopup>false</IconPopup>
                  </TEnumItem>
                </GrupItem>
                <GrupItem>
                  <TBoolItem>
                    <Name>Reset MSP</Name>
                    <Symbol>ResetMSP</Symbol>
                    <TypeSpec>typeYesNo</TypeSpec>
                    <Hint>If set to yes (default), the Cortex-M3/M4/M7 ports reset the MSP to value present in the vector table. That gives all the MSP stack space to the interrupts. Note tthe MSP is not reset for Cortex-M0 and if vPortEndScheduler() is used</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <EditLine>false</EditLine>
                    <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
                    <DefaultIndex>0</DefaultIndex>
                    <TextValueIndex>false</TextValueIndex>
                    <RuntimeProperty>false</RuntimeProperty>
                    <CanDelete>false</CanDelete>
                    <IconPopup>false</IconPopup>
                    <DefaultValue>true</DefaultValue>
                    <Popup>false</Popup>
                  </TBoolItem>
                </GrupItem>
                <GrupItem>
                  <TBoolItem>
                    <Name>MPU</Name>
                    <Symbol>useMPUsupport</Symbol>
                    <TypeSpec>typeYesNo</TypeSpec>
                    <Hint>Using MPU (Memory Protection Unit) support in the port.</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <EditLine>false</EditLine>
                    <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
                    <DefaultIndex>1</DefaultIndex>
                    <TextValueIndex>false</TextValueIndex>
                    <RuntimeProperty>false</RuntimeProperty>
                    <CanDelete>false</CanDelete>
                    <IconPopup>false</IconPopup>
                    <DefaultValue>false</DefaultValue>
                    <Popup>false</Popup>
                  </TBoolItem>
                </GrupItem>
                <GrupItem>
                  <TBoolGrupItem>
                    <Name>SysTick</Name>
                    <Symbol>useARMSysTickTimer</Symbol>
                    <TypeSpec>typeEnaDis</TypeSpec>
                    <Hint>If enabled, the port will use the ARM SysTick timer directly and no Processor Expert Timer is used.</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <BoldName>true</BoldName>
                    <EditLine>false</EditLine>
                    <Description>Enabled</Description>
                    <Expanded>Yes</Expanded>
                    <DefaultValue>true</DefaultValue>
                    <DefineSymbol>YES_NO</DefineSymbol>
                    <IfDisabled>setNOTHING</IfDisabled>
                    <Children>
                      <GrupItem>
                        <TBoolItem>
                          <Name>Core Clock</Name>
                          <Symbol>useARMSysTickUseCoreClock</Symbol>
                          <TypeSpec>typeYesNo</TypeSpec>
                          <Hint>If set to yes, the CLK bit in the SysTick configuration register will be set (using the core clock), otherwise the bit is cleared. If the bit is cleared,  the external reference clock will be used. The Kinetis K series does not implement this, so only the core clock can be used. For the Kinetis L series, a fixed prescaler of 16 is used.</Hint>
                          <ItemLevel>BASIC</ItemLevel>
                          <EditLine>false</EditLine>
                          <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
                          <DefaultIndex>0</DefaultIndex>
                          <TextValueIndex>false</TextValueIndex>
                          <RuntimeProperty>false</RuntimeProperty>
                          <CanDelete>false</CanDelete>
                          <IconPopup>false</IconPopup>
                          <DefaultValue>true</DefaultValue>
                          <Popup>false</Popup>
                        </TBoolItem>
                      </GrupItem>
                    </Children>
                  </TBoolGrupItem>
                </GrupItem>
                <GrupItem>
                  <TBoolGrupItem>
                    <Name>Low Power Timer</Name>
                    <Symbol>useARMLowPowerTimer</Symbol>
                    <TypeSpec>typeEnaDis</TypeSpec>
                    <Hint>If enabled, it uses the Low Power Timer of the Kinetis.</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <BoldName>true</BoldName>
                    <EditLine>false</EditLine>
                    <Description>Disabled</Description>
                    <Expanded>No</Expanded>
                    <DefaultValue>false</DefaultValue>
                    <DefineSymbol>YES_NO</DefineSymbol>
                    <IfDisabled>setNOTHING</IfDisabled>
                  </TBoolGrupItem>
                </GrupItem>
              </Children>
            </TBoolGrupItem>
          </GrupItem>
          <GrupItem>
            <TBoolGrupItem>
              <Name>non-LDD SWI</Name>
              <Symbol>NonLDDSWIGroup</Symbol>
              <TypeSpec>typeEnaDis</TypeSpec>
              <Hint>Group configuring the software interrupt using classic non-Low Level Driver component</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <BoldName>true</BoldName>
              <EditLine>false</EditLine>
              <Description>Enabled</Description>
              <Expanded>Yes</Expanded>
              <DefaultValue>true</DefaultValue>
              <DefineSymbol>YES_NO</DefineSymbol>
              <IfDisabled>setNOTHING</IfDisabled>
              <Children>
                <GrupItem>
                  <TInhrItem>
                    <Name>SWI</Name>
                    <Symbol>SWI</Symbol>
                    <TypeSpec>FreeRTOS\SWI</TypeSpec>
                    <Hint>In order to make a context switch, the RTOS needs a SWI (software interrupt).</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <EditLine>false</EditLine>
                    <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
                    <DefaultIndex>-1</DefaultIndex>
                    <TextValueIndex>false</TextValueIndex>
                    <RuntimeProperty>false</RuntimeProperty>
                    <CanDelete>false</CanDelete>
                    <IconPopup>false</IconPopup>
                    <InhrBeanBaseName>RTOSSWI</InhrBeanBaseName>
                    <ShowInheritedMethodsEventsInPrjTree>true</ShowInheritedMethodsEventsInPrjTree>
                  </TInhrItem>
                </GrupItem>
              </Children>
            </TBoolGrupItem>
          </GrupItem>
          <GrupItem>
            <TBoolItem>
              <Name>Preemptive</Name>
              <Symbol>UsePreemption</Symbol>
              <TypeSpec>typeYesNo</TypeSpec>
              <Hint>Set to 1 to use the preemptive kernel, or 0 to use the cooperative kernel. (configUSE_PREEMPTION flag)</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>false</EditLine>
              <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
              <DefaultIndex>0</DefaultIndex>
              <TextValueIndex>false</TextValueIndex>
              <RuntimeProperty>false</RuntimeProperty>
              <CanDelete>false</CanDelete>
              <IconPopup>false</IconPopup>
              <DefaultValue>true</DefaultValue>
              <Popup>false</Popup>
            </TBoolItem>
          </GrupItem>
          <GrupItem>
            <TBoolItem>
              <Name>Optimized Task Selection</Name>
              <Symbol>configUseOptimizedTaskSelection</Symbol>
              <TypeSpec>typeYesNo</TypeSpec>
              <Hint>If enabled, it enables configUSE_PORT_OPTIMISED_TASK_SELECTION which uses an optimized task selection implemented for ARM. Note that this only supports up to 32 priorirites, and only few ports (like the one for ARM Cortex-M4/M7) has it implemented.</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>false</EditLine>
              <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
              <DefaultIndex>0</DefaultIndex>
              <TextValueIndex>false</TextValueIndex>
              <RuntimeProperty>false</RuntimeProperty>
              <CanDelete>false</CanDelete>
              <IconPopup>false</IconPopup>
              <DefaultValue>true</DefaultValue>
              <Popup>false</Popup>
            </TBoolItem>
          </GrupItem>
          <GrupItem>
            <TBoolItem>
              <Name>Time Slicing</Name>
              <Symbol>UseTimeSlicing</Symbol>
              <TypeSpec>typeYesNo</TypeSpec>
              <Hint>Set to 1 (default) time will be time slices among the ready high priority tasks of same priority (configUSE_TIME_SLICING flag)</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>false</EditLine>
              <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
              <DefaultIndex>0</DefaultIndex>
              <TextValueIndex>false</TextValueIndex>
              <RuntimeProperty>false</RuntimeProperty>
              <CanDelete>false</CanDelete>
              <IconPopup>false</IconPopup>
              <DefaultValue>true</DefaultValue>
              <Popup>false</Popup>
            </TBoolItem>
          </GrupItem>
          <GrupItem>
            <TBoolItem>
              <Name>Use Co-Routines</Name>
              <Symbol>UseCoroutines</Symbol>
              <TypeSpec>typeYesNo</TypeSpec>
              <Hint>Set to 1 to include co-routine functionality in the build, or 0 to omit co-routine functionality from the build. To include co-routines croutine.c must be included in the project. </Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>false</EditLine>
              <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
              <DefaultIndex>1</DefaultIndex>
              <TextValueIndex>false</TextValueIndex>
              <RuntimeProperty>false</RuntimeProperty>
              <CanDelete>false</CanDelete>
              <IconPopup>false</IconPopup>
              <DefaultValue>false</DefaultValue>
              <Popup>false</Popup>
            </TBoolItem>
          </GrupItem>
          <GrupItem>
            <TBoolItem>
              <Name>Idle should yield</Name>
              <Symbol>IdleShouldYield</Symbol>
              <TypeSpec>typeYesNo</TypeSpec>
              <Hint>This parameter controls the behaviour of tasks at the idle priority. It only has an effect if:\n
   1. The preemptive scheduler is being used.\n
   2. The users application creates tasks that run at the idle priority.\n
Tasks that share the same priority will time slice. Assuming none of the tasks get preempted, it might be assumed that each task of at a given priority will be allocated an equal amount of processing time - and if the shared priority is above the idle priority then this is indeed the case. </Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>false</EditLine>
              <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
              <DefaultIndex>0</DefaultIndex>
              <TextValueIndex>false</TextValueIndex>
              <RuntimeProperty>false</RuntimeProperty>
              <CanDelete>false</CanDelete>
              <IconPopup>false</IconPopup>
              <DefaultValue>true</DefaultValue>
              <Popup>false</Popup>
            </TBoolItem>
          </GrupItem>
          <GrupItem>
            <TIntgItem>
              <Name>Task Name Length</Name>
              <Symbol>TaskNameLength</Symbol>
              <Hint>The maximum permissible length of the descriptive name given to a task when the task is created. The length is specified in the number of characters including the NULL termination byte. (configMAX_TASK_NAME_LEN)</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue>12</DefaultValue>
              <MinValue>1</MinValue>
              <MaxValue>-1</MaxValue>
              <Bases>DEC</Bases>
              <DefaultBase>DEC</DefaultBase>
              <ExtraHintDisabled>false</ExtraHintDisabled>
              <ChangeValueIntoRange>true</ChangeValueIntoRange>
              <RuntimeProperty>false</RuntimeProperty>
            </TIntgItem>
          </GrupItem>
          <GrupItem>
            <TStrgItem>
              <Name>Minimal Stack Size</Name>
              <Symbol>MinimalStackSize</Symbol>
              <Hint>The size of the stack used by the idle task (configMINIMAL_STACK_SIZE flag). Generally this should not be reduced from the value set in the FreeRTOSConfig.h file provided with the demo application for the port you are using. Note that the size is in stack units (portSTACK_TYPE), which is 4 bytes for a 32bit core like ColdFire and ARM/Kinetis and 1 byte for HCS08. Keep in mind that there is the IDLE task too which needs stack plus the task descriptor block.</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue>200</DefaultValue>
              <StrDefine>nothing</StrDefine>
              <MinLength>0</MinLength>
              <MaxLength>-1</MaxLength>
            </TStrgItem>
          </GrupItem>
          <GrupItem>
            <TStrgItem>
              <Name>Maximum Priorities</Name>
              <Symbol>MaxPriority</Symbol>
              <Hint>Each task is assigned a priority from 0 to ( configMAX_PRIORITIES - 1 ). configMAX_PRIORITIES is defined within FreeRTOSConfig.h and can be set on an application by application basis. The higher the value given to configMAX_PRIORITIES the more RAM the FreeRTOS kernel will consume. </Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue>6</DefaultValue>
              <StrDefine>nothing</StrDefine>
              <MinLength>0</MinLength>
              <MaxLength>-1</MaxLength>
            </TStrgItem>
          </GrupItem>
          <GrupItem>
            <TIntgItem>
              <Name>Maximum Coroutine Priorities</Name>
              <Symbol>MaxCoroutinePriorities</Symbol>
              <Hint>Each co-routine is assigned a priority from 0 to ( configMAX_CO_ROUTINE_PRIORITIES - 1 ). configMAX_CO_ROUTINE_PRIORITIES is defined within FreeRTOSConfig.h and can be set on an application by application basis. The higher the value given to configMAX_CO_ROUTINE_PRIORITIES the more RAM the FreeRTOS kernel will consume. </Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue>2</DefaultValue>
              <MinValue>1</MinValue>
              <MaxValue>-1</MaxValue>
              <Bases>DEC</Bases>
              <DefaultBase>DEC</DefaultBase>
              <ExtraHintDisabled>false</ExtraHintDisabled>
              <ChangeValueIntoRange>true</ChangeValueIntoRange>
              <RuntimeProperty>false</RuntimeProperty>
            </TIntgItem>
          </GrupItem>
          <GrupItem>
            <TEnumItem>
              <Name>Stackoverflow checking method</Name>
              <Symbol>StackOverflowCheckingMethodNumber</Symbol>
              <TypeSpec>typeStackOverflowMethod</TypeSpec>
              <Hint>Stack Overflow Detection - Method 1\n
It is likely that the stack will reach its greatest (deepest) value after the kernel has swapped the task out of the Running state because this is when the stack will contain the task context. At this point the kernel can check that the processor stack pointer remains within the valid stack space. The stack overflow hook function is called if the stack pointer contain a value that is outside of the valid stack range.\n
This method is quick but not guaranteed to catch all stack overflows. Set configCHECK_FOR_STACK_OVERFLOW to 1 to use this method only.\n
\n
Stack Overflow Detection - Method 2\n
When a task is first created its stack is filled with a known value. When swapping a task out of the Running state the kernel can check the last 16 bytes within the valid stack range to ensure that these known values have not been overwritten by the task or interrupt activity. The stack overflow hook function is called should any of these 16 bytes not remain at their initial value.\n
This method is less efficient than method one, but still fairly fast. It is very likely to catch stack overflows but is still not guaranteed to catch all overflows.\n
To use this method in combination with method 1 set configCHECK_FOR_STACK_OVERFLOW to 2. It is not possible to use only this method.</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
              <DefaultIndex>0</DefaultIndex>
              <TextValueIndex>true</TextValueIndex>
              <RuntimeProperty>false</RuntimeProperty>
              <CanDelete>false</CanDelete>
              <IconPopup>false</IconPopup>
            </TEnumItem>
          </GrupItem>
          <GrupItem>
            <TBoolItem>
              <Name>Cleanup Resources</Name>
              <Symbol>CleanupResources</Symbol>
              <TypeSpec>typeYesNo</TypeSpec>
              <Hint>This setting controls the INCLUDE_vTaskCleanUpResources define.</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>false</EditLine>
              <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
              <DefaultIndex>0</DefaultIndex>
              <TextValueIndex>false</TextValueIndex>
              <RuntimeProperty>false</RuntimeProperty>
              <CanDelete>false</CanDelete>
              <IconPopup>false</IconPopup>
              <DefaultValue>true</DefaultValue>
              <Popup>false</Popup>
            </TBoolItem>
          </GrupItem>
          <GrupItem>
            <TBoolItem>
              <Name>TaskExitError Handler</Name>
              <Symbol>TaskExitErrorHandler</Symbol>
              <TypeSpec>typeYesNo</TypeSpec>
              <Hint>A function that implements a task must not exit or attempt to return to its caller as there is nothing to return to. If this setting is enabled, then the function prvTaskExitError() will be called if the task returns. Note that if enabled, it might confuse the GDB debugger and not properly show the task stack frames.</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>false</EditLine>
              <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
              <DefaultIndex>1</DefaultIndex>
              <TextValueIndex>false</TextValueIndex>
              <RuntimeProperty>false</RuntimeProperty>
              <CanDelete>false</CanDelete>
              <IconPopup>false</IconPopup>
              <DefaultValue>false</DefaultValue>
              <Popup>false</Popup>
            </TBoolItem>
          </GrupItem>
        </Children>
      </TGrupItem>
    </Property>
    <Property>
      <TGrupItem>
        <Name>Ticks</Name>
        <Symbol>TicksGroup</Symbol>
        <Hint>Group controlling how ticks are handled</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <BoldName>true</BoldName>
        <EditLine>false</EditLine>
        <Description>Settings for the periodic tick timer</Description>
        <Expanded>Yes</Expanded>
        <Children>
          <GrupItem>
            <TBoolGrupItem>
              <Name>Tickless Idle Mode</Name>
              <Symbol>TicklessIdleModeEnabled</Symbol>
              <TypeSpec>typeEnaDis</TypeSpec>
              <Hint>If supported, a tickless idle mode is used for power reduction. See http://www.freertos.org/low-power-tickless-rtos.html</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <BoldName>true</BoldName>
              <EditLine>false</EditLine>
              <Description>Disabled</Description>
              <Expanded>No</Expanded>
              <DefaultValue>false</DefaultValue>
              <DefineSymbol>YES_NO</DefineSymbol>
              <IfDisabled>setNOTHING</IfDisabled>
              <Children>
                <GrupItem>
                  <TIntgItem>
                    <Name>Stopped Timer Compensation</Name>
                    <Symbol>StoppedTimerCompensation</Symbol>
                    <Hint>vPortSuppressTicksAndSleep() needs to stop the tick timer for a short time. This value compensates for the time delay. This value is assigned to configSTOPPED_TIMER_COMPENSATION in port.c</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <EditLine>true</EditLine>
                    <DefaultValue>45</DefaultValue>
                    <MinValue>0</MinValue>
                    <MaxValue>-1</MaxValue>
                    <Bases>DEC</Bases>
                    <DefaultBase>DEC</DefaultBase>
                    <ExtraHintDisabled>false</ExtraHintDisabled>
                    <ChangeValueIntoRange>false</ChangeValueIntoRange>
                    <RuntimeProperty>false</RuntimeProperty>
                  </TIntgItem>
                </GrupItem>
                <GrupItem>
                  <TIntgItem>
                    <Name>Expected Idle Time (Ticks) before Sleep</Name>
                    <Symbol>ExpectedIdleTimeBeforeSleep</Symbol>
                    <Hint>Tickless mode will only be entered if the idle ticks are larger than this value. This defines the value for configEXPECTED_IDLE_TIME_BEFORE_SLEEP.</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <EditLine>true</EditLine>
                    <DefaultValue>2</DefaultValue>
                    <MinValue>2</MinValue>
                    <MaxValue>-1</MaxValue>
                    <Bases>DEC</Bases>
                    <DefaultBase>DEC</DefaultBase>
                    <ExtraHintDisabled>false</ExtraHintDisabled>
                    <ChangeValueIntoRange>false</ChangeValueIntoRange>
                    <RuntimeProperty>false</RuntimeProperty>
                  </TIntgItem>
                </GrupItem>
                <GrupItem>
                  <TBoolGrupItem>
                    <Name>Idle Decision Hook</Name>
                    <Symbol>TicklessIdleDecisionHookEnabled</Symbol>
                    <TypeSpec>typeEnaDis</TypeSpec>
                    <Hint>Hook called to ask the application if the RTOS is allowed to enter the tickless idle mode. The application might prevent entering tickless idle mode e.g. if this would shug down serial or USB communication.</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <BoldName>true</BoldName>
                    <EditLine>false</EditLine>
                    <Description>Disabled</Description>
                    <Expanded>No</Expanded>
                    <DefaultValue>false</DefaultValue>
                    <DefineSymbol>YES_NO</DefineSymbol>
                    <IfDisabled>setNOTHING</IfDisabled>
                    <Children>
                      <GrupItem>
                        <TStrgItem>
                          <Name>Hook function name</Name>
                          <Symbol>xEnterTicklessIdleFctName</Symbol>
                          <Hint>Function name of the decision hook. The implementation must use this prototype: BaseType_t  xEnterTicklessIdle(void)</Hint>
                          <ItemLevel>BASIC</ItemLevel>
                          <EditLine>true</EditLine>
                          <DefaultValue>xEnterTicklessIdle</DefaultValue>
                          <StrDefine>nothing</StrDefine>
                          <MinLength>0</MinLength>
                          <MaxLength>-1</MaxLength>
                        </TStrgItem>
                      </GrupItem>
                    </Children>
                  </TBoolGrupItem>
                </GrupItem>
              </Children>
            </TBoolGrupItem>
          </GrupItem>
          <GrupItem>
            <TIntgItem>
              <Name>Tick Rate (Hz)</Name>
              <Symbol>TickRateHz</Symbol>
              <Hint>The frequency of the RTOS tick interrupt.\n
\n
The tick interrupt is used to measure time. Therefore a higher tick frequency means time can be measured to a higher resolution. However, a high tick frequency also means that the kernel will use more CPU time so be less efficient. The RTOS demo applications all use a tick rate of 1000Hz. This is used to test the kernel and is higher than would normally be required.\n
\n
More than one task can share the same priority. The kernel will share processor time between tasks of the same priority by switching between the tasks during each RTOS tick. A high tick rate frequency will therefore also have the effect of reducing the 'time slice' given to each task. </Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue>100</DefaultValue>
              <MinValue>1</MinValue>
              <MaxValue>-1</MaxValue>
              <Bases>DEC</Bases>
              <DefaultBase>DEC</DefaultBase>
              <ExtraHintDisabled>false</ExtraHintDisabled>
              <ChangeValueIntoRange>true</ChangeValueIntoRange>
              <RuntimeProperty>false</RuntimeProperty>
            </TIntgItem>
          </GrupItem>
          <GrupItem>
            <TBoolItem>
              <Name>Use 16bit ticks</Name>
              <Symbol>Use16bitTicks</Symbol>
              <TypeSpec>typeYesNo</TypeSpec>
              <Hint>Time is measured in 'ticks' - which is the number of times the tick interrupt has executed since the kernel was started. The tick count is held in a variable of type portTickType.\n
Defining configUSE_16_BIT_TICKS as 1 causes portTickType to be defined (typedef'ed) as an unsigned 16bit type. Defining configUSE_16_BIT_TICKS as 0 causes portTickType to be defined (typedef'ed) as an unsigned 32bit type.\n
Using a 16 bit type will greatly improve performance on 8 and 16 bit architectures, but limits the maximum specifiable time period to 65535 'ticks'. Therefore, assuming a tick frequency of 250Hz, the maximum time a task can delay or block when a 16bit counter is used is 262 seconds, compared to 17179869 seconds when using a 32bit counter. </Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>false</EditLine>
              <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
              <DefaultIndex>1</DefaultIndex>
              <TextValueIndex>false</TextValueIndex>
              <RuntimeProperty>false</RuntimeProperty>
              <CanDelete>false</CanDelete>
              <IconPopup>false</IconPopup>
              <DefaultValue>false</DefaultValue>
              <Popup>false</Popup>
            </TBoolItem>
          </GrupItem>
          <GrupItem>
            <TBoolGrupItem>
              <Name>non-LDD Tick</Name>
              <Symbol>NonLDDTickGroup</Symbol>
              <TypeSpec>typeEnaDis</TypeSpec>
              <Hint>Group for classic non-LDD components</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <BoldName>true</BoldName>
              <EditLine>false</EditLine>
              <Description>Enabled</Description>
              <Expanded>Yes</Expanded>
              <DefaultValue>true</DefaultValue>
              <DefineSymbol>YES_NO</DefineSymbol>
              <IfDisabled>setNOTHING</IfDisabled>
              <Children>
                <GrupItem>
                  <TInhrItem>
                    <Name>Tick Counter</Name>
                    <Symbol>TickCntr</Symbol>
                    <TypeSpec>FreeRTOS\TickCntr</TypeSpec>
                    <Hint>Timer generating the ticks for the RTOS</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <EditLine>false</EditLine>
                    <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
                    <DefaultIndex>-1</DefaultIndex>
                    <TextValueIndex>false</TextValueIndex>
                    <RuntimeProperty>false</RuntimeProperty>
                    <CanDelete>false</CanDelete>
                    <IconPopup>false</IconPopup>
                    <InhrBeanBaseName>TickCntr</InhrBeanBaseName>
                    <ShowInheritedMethodsEventsInPrjTree>true</ShowInheritedMethodsEventsInPrjTree>
                  </TInhrItem>
                </GrupItem>
              </Children>
            </TBoolGrupItem>
          </GrupItem>
          <GrupItem>
            <TBoolGrupItem>
              <Name>LDD Tick</Name>
              <Symbol>LDDTickGroup</Symbol>
              <TypeSpec>typeEnaDis</TypeSpec>
              <Hint>Group for Logical Device Drivers</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <BoldName>true</BoldName>
              <EditLine>false</EditLine>
              <Description>Enabled</Description>
              <Expanded>Yes</Expanded>
              <DefaultValue>true</DefaultValue>
              <DefineSymbol>YES_NO</DefineSymbol>
              <IfDisabled>setNOTHING</IfDisabled>
              <Children>
                <GrupItem>
                  <TInhrItem>
                    <Name>Tick Timer</Name>
                    <Symbol>TickTimerLDD</Symbol>
                    <TypeSpec>FreeRTOS\TickLDD</TypeSpec>
                    <Hint>Tick Timer Interrupt</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <EditLine>false</EditLine>
                    <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
                    <DefaultIndex>-1</DefaultIndex>
                    <TextValueIndex>false</TextValueIndex>
                    <RuntimeProperty>false</RuntimeProperty>
                    <CanDelete>false</CanDelete>
                    <IconPopup>false</IconPopup>
                    <InhrBeanBaseName>RTOSTICKLDD</InhrBeanBaseName>
                    <ShowInheritedMethodsEventsInPrjTree>true</ShowInheritedMethodsEventsInPrjTree>
                  </TInhrItem>
                </GrupItem>
              </Children>
            </TBoolGrupItem>
          </GrupItem>
        </Children>
      </TGrupItem>
    </Property>
    <Property>
      <TGrupItem>
        <Name>Queues</Name>
        <Symbol>QueuesGroup</Symbol>
        <Hint>This group defines how queues are handled</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <BoldName>true</BoldName>
        <EditLine>false</EditLine>
        <Description>Settings for Queues</Description>
        <Expanded>No</Expanded>
        <Children>
          <GrupItem>
            <TIntgItem>
              <Name>Queue Registry Size</Name>
              <Symbol>QueueRegistrySize</Symbol>
              <Hint>The queue registry has two purposes, both of which are associated with kernel aware debugging:\n
   1. It allows a textual name to be associated with a queue for easy queue identification within a debugging GUI.\n
   2. It contains the information required by a debugger to locate each registered queue and semaphore.\n
The queue registry has no purpose unless you are using a kernel aware debugger.\n
configQUEUE_REGISTRY_SIZE defines the maximum number of queues and semaphores that can be registered. Only those queues and semaphores that you want to view using a kernel aware debugger need be registered. See the API reference documentation for vQueueAddToRegistry() and vQueueUnregisterQueue() for more information.</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue>5</DefaultValue>
              <MinValue>0</MinValue>
              <MaxValue>-1</MaxValue>
              <Bases>DEC</Bases>
              <DefaultBase>DEC</DefaultBase>
              <ExtraHintDisabled>false</ExtraHintDisabled>
              <ChangeValueIntoRange>true</ChangeValueIntoRange>
              <RuntimeProperty>false</RuntimeProperty>
            </TIntgItem>
          </GrupItem>
          <GrupItem>
            <TBoolItem>
              <Name>Queue Sets</Name>
              <Symbol>useQueueSets</Symbol>
              <TypeSpec>typeYesNo</TypeSpec>
              <Hint>If queue sets are supported. This sets configUSE_QUEUE_SETS in FreeRTOSConfig.h</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>false</EditLine>
              <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
              <DefaultIndex>1</DefaultIndex>
              <TextValueIndex>false</TextValueIndex>
              <RuntimeProperty>false</RuntimeProperty>
              <CanDelete>false</CanDelete>
              <IconPopup>false</IconPopup>
              <DefaultValue>false</DefaultValue>
              <Popup>false</Popup>
            </TBoolItem>
          </GrupItem>
        </Children>
      </TGrupItem>
    </Property>
    <Property>
      <TGrupItem>
        <Name>Semaphores and Mutexes</Name>
        <Symbol>MutexGroup</Symbol>
        <Hint>This group defines how semaphores and mutexes are handled</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <BoldName>true</BoldName>
        <EditLine>false</EditLine>
        <Description>Settings for Mutex and Semaphore</Description>
        <Expanded>No</Expanded>
        <Children>
          <GrupItem>
            <TBoolItem>
              <Name>Use Mutexes</Name>
              <Symbol>UseMutexes</Symbol>
              <TypeSpec>typeYesNo</TypeSpec>
              <Hint>Set to 1 to include mutex functionality in the build, or 0 to omit mutex functionality from the build. Readers should familiarise themselves with the differences between mutexes and binary semaphores in relation to the FreeRTOS.org functionality.</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>false</EditLine>
              <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
              <DefaultIndex>0</DefaultIndex>
              <TextValueIndex>false</TextValueIndex>
              <RuntimeProperty>false</RuntimeProperty>
              <CanDelete>false</CanDelete>
              <IconPopup>false</IconPopup>
              <DefaultValue>true</DefaultValue>
              <Popup>false</Popup>
            </TBoolItem>
          </GrupItem>
          <GrupItem>
            <TBoolItem>
              <Name>Use Recursive Mutexes</Name>
              <Symbol>UseRecursiveMutexes</Symbol>
              <TypeSpec>typeYesNo</TypeSpec>
              <Hint>Set to 1 to include recursive mutex functionality in the build, or 0 to omit recursive mutex functionality from the build. This affects if xSemaphoreTakeRecursive() and xSemaphoreGiveRecursive() are available or not.</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>false</EditLine>
              <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
              <DefaultIndex>0</DefaultIndex>
              <TextValueIndex>false</TextValueIndex>
              <RuntimeProperty>false</RuntimeProperty>
              <CanDelete>false</CanDelete>
              <IconPopup>false</IconPopup>
              <DefaultValue>true</DefaultValue>
              <Popup>false</Popup>
            </TBoolItem>
          </GrupItem>
        </Children>
      </TGrupItem>
    </Property>
    <Property>
      <TBoolGrupItem>
        <Name>Timers</Name>
        <Symbol>TimersEnabled</Symbol>
        <TypeSpec>typeEnaDis</TypeSpec>
        <Hint>Group configuring the software timers</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <BoldName>true</BoldName>
        <EditLine>false</EditLine>
        <Description>Disabled</Description>
        <Expanded>No</Expanded>
        <DefaultValue>false</DefaultValue>
        <DefineSymbol>YES_NO</DefineSymbol>
        <IfDisabled>setNOTHING</IfDisabled>
        <Children>
          <GrupItem>
            <TIntgItem>
              <Name>Queue Length</Name>
              <Symbol>TimerTaskQueueLength</Symbol>
              <Hint>Sets configTIMER_QUEUE_LENGTH</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue>10</DefaultValue>
              <MinValue>0</MinValue>
              <MaxValue>-1</MaxValue>
              <Bases>DEC</Bases>
              <DefaultBase>DEC</DefaultBase>
              <ExtraHintDisabled>false</ExtraHintDisabled>
              <ChangeValueIntoRange>false</ChangeValueIntoRange>
              <RuntimeProperty>false</RuntimeProperty>
            </TIntgItem>
          </GrupItem>
          <GrupItem>
            <TStrgItem>
              <Name>Priority</Name>
              <Symbol>TimerTaskPriority</Symbol>
              <Hint>Priority of the software timer task (configTIMER_TASK_PRIORITY)</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue>(configMAX_PRIORITIES-1)</DefaultValue>
              <StrDefine>nothing</StrDefine>
              <MinLength>0</MinLength>
              <MaxLength>-1</MaxLength>
            </TStrgItem>
          </GrupItem>
          <GrupItem>
            <TStrgItem>
              <Name>Stack Depth</Name>
              <Symbol>TimerTaskStackDepth</Symbol>
              <Hint>configures the value of configTIMER_TASK_STACK_DEPTH which defines the stack size for the timer task. The units are 'stack units', so 32bits for an ARM.</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue>(configMINIMAL_STACK_SIZE)</DefaultValue>
              <StrDefine>nothing</StrDefine>
              <MinLength>0</MinLength>
              <MaxLength>-1</MaxLength>
            </TStrgItem>
          </GrupItem>
          <GrupItem>
            <TBoolItem>
              <Name>Use Daemon Task Startup Hook</Name>
              <Symbol>UseDaemonTaskStartupHook</Symbol>
              <TypeSpec>typeYesNo</TypeSpec>
              <Hint>Configures configUSE_DAEMON_TASK_STARTUP_HOOK. If enabled, uses an application specific vApplicationDaemonTaskStartupHook().</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>false</EditLine>
              <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
              <DefaultIndex>1</DefaultIndex>
              <TextValueIndex>false</TextValueIndex>
              <RuntimeProperty>false</RuntimeProperty>
              <CanDelete>false</CanDelete>
              <IconPopup>false</IconPopup>
              <DefaultValue>false</DefaultValue>
              <Popup>false</Popup>
            </TBoolItem>
          </GrupItem>
        </Children>
      </TBoolGrupItem>
    </Property>
    <Property>
      <TGrupItem>
        <Name>Memory</Name>
        <Symbol>MemoryGroup</Symbol>
        <Hint>This group controls the heap and memory settings</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <BoldName>true</BoldName>
        <EditLine>false</EditLine>
        <Description>Settings for the memory and heap allocation</Description>
        <Expanded>Yes</Expanded>
        <Children>
          <GrupItem>
            <TBoolGrupItem>
              <Name>Dynamic Allocation</Name>
              <Symbol>DynamicAllocation</Symbol>
              <TypeSpec>typeEnaDis</TypeSpec>
              <Hint>DynamicAllocation</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <BoldName>true</BoldName>
              <EditLine>false</EditLine>
              <Description>Enabled</Description>
              <Expanded>Yes</Expanded>
              <DefaultValue>true</DefaultValue>
              <DefineSymbol>YES_NO</DefineSymbol>
              <IfDisabled>setNOTHING</IfDisabled>
              <Children>
                <GrupItem>
                  <TBoolItem>
                    <Name>Application allocated Heap</Name>
                    <Symbol>ApplicationAllocatedHeap</Symbol>
                    <TypeSpec>typeYesNo</TypeSpec>
                    <Hint>Configures configAPPLICATION_ALLOCATED_HEAP in FreeRTOSConfig.h. If set to yes, the application needs to define the heap memory variable, e.g. to use special segment attributes.</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <EditLine>false</EditLine>
                    <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
                    <DefaultIndex>1</DefaultIndex>
                    <TextValueIndex>false</TextValueIndex>
                    <RuntimeProperty>false</RuntimeProperty>
                    <CanDelete>false</CanDelete>
                    <IconPopup>false</IconPopup>
                    <DefaultValue>false</DefaultValue>
                    <Popup>false</Popup>
                  </TBoolItem>
                </GrupItem>
                <GrupItem>
                  <TIntgItem>
                    <Name>Heap Size</Name>
                    <Symbol>TotalHeapSize</Symbol>
                    <Hint>The total amount of RAM available to the kernel. This value is used by the memory allocation schemes. Value not used if using Scheme3 (malloc/free).</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <EditLine>true</EditLine>
                    <DefaultValue>2048</DefaultValue>
                    <MinValue>1</MinValue>
                    <MaxValue>-1</MaxValue>
                    <Bases>DEC HEX</Bases>
                    <DefaultBase>DEC</DefaultBase>
                    <ExtraHintDisabled>false</ExtraHintDisabled>
                    <ChangeValueIntoRange>true</ChangeValueIntoRange>
                    <RuntimeProperty>false</RuntimeProperty>
                  </TIntgItem>
                </GrupItem>
                <GrupItem>
                  <TStrgItem>
                    <Name>Linker Heap Base Symbol</Name>
                    <Symbol>LinkerHeapBaseSymbolName</Symbol>
                    <Hint>Linker defined symbol for the heap base address (configLINKER_HEAP_BASE_SYMBOL) used for Scheme 6. Commonly used name is __HeapBase. Check your linker file.</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <EditLine>true</EditLine>
                    <DefaultValue>__HeapBase</DefaultValue>
                    <StrDefine>nothing</StrDefine>
                    <MinLength>0</MinLength>
                    <MaxLength>-1</MaxLength>
                  </TStrgItem>
                </GrupItem>
                <GrupItem>
                  <TStrgItem>
                    <Name>Linker Heap Limit Symbol</Name>
                    <Symbol>LinkerHeapLimitSymbolName</Symbol>
                    <Hint>Linker defined symbol for the heap limit address (configLINKER_HEAP_LIMIT_SYMBOL) used for Scheme 6. Commonly used name is __HeapLimit. Check your linker file.</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <EditLine>true</EditLine>
                    <DefaultValue>__HeapLimit</DefaultValue>
                    <StrDefine>nothing</StrDefine>
                    <MinLength>0</MinLength>
                    <MaxLength>-1</MaxLength>
                  </TStrgItem>
                </GrupItem>
                <GrupItem>
                  <TStrgItem>
                    <Name>Linker Heap Size Symbol</Name>
                    <Symbol>LinkerHeapSizeSymbolName</Symbol>
                    <Hint>Linker defined symbol for the heap size (configLINKER_HEAP_SIZE_SYMBOL) used for Scheme 6. Commonly used names are __heap_size or HEAP_SIZE. Check your linker file.</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <EditLine>true</EditLine>
                    <DefaultValue>__heap_size</DefaultValue>
                    <StrDefine>nothing</StrDefine>
                    <MinLength>0</MinLength>
                    <MaxLength>-1</MaxLength>
                  </TStrgItem>
                </GrupItem>
                <GrupItem>
                  <TEnumItem>
                    <Name>Memory Allocation Scheme</Name>
                    <Symbol>MemoryScheme</Symbol>
                    <TypeSpec>typeMemAllocScheme</TypeSpec>
                    <Hint>Configures configUSE_HEAP_SCHEME.\n
Scheme 1:\n
This is the simplest scheme of all. It does not permit memory to be freed once it has been allocated, but despite this is suitable for a surprisingly large number of applications.\n
\n
Scheme 2:\n
This scheme uses a best fit algorithm and, unlike scheme 1, allows previously allocated blocks to be freed. It does not however combine adjacent free blocks into a single large block.\n
\n
Scheme 3:\n
This is just a wrapper for the standard malloc() and free() functions. It makes them thread safe.\n
\n
Scheme 4:\n
This scheme uses a first fit algorithm and, unlike scheme 2, does combine adjacent free memory blocks into a single large block (it does include a coalescence algorithm).\n
\n
Scheme 5:\n
This scheme allows the heap to be defined across multiple non-contigous blocks and combines (coalescences) adjacent memory blocks as they are freed. vPortDefineHeapRegions() ***must*** be called before pvPortMalloc().\n
\n
Scheme 6:\n
Safe wrapper to newlib, provided by Dave Nadler. See http://www.nadler.com/embedded/newlibAndFreeRTOS.html. Requires three heap linker symbols for base, limit and size.</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <EditLine>true</EditLine>
                    <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
                    <DefaultIndex>3</DefaultIndex>
                    <TextValueIndex>true</TextValueIndex>
                    <RuntimeProperty>false</RuntimeProperty>
                    <CanDelete>false</CanDelete>
                    <IconPopup>false</IconPopup>
                  </TEnumItem>
                </GrupItem>
              </Children>
            </TBoolGrupItem>
          </GrupItem>
          <GrupItem>
            <TBoolGrupItem>
              <Name>Static Allocation</Name>
              <Symbol>StaticAllocation</Symbol>
              <TypeSpec>typeEnaDis</TypeSpec>
              <Hint>StaticAllocation</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <BoldName>true</BoldName>
              <EditLine>false</EditLine>
              <Description>Disabled</Description>
              <Expanded>No</Expanded>
              <DefaultValue>false</DefaultValue>
              <DefineSymbol>YES_NO</DefineSymbol>
              <IfDisabled>setNOTHING</IfDisabled>
              <Children>
                <GrupItem>
                  <TBoolItem>
                    <Name>Default vApplicationGetIdleTaskMemory()</Name>
                    <Symbol>defaultvApplicationGetIdleTaskMemory</Symbol>
                    <TypeSpec>typeYesNo</TypeSpec>
                    <Hint>If enabled, it generates a default vApplicationGetIdleTaskMemory() implementation for the IDLE task.</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <EditLine>false</EditLine>
                    <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
                    <DefaultIndex>0</DefaultIndex>
                    <TextValueIndex>false</TextValueIndex>
                    <RuntimeProperty>false</RuntimeProperty>
                    <CanDelete>false</CanDelete>
                    <IconPopup>false</IconPopup>
                    <DefaultValue>true</DefaultValue>
                    <Popup>false</Popup>
                  </TBoolItem>
                </GrupItem>
                <GrupItem>
                  <TBoolItem>
                    <Name>Default vApplicationGetTimerTaskMemory()</Name>
                    <Symbol>defaultvApplicationGetTimerTaskMemory</Symbol>
                    <TypeSpec>typeYesNo</TypeSpec>
                    <Hint>If enabled, it generates a default vApplicationGetTimerTaskMemory() implementation for the timer task.</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <EditLine>false</EditLine>
                    <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
                    <DefaultIndex>0</DefaultIndex>
                    <TextValueIndex>false</TextValueIndex>
                    <RuntimeProperty>false</RuntimeProperty>
                    <CanDelete>false</CanDelete>
                    <IconPopup>false</IconPopup>
                    <DefaultValue>true</DefaultValue>
                    <Popup>false</Popup>
                  </TBoolItem>
                </GrupItem>
              </Children>
            </TBoolGrupItem>
          </GrupItem>
          <GrupItem>
            <TBoolGrupItem>
              <Name>User Memory Section</Name>
              <Symbol>UserHeapSectionEnabled</Symbol>
              <TypeSpec>typeEnaDis</TypeSpec>
              <Hint>An optional user section attribute can be provided to place the heap/memory into a user section. This is for example needed for the Kinetis K series where the RAM area is splitted. With this, e.g.  __attribute__((section (".m_data_20000000"))) can be specified for the heap object in heap.c</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <BoldName>true</BoldName>
              <EditLine>false</EditLine>
              <Description>Disabled</Description>
              <Expanded>No</Expanded>
              <DefaultValue>false</DefaultValue>
              <DefineSymbol>YES_NO</DefineSymbol>
              <IfDisabled>setNOTHING</IfDisabled>
              <Children>
                <GrupItem>
                  <TStrgItem>
                    <Name>Heap Section Name</Name>
                    <Symbol>HeapSectionName</Symbol>
                    <Hint>Use ".m_data_20000000" for gcc, and "m_data_20000000" for IAR. The following will be added to the heap variable: __attribute__((section ("sectionName"))). For IAR a similar construct is used.</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <EditLine>true</EditLine>
                    <DefaultValue>.m_data_20000000</DefaultValue>
                    <StrDefine>nothing</StrDefine>
                    <MinLength>0</MinLength>
                    <MaxLength>-1</MaxLength>
                  </TStrgItem>
                </GrupItem>
              </Children>
            </TBoolGrupItem>
          </GrupItem>
        </Children>
      </TGrupItem>
    </Property>
    <Property>
      <TGrupItem>
        <Name>RTOS Adaptor</Name>
        <Symbol>RTOSAdaptorGrp</Symbol>
        <TypeSpec>typeYesNo</TypeSpec>
        <Hint>Contains the RTOS specific settings. RTOS adaptor is a part of RTOS component which handles the integration of HAL into specific RTOS.</Hint>
        <ItemLevel>EXPERT</ItemLevel>
        <BoldName>true</BoldName>
        <EditLine>false</EditLine>
        <Description>Configures the RTOS adapter settings</Description>
        <Expanded>Yes</Expanded>
        <Children>
          <GrupItem>
            <TGrupItem>
              <Name>Memory allocation</Name>
              <Symbol>MemoryAllocationGroup</Symbol>
              <TypeSpec>typeYesNo</TypeSpec>
              <Hint>Definition of the RTOS API which provides the memory allocation functionality for HAL driver code.</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <BoldName>true</BoldName>
              <EditLine>false</EditLine>
              <Description>Configures how memory is allocated and deallocated.</Description>
              <Expanded>Yes</Expanded>
              <Children>
                <GrupItem>
                  <TBoolGrupItem>
                    <Name>User function for memory allocation</Name>
                    <Symbol>hasUserMallocFun</Symbol>
                    <TypeSpec>typeYesNo</TypeSpec>
                    <Hint>The memory allocation function should allocate the specified number of bytes of memory and return the address of the allocated space. The allocated memory area type should be suitable for usage by RTOS component. If there is an error, it should return NULL pointer.</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <BoldName>true</BoldName>
                    <EditLine>false</EditLine>
                    <Description>no</Description>
                    <Expanded>No</Expanded>
                    <DefaultValue>false</DefaultValue>
                    <DefineSymbol>YES_NO</DefineSymbol>
                    <IfDisabled>setNOTHING</IfDisabled>
                    <Children>
                      <GrupItem>
                        <TStrgItem>
                          <Name>User function name</Name>
                          <Symbol>userMallocFunName</Symbol>
                          <Hint>The name of the user function (see above for description).</Hint>
                          <ItemLevel>BASIC</ItemLevel>
                          <EditLine>true</EditLine>
                          <DefaultValue>malloc</DefaultValue>
                          <StrDefine>nothing</StrDefine>
                          <MinLength>0</MinLength>
                          <MaxLength>-1</MaxLength>
                        </TStrgItem>
                      </GrupItem>
                    </Children>
                  </TBoolGrupItem>
                </GrupItem>
                <GrupItem>
                  <TBoolGrupItem>
                    <Name>User function for memory deallocation</Name>
                    <Symbol>hasUserDeallocFun</Symbol>
                    <TypeSpec>typeYesNo</TypeSpec>
                    <Hint>The memory deallocation function should free the memory area allocated by the memory allocation function. The function can be called only for areas allocated by a pair memory allocation function (see property hasUserMallocFun User function for memory allocation.</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <BoldName>true</BoldName>
                    <EditLine>false</EditLine>
                    <Description>no</Description>
                    <Expanded>No</Expanded>
                    <DefaultValue>false</DefaultValue>
                    <DefineSymbol>YES_NO</DefineSymbol>
                    <IfDisabled>setNOTHING</IfDisabled>
                    <Children>
                      <GrupItem>
                        <TStrgItem>
                          <Name>User function name</Name>
                          <Symbol>userDeallocFunName</Symbol>
                          <Hint>The name of the user function (see above for description).</Hint>
                          <ItemLevel>BASIC</ItemLevel>
                          <EditLine>true</EditLine>
                          <DefaultValue>free</DefaultValue>
                          <StrDefine>nothing</StrDefine>
                          <MinLength>0</MinLength>
                          <MaxLength>-1</MaxLength>
                        </TStrgItem>
                      </GrupItem>
                    </Children>
                  </TBoolGrupItem>
                </GrupItem>
              </Children>
            </TGrupItem>
          </GrupItem>
          <GrupItem>
            <TGrupItem>
              <Name>Critical section</Name>
              <Symbol>CriticalSectionGroup</Symbol>
              <TypeSpec>typeYesNo</TypeSpec>
              <Hint>Definition of the RTOS API which provides the critical section handling for HAL driver code.</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <BoldName>true</BoldName>
              <EditLine>false</EditLine>
              <Description>Configures how critical sections are handled.</Description>
              <Expanded>Yes</Expanded>
              <Children>
                <GrupItem>
                  <TBoolGrupItem>
                    <Name>User function for entering critical section</Name>
                    <Symbol>hasUserEnterCriticalFun</Symbol>
                    <TypeSpec>typeYesNo</TypeSpec>
                    <Hint>The open critical section function should introduce the code what cannot be interrupted by the ISRs. Such function can be also called from ISRs and/or within context where ISRs are already disabled. In this situation the function has no effect (except that the pair call to critical section close function will be also ignored - see property hasUserExitCriticalFun. The function has no parameters and returns no value.</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <BoldName>true</BoldName>
                    <EditLine>false</EditLine>
                    <Description>no</Description>
                    <Expanded>No</Expanded>
                    <DefaultValue>false</DefaultValue>
                    <DefineSymbol>YES_NO</DefineSymbol>
                    <IfDisabled>setNOTHING</IfDisabled>
                    <Children>
                      <GrupItem>
                        <TStrgItem>
                          <Name>User function name</Name>
                          <Symbol>userEnterCriticalFunName</Symbol>
                          <Hint>The name of the user function (see above for description).</Hint>
                          <ItemLevel>BASIC</ItemLevel>
                          <EditLine>true</EditLine>
                          <DefaultValue>EnterCritical</DefaultValue>
                          <StrDefine>nothing</StrDefine>
                          <MinLength>0</MinLength>
                          <MaxLength>-1</MaxLength>
                        </TStrgItem>
                      </GrupItem>
                    </Children>
                  </TBoolGrupItem>
                </GrupItem>
                <GrupItem>
                  <TBoolGrupItem>
                    <Name>User function for exiting critical section</Name>
                    <Symbol>hasUserExitCriticalFun</Symbol>
                    <TypeSpec>typeYesNo</TypeSpec>
                    <Hint>The close critical section function should terminate the code what cannot be interrupted by the ISRs. Such function need always to have a pair open critical section call (see property hasUserEnterCriticalFun. If call to the pair open critical section was ignored, the respective close should be also ignored. The function has no parameters and returns no value.</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <BoldName>true</BoldName>
                    <EditLine>false</EditLine>
                    <Description>no</Description>
                    <Expanded>No</Expanded>
                    <DefaultValue>false</DefaultValue>
                    <DefineSymbol>YES_NO</DefineSymbol>
                    <IfDisabled>setNOTHING</IfDisabled>
                    <Children>
                      <GrupItem>
                        <TStrgItem>
                          <Name>User function name</Name>
                          <Symbol>userExitCriticalFunName</Symbol>
                          <Hint>The name of the user function (see above for description).</Hint>
                          <ItemLevel>BASIC</ItemLevel>
                          <EditLine>true</EditLine>
                          <DefaultValue>ExitCritical</DefaultValue>
                          <StrDefine>nothing</StrDefine>
                          <MinLength>0</MinLength>
                          <MaxLength>-1</MaxLength>
                        </TStrgItem>
                      </GrupItem>
                    </Children>
                  </TBoolGrupItem>
                </GrupItem>
              </Children>
            </TGrupItem>
          </GrupItem>
        </Children>
      </TGrupItem>
    </Property>
    <Property>
      <TBoolGrupItem>
        <Name>Shell</Name>
        <Symbol>ShellEnabled</Symbol>
        <TypeSpec>typeEnaDis</TypeSpec>
        <Hint>If shell support shall be added or not. If enabled, will enable 'Use Trace Facility' (configUSE_TRACE_FACILITY).</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <BoldName>true</BoldName>
        <EditLine>false</EditLine>
        <Description>Disabled</Description>
        <Expanded>No</Expanded>
        <DefaultValue>false</DefaultValue>
        <DefineSymbol>YES_NO</DefineSymbol>
        <IfDisabled>setNOTHING</IfDisabled>
        <Children>
          <GrupItem>
            <TIntgItem>
              <Name>Max number of tasks</Name>
              <Symbol>ShellMaxNofTasks</Symbol>
              <Hint>Maximum number of tasks, used for the tasklist command.</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue>16</DefaultValue>
              <MinValue>1</MinValue>
              <MaxValue>-1</MaxValue>
              <Bases>DEC</Bases>
              <DefaultBase>DEC</DefaultBase>
              <ExtraHintDisabled>false</ExtraHintDisabled>
              <ChangeValueIntoRange>false</ChangeValueIntoRange>
              <RuntimeProperty>false</RuntimeProperty>
            </TIntgItem>
          </GrupItem>
          <GrupItem>
            <TInhrLinkItem>
              <Name>Shell</Name>
              <Symbol>Shell</Symbol>
              <TypeSpec>FreeRTOS\Shell</TypeSpec>
              <Hint>Interface to shell</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>false</EditLine>
              <DefaultValue/>
              <CanDelete>false</CanDelete>
              <IconPopup>false</IconPopup>
              <SortStyle/>
            </TInhrLinkItem>
          </GrupItem>
        </Children>
      </TBoolGrupItem>
    </Property>
    <Property>
      <TInhrLinkItem>
        <Name>Utility</Name>
        <Symbol>Utility</Symbol>
        <TypeSpec>Utility_I</TypeSpec>
        <Hint>Interface to utility functions</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <DefaultValue/>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <SortStyle/>
      </TInhrLinkItem>
    </Property>
  </PropertyList>
  <MethodList>
    <Method>
      <TMthdItem>
        <Name>xTaskCreate</Name>
        <Symbol>xTaskCreate</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Create a new task and add it to the list of tasks that are ready to run.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>portBASE_TYPE</ReturnType>
        <RetHint>pdPASS if the task was successfully created and added to a ready list, otherwise an error code defined in the file projdefs.h</RetHint>
        <ParamCount>6</ParamCount>
        <Parameter>
          <ParName>pvTaskCode</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Pointer to the task entry function. Tasks must be implemented to never return (i.e. continuous loop).</ParHint>
          <ParUserDeclaration>pdTASK_CODE pvTaskCode</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>pcName</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>A descriptive name for the task. This is mainly used to facilitate debugging. Max length defined by configMAX_TASK_NAME_LEN.</ParHint>
          <ParUserDeclaration>const portCHAR * const pcName</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>usStackDepth</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The size of the task stack specified as the number of variables the stack can hold - not the number of bytes. For example, if the stack is 16 bits wide and usStackDepth is defined as 100, 200 bytes will be allocated for stack storage. The stack depth multiplied by the stack width must not exceed the maximum value that can be contained in a variable of type size_t.</ParHint>
          <ParUserDeclaration>unsigned portSHORT usStackDepth</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>pvParameters</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Pointer that will be used as the parameter for the task being created.</ParHint>
          <ParUserDeclaration>void *pvParameters</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>uxPriority</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The priority at which the task should run.</ParHint>
          <ParUserDeclaration>unsigned portBASE_TYPE uxPriority</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>pvCreatedTask</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Used to pass back a handle by which the created task can be referenced.</ParHint>
          <ParUserDeclaration>xTaskHandle *pvCreatedTask</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>portBASE_TYPE #M#_#C#(pdTASK_CODE pvTaskCode, const portCHAR * const pcName, unsigned portSHORT usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pvCreatedTask)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xTaskCreateStatic</Name>
        <Symbol>xTaskCreateStatic</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Create a new task and add it to the list of tasks that are ready to run.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>TaskHandle_t</ReturnType>
        <RetHint>Task handle if the task was successfully created and added to a ready list, otherwise Null.</RetHint>
        <ParamCount>7</ParamCount>
        <Parameter>
          <ParName>pvTaskCode</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Pointer to the task entry function. Tasks must be implemented to never return (i.e. continuous loop).</ParHint>
          <ParUserDeclaration>pdTASK_CODE pvTaskCode</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>pcName</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>A descriptive name for the task. This is mainly used to facilitate debugging. Max length defined by configMAX_TASK_NAME_LEN.</ParHint>
          <ParUserDeclaration>const portCHAR * const pcName</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>usStackDepth</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The size of the task stack specified as the number of variables the stack can hold - not the number of bytes. For example, if the stack is 16 bits wide and usStackDepth is defined as 100, 200 bytes will be allocated for stack storage. The stack depth multiplied by the stack width must not exceed the maximum value that can be contained in a variable of type size_t.</ParHint>
          <ParUserDeclaration>unsigned portSHORT usStackDepth</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>pvParameters</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Pointer that will be used as the parameter for the task being created.</ParHint>
          <ParUserDeclaration>void *pvParameters</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>uxPriority</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The priority at which the task should run.</ParHint>
          <ParUserDeclaration>unsigned portBASE_TYPE uxPriority</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>puxStackBuffer</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Must point to a StackType_t array that has at least ulStackDepth indexes (see the ulStackDepth parameter above) - the array will be used as the task's stack, so must be persistent (not declared on the stack of a function)</ParHint>
          <ParUserDeclaration>StackType_t * const puxStackBuffer</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>pxTaskBuffer</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Must point to a variable of type StaticTask_t. The variable will be used to hold the new task's data structures (TCB), so it must be persistent (not declared on the stack of a function). </ParHint>
          <ParUserDeclaration>StaticTask_t * const pxTaskBuffer</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>TaskHandle_t #M#_#C#(pdTASK_CODE pvTaskCode, const portCHAR * const pcName, unsigned portSHORT usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, StackType_t * const puxStackBuffer, StaticTask_t * const pxTaskBuffer)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>vTaskDelete</Name>
        <Symbol>vTaskDelete</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Remove a task from the RTOS real time kernels management. The task being deleted will be removed from all ready, blocked, suspended and event lists.\n
NOTE: The idle task is responsible for freeing the kernel allocated memory from tasks that have been deleted. It is therefore important that the idle task is not starved of microcontroller processing time if your application makes any calls to vTaskDelete (). Memory allocated by the task code is not automatically freed, and should be freed before the task is deleted.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>1</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>false</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>pxTask</ParName>
          <ParType>xTaskHandle</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The handle of the task to be deleted. Passing NULL will cause the calling task to be deleted.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(xTaskHandle pxTask)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>vTaskStartScheduler</Name>
        <Symbol>vTaskStartScheduler</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Starts the real time kernel tick processing. After calling the kernel has control over which tasks are executed and when.\n
The idle task is created automatically when vTaskStartScheduler() is called.\n
If vTaskStartScheduler() is successful the function will not return until an executing task calls vTaskEndScheduler(). The function might fail and return immediately if there is insufficient RAM available for the idle task to be created.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>vTaskEndScheduler</Name>
        <Symbol>vTaskEndScheduler</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Stops the real time kernel tick. All created tasks will be automatically deleted and multitasking (either preemptive or cooperative) will stop. Execution then resumes from the point where vTaskStartScheduler() was called, as if vTaskStartScheduler() had just returned.\n
\n
See the demo application file main. c in the demo/PC directory for an example that uses vTaskEndScheduler ().\n
\n
vTaskEndScheduler () requires an exit function to be defined within the portable layer (see vPortEndScheduler () in port. c for the PC port). This performs hardware specific operations such as stopping the kernel tick.\n
\n
vTaskEndScheduler () will cause all of the resources allocated by the kernel to be freed - but will not free resources allocated by application tasks.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>1</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>false</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>vTaskSuspend</Name>
        <Symbol>vTaskSuspend</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Suspend any task. When suspended a task will never get any microcontroller processing time, no matter what its priority. Calls to vTaskSuspend are not accumulative - i.e. calling vTaskSuspend() twice on the same task still only requires one call to vTaskResume() to ready the suspended task.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>pxTaskToSuspend</ParName>
          <ParType>xTaskHandle</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Handle to the task being suspended. Passing a NULL handle will cause the calling task to be suspended.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(xTaskHandle pxTaskToSuspend)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>vTaskSuspendAll</Name>
        <Symbol>vTaskSuspendAll</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Suspends all real time kernel activity while keeping interrupts (including the kernel tick) enabled.\n
After calling vTaskSuspendAll () the calling task will continue to execute without risk of being swapped out until a call to xTaskResumeAll () has been made.\n
API functions that have the potential to cause a context switch (for example, vTaskDelayUntil(), xQueueSend(), etc.) must not be called while the scheduler is suspended.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>vTaskResume</Name>
        <Symbol>vTaskResume</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Resumes a suspended task. A task that has been suspended by one of more calls to vTaskSuspend() will be made available for running again by a single call to vTaskResume().</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>pxTaskToResume</ParName>
          <ParType>xTaskHandle</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Handle to the task being readied.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(xTaskHandle pxTaskToResume)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xTaskResumeAll</Name>
        <Symbol>xTaskResumeAll</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Resumes real time kernel activity following a call to vTaskSuspendAll (). After a call to xTaskSuspendAll () the kernel will take control of which task is executing at any time.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>portBASE_TYPE</ReturnType>
        <RetHint>If resuming the scheduler caused a context switch then pdTRUE is returned, otherwise pdFALSE is returned.</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>portBASE_TYPE #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xTaskResumeFromISR</Name>
        <Symbol>xTaskResumeFromISR</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>An implementation of vTaskResume() that can be called from within an ISR. A task that has been suspended by one of more calls to vTaskSuspend() will be made available for running again by a single call to xTaskResumeFromISR().</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>portBASE_TYPE</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>pxTaskToResume</ParName>
          <ParType>xTaskHandle</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Handle to the task being readied.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>portBASE_TYPE #M#_#C#(xTaskHandle pxTaskToResume)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>vTaskStepTick</Name>
        <Symbol>vTaskStepTick</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint> If the RTOS is configured to use tickless idle functionality then the tick interrupt will be stopped, and the microcontroller placed into a low power state, whenever the Idle task is the only task able to execute. Upon exiting the low power state the tick count value must be corrected to account for the time that passed while it was stopped.\n
\n
If a FreeRTOS port includes a default portSUPPRESS_TICKS_AND_SLEEP() implementation, then vTaskStepTick() is used internally to ensure the correct tick count value is maintained. vTaskStepTick() is a public API function to allow the default portSUPPRESS_TICKS_AND_SLEEP() implementation to be overridden, and for a portSUPPRESS_TICKS_AND_SLEEP() to be provided if the port being used does not provide a default. </Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>1</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>false</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>xTicksToJump</ParName>
          <ParType>portTickType</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The number of RTOS ticks that have passed since the tick interrupt was stopped. For correct operation the parameter must be less than or equal to the portSUPPRESS_TICKS_AND_SLEEP() parameter. </ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(portTickType xTicksToJump)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xTaskAbortDelay</Name>
        <Symbol>xTaskAbortDelay</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Forces a task to leave the Blocked state, and enter the Ready state, even if the event the task was in the Blocked state to wait for has not occurred, and any specified timeout has not expired. </Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>1</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>false</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>BaseType_t</ReturnType>
        <RetHint>If the task referenced by xTask was not in the Blocked state then pdFAIL is returned. Otherwise pdPASS is returned. </RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>xTask</ParName>
          <ParType>TaskHandle_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The handle of the task that will be forced out of the Blocked state. </ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>BaseType_t #M#_#C#(TaskHandle_t xTask)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>taskYIELD</Name>
        <Symbol>taskYIELD</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Macro for forcing a context switch.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>taskENTER_CRITICAL</Name>
        <Symbol>taskENTER_CRITICAL</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Macro to mark the start of a critical code region. Preemptive context switches cannot occur when in a critical region.\n
\n
NOTE: This may alter the stack (depending on the portable implementation) so must be used with care!</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>taskEXIT_CRITICAL</Name>
        <Symbol>taskEXIT_CRITICAL</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Macro to mark the end of a critical code region. Preemptive context switches cannot occur when in a critical region.\n
\n
NOTE: This may alter the stack (depending on the portable implementation) so must be used with care!</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>taskDISABLE_INTERRUPTS</Name>
        <Symbol>taskDISABLE_INTERRUPTS</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Macro to disable all maskable interrupts.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>taskENABLE_INTERRUPTS</Name>
        <Symbol>taskENABLE_INTERRUPTS</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Macro to enable microcontroller interrupts.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>vTaskDelay</Name>
        <Symbol>vTaskDelay</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Delay a task for a given number of ticks. The actual time that the task remains blocked depends on the tick rate. The macro pdMS_TO_TICKS() can be used to calculate real time from the tick rate - with the resolution of one tick period.\n
\n
vTaskDelay() specifies a time at which the task wishes to unblock relative to the time at which vTaskDelay() is called. For example, specifying a block period of 100 ticks will cause the task to unblock 100 ticks after vTaskDelay() is called. vTaskDelay() does not therefore provide a good method of controlling the frequency of a cyclical task as the path taken through the code, as well as other task and interrupt activity, will effect the frequency at which vTaskDelay() gets called and therefore the time at which the task next executes. See vTaskDelayUntil() for an alternative API function designed to facilitate fixed frequency execution. It does this by specifying an absolute time (rather than a relative time) at which the calling task should unblock. </Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>xTicksToDelay</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The amount of time, in tick periods, that the calling task should block.</ParHint>
          <ParUserDeclaration>portTickType xTicksToDelay</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(portTickType xTicksToDelay)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>vTaskDelayUntil</Name>
        <Symbol>vTaskDelayUntil</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Delay a task until a specified time. This function can be used by cyclical tasks to ensure a constant execution frequency.\n
\n
This function differs from vTaskDelay() in one important aspect: vTaskDelay() specifies a time at which the task wishes to unblock relative to the time at which vTaskDelay() is called, whereas vTaskDelayUntil() specifies an absolute time at which the task wishes to unblock.\n
\n
vTaskDelay() will cause a task to block for the specified number of ticks from the time vTaskDelay() is called. It is therefore difficult to use vTaskDelay() by itself to generate a fixed execution frequency as the time between a task unblocking following a call to vTaskDelay() and that task next calling vTaskDelay() may not be fixed [the task may take a different path though the code between calls, or may get interrupted or preempted a different number of times each time it executes].\n
\n
Whereas vTaskDelay() specifies a wake time relative to the time at which the function is called, vTaskDelayUntil() specifies the absolute (exact) time at which it wishes to unblock.\n
\n
It should be noted that vTaskDelayUntil() will return immediately (without blocking) if it is used to specify a wake time that is already in the past. Therefore a task using vTaskDelayUntil() to execute periodically will have to re-calculate its required wake time if the periodic execution is halted for any reason (for example, the task is temporarily placed into the Suspended state) causing the task to miss one or more periodic executions. This can be detected by checking the variable passed by reference as the pxPreviousWakeTime parameter against the current tick count. This is however not necessary under most usage scenarios.\n
\n
The constant portTICK_RATE_MS can be used to calculate real time from the tick rate - with the resolution of one tick period.\n
\n
This function must not be called while the scheduler has been suspended by a call to vTaskSuspendAll(). </Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>pxPreviousWakeTime</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Pointer to a variable that holds the time at which the task was last unblocked. The variable must be initialised with the current time prior to its first use (see the example below). Following this the variable is automatically updated within vTaskDelayUntil(). </ParHint>
          <ParUserDeclaration>portTickType *pxPreviousWakeTime</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>xTimeIncrement</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The cycle time period. The task will be unblocked at time (*pxPreviousWakeTime + xTimeIncrement). Calling vTaskDelayUntil with the same xTimeIncrement parameter value will cause the task to execute with a fixed interval period. </ParHint>
          <ParUserDeclaration>portTickType xTimeIncrement</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(portTickType *pxPreviousWakeTime, portTickType xTimeIncrement)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>uxTaskPriorityGet</Name>
        <Symbol>uxTaskPriorityGet</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Obtain the priority of any task.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>unsigned_portBASE_TYPE</ReturnType>
        <RetHint>The priority of pxTask.</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>pxTask</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Handle of the task to be queried. Passing a NULL handle results in the priority of the calling task being returned.</ParHint>
          <ParUserDeclaration>xTaskHandle pxTask</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>unsigned_portBASE_TYPE #M#_#C#(xTaskHandle pxTask)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xTaskGetTickCount</Name>
        <Symbol>xTaskGetTickCount</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Return the count of ticks since vTaskStartScheduler was called.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>portTickType</ReturnType>
        <RetHint>tick count</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>portTickType #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xTaskGetTickCountFromISR</Name>
        <Symbol>xTaskGetTickCountFromISR</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>A version of xTaskGetTickCount() that can be called from an ISR. </Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>portTickType</ReturnType>
        <RetHint>The count of ticks since vTaskStartScheduler was called. </RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>portTickType #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>vTaskPrioritySet</Name>
        <Symbol>vTaskPrioritySet</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Set the priority of any task.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>pxTask</ParName>
          <ParType>xTaskHandle</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Handle to the task for which the priority is being set. Passing a NULL handle results in the priority of the calling task being set.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>uxNewPriority</ParName>
          <ParType>unsigned_portBASE_TYPE</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The priority to which the task will be set.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(xTaskHandle pxTask, unsigned_portBASE_TYPE uxNewPriority)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>vSemaphoreCreateBinary</Name>
        <Symbol>vSemaphoreCreateBinary</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Macro that creates a semaphore by using the existing queue mechanism. The queue length is 1 as this is a binary semaphore. The data size is 0 as we don't want to actually store any data - we just want to know if the queue is empty or full.\n
\n
Binary semaphores and mutexes are very similar but have some subtle differences: Mutexes include a priority inheritance mechanism, binary semaphores do not. This makes binary semaphores the better choice for implementing synchronisation (between tasks or between tasks and an interrupt), and mutexes the better choice for implementing simple mutual exclusion.\n
\n
This old vSemaphoreCreateBinary() macro is now deprecated in favour of the xSemaphoreCreateBinary() function.  Note that binary semaphores created using the vSemaphoreCreateBinary() macro are created in a state such that the first call to 'take' the semaphore would pass, whereas binary semaphores created using xSemaphoreCreateBinary() are created in a state such that the the semaphore must first be 'given' before it can be 'taken'.\n
\n
A binary semaphore need not be given back once obtained, so task synchronisation can be implemented by one task/interrupt continuously 'giving' the semaphore while another continuously 'takes' the semaphore. This is demonstrated by the sample code on the xSemaphoreGiveFromISR() documentation page.\n
\n
The priority of a task that 'takes' a mutex can potentially be raised if another task of higher priority attempts to obtain the same mutex. The task that owns the mutex 'inherits' the priority of the task attempting to 'take' the same mutex. This means the mutex must always be 'given' back - otherwise the higher priority task will never be able to obtain the mutex, and the lower priority task will never 'disinherit' the priority. An example of a mutex being used to implement mutual exclusion is provided on the xSemaphoreTake() documentation page.\n
\n
Both mutex and binary semaphores are assigned to variables of type xSemaphoreHandle and can be used in any API function that takes a parameter of this type. </Hint>
        <ItemLevel>@ HIDDEN @</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>void</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>xSemaphore</ParName>
          <ParType>xSemaphoreHandle</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Handle to the created semaphore. Should be of type xSemaphoreHandle.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(xSemaphoreHandle xSemaphore)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xSemaphoreCreateBinary</Name>
        <Symbol>xSemaphoreCreateBinary</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>The old vSemaphoreCreateBinary() macro is now deprecated in favour of this xSemaphoreCreateBinary() function.  Note that binary semaphores created using the vSemaphoreCreateBinary() macro are created in a state such that the first call to 'take' the semaphore would pass, whereas binary semaphores created using xSemaphoreCreateBinary() are created in a state such that the the semaphore must first be 'given' before it can be 'taken'.\n
\n
Function that creates a semaphore by using the existing queue mechanism. The queue length is 1 as this is a binary semaphore.  The data size is 0 as nothing is actually stored - all that is important is whether the queue is empty or full (the binary semaphore is available or not).\n
\n
This type of semaphore can be used for pure synchronisation between tasks or between an interrupt and a task.  The semaphore need not be given back once obtained, so one task/interrupt can continuously 'give' the semaphore while another continuously 'takes' the semaphore.  For this reason this type of semaphore does not use a priority inheritance mechanism.  For an alternative that does use priority inheritance see xSemaphoreCreateMutex().</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>SemaphoreHandle_t</ReturnType>
        <RetHint>Handle to the created semaphore.</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>SemaphoreHandle_t #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xSemaphoreCreateBinaryStatic</Name>
        <Symbol>xSemaphoreCreateBinaryStatic</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>The old vSemaphoreCreateBinary() macro is now deprecated in favour of this xSemaphoreCreateBinary() function.  Note that binary semaphores created using the vSemaphoreCreateBinary() macro are created in a state such that the first call to 'take' the semaphore would pass, whereas binary semaphores created using xSemaphoreCreateBinary() are created in a state such that the the semaphore must first be 'given' before it can be 'taken'.\n
\n
Function that creates a semaphore by using the existing queue mechanism. The queue length is 1 as this is a binary semaphore.  The data size is 0 as nothing is actually stored - all that is important is whether the queue is empty or full (the binary semaphore is available or not).\n
\n
This type of semaphore can be used for pure synchronisation between tasks or between an interrupt and a task.  The semaphore need not be given back once obtained, so one task/interrupt can continuously 'give' the semaphore while another continuously 'takes' the semaphore.  For this reason this type of semaphore does not use a priority inheritance mechanism.  For an alternative that does use priority inheritance see xSemaphoreCreateMutex().</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>SemaphoreHandle_t</ReturnType>
        <RetHint>Handle to the created semaphore.</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>pxSemaphoreBuffer</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Must point to a variable of type StaticSemaphore_t, which will be used to hold the semaphore's state.</ParHint>
          <ParUserDeclaration>StaticSemaphore_t *pxSemaphoreBuffer</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>SemaphoreHandle_t #M#_#C#(StaticSemaphore_t *pxSemaphoreBuffer)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xSemaphoreCreateCounting</Name>
        <Symbol>xSemaphoreCreateCounting</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Macro that creates a counting semaphore by using the existing queue mechanism.\n
\n
Counting semaphores are typically used for two things:\n
\n
1. Counting events.\n
In this usage scenario an event handler will 'give' a semaphore each time an event occurs (incrementing the semaphore count value), and a handler task will 'take' a semaphore each time it processes an event (decrementing the semaphore count value). The count value is therefore the difference between the number of events that have occurred and the number that have been processed. In this case it is desirable for the initial count value to be zero.\n
\n
2. Resource management.\n
In this usage scenario the count value indicates the number of resources available. To obtain control of a resource a task must first obtain a semaphore - decrementing the semaphore count value. When the count value reaches zero there are no free resources. When a task finishes with the resource it 'gives' the semaphore back - incrementing the semaphore count value. In this case it is desirable for the initial count value to be equal to the maximum count value, indicating that all resources are free.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>xSemaphoreHandle</ReturnType>
        <RetHint>xSemaphoreHandle handle</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>uxMaxCount</ParName>
          <ParType>unsigned_portBASE_TYPE</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The maximum count value that can be reached. When the semaphore reaches this value it can no longer be 'given'.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>uxInitialCount</ParName>
          <ParType>unsigned_portBASE_TYPE</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The count value assigned to the semaphore when it is created.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>xSemaphoreHandle #M#_#C#(unsigned_portBASE_TYPE uxMaxCount, unsigned_portBASE_TYPE uxInitialCount)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xSemaphoreCreateCountingStatic</Name>
        <Symbol>xSemaphoreCreateCountingStatic</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Macro that creates a counting semaphore by using the existing queue mechanism.\n
\n
Counting semaphores are typically used for two things:\n
\n
1. Counting events.\n
In this usage scenario an event handler will 'give' a semaphore each time an event occurs (incrementing the semaphore count value), and a handler task will 'take' a semaphore each time it processes an event (decrementing the semaphore count value). The count value is therefore the difference between the number of events that have occurred and the number that have been processed. In this case it is desirable for the initial count value to be zero.\n
\n
2. Resource management.\n
In this usage scenario the count value indicates the number of resources available. To obtain control of a resource a task must first obtain a semaphore - decrementing the semaphore count value. When the count value reaches zero there are no free resources. When a task finishes with the resource it 'gives' the semaphore back - incrementing the semaphore count value. In this case it is desirable for the initial count value to be equal to the maximum count value, indicating that all resources are free.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>xSemaphoreHandle</ReturnType>
        <RetHint>xSemaphoreHandle handle</RetHint>
        <ParamCount>3</ParamCount>
        <Parameter>
          <ParName>uxMaxCount</ParName>
          <ParType>unsigned_portBASE_TYPE</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The maximum count value that can be reached. When the semaphore reaches this value it can no longer be 'given'.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>uxInitialCount</ParName>
          <ParType>unsigned_portBASE_TYPE</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The count value assigned to the semaphore when it is created.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>pxSempahoreBuffer</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Must point to a variable of type StaticSemaphore_t, which is then used to hold the semaphore's data structures.</ParHint>
          <ParUserDeclaration>StaticSemaphore_t pxSempahoreBuffer</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>xSemaphoreHandle #M#_#C#(unsigned_portBASE_TYPE uxMaxCount, unsigned_portBASE_TYPE uxInitialCount, StaticSemaphore_t pxSempahoreBuffer)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xSemaphoreGive</Name>
        <Symbol>xSemaphoreGive</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Macro to release a semaphore. The semaphore must have previously been created with a call to vSemaphoreCreateBinary(), xSemaphoreCreateMutex() or xSemaphoreCreateCounting(), and obtained using sSemaphoreTake().\n
\n
This must not be used from an ISR. See xSemaphoreGiveFromISR() for an alternative which can be used from an ISR.\n
\n
This macro must also not be used on semaphores created using xSemaphoreCreateRecursiveMutex().\n
\n
xSemaphoreGive() is part of the fully featured intertask communications API. xSemaphoreAltGive() is the alternative API equivalent. Both versions require the same parameters and return the same values. </Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>Boolean</ReturnType>
        <RetHint>Returns pdTRUE if the semaphore was given.</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>xMutex</ParName>
          <ParType>xSemaphoreHandle</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>A handle to the mutex being released, or 'given'.  This is the handle returned by xSemaphoreCreateMutex();</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>bool #M#_#C#(xSemaphoreHandle xMutex)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xSemaphoreTake</Name>
        <Symbol>xSemaphoreTake</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Macro to obtain a semaphore. The semaphore must have previously been created with a call to vSemaphoreCreateBinary(), xSemaphoreCreateMutex() or xSemaphoreCreateCounting().\n
\n
This macro must not be called from an ISR. xQueueReceiveFromISR() can be used to take a semaphore from within an interrupt if required, although this would not be a normal operation. Semaphores use queues as their underlying mechanism, so functions are to some extent interoperable.\n
\n
xSemaphoreTake() is part of the fully featured intertask communications API. xSemaphoreAltTake() is the alternative API equivalent. Both versions require the same parameters and return the same values.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>Boolean</ReturnType>
        <RetHint>Returns pdTRUE if the semaphore was obtained.  pdFALSE if xBlockTime expired without the semaphore becoming available.</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>xMutex</ParName>
          <ParType>xSemaphoreHandle</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>A handle to the mutex being obtained.  This is the handle returned by xSemaphoreCreateMutex();</ParHint>
        </Parameter>
        <Parameter>
          <ParName>xBlockTime</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The time in ticks to wait for the semaphore to become available.  The macro portTICK_RATE_MS can be used to convert this to a real time.  A block time of zero can be used to poll the semaphore.  If the task already owns the semaphore then xSemaphoreTakeRecursive() will return immediately no matter what the value of xBlockTime. Specifying the block time as portMAX_DELAY will cause the task to block indefinitely (without a timeout).</ParHint>
          <ParUserDeclaration>portTickType xBlockTime</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>bool #M#_#C#(xSemaphoreHandle xMutex, portTickType xBlockTime)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>uxSemaphoreGetCount</Name>
        <Symbol>uxSemaphoreGetCount</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint/>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>UBaseType_t</ReturnType>
        <RetHint>If the semaphore is a counting semaphore then the semaphores current count value is returned. If the semaphore is a binary semaphore then 1 is returned if the semaphore is available, and 0 is returned if the semaphore is not available. </RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>xSemaphore</ParName>
          <ParType>SemaphoreHandle_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The handle of the semaphore being queried. </ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>UBaseType_t #M#_#C#(SemaphoreHandle_t xSemaphore)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xSemaphoreGiveFromISR</Name>
        <Symbol>xSemaphoreGiveFromISR</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Macro to release a semaphore. The semaphore must have previously been created with a call to vSemaphoreCreateBinary() or xSemaphoreCreateCounting().\n
\n
Mutex type semaphores (those created using a call to xSemaphoreCreateMutex()) must not be used with this macro.\n
\n
This macro can be used from an ISR.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>Boolean</ReturnType>
        <RetHint>Returns pdTRUE if the semaphore was given.</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>xSemaphore</ParName>
          <ParType>xSemaphoreHandle</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>A handle to the semaphore being released. This is the handle returned when the semaphore was created.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>pxHigherPriorityTaskWoken</ParName>
          <ParType>signed_portBASE_TYPE</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>xSemaphoreGiveFromISR() will set *pxHigherPriorityTaskWoken to pdTRUE if giving the semaphoree caused a task to unblock, and the unblocked task has a priority higher than the currently running task. If xSemaphoreGiveFromISR() sets this value to pdTRUE then a context switch should be requested before the interrupt is exited.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>bool #M#_#C#(xSemaphoreHandle xSemaphore, signed_portBASE_TYPE *pxHigherPriorityTaskWoken)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xSemaphoreTakeFromISR</Name>
        <Symbol>xSemaphoreTakeFromISR</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Macro to take a semaphore from an ISR. The semaphore must have previously been created with a call to vSemaphoreCreateBinary() or xSemaphoreCreateCounting().\n
\n
Mutex type semaphores (those created using a call to xSemaphoreCreateMutex()) must not be used with this macro.\n
\n
This macro can be used from an ISR, however taking a semaphore from an ISR is not a common operation.  It is likely to only be useful when taking a counting semaphore when an interrupt is obtaining an object from a resource pool (when the semaphore count indicates the number of resources available).</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>Boolean</ReturnType>
        <RetHint>Returns pdTRUE if the semaphore was given.</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>xSemaphore</ParName>
          <ParType>xSemaphoreHandle</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>A handle to the semaphore being taken. This is the handle returned when the semaphore was created.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>pxHigherPriorityTaskWoken</ParName>
          <ParType>signed_portBASE_TYPE</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>xSemaphoreTakeFromISR() will set *pxHigherPriorityTaskWoken to pdTRUE if taking the semaphore caused a task to unblock, and the unblocked task has a priority higher than the currently running task.  If xSemaphoreTakeFromISR() sets this value to pdTRUE then a context switch should be requested before the interrupt is exited.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>bool #M#_#C#(xSemaphoreHandle xSemaphore, signed_portBASE_TYPE *pxHigherPriorityTaskWoken)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xSemaphoreGetMutexHolder</Name>
        <Symbol>xSemaphoreGetMutexHolder</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Returns the holder of a mutex or semaphore. If xMutex is indeed a mutex type semaphore, return the current mutex holder. If xMutex is not a mutex type semaphore, or the mutex is available (not held by a task), return NULL. Note: This Is is a good way of determining if the calling task is the mutex holder, but not a good way of determining the identity of the mutex holder as the holder may change between the function exiting and the returned value being tested.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>pointer</ReturnType>
        <RetHint>Not NULL if the calling task is the holder of the mutex, NULL otherwise.</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>xSemaphore</ParName>
          <ParType>xSemaphoreHandle</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>A handle to the semaphore.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void* #M#_#C#(xSemaphoreHandle xSemaphore)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xSemaphoreCreateMutex</Name>
        <Symbol>xSemaphoreCreateMutex</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Macro that creates a mutex semaphore by using the existing queue mechanism.\n
\n
Mutexes created using this macro can be accessed using the xSemaphoreTake() and xSemaphoreGive() macros. The xSemaphoreTakeRecursive() and xSemaphoreGiveRecursive() macros should not be used.\n
\n
Mutexes and binary semaphores are very similar but have some subtle differences: Mutexes include a priority inheritance mechanism, binary semaphores do not. This makes binary semaphores the better choice for implementing synchronisation (between tasks or between tasks and an interrupt), and mutexes the better choice for implementing simple mutual exclusion.\n
\n
The priority of a task that 'takes' a mutex can potentially be raised if another task of higher priority attempts to obtain the same mutex. The task that owns the mutex 'inherits' the priority of the task attempting to 'take' the same mutex. This means the mutex must always be 'given' back - otherwise the higher priority task will never be able to obtain the mutex, and the lower priority task will never 'disinherit' the priority. An example of a mutex being used to implement mutual exclusion is provided on the xSemaphoreTake() documentation page.\n
\n
A binary semaphore need not be given back once obtained, so task synchronisation can be implemented by one task/interrupt continuously 'giving' the semaphore while another continuously 'takes' the semaphore. This is demonstrated by the sample code on the xSemaphoreGiveFromISR() documentation page.\n
\n
Both mutex and binary semaphores are assigned to variables of type xSemaphoreHandle and can be used in any API function that takes a parameter of this type. </Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>xSemaphoreHandle</ReturnType>
        <RetHint>Handle to the created mutex semaphore.  Should be of type  xSemaphoreHandle.</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>xSemaphoreHandle #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xSemaphoreCreateMutexStatic</Name>
        <Symbol>xSemaphoreCreateMutexStatic</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Macro that creates a mutex semaphore by using the existing queue mechanism.\n
\n
Mutexes created using this macro can be accessed using the xSemaphoreTake() and xSemaphoreGive() macros. The xSemaphoreTakeRecursive() and xSemaphoreGiveRecursive() macros should not be used.\n
\n
Mutexes and binary semaphores are very similar but have some subtle differences: Mutexes include a priority inheritance mechanism, binary semaphores do not. This makes binary semaphores the better choice for implementing synchronisation (between tasks or between tasks and an interrupt), and mutexes the better choice for implementing simple mutual exclusion.\n
\n
The priority of a task that 'takes' a mutex can potentially be raised if another task of higher priority attempts to obtain the same mutex. The task that owns the mutex 'inherits' the priority of the task attempting to 'take' the same mutex. This means the mutex must always be 'given' back - otherwise the higher priority task will never be able to obtain the mutex, and the lower priority task will never 'disinherit' the priority. An example of a mutex being used to implement mutual exclusion is provided on the xSemaphoreTake() documentation page.\n
\n
A binary semaphore need not be given back once obtained, so task synchronisation can be implemented by one task/interrupt continuously 'giving' the semaphore while another continuously 'takes' the semaphore. This is demonstrated by the sample code on the xSemaphoreGiveFromISR() documentation page.\n
\n
Both mutex and binary semaphores are assigned to variables of type xSemaphoreHandle and can be used in any API function that takes a parameter of this type. </Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>xSemaphoreHandle</ReturnType>
        <RetHint>Handle to the created mutex semaphore.  Should be of type  xSemaphoreHandle.</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>Variable_1</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Must point to a variable of type StaticSemaphore_t, which will be used to hold the mutex type semaphore's state. </ParHint>
          <ParUserDeclaration>StaticSemaphore_t *pxMutexBuffer</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>xSemaphoreHandle #M#_#C#(StaticSemaphore_t *pxMutexBuffer)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xSemaphoreCreateRecursiveMutex</Name>
        <Symbol>xSemaphoreCreateRecursiveMutex</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Macro that implements a recursive mutex by using the existing queue mechanism.\n
Mutexes created using this macro can be accessed using the xSemaphoreTakeRecursive() and xSemaphoreGiveRecursive() macros.  The  xSemaphoreTake() and xSemaphoreGive() macros should not be used.\n
A mutex used recursively can be 'taken' repeatedly by the owner. The mutex doesn't become available again until the owner has called xSemaphoreGiveRecursive() for each successful 'take' request.  For example, if a task successfully 'takes' the same mutex 5 times then the mutex will not be available to any other task until it has also  'given' the mutex back exactly five times.\n
This type of semaphore uses a priority inheritance mechanism so a task 'taking' a semaphore MUST ALWAYS 'give' the semaphore back once the semaphore it is no longer required. Mutex type semaphores cannot be used from within interrupt service routines.\n
See vSemaphoreCreateBinary() for an alternative implementation that can be used for pure synchronisation (where one task or interrupt always 'gives' the semaphore and another always 'takes' the semaphore) and from within interrupt service routines.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>xSemaphoreHandle</ReturnType>
        <RetHint>Handle to the created mutex semaphore.  Should be of type  xSemaphoreHandle.</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>xSemaphoreHandle #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xSemaphoreCreateRecursiveMutexStatic</Name>
        <Symbol>xSemaphoreCreateRecursiveMutexStatic</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Macro that implements a recursive mutex by using the existing queue mechanism.\n
Mutexes created using this macro can be accessed using the xSemaphoreTakeRecursive() and xSemaphoreGiveRecursive() macros.  The  xSemaphoreTake() and xSemaphoreGive() macros should not be used.\n
A mutex used recursively can be 'taken' repeatedly by the owner. The mutex doesn't become available again until the owner has called xSemaphoreGiveRecursive() for each successful 'take' request.  For example, if a task successfully 'takes' the same mutex 5 times then the mutex will not be available to any other task until it has also  'given' the mutex back exactly five times.\n
This type of semaphore uses a priority inheritance mechanism so a task 'taking' a semaphore MUST ALWAYS 'give' the semaphore back once the semaphore it is no longer required. Mutex type semaphores cannot be used from within interrupt service routines.\n
See vSemaphoreCreateBinary() for an alternative implementation that can be used for pure synchronisation (where one task or interrupt always 'gives' the semaphore and another always 'takes' the semaphore) and from within interrupt service routines.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>xSemaphoreHandle</ReturnType>
        <RetHint>Handle to the created mutex semaphore.  Should be of type  xSemaphoreHandle.</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>Variable_1</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Must point to a variable of type StaticSemaphore_t, which will be used to hold the mutex type semaphore's state. </ParHint>
          <ParUserDeclaration>StaticSemaphore_t *pxMutexBuffer</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>xSemaphoreHandle #M#_#C#(StaticSemaphore_t *pxMutexBuffer)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xSemaphoreTakeRecursive</Name>
        <Symbol>xSemaphoreTakeRecursive</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Macro to recursively obtain, or 'take', a mutex type semaphore. The mutex must have previously been created using a call to xSemaphoreCreateRecursiveMutex();\n
This macro must not be used on mutexes created using xSemaphoreCreateMutex(). A mutex used recursively can be 'taken' repeatedly by the owner. The mutex doesn't become available again until the owner has called xSemaphoreGiveRecursive() for each successful 'take' request.  For example, if a task successfully 'takes' the same mutex 5 times then the mutex will not be available to any other task until it has also  'given' the mutex back exactly five times.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>Boolean</ReturnType>
        <RetHint>Returns pdTRUE if the semaphore was obtained.  pdFALSE if xBlockTime expired without the semaphore becoming available.</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>xMutex</ParName>
          <ParType>xSemaphoreHandle</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>A handle to the mutex being obtained.  This is the handle returned by xSemaphoreCreateRecursiveMutex();</ParHint>
        </Parameter>
        <Parameter>
          <ParName>xBlockTime</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The time in ticks to wait for the semaphore to become available.  The macro portTICK_RATE_MS can be used to convert this to a real time.  A block time of zero can be used to poll the semaphore.  If the task already owns the semaphore then xSemaphoreTakeRecursive() will return immediately no matter what the value of xBlockTime.</ParHint>
          <ParUserDeclaration>portTickType xBlockTime</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>bool #M#_#C#(xSemaphoreHandle xMutex, portTickType xBlockTime)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xSemaphoreGiveRecursive</Name>
        <Symbol>xSemaphoreGiveRecursive</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Macro to recursively release, or 'give', a mutex type semaphore. The mutex must have previously been created using a call to xSemaphoreCreateRecursiveMutex();\n
This macro must not be used on mutexes created using xSemaphoreCreateMutex(). A mutex used recursively can be 'taken' repeatedly by the owner. The mutex doesn't become available again until the owner has called xSemaphoreGiveRecursive() for each successful 'take' request.  For example, if a task successfully 'takes' the same mutex 5 times then the mutex will not be available to any other task until it has also  'given' the mutex back exactly five times.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>Boolean</ReturnType>
        <RetHint>Returns pdTRUE if the semaphore was given.</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>xMutex</ParName>
          <ParType>xSemaphoreHandle</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>A handle to the mutex being released, or 'given'.  This is the handle returned by xSemaphoreCreateMutex();</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>bool #M#_#C#(xSemaphoreHandle xMutex)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>vSemaphoreDelete</Name>
        <Symbol>vSemaphoreDelete</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Delete a semaphore.  This function must be used with care.  For example, do not delete a mutex type semaphore if the mutex is held by a task.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>void</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>xSemaphore</ParName>
          <ParType>xSemaphoreHandle</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>A handle to the semaphore to be deleted.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(xSemaphoreHandle xSemaphore)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>pvPortMalloc</Name>
        <Symbol>pvPortMalloc</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Allocates a memory block using the port pvPortMalloc() function</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>pVoid</ReturnType>
        <RetHint>memory block or NULL if failed</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>xWantedSize</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>size of memory block requested</ParHint>
          <ParUserDeclaration>size_t xWantedSize</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>pVoid #M#_#C#(size_t xWantedSize)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>vPortFree</Name>
        <Symbol>vPortFree</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Frees a memory block previously allocated with pvPortMalloc()</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>pv</ParName>
          <ParType>Boolean</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to data</ParHint>
          <ParUserDeclaration>void *pv</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(void *pv)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xPortGetFreeHeapSize</Name>
        <Symbol>xPortGetFreeHeapSize</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Returns the actual free size of the heap</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>Tsize_t</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>Tsize_t #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>vTaskSetApplicationTaskTag</Name>
        <Symbol>vTaskSetApplicationTaskTag</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>A 'tag' value can be assigned to each task. This value is for the use of the application only - the RTOS kernel itself does not make use of it in any way.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>1</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>false</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>3</ParamCount>
        <Parameter>
          <ParName>xTask</ParName>
          <ParType>xTaskHandle</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The handle of the task to which a tag value is being assigned. Passing xTask as NULL causes the tag to be assigned to the calling task.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>pxHookFunction</ParName>
          <ParType>pdTASK_HOOK_CODE</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The value being assigned to the task tag. This is of type pdTASK_HOOK_CODE to permit a function pointer to be assigned as the tag, although any value can actually be assigned. See the example below.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>Variable_1</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint/>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(xTaskHandle xTask, pdTASK_HOOK_CODE pxHookFunction, byte Variable_1)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xTaskGetApplicationTaskTag</Name>
        <Symbol>xTaskGetApplicationTaskTag</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Returns the ‘tag’ value associated with a task. The meaning and use of the tag value is defined by the application writer. The RTOS kernel itself will not normally access the tag value. </Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>1</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>false</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>pdTASK_HOOK_CODE</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>xTask</ParName>
          <ParType>xTaskHandle</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The handle of the task being queried. A task can query its own tag value by using NULL as the parameter value.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>pdTASK_HOOK_CODE #M#_#C#(xTaskHandle xTask)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xTaskCallApplicationTaskHook</Name>
        <Symbol>xTaskCallApplicationTaskHook</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint> A 'tag' value can be assigned to each task. Normally this value is for the use of the application only and the RTOS kernel does not access it. However, it is possible to use the tag to assign a hook (or callback) function to a task - the hook function being executed by calling xTaskCallApplicationTaskHook(). Each task can define its own callback, or simply not define a callback at all.\n
\n
Although it is possible to use the first function parameter to call the hook function of any task, the most common use of task hook function is with the trace hook macros, as per the example given below.\n
\n
Task hook functions must have type pdTASK_HOOK_CODE, that is take a void * parameter, and return a value of type portBASE_TYPE. The void * parameter can be used to pass any information into the hook function. </Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>1</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>false</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>portBASE_TYPE</ReturnType>
        <RetHint>return value</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>xTask</ParName>
          <ParType>xTaskHandle</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The handle of the task whose hook function is being called. Passing NULL as xTask will call the hook function associated with the currently executing task.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>pvParameter</ParName>
          <ParType>pointer</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The value to pass to the hook function. This can be a pointer to a structure, or simply a numeric value.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>portBASE_TYPE #M#_#C#(xTaskHandle xTask, void* pvParameter)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xTaskGetCurrentTaskHandle</Name>
        <Symbol>xTaskGetCurrentTaskHandle</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>The handle of the currently running (calling) task.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>xTaskHandle</ReturnType>
        <RetHint>The handle of the currently running (calling) task.</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>xTaskHandle #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xTaskGetIdleTaskHandle</Name>
        <Symbol>xTaskGetIdleTaskHandle</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>The task handle associated with the Idle task. The Idle task is created automatically when the RTOS scheduler is started.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>xTaskHandle</ReturnType>
        <RetHint>The task handle associated with the Idle task. The Idle task is created automatically when the RTOS scheduler is started.</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>xTaskHandle #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xTaskGetHandle</Name>
        <Symbol>xTaskGetHandle</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Looks up the handle of a task from the task's name. </Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>TaskHandle_t</ReturnType>
        <RetHint>If a task that has the name passed in pcNameToQuery can be located then the handle of the task is returned, otherwise NULL is returned. </RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>pcNameToQuery</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>The text name (as a standard C NULL terminated string) of the task for which the handle will be returned.</ParHint>
          <ParUserDeclaration>const char *pcNameToQuery </ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>TaskHandle_t #M#_#C#(const char *pcNameToQuery )</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>pcTaskGetTaskName</Name>
        <Symbol>pcTaskGetTaskName</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Returns the name of the task.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>8bit signed</ReturnType>
        <RetHint>A pointer to the subject tasks name, which is a standard NULL terminated C string</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>xTaskToQuery</ParName>
          <ParType>xTaskHandle</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The handle of the task being queried. xTaskToQuery can be set to NULL to query the name of the calling task.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>signed char #M#_#C#(xTaskHandle xTaskToQuery)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>eTaskGetState</Name>
        <Symbol>eTaskGetState</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Returns as an enumerated type the state in which a task existed at the time eTaskGetState() was executed. </Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>1</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>false</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>eTaskState</ReturnType>
        <RetHint>task state (eReady, eRunning, eBlocked, eSuspended, eDeleted)</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>xTask</ParName>
          <ParType>xTaskHandle</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The handle of the subject task (the task being queried).</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>eTaskState #M#_#C#(xTaskHandle xTask)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xTaskGetSchedulerState</Name>
        <Symbol>xTaskGetSchedulerState</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Returns the state of the scheduler</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>portBASE_TYPE</ReturnType>
        <RetHint>One of the following constants (defined within task.h): taskSCHEDULER_NOT_STARTED, taskSCHEDULER_RUNNING, taskSCHEDULER_SUSPENDED.</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>portBASE_TYPE #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>vTaskList</Name>
        <Symbol>vTaskList</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>configUSE_TRACE_FACILITY, INCLUDE_vTaskDelete and INCLUDE_vTaskSuspend must all be defined as 1 for this function to be available. See the configuration section for more information.\n
NOTE: This function will disable interrupts for its duration.  It is not intended for normal application runtime use but as a debug aid. Lists all the current tasks, along with their current state and stack usage high water mark.\n
Tasks are reported as blocked ('B'), ready ('R'), deleted ('D') or suspended ('S').</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>pcWriteBuffer</ParName>
          <ParType>8bit signed</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to buffer. A buffer into which the above mentioned details will be written, in ascii form.  This buffer is assumed to be large enough to contain the generated report.  Approximately 40 bytes per task should be sufficient.</ParHint>
          <ParUserDeclaration>signed portCHAR *pcWriteBuffer</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>bufSize</ParName>
          <ParType>uint16_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>size of buffer</ParHint>
          <ParUserDeclaration>size_t bufSize</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(signed portCHAR *pcWriteBuffer, size_t bufSize)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>uxTaskGetStackHighWaterMark</Name>
        <Symbol>uxTaskGetStackHighWaterMark</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>The stack used by a task will grow and shrink as the task executes and interrupts are processed. uxTaskGetStackHighWaterMark() returns the minimum amount of remaining stack space that was available to the task since the task started executing - that is the amount of stack that remained unused when the task stack was at its greatest (deepest) value. This is what is referred to as the stack 'high water mark'.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>unsigned_portBASE_TYPE</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>xTask</ParName>
          <ParType>xTaskHandle</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The handle of the task being queried. A task may query its own high water mark by passing NULL as the xTask parameter.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>unsigned_portBASE_TYPE #M#_#C#(xTaskHandle xTask)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>uxTaskGetNumberOfTasks</Name>
        <Symbol>uxTaskGetNumberOfTasks</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Returns the number of tasks</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>unsigned_portBASE_TYPE</ReturnType>
        <RetHint>number of tasks</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>unsigned_portBASE_TYPE #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>vTaskGetRunTimeStats</Name>
        <Symbol>vTaskGetRunTimeStats</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>configGENERATE_RUN_TIME_STATS must be defined as 1 for this function to be available. The application must also then provide definitions for portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() and portGET_RUN_TIME_COUNTER_VALUE to configure a peripheral timer/counter and return the timers current count value respectively. The counter should be at least 10 times the frequency of the tick count.\n
NOTE: This function will disable interrupts for its duration. It is not intended for normal application runtime use but as a debug aid.\n
Setting configGENERATE_RUN_TIME_STATS to 1 will result in a total accumulated execution time being stored for each task. The resolution of the accumulated time value depends on the frequency of the timer configured by the portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() macro. Calling vTaskGetRunTimeStats() writes the total execution time of each task into a buffer, both as an absolute count value and as a percentage of the total system execution time. </Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>pcWriteBuffer</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>A buffer into which the execution times will be written, in ascii form. This buffer is assumed to be large enough to contain the generated report. Approximately 40 bytes per task should be sufficient. </ParHint>
          <ParUserDeclaration>portCHAR *pcWriteBuffer</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>bufSize</ParName>
          <ParType>16bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>size of buffer</ParHint>
          <ParUserDeclaration>size_t bufSize</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(portCHAR *pcWriteBuffer, size_t bufSize)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>uxQueueMessagesWaiting</Name>
        <Symbol>uxQueueMessagesWaiting</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Queries the number of items that are currently held within a queue.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>unsigned_portBASE_TYPE</ReturnType>
        <RetHint>The number of items that are held within the queue being queried.</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>xQueue</ParName>
          <ParType>xQueueHandle</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The handle of the queue being queried.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>unsigned_portBASE_TYPE #M#_#C#(xQueueHandle xQueue)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>uxQueueMessagesWaitingfromISR</Name>
        <Symbol>uxQueueMessagesWaitingfromISR</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>A version of uxQueueMessagesWaiting() that can be used from inside an interrupt service routine.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>unsigned_portBASE_TYPE</ReturnType>
        <RetHint>The number of items that are held within the queue being queried.</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>xQueue</ParName>
          <ParType>xQueueHandle</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The handle of the queue being queried.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>unsigned_portBASE_TYPE #M#_#C#(xQueueHandle xQueue)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xQueueCreate</Name>
        <Symbol>xQueueCreate</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Creates a queue.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>xQueueHandle</ReturnType>
        <RetHint>A handle to the created queue is returned provided the queue was created successfully. NULL is returned if the queue cannot be created because there is too little heap RAM available.</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>uxQueueLength</ParName>
          <ParType>unsigned_portBASE_TYPE</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The maximum number of items the queue can hold at any time.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>uxItemSize</ParName>
          <ParType>unsigned_portBASE_TYPE</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The size in bytes of each item the queue will hold.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>xQueueHandle #M#_#C#(unsigned_portBASE_TYPE uxQueueLength, unsigned_portBASE_TYPE uxItemSize)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xQueueCreateStatic</Name>
        <Symbol>xQueueCreateStatic</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Creates a queue.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>xQueueHandle</ReturnType>
        <RetHint>A handle to the created queue is returned provided the queue was created successfully. NULL is returned if the queue cannot be created because there is too little heap RAM available.</RetHint>
        <ParamCount>4</ParamCount>
        <Parameter>
          <ParName>uxQueueLength</ParName>
          <ParType>unsigned_portBASE_TYPE</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The maximum number of items the queue can hold at any time.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>uxItemSize</ParName>
          <ParType>unsigned_portBASE_TYPE</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The size in bytes of each item the queue will hold.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>pucQueueStorageBuffer</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>If uxItemSize is not zero then pucQueueStorageBuffer must point to a uint8_t array that is at least large enough to hold the maximum number of items that can be in the queue at any one time - which is ( uxQueueLength * uxItemSize ) bytes. If uxItemSize is zero then pucQueueStorageBuffer can be NULL. </ParHint>
          <ParUserDeclaration>uint8_t *pucQueueStorageBuffer</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>pxQueueBuffer</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Must point to a variable of type StaticQueue_t, which will be used to hold the queue's data structure.</ParHint>
          <ParUserDeclaration>StaticQueue_t *pxQueueBuffer</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>xQueueHandle #M#_#C#(unsigned_portBASE_TYPE uxQueueLength, unsigned_portBASE_TYPE uxItemSize, uint8_t *pucQueueStorageBuffer, StaticQueue_t *pxQueueBuffer)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>vQueueDelete</Name>
        <Symbol>vQueueDelete</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Deletes a queue that was previously created using a call to xQueueCreate(). vQueueDelete() can also be used to delete a semaphore.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>void</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>pxQueueToDelete</ParName>
          <ParType>xQueueHandle</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The handle of the queue being deleted. Semaphore handles can also be used. Queues are used to pass data between tasks and between tasks and interrupts. A queue/semaphore must not be deleted if there are any tasks that are blocked on the queue/semaphore waiting for events (sends or receives).</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(xQueueHandle pxQueueToDelete)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xQueueReset</Name>
        <Symbol>xQueueReset</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Reset a queue back to its original empty state.  pdPASS is returned if the queue is successfully reset.  pdFAIL is returned if the queue could not be reset because there are tasks blocked on the queue waiting to either receive from the queue or send to the queue.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>portBASE_TYPE</ReturnType>
        <RetHint>pdPASS is returned if the queue is successfully reset. pdFAIL is returned if the queue could not be reset because there are tasks blocked on the queue waiting to either receive from the queue or send to the queue.</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>xQueue</ParName>
          <ParType>xQueueHandle</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The handle of the queue to reset.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>portBASE_TYPE #M#_#C#(xQueueHandle xQueue)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xQueueSendToBack</Name>
        <Symbol>xQueueSendToBack</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Sends an item to the back of a queue.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>portBASE_TYPE</ReturnType>
        <RetHint>pdPASS: Data was successfully sent to the queue. If a block time was specified then the calling task may have been temporarily placed into the Blocked state to wait for space to become available and space did become available before the block time expired.\nerrQUEUE_FULL: The queue is already full so no data could be sent to the queue. If a block time was specified then the calling task may have been temporarily placed into the Blocked state to wait for space to become available, but no space became available before the block time expired.</RetHint>
        <ParamCount>3</ParamCount>
        <Parameter>
          <ParName>xQueue</ParName>
          <ParType>xQueueHandle</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The handle of the queue to which the data is to be sent.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>pvItemToQueue</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>A pointer to the data to be sent to the queue. The size of the data that can be sent to a queue was defined when the queue was created.</ParHint>
          <ParUserDeclaration>const void *pvItemToQueue</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>xTicksToWait</ParName>
          <ParType>portTickType</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The number of ticks for which the calling task should be held in the Blocked state to wait for space to become available on the queue should the queue already be full.\nA value of zero will prevent the calling task from entering the Blocked state.\nIf INCLUDE_vTaskSuspend is set to 1 then a value of portMAX_DELAY will hold the task in the Blocked state indefinitely to wait for space to become available on the queue.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>portBASE_TYPE #M#_#C#(xQueueHandle xQueue, const void *pvItemToQueue, portTickType xTicksToWait)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xQueueSendToFront</Name>
        <Symbol>xQueueSendToFront</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Sends an item to the front of a queue.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>portBASE_TYPE</ReturnType>
        <RetHint>pdPASS: Data was successfully sent to the queue. If a block time was specified then the calling task may have been temporarily placed into the Blocked state to wait for space to become available and space did become available before the block time expired.\nerrQUEUE_FULL: The queue is already full so no data could be sent to the queue. If a block time was specified then the calling task may have been temporarily placed into the Blocked state to wait for space to become available, but no space became available before the block time expired.</RetHint>
        <ParamCount>3</ParamCount>
        <Parameter>
          <ParName>xQueue</ParName>
          <ParType>xQueueHandle</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The handle of the queue to which the data is to be sent.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>pvItemToQueue</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>A pointer to the data to be sent to the queue. The size of the data that can be sent to a queue was defined when the queue was created.</ParHint>
          <ParUserDeclaration>const void *pvItemToQueue</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>xTicksToWait</ParName>
          <ParType>portTickType</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The number of ticks for which the calling task should be held in the Blocked state to wait for space to become available on the queue should the queue already be full.\nA value of zero will prevent the calling task from entering the Blocked state.\nIf INCLUDE_vTaskSuspend is set to 1 then a value of portMAX_DELAY will hold the task in the Blocked state indefinitely to wait for space to become available on the queue.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>portBASE_TYPE #M#_#C#(xQueueHandle xQueue, const void *pvItemToQueue, portTickType xTicksToWait)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xQueueReceive</Name>
        <Symbol>xQueueReceive</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Receives an item from a queue.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>portBASE_TYPE</ReturnType>
        <RetHint>pdPASS: Data was successfully read from the queue. If a block time was specified then the calling task may have been temporarily placed into the Blocked state to wait for data to become available and data did become available before the block time expired.\nerrQUEUE_EMPTY: The queue was empty so no date could be read form the queue. If a block time was specified then the calling task may have been temporarily placed into the Blocked state to wait for data to become available, but no data became available before the block time expired.</RetHint>
        <ParamCount>3</ParamCount>
        <Parameter>
          <ParName>xQueue</ParName>
          <ParType>xQueueHandle</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The handle of the queue from which the data is to be received.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>pvBuffer</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>A pointer to the memory into which the data received from the queue will be copied.\nThe length of the buffer must be at least equal to the queue item size (set when the queue was created).</ParHint>
          <ParUserDeclaration>void *pvBuffer</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>xTicksToWait</ParName>
          <ParType>portTickType</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The number of ticks for which the calling task should be held in the Blocked state to wait for data to become available from the queue should the queue already be empty.\nA value of zero will prevent the calling task from entering the Blocked state.\nIf INCLUDE_vTaskSuspend is set to 1 then a value of portMAX_DELAY will hold the task in the Blocked state indefinitely to wait for data.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>portBASE_TYPE #M#_#C#(xQueueHandle xQueue, void *pvBuffer, portTickType xTicksToWait)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xQueueOverwrite</Name>
        <Symbol>xQueueOverwrite</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>This is a macro that calls the xQueueGenericSend() function. A version of xQueueSendToBack() that will write to the queue even if the queue is full, overwriting data that is already held in the queue. xQueueOverwrite() is intended for use with queues that have a length of one, meaning the queue is either empty or full. This function must not be called from an interrupt service routine (ISR). See xQueueOverwriteFromISR() for an alternative which may be used in an ISR. </Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>portBASE_TYPE</ReturnType>
        <RetHint>pdPASS: Data was successfully sent to the queue. If a block time was specified then the calling task may have been temporarily placed into the Blocked state to wait for space to become available and space did become available before the block time expired.\nerrQUEUE_FULL: The queue is already full so no data could be sent to the queue. If a block time was specified then the calling task may have been temporarily placed into the Blocked state to wait for space to become available, but no space became available before the block time expired.</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>xQueue</ParName>
          <ParType>xQueueHandle</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The handle of the queue to which the data is to be sent.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>pvItemToQueue</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>A pointer to the data to be sent to the queue. The size of the data that can be sent to a queue was defined when the queue was created.</ParHint>
          <ParUserDeclaration>const void *pvItemToQueue</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>portBASE_TYPE #M#_#C#(xQueueHandle xQueue, const void *pvItemToQueue)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xQueueOverwriteFromISR</Name>
        <Symbol>xQueueOverwriteFromISR</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>This is a macro that calls the xQueueGenericSendFromISR() function. A version of xQueueOverwrite() that can be used in an ISR. xQueueOverwriteFromISR() is similar to xQueueSendToBackFromISR(), but will write to the queue even if the queue is full, overwriting data that is already held in the queue. xQueueOverwriteFromISR() is intended for use with queues that have a length of one, meaning the queue is either empty or full. </Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>portBASE_TYPE</ReturnType>
        <RetHint>pdTRUE Data was successfully sent to the queue.\nerrQUEUE_FULL Data could not be sent to the queue because the queue was already full.</RetHint>
        <ParamCount>3</ParamCount>
        <Parameter>
          <ParName>xQueue</ParName>
          <ParType>xQueueHandle</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The handle of the queue to which the data is to be sent.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>pvItemToQueue</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>A pointer to the data to be sent to the queue. The size of the data that can be sent to a queue was defined when the queue was created.</ParHint>
          <ParUserDeclaration>const void *pvItemToQueue</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>pxHigherPriorityTaskWoken</ParName>
          <ParType>portBASE_TYPE</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>xQueueSendFromISR() will set *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task to unblock, and the unblocked task has a priority higher than the currently running task. If xQueueSendFromISR() sets this value to pdTRUE then a context switch should be performed before the interrupt is exited.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>portBASE_TYPE #M#_#C#(xQueueHandle xQueue, const void *pvItemToQueue, portBASE_TYPE *pxHigherPriorityTaskWoken)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xQueuePeek</Name>
        <Symbol>xQueuePeek</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Reads an item from a queue, but does not remove the item from the queue. Therefore the same item would be returned the next time xQueueReceive() or xQueuePeek() was called on the same queue.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>portBASE_TYPE</ReturnType>
        <RetHint>pdPASS: Data was successfully read from the queue. If a block time was specified then the calling task may have been temporarily placed into the Blocked state to wait for data to become available and data did become available before the block time expired.\nerrQUEUE_EMPTY: The queue was empty so no date could be read form the queue. If a block time was specified then the calling task may have been temporarily placed into the Blocked state to wait for data to become available, but no data became available before the block time expired.</RetHint>
        <ParamCount>3</ParamCount>
        <Parameter>
          <ParName>xQueue</ParName>
          <ParType>xQueueHandle</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The handle of the queue from which the data is to be read.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>pvBuffer</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>A pointer to the memory into which the data read from the queue will be copied. The length of the buffer must be at least equal to the queue item size (set when the queue was created).</ParHint>
          <ParUserDeclaration>void *pvBuffer</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>xTicksToWait</ParName>
          <ParType>portTickType</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The number of ticks for which the calling task should be held in the Blocked state to wait for data to become available from the queue should the queue already be empty.\nA value of zero will prevent the calling task from entering the Blocked state.\nIf INCLUDE_vTaskSuspend is set to 1 then a value of portMAX_DELAY will hold the task in the Blocked state indefinitely to wait for data.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>portBASE_TYPE #M#_#C#(xQueueHandle xQueue, void *pvBuffer, portTickType xTicksToWait)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xQueuePeekFromISR</Name>
        <Symbol>xQueuePeekFromISR</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>A version of xQueuePeek() that can be used from an interrupt service routine (ISR). Reads an item from a queue, but does not remove the item from the queue. Therefore the same item would be returned the next time xQueueReceive() or xQueuePeek() was called on the same queue.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>portBASE_TYPE</ReturnType>
        <RetHint>pdPASS: Data was successfully read from the queue. If a block time was specified then the calling task may have been temporarily placed into the Blocked state to wait for data to become available and data did become available before the block time expired.\nerrQUEUE_EMPTY: The queue was empty so no date could be read form the queue. If a block time was specified then the calling task may have been temporarily placed into the Blocked state to wait for data to become available, but no data became available before the block time expired.</RetHint>
        <ParamCount>3</ParamCount>
        <Parameter>
          <ParName>xQueue</ParName>
          <ParType>xQueueHandle</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The handle of the queue from which the data is to be read.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>pvBuffer</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>A pointer to the memory into which the data read from the queue will be copied. The length of the buffer must be at least equal to the queue item size (set when the queue was created).</ParHint>
          <ParUserDeclaration>void *pvBuffer</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>xTicksToWait</ParName>
          <ParType>portTickType</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The number of ticks for which the calling task should be held in the Blocked state to wait for data to become available from the queue should the queue already be empty.\nA value of zero will prevent the calling task from entering the Blocked state.\nIf INCLUDE_vTaskSuspend is set to 1 then a value of portMAX_DELAY will hold the task in the Blocked state indefinitely to wait for data.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>portBASE_TYPE #M#_#C#(xQueueHandle xQueue, void *pvBuffer, portTickType xTicksToWait)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xQueueSendToBackFromISR</Name>
        <Symbol>xQueueSendToBackFromISR</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Versions of xQueueSendToBack() API functions that can be called from an ISR. Unlike xQueueSendToBack() these functions do not permit a block time to be specified.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>portBASE_TYPE</ReturnType>
        <RetHint>pdTRUE Data was successfully sent to the queue.\nerrQUEUE_FULL Data could not be sent to the queue because the queue was already full.</RetHint>
        <ParamCount>3</ParamCount>
        <Parameter>
          <ParName>xQueue</ParName>
          <ParType>xQueueHandle</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The handle of the queue to which the data is to be sent.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>pvItemToQueue</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>A pointer to the data to be sent to the queue. The size of the data that can be sent to a queue was defined when the queue was created.</ParHint>
          <ParUserDeclaration>const void *pvItemToQueue</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>pxHigherPriorityTaskWoken</ParName>
          <ParType>portBASE_TYPE</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>xQueueSendFromISR() will set *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task to unblock, and the unblocked task has a priority higher than the currently running task. If xQueueSendFromISR() sets this value to pdTRUE then a context switch should be performed before the interrupt is exited.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>portBASE_TYPE #M#_#C#(xQueueHandle xQueue, const void *pvItemToQueue, portBASE_TYPE *pxHigherPriorityTaskWoken)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xQueueSendToFrontFromISR</Name>
        <Symbol>xQueueSendToFrontFromISR</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Versions of xQueueSendToFront() API functions that can be called from an ISR. Unlike xQueueSendToFront() these functions do not permit a block time to be specified.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>portBASE_TYPE</ReturnType>
        <RetHint>pdTRUE Data was successfully sent to the queue.\nerrQUEUE_FULL Data could not be sent to the queue because the queue was already full.</RetHint>
        <ParamCount>3</ParamCount>
        <Parameter>
          <ParName>xQueue</ParName>
          <ParType>xQueueHandle</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The handle of the queue to which the data is to be sent.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>pvItemToQueue</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>A pointer to the data to be sent to the queue. The size of the data that can be sent to a queue was defined when the queue was created.</ParHint>
          <ParUserDeclaration>const void *pvItemToQueue</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>pxHigherPriorityTaskWoken</ParName>
          <ParType>portBASE_TYPE</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>xQueueSendFromISR() will set *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task to unblock, and the unblocked task has a priority higher than the currently running task. If xQueueSendFromISR() sets this value to pdTRUE then a context switch should be performed before the interrupt is exited.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>portBASE_TYPE #M#_#C#(xQueueHandle xQueue, const void *pvItemToQueue, portBASE_TYPE *pxHigherPriorityTaskWoken)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xQueueReceiveFromISR</Name>
        <Symbol>xQueueReceiveFromISR</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>A version of xQueueReceive() that can be called from an ISR. Unlike xQueueReceive(), xQueueReceiveFromISR() does not permit a block time to be specified.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>portBASE_TYPE</ReturnType>
        <RetHint>pdPASS: Data was successfully read from the queue. If a block time was specified then the calling task may have been temporarily placed into the Blocked state to wait for data to become available and data did become available before the block time expired.\nerrQUEUE_EMPTY: The queue was empty so no date could be read form the queue. If a block time was specified then the calling task may have been temporarily placed into the Blocked state to wait for data to become available, but no data became available before the block time expired.</RetHint>
        <ParamCount>3</ParamCount>
        <Parameter>
          <ParName>xQueue</ParName>
          <ParType>xQueueHandle</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The handle of the queue from which the data is to be received.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>pvBuffer</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>A pointer to the memory into which the data received from the queue will be copied.The length of the buffer must be at least equal to the queue item size (set when the queue was created).</ParHint>
          <ParUserDeclaration>void *pvBuffer</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>pxHigherPriorityTaskWoken</ParName>
          <ParType>portBASE_TYPE</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to A task may be blocked waiting for space to become available on the queue. If xQueueReceiveFromISR() causes such a task to unblock then *pxHigherPriorityTaskWoken will get set to pdTRUE, otherwise *pxHigherPriorityTaskWoken will remain unchanged.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>portBASE_TYPE #M#_#C#(xQueueHandle xQueue, void *pvBuffer, portBASE_TYPE *pxHigherPriorityTaskWoken)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>vQueueAddToRegistry</Name>
        <Symbol>vQueueAddToRegistry</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Assigns a name to a queue and adds the queue to the registry. </Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>xQueue</ParName>
          <ParType>xQueueHandle</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The handle of the queue being added to the registry.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>pcQueueName</ParName>
          <ParType>char</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to the name to be assigned to the queue. This is just a text string used to facilitate debugging.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(xQueueHandle xQueue, char *pcQueueName)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>vQueueUnregisterQueue</Name>
        <Symbol>vQueueUnregisterQueue</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Removes a queue from the queue registry. </Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>xQueue</ParName>
          <ParType>xQueueHandle</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The handle of the queue being removed from the registry.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(xQueueHandle xQueue)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xQueueIsQueueFullFromISR</Name>
        <Symbol>xQueueIsQueueFullFromISR</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Queries a queue to determine if the queue is full. This function should only be used in an ISR. </Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>portBASE_TYPE</ReturnType>
        <RetHint>pdFALSE if the queue is not full, or any other value if the queue is full. </RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>xQueue</ParName>
          <ParType>xQueueHandle</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The handle of the queue being queried.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>portBASE_TYPE #M#_#C#(xQueueHandle xQueue)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xQueueIsQueueEmptyFromISR</Name>
        <Symbol>xQueueIsQueueEmptyFromISR</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Queries a queue to determine if the queue is empty. This function should only be used in an ISR. </Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>portBASE_TYPE</ReturnType>
        <RetHint>pdFALSE if the queue is not empty, or any other value if the queue is empty. </RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>xQueue</ParName>
          <ParType>xQueueHandle</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The handle of the queue being queried.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>portBASE_TYPE #M#_#C#(xQueueHandle xQueue)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xQueueCreateSet</Name>
        <Symbol>xQueueCreateSet</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Queue sets provide a mechanism to allow an RTOS task to block (pend) on a read operation from multiple RTOS queues or semaphores simultaneously. Note that there are simpler alternatives to using queue sets. See the Blocking on Multiple Objects page for more information.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>xQueueSetHandle</ReturnType>
        <RetHint>If the queue set is created successfully then a handle to the created queue set is returned. Otherwise NULL is returned. </RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>uxEventQueueLength</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint/>
          <ParUserDeclaration>unsigned portBASE_TYPE uxEventQueueLength</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>xQueueSetHandle #M#_#C#(unsigned portBASE_TYPE uxEventQueueLength)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xQueueAddToSet</Name>
        <Symbol>xQueueAddToSet</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint> Adds an RTOS queue or semaphore to a queue set that was previously created by a call to xQueueCreateSet().</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>portBASE_TYPE</ReturnType>
        <RetHint>If the queue or semaphore was successfully added to the queue set then pdPASS is returned. If the queue could not be successfully added to the queue set because it is already a member of a different queue set then pdFAIL is returned. </RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>xQueueOrSemaphore</ParName>
          <ParType>xQueueSetMemberHandle</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The handle of the queue or semaphore being added to the queue set (cast to an xQueueSetMemberHandle type). </ParHint>
        </Parameter>
        <Parameter>
          <ParName>xQueueSet</ParName>
          <ParType>xQueueSetHandle</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The handle of the queue set to which the queue or semaphore is being added. </ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>portBASE_TYPE #M#_#C#(xQueueSetMemberHandle xQueueOrSemaphore, xQueueSetHandle xQueueSet)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xQueueRemoveFromSet</Name>
        <Symbol>xQueueRemoveFromSet</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Remove an RTOS queue or semaphore from a queue set. An RTOS queue or semaphore can only be removed from a queue set if the queue or semaphore is empty. </Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>portBASE_TYPE</ReturnType>
        <RetHint>If the queue or semaphore was successfully added to the queue set then pdPASS is returned. If the queue could not be successfully added to the queue set because it is already a member of a different queue set then pdFAIL is returned. </RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>xQueueOrSemaphore</ParName>
          <ParType>xQueueSetMemberHandle</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The handle of the queue or semaphore being removed from the queue set (cast to an xQueueSetMemberHandle type). </ParHint>
        </Parameter>
        <Parameter>
          <ParName>xQueueSet</ParName>
          <ParType>xQueueSetHandle</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The handle of the queue set in which the queue or semaphore is included.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>portBASE_TYPE #M#_#C#(xQueueSetMemberHandle xQueueOrSemaphore, xQueueSetHandle xQueueSet)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xQueueSelectFromSet</Name>
        <Symbol>xQueueSelectFromSet</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>xQueueSelectFromSet() selects from the members of a queue set a queue or semaphore that either contains data (in the case of a queue) or is available to take (in the case of a semaphore). xQueueSelectFromSet() effectively allows a task to block (pend) on a read operation on all the queues and semaphores in a queue set simultaneously. </Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>xQueueSetMemberHandle</ReturnType>
        <RetHint>xQueueSelectFromSet() will return the handle of a queue (cast to a xQueueSetMemberHandle type) contained in the queue set that contains data, or the handle of a semaphore (cast to a xQueueSetMemberHandle type) contained in the queue set that is available, or NULL if no such queue or semaphore exists before before the specified block time expires. </RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>xQueueSet</ParName>
          <ParType>xQueueSetHandle</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The queue set on which the task will (potentially) block. </ParHint>
        </Parameter>
        <Parameter>
          <ParName>xBlockTimeTicks</ParName>
          <ParType>portTickType</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The maximum time, in ticks, that the calling task will remain in the Blocked state (with other tasks executing) to wait for a member of the queue set to be ready for a successful queue read or semaphore take operation. </ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>xQueueSetMemberHandle #M#_#C#(xQueueSetHandle xQueueSet, portTickType xBlockTimeTicks)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xQueueSelectFromSetFromISR</Name>
        <Symbol>xQueueSelectFromSetFromISR</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>A version of xQueueSelectFromSet() that can be used from an interrupt service routine (ISR). </Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>xQueueSetMemberHandle</ReturnType>
        <RetHint>xQueueSelectFromSet() will return the handle of a queue (cast to a xQueueSetMemberHandle type) contained in the queue set that contains data, or the handle of a semaphore (cast to a xQueueSetMemberHandle type) contained in the queue set that is available, or NULL if no such queue or semaphore exists before before the specified block time expires. </RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>xQueueSet</ParName>
          <ParType>xQueueSetHandle</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The queue set being queried. It is not possible to block on a read as this function is designed to be used from an interrupt. </ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>xQueueSetMemberHandle #M#_#C#(xQueueSetHandle xQueueSet)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xEventGroupCreate</Name>
        <Symbol>xEventGroupCreate</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint> Create a new RTOS event group. This function cannot be called from an interrupt.\n
\n
Event groups are stored in variables of type EventGroupHandle_t. The number of bits (or flags) implemented within an event group is 8 if configUSE_16_BIT_TICKS is set to 1, or 24 if configUSE_16_BIT_TICKS is set to 0. The dependency on configUSE_16_BIT_TICKS results from the data type used for thread local storage in the internal implementation of RTOS tasks. </Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>EventGroupHandle_t</ReturnType>
        <RetHint>Event Group Handle. If the event group was created then a handle to the event group is returned. If there was insufficient FreeRTOS heap available to create the event group then NULL is returned. </RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>EventGroupHandle_t #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xEventGroupCreateStatic</Name>
        <Symbol>xEventGroupCreateStatic</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint> Create a new RTOS event group. This function cannot be called from an interrupt.\n
\n
Event groups are stored in variables of type EventGroupHandle_t. The number of bits (or flags) implemented within an event group is 8 if configUSE_16_BIT_TICKS is set to 1, or 24 if configUSE_16_BIT_TICKS is set to 0. The dependency on configUSE_16_BIT_TICKS results from the data type used for thread local storage in the internal implementation of RTOS tasks. </Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>EventGroupHandle_t</ReturnType>
        <RetHint>Event Group Handle. If the event group was created then a handle to the event group is returned. If there was insufficient FreeRTOS heap available to create the event group then NULL is returned. </RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>pxEventGroupBuffer</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Must point to a variable of type StaticEventGroup_t, in which the event group data structure will be stored.</ParHint>
          <ParUserDeclaration>StaticEventGroup_t *pxEventGroupBuffer</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>EventGroupHandle_t #M#_#C#(StaticEventGroup_t *pxEventGroupBuffer)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xEventGroupWaitBits</Name>
        <Symbol>xEventGroupWaitBits</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint> Read bits within an RTOS event group, optionally entering the Blocked state (with a timeout) to wait for a bit or group of bits to become set. This function cannot be called from an interrupt. </Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>8bit unsigned</ReturnType>
        <RetHint>EventBits_t: The value of the event group at the time either the event bits being waited for became set, or the block time expired. The current value of the event bits in an event group will be different to the returned value if a higher priority task or interrupt changed the value of an event bit between the calling task leaving the Blocked state and exiting the xEventGroupWaitBits() function.\n\nTest the return value to know which bits were set. If xEventGroupWaitBits() returned because its timeout expired then not all the bits being waited for will be set. If xEventGroupWaitBits() returned because the bits it was waiting for were set then the returned value is the event group value before any bits were automatically cleared because the xClearOnExit parameter was set to pdTRUE. </RetHint>
        <ParamCount>5</ParamCount>
        <Parameter>
          <ParName>xEventGroup</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The event group in which the bits are being tested. The event group must have previously been created using a call to xEventGroupCreate(). </ParHint>
          <ParUserDeclaration>const EventGroupHandle_t xEventGroup</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>uxBitsToWaitFor</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>A bitwise value that indicates the bit or bits to test inside the event group. For example, to wait for bit 0 and/or bit 2 set uxBitsToWaitFor to 0x05. To wait for bits 0 and/or bit 1 and/or bit 2 set uxBitsToWaitFor to 0x07. Etc.\n\nuxBitsToWaitFor must not be set to 0. </ParHint>
          <ParUserDeclaration>const EventBits_t uxBitsToWaitFor</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>xClearOnExit</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>If xClearOnExit is set to pdTRUE then any bits set in the value passed as the uxBitsToWaitFor parameter will be cleared in the event group before xEventGroupWaitBits() returns if xEventGroupWaitBits() returns for any reason other than a timeout. The timeout value is set by the xTicksToWait parameter.\n\nIf xClearOnExit is set to pdFALSE then the bits set in the event group are not altered when the call to xEventGroupWaitBits() returns. </ParHint>
          <ParUserDeclaration>const BaseType_t xClearOnExit</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>xWaitForAllBits</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>xWaitForAllBits is used to create either a logical AND test (where all bits must be set) or a logical OR test (where one or more bits must be set) as follows:\n\nIf xWaitForAllBits is set to pdTRUE then xEventGroupWaitBits() will return when either all the bits set in the value passed as the uxBitsToWaitFor parameter are set in the event group or the specified block time expires.\n\nIf xWaitForAllBits is set to pdFALSE then xEventGroupWaitBits() will return when any of the bits set in the value passed as the uxBitsToWaitFor parameter are set in the event group or the specified block time expires. </ParHint>
          <ParUserDeclaration>const BaseType_t xWaitForAllBits</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>xTicksToWait</ParName>
          <ParType>TickType_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The maximum amount of time (specified in 'ticks') to wait for one/all (depending on the xWaitForAllBits value) of the bits specified by uxBitsToWaitFor to become set. </ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>byte #M#_#C#(const EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xEventGroupSetBits</Name>
        <Symbol>xEventGroupSetBits</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint> Set bits (flags) within an RTOS event group. This function cannot be called from an interrupt. xEventGroupSetBitsFromISR() is a version that can be called from an interrupt.\n
\n
Setting bits in an event group will automatically unblock tasks that are blocked waiting for the bits. </Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>EventBits_t</ReturnType>
        <RetHint>The value of the event group at the time the call to xEventGroupSetBits() returns.\n\nThere are two reasons why the returned value might have the bits specified by the uxBitsToSet parameter cleared:\n\n    If setting a bit results in a task that was waiting for the bit leaving the blocked state then it is possible the bit will have been cleared automatically (see the xClearBitOnExit parameter of xEventGroupWaitBits()).\n\n    Any unblocked (or otherwise Ready state) task that has a priority above that of the task that called xEventGroupSetBits() will execute and may change the event group value before the call to xEventGroupSetBits() returns.</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>xEventGroup</ParName>
          <ParType>EventGroupHandle_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The event group in which the bits are to be set. The event group must have previously been created using a call to xEventGroupCreate(). </ParHint>
        </Parameter>
        <Parameter>
          <ParName>uxBitsToSet</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>A bitwise value that indicates the bit or bits to set in the event group. For example, set uxBitsToSet to 0x08 to set only bit 3. Set uxBitsToSet to 0x09 to set bit 3 and bit 0. </ParHint>
          <ParUserDeclaration>const EventBits_t uxBitsToSet </ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>EventBits_t #M#_#C#(EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xEventGroupSetBitsFromISR</Name>
        <Symbol>xEventGroupSetBitsFromISR</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint> Set bits (flags) within an RTOS event group. A version of xEventGroupSetBits() that can be called from an interrupt service routine (ISR).\n
\n
Setting bits in an event group will automatically unblock tasks that are blocked waiting for the bits.\n
\n
Setting bits in an event group is not a deterministic operation because there are an unknown number of tasks that may be waiting for the bit or bits being set. FreeRTOS does not allow non-deterministic operations to be performed in interrupts or from critical sections. Therefore xEventGroupSetBitFromISR() sends a message to the RTOS daemon task to have the set operation performed in the context of the daemon task - where a scheduler lock is used in place of a critical section.\n
\n
INCLUDE_xEventGroupSetBitFromISR, configUSE_TIMERS and INCLUDE_xTimerPendFunctionCall must all be set to 1 in FreeRTOSConfig.h for the xEventGroupSetBitsFromISR() function to be available. </Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>EventBits_t</ReturnType>
        <RetHint>The value of the event group at the time the call to xEventGroupSetBits() returns.\n\nThere are two reasons why the returned value might have the bits specified by the uxBitsToSet parameter cleared:\n\n    If setting a bit results in a task that was waiting for the bit leaving the blocked state then it is possible the bit will have been cleared automatically (see the xClearBitOnExit parameter of xEventGroupWaitBits()).\n\n    Any unblocked (or otherwise Ready state) task that has a priority above that of the task that called xEventGroupSetBits() will execute and may change the event group value before the call to xEventGroupSetBits() returns.</RetHint>
        <ParamCount>3</ParamCount>
        <Parameter>
          <ParName>xEventGroup</ParName>
          <ParType>EventGroupHandle_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The event group in which the bits are to be set. The event group must have previously been created using a call to xEventGroupCreate(). </ParHint>
        </Parameter>
        <Parameter>
          <ParName>uxBitsToSet</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>A bitwise value that indicates the bit or bits to set in the event group. For example, set uxBitsToSet to 0x08 to set only bit 3. Set uxBitsToSet to 0x09 to set bit 3 and bit 0. </ParHint>
          <ParUserDeclaration>const EventBits_t uxBitsToSet </ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>pxHigherPriorityTaskWoken</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Calling this function will result in a message being sent to the RTOS daemon task. If the priority of the daemon task is higher than the priority of the currently running task (the task the interrupt interrupted) then *pxHigherPriorityTaskWoken will be set to pdTRUE by xEventGroupSetBitsFromISR(), indicating that a context switch should be requested before the interrupt exits. For that reason *pxHigherPriorityTaskWoken must be initialised to pdFALSE. See the example code below. </ParHint>
          <ParUserDeclaration>BaseType_t *pxHigherPriorityTaskWoken</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>EventBits_t #M#_#C#(EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet , BaseType_t *pxHigherPriorityTaskWoken)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xEventGroupClearBits</Name>
        <Symbol>xEventGroupClearBits</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Clear bits (flags) within an RTOS event group. This function cannot be called from an interrupt. See xEventGroupClearBitsFromISR() for a version that can be called from an interrupt. </Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>EventBits_t</ReturnType>
        <RetHint>The value of the event group at the time the call to xEventGroupSetBits() returns.\n\nThere are two reasons why the returned value might have the bits specified by the uxBitsToSet parameter cleared:\n\n    If setting a bit results in a task that was waiting for the bit leaving the blocked state then it is possible the bit will have been cleared automatically (see the xClearBitOnExit parameter of xEventGroupWaitBits()).\n\n    Any unblocked (or otherwise Ready state) task that has a priority above that of the task that called xEventGroupSetBits() will execute and may change the event group value before the call to xEventGroupSetBits() returns.</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>xEventGroup</ParName>
          <ParType>EventGroupHandle_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The event group in which the bits are to be cleared. The event group must have previously been created using a call to xEventGroupCreate(). </ParHint>
        </Parameter>
        <Parameter>
          <ParName>uxBitsToSet</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>A bitwise value that indicates the bit or bits to clear in the event group. For example set uxBitsToClear to 0x08 to clear just bit 3. Set uxBitsToClear to 0x09 to clear bit 3 and bit 0. </ParHint>
          <ParUserDeclaration>const EventBits_t uxBitsToSet </ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>EventBits_t #M#_#C#(EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xEventGroupClearBitsFromISR</Name>
        <Symbol>xEventGroupClearBitsFromISR</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint> A version of xEventGroupClearBits() that can be called from an interrupt. </Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>EventBits_t</ReturnType>
        <RetHint>The value of the event group at the time the call to xEventGroupSetBits() returns.\n\nThere are two reasons why the returned value might have the bits specified by the uxBitsToSet parameter cleared:\n\n    If setting a bit results in a task that was waiting for the bit leaving the blocked state then it is possible the bit will have been cleared automatically (see the xClearBitOnExit parameter of xEventGroupWaitBits()).\n\n    Any unblocked (or otherwise Ready state) task that has a priority above that of the task that called xEventGroupSetBits() will execute and may change the event group value before the call to xEventGroupSetBits() returns.</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>xEventGroup</ParName>
          <ParType>EventGroupHandle_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The event group in which the bits are to be set. The event group must have previously been created using a call to xEventGroupCreate(). </ParHint>
        </Parameter>
        <Parameter>
          <ParName>uxBitsToSet</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>A bitwise value that indicates the bit or bits to set in the event group. For example, set uxBitsToSet to 0x08 to set only bit 3. Set uxBitsToSet to 0x09 to set bit 3 and bit 0. </ParHint>
          <ParUserDeclaration>const EventBits_t uxBitsToSet </ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>EventBits_t #M#_#C#(EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xEventGroupGetBits</Name>
        <Symbol>xEventGroupGetBits</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Returns the current value of the event bits (event flags) in an RTOS event group. This function cannot be used from an interrupt. See xEventGroupsGetBitsFromISR() for a version that can be used in an interrupt. </Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>EventBits_t</ReturnType>
        <RetHint>The value of the event bits in the event group at the time xEventGroupGetBits() was called. </RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>xEventGroup</ParName>
          <ParType>EventGroupHandle_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The event group being queried. The event group must have previously been created using a call to xEventGroupCreate().</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>EventBits_t #M#_#C#(EventGroupHandle_t xEventGroup)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xEventGroupGetBitsFromISR</Name>
        <Symbol>xEventGroupGetBitsFromISR</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>A version of xEventGroupGetBits() that can be called from an interrupt. </Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>EventBits_t</ReturnType>
        <RetHint>The value of the event bits in the event group at the time xEventGroupGetBits() was called. </RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>xEventGroup</ParName>
          <ParType>EventGroupHandle_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The event group being queried. The event group must have previously been created using a call to xEventGroupCreate().</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>EventBits_t #M#_#C#(EventGroupHandle_t xEventGroup)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xEventGroupSync</Name>
        <Symbol>xEventGroupSync</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint> Atomically set bits (flags) within an RTOS event group, then wait for a combination of bits to be set within the same event group. This functionality is typically used to synchronise multiple tasks (often called a task rendezvous), where each task has to wait for the other tasks to reach a synchronisation point before proceeding.\n
\n
This function cannot be used from an interrupt.\n
\n
The function will return before its block time expires if the bits specified by the uxBitsToWait parameter are set, or become set within that time. In this case all the bits specified by uxBitsToWait will be automatically cleared before the function returns. </Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>EventBits_t</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>4</ParamCount>
        <Parameter>
          <ParName>xEventGroup</ParName>
          <ParType>EventGroupHandle_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The event group in which the bits are being set and tested. The event group must have previously been created using a call to xEventGroupCreate().</ParHint>
        </Parameter>
        <Parameter>
          <ParName>uxBitsToSet</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The bit or bits to set in the event group before determining if (and possibly waiting for), all the bits specified by the uxBitsToWait parameter are set. For example, set uxBitsToSet to 0x04 to set bit 2 within the event group. </ParHint>
          <ParUserDeclaration>const EventBits_t uxBitsToSet</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>uxBitsToWaitFor</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>A bitwise value that indicates the bit or bits to test inside the event group. For example, set uxBitsToWaitFor to 0x05 to wait for bits 0 and bit 2. Set uxBitsToWaitFor to 0x07 to wait for bit 0 and bit 1 and bit 2. Etc. </ParHint>
          <ParUserDeclaration>const EventBits_t uxBitsToWaitFor</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>xTicksToWait</ParName>
          <ParType>TickType_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The maximum amount of time (specified in 'ticks') to wait for all the bits specified by the uxBitsToWaitFor parameter value to become set. </ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>EventBits_t #M#_#C#(EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xTimerCreate</Name>
        <Symbol>xTimerCreate</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint> Creates a new software timer instance. This allocates the storage required by the new timer, initialises the new timers internal state, and returns a handle by which the new timer can be referenced.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>TimerHandle_t</ReturnType>
        <RetHint>Timer handle. If the timer is successfully created then a handle to the newly created timer is returned. If the timer cannot be created (because either there is insufficient FreeRTOS heap remaining to allocate the timer structures, or the timer period was set to 0) then NULL is returned. </RetHint>
        <ParamCount>5</ParamCount>
        <Parameter>
          <ParName>pcTimerName</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Atextnamethatisassignedtothetimer_Thisisdonepurelytoassistdebugging_TheRTOSkernelitselfonlyeverreferencesatimerbyitshandle_andneverbyitsname_</ParHint>
          <ParUserDeclaration>const char * const pcTimerName</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>xTimerPeriod</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The timer period. The time is defined in tick periods so the constant portTICK_PERIOD_MS can be used to convert a time that has been specified in milliseconds. For example, if the timer must expire after 100 ticks, then xTimerPeriod should be set to 100. Alternatively, if the timer must expire after 500ms, then xPeriod can be set to ( 500 / portTICK_PERIOD_MS ) provided configTICK_RATE_HZ is less than or equal to 1000. </ParHint>
          <ParUserDeclaration>const TickType_t xTimerPeriod</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>uxAutoReload</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>If uxAutoReload is set to pdTRUE, then the timer will expire repeatedly with a frequency set by the xTimerPeriod parameter. If uxAutoReload is set to pdFALSE, then the timer will be a one-shot and enter the dormant state after it expires. </ParHint>
          <ParUserDeclaration>const UBaseType_t uxAutoReload</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>pvTimerID</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>An identifier that is assigned to the timer being created. Typically this would be used in the timer callback function to identify which timer expired when the same callback function is assigned to more than one timer. </ParHint>
          <ParUserDeclaration>void *const pvTimerID</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>pxCallbackFunction</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The function to call when the timer expires. Callback functions must have the prototype defined by TimerCallbackFunction_t, which is "void vCallbackFunction( TimerHandle_t xTimer );". </ParHint>
          <ParUserDeclaration>TimerCallbackFunction_t pxCallbackFunction</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>TimerHandle_t #M#_#C#(const char * const pcTimerName, const TickType_t xTimerPeriod, const UBaseType_t uxAutoReload, void *const pvTimerID, TimerCallbackFunction_t pxCallbackFunction)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xTimerCreateStatic</Name>
        <Symbol>xTimerCreateStatic</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint> Creates a new software timer instance. This allocates the storage required by the new timer, initialises the new timers internal state, and returns a handle by which the new timer can be referenced.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>1</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>false</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>TimerHandle_t</ReturnType>
        <RetHint>Timer handle. If the timer is successfully created then a handle to the newly created timer is returned. If the timer cannot be created (because either there is insufficient FreeRTOS heap remaining to allocate the timer structures, or the timer period was set to 0) then NULL is returned. </RetHint>
        <ParamCount>6</ParamCount>
        <Parameter>
          <ParName>pcTimerName</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Atextnamethatisassignedtothetimer_Thisisdonepurelytoassistdebugging_TheRTOSkernelitselfonlyeverreferencesatimerbyitshandle_andneverbyitsname_</ParHint>
          <ParUserDeclaration>const char * const pcTimerName</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>xTimerPeriod</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The timer period. The time is defined in tick periods so the constant portTICK_PERIOD_MS can be used to convert a time that has been specified in milliseconds. For example, if the timer must expire after 100 ticks, then xTimerPeriod should be set to 100. Alternatively, if the timer must expire after 500ms, then xPeriod can be set to ( 500 / portTICK_PERIOD_MS ) provided configTICK_RATE_HZ is less than or equal to 1000. </ParHint>
          <ParUserDeclaration>const TickType_t xTimerPeriod</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>uxAutoReload</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>If uxAutoReload is set to pdTRUE, then the timer will expire repeatedly with a frequency set by the xTimerPeriod parameter. If uxAutoReload is set to pdFALSE, then the timer will be a one-shot and enter the dormant state after it expires. </ParHint>
          <ParUserDeclaration>const UBaseType_t uxAutoReload</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>pvTimerID</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>An identifier that is assigned to the timer being created. Typically this would be used in the timer callback function to identify which timer expired when the same callback function is assigned to more than one timer. </ParHint>
          <ParUserDeclaration>void *const pvTimerID</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>pxCallbackFunction</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The function to call when the timer expires. Callback functions must have the prototype defined by TimerCallbackFunction_t, which is "void vCallbackFunction( TimerHandle_t xTimer );". </ParHint>
          <ParUserDeclaration>TimerCallbackFunction_t pxCallbackFunction</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>pxTimerBuffer</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Must point to a variable of type StaticTimer_t, which is then used to hold the timer's state. </ParHint>
          <ParUserDeclaration>StaticTimer_t *pxTimerBuffer</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>TimerHandle_t #M#_#C#(const char * const pcTimerName, const TickType_t xTimerPeriod, const UBaseType_t uxAutoReload, void *const pvTimerID, TimerCallbackFunction_t pxCallbackFunction, StaticTimer_t *pxTimerBuffer)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xTimerIsTimerActive</Name>
        <Symbol>xTimerIsTimerActive</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Queries a timer to see if it is active or dormant.\n
 A timer will be dormant if:\n
\n
    It has been created but not started, or\n
    It is an expired one-shot timer that has not been restarted.\n
\n
Timers are created in the dormant state. The xTimerStart(), xTimerReset(), xTimerStartFromISR(), xTimerResetFromISR(), xTimerChangePeriod() and xTimerChangePeriodFromISR() API functions can all be used to transition a timer into the active state. </Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>BaseType_t</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>xTimer</ParName>
          <ParType>TimerHandle_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The timer being queried. </ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>BaseType_t #M#_#C#(TimerHandle_t xTimer)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xTimerStart</Name>
        <Symbol>xTimerStart</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint> Timer functionality is provided by a timer service/daemon task. Many of the public FreeRTOS timer API functions send commands to the timer service task through a queue called the timer command queue. The timer command queue is private to the RTOS kernel itself and is not directly accessible to application code. The length of the timer command queue is set by the configTIMER_QUEUE_LENGTH configuration constant.\n
\n
xTimerStart() starts a timer that was previously created using the xTimerCreate() API function. If the timer had already been started and was already in the active state, then xTimerStart() has equivalent functionality to the xTimerReset() API function.\n
\n
Starting a timer ensures the timer is in the active state. If the timer is not stopped, deleted, or reset in the mean time, the callback function associated with the timer will get called 'n 'ticks after xTimerStart() was called, where 'n' is the timers defined period.\n
\n
It is valid to call xTimerStart() before the RTOS scheduler has been started, but when this is done the timer will not actually start until the RTOS scheduler is started, and the timers expiry time will be relative to when the RTOS scheduler is started, not relative to when xTimerStart() was called.\n
\n
The configUSE_TIMERS configuration constant must be set to 1 for xTimerStart() to be available. </Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>BaseType_t</ReturnType>
        <RetHint>pdFAIL will be returned if the start command could not be sent to the timer command queue even after xBlockTime ticks had passed. pdPASS will be returned if the command was successfully sent to the timer command queue. When the command is actually processed will depend on the priority of the timer service/daemon task relative to other tasks in the system, although the timers expiry time is relative to when xTimerStart() is actually called. The timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY configuration constant.</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>xTimer</ParName>
          <ParType>TimerHandle_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The handle of the timer being started/restarted. </ParHint>
        </Parameter>
        <Parameter>
          <ParName>xBlockTime</ParName>
          <ParType>TickType_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Specifies the time, in ticks, that the calling task should be held in the Blocked state to wait for the start command to be successfully sent to the timer command queue, should the queue already be full when xTimerStart() was called. xBlockTime is ignored if xTimerStart() is called before the RTOS scheduler is started.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>BaseType_t #M#_#C#(TimerHandle_t xTimer, TickType_t xBlockTime)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xTimerStop</Name>
        <Symbol>xTimerStop</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint> Timer functionality is provided by a timer service/daemon task. Many of the public FreeRTOS timer API functions send commands to the timer service task through a queue called the timer command queue. The timer command queue is private to the RTOS kernel itself and is not directly accessible to application code. The length of the timer command queue is set by the configTIMER_QUEUE_LENGTH configuration constant.\n
\n
xTimerStop() stops a timer that was previously started using either of the xTimerStart(), xTimerReset(), xTimerStartFromISR(), xTimerResetFromISR(), xTimerChangePeriod() and xTimerChangePeriodFromISR() API functions.\n
\n
Stopping a timer ensures the timer is not in the active state.\n
\n
The configUSE_TIMERS configuration constant must be set to 1 for xTimerStop() to be available. </Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>BaseType_t</ReturnType>
        <RetHint>pdFAIL will be returned if the stop command could not be sent to the timer command queue even after xBlockTime ticks had passed. pdPASS will be returned if the command was successfully sent to the timer command queue. When the command is actually processed will depend on the priority of the timer service/daemon task relative to other tasks in the system. The timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY configuration constant. </RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>xTimer</ParName>
          <ParType>TimerHandle_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The handle of the timer being stopped. </ParHint>
        </Parameter>
        <Parameter>
          <ParName>xBlockTime</ParName>
          <ParType>TickType_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Specifies the time, in ticks, that the calling task should be held in the Blocked state to wait for the stop command to be successfully sent to the timer command queue, should the queue already be full when xTimerStop() was called. xBlockTime is ignored if xTimerStop() is called before the RTOS scheduler is started. </ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>BaseType_t #M#_#C#(TimerHandle_t xTimer, TickType_t xBlockTime)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xTimerChangePeriod</Name>
        <Symbol>xTimerChangePeriod</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint> Timer functionality is provided by a timer service/daemon task. Many of the public FreeRTOS timer API functions send commands to the timer service task through a queue called the timer command queue. The timer command queue is private to the RTOS kernel itself and is not directly accessible to application code. The length of the timer command queue is set by the configTIMER_QUEUE_LENGTH configuration constant.\n
\n
xTimerChangePeriod() changes the period of a timer that was previously created using the xTimerCreate() API function.\n
\n
xTimerChangePeriod() can be called to change the period of an active or dormant state timer.\n
\n
The configUSE_TIMERS configuration constant must be set to 1 for xTimerChangePeriod() to be available. </Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>BaseType_t</ReturnType>
        <RetHint>pdFAIL will be returned if the change period command could not be sent to the timer command queue even after xBlockTime ticks had passed. pdPASS will be returned if the command was successfully sent to the timer command queue. When the command is actually processed will depend on the priority of the timer service/daemon task relative to other tasks in the system. The timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY configuration constant. </RetHint>
        <ParamCount>3</ParamCount>
        <Parameter>
          <ParName>xTimer</ParName>
          <ParType>TimerHandle_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The handle of the timer that is having its period changed. </ParHint>
        </Parameter>
        <Parameter>
          <ParName>xNewPeriod</ParName>
          <ParType>TickType_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The new period for xTimer. Timer periods are specified in tick periods, so the constant portTICK_PERIOD_MS can be used to convert a time that has been specified in milliseconds. For example, if the timer must expire after 100 ticks, then xNewPeriod should be set to 100. Alternatively, if the timer must expire after 500ms, then xNewPeriod can be set to ( 500 / portTICK_PERIOD_MS ) provided configTICK_RATE_HZ is less than or equal to 1000. </ParHint>
        </Parameter>
        <Parameter>
          <ParName>xBlockTime</ParName>
          <ParType>TickType_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Specifies the time, in ticks, that the calling task should be held in the Blocked state to wait for the change period command to be successfully sent to the timer command queue, should the queue already be full when xTimerChangePeriod() was called. xBlockTime is ignored if xTimerChangePeriod() is called before the RTOS scheduler is started. </ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>BaseType_t #M#_#C#(TimerHandle_t xTimer, TickType_t xNewPeriod, TickType_t xBlockTime)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xTimerDelete</Name>
        <Symbol>xTimerDelete</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint> Timer functionality is provided by a timer service/daemon task. Many of the public FreeRTOS timer API functions send commands to the timer service task through a queue called the timer command queue. The timer command queue is private to the RTOS kernel itself and is not directly accessible to application code. The length of the timer command queue is set by the configTIMER_QUEUE_LENGTH configuration constant.\n
\n
xTimerDelete() deletes a timer that was previously created using the xTimerCreate() API function.\n
\n
The configUSE_TIMERS configuration constant must be set to 1 for xTimerDelete() to be available. </Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>BaseType_t</ReturnType>
        <RetHint>pdFAIL will be returned if the delete command could not be sent to the timer command queue even after xBlockTime ticks had passed. pdPASS will be returned if the command was successfully sent to the timer command queue. When the command is actually processed will depend on the priority of the timer service/daemon task relative to other tasks in the system. The timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY configuration constant. </RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>xTimer</ParName>
          <ParType>TickType_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The handle of the timer being deleted. </ParHint>
        </Parameter>
        <Parameter>
          <ParName>xBlockTime</ParName>
          <ParType>TickType_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Specifies the time, in ticks, that the calling task should be held in the Blocked state to wait for the delete command to be successfully sent to the timer command queue, should the queue already be full when xTimerDelete() was called. xBlockTime is ignored if xTimerDelete() is called before the RTOS scheduler is started. </ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>BaseType_t #M#_#C#(TickType_t xTimer, TickType_t xBlockTime)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xTimerReset</Name>
        <Symbol>xTimerReset</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint> Timer functionality is provided by a timer service/daemon task. Many of the public FreeRTOS timer API functions send commands to the timer service task through a queue called the timer command queue. The timer command queue is private to the RTOS kernel itself and is not directly accessible to application code. The length of the timer command queue is set by the configTIMER_QUEUE_LENGTH configuration constant.\n
\n
xTimerReset() re-starts a timer that was previously created using the xTimerCreate() API function. If the timer had already been started and was already in the active state, then xTimerReset() will cause the timer to re-evaluate its expiry time so that it is relative to when xTimerReset() was called. If the timer was in the dormant state then xTimerReset() has equivalent functionality to the xTimerStart() API function.\n
\n
Resetting a timer ensures the timer is in the active state. If the timer is not stopped, deleted, or reset in the mean time, the callback function associated with the timer will get called 'n' ticks after xTimerReset() was called, where 'n' is the timers defined period.\n
\n
It is valid to call xTimerReset() before the RTOS scheduler has been started, but when this is done the timer will not actually start until the RTOS scheduler is started, and the timers expiry time will be relative to when the RTOS scheduler is started, not relative to when xTimerReset() was called.\n
\n
The configUSE_TIMERS configuration constant must be set to 1 for xTimerReset() to be available. </Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>BaseType_t</ReturnType>
        <RetHint>pdFAIL will be returned if the reset command could not be sent to the timer command queue even after xBlockTime ticks had passed. pdPASS will be returned if the command was successfully sent to the timer command queue. When the command is actually processed will depend on the priority of the timer service/daemon task relative to other tasks in the system, although the timers expiry time is relative to when xTimerReset() is actually called. The timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY configuration constant. </RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>xTimer</ParName>
          <ParType>TimerHandle_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The handle of the timer being reset/started/restarted. </ParHint>
        </Parameter>
        <Parameter>
          <ParName>xBlockTime</ParName>
          <ParType>TickType_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Specifies the time, in ticks, that the calling task should be held in the Blocked state to wait for the reset command to be successfully sent to the timer command queue, should the queue already be full when xTimerReset() was called. xBlockTime is ignored if xTimerReset() is called before the RTOS scheduler is started. </ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>BaseType_t #M#_#C#(TimerHandle_t xTimer, TickType_t xBlockTime)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xTimerStartFromISR</Name>
        <Symbol>xTimerStartFromISR</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>A version of xTimerStart() that can be called from an interrupt service routine. </Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>BaseType_t</ReturnType>
        <RetHint>pdFAIL will be returned if the start command could not be sent to the timer command queue. pdPASS will be returned if the command was successfully sent to the timer command queue. When the command is actually processed will depend on the priority of the timer service/daemon task relative to other tasks in the system, although the timers expiry time is relative to when xTimerStartFromISR() is actually called. The timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY configuration constant. </RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>xTimer</ParName>
          <ParType>TimerHandle_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The handle of the timer being started/restarted. </ParHint>
        </Parameter>
        <Parameter>
          <ParName>pxHigherPriorityTaskWoken</ParName>
          <ParType>BaseType_t</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>The timer service/daemon task spends most of its time in the Blocked state, waiting for messages to arrive on the timer command queue. Calling xTimerStartFromISR() writes a message to the timer command queue, so has the potential to transition the timer service/daemon task out of the Blocked state. If calling xTimerStartFromISR() causes the timer service/daemon task to leave the Blocked state, and the timer service/ daemon task has a priority equal to or greater than the currently executing task (the task that was interrupted), then *pxHigherPriorityTaskWoken will get set to pdTRUE internally within the xTimerStartFromISR() function. If xTimerStartFromISR() sets this value to pdTRUE, then a context switch should be performed before the interrupt exits. </ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>BaseType_t #M#_#C#(TimerHandle_t xTimer, BaseType_t *pxHigherPriorityTaskWoken)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xTimerStopFromISR</Name>
        <Symbol>xTimerStopFromISR</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>A version of xTimerStop() that can be called from an interrupt service routine.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>BaseType_t</ReturnType>
        <RetHint>pdFAIL will be returned if the stop command could not be sent to the timer command queue. pdPASS will be returned if the command was successfully sent to the timer command queue. When the command is actually processed will depend on the priority of the timer service/daemon task relative to other tasks in the system. The timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY configuration constant. </RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>xTimer</ParName>
          <ParType>TimerHandle_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The handle of the timer being stopped. </ParHint>
        </Parameter>
        <Parameter>
          <ParName>pxHigherPriorityTaskWoken</ParName>
          <ParType>BaseType_t</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>The timer service/daemon task spends most of its time in the Blocked state, waiting for messages to arrive on the timer command queue. Calling xTimerStopFromISR() writes a message to the timer command queue, so has the potential to transition the timer service/daemon task out of the Blocked state. If calling xTimerStopFromISR() causes the timer service/daemon task to leave the Blocked state, and the timer service/ daemon task has a priority equal to or greater than the currently executing task (the task that was interrupted), then *pxHigherPriorityTaskWoken will get set to pdTRUE internally within the xTimerStopFromISR() function. If xTimerStopFromISR() sets this value to pdTRUE, then a context switch should be performed before the interrupt exits. </ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>BaseType_t #M#_#C#(TimerHandle_t xTimer, BaseType_t *pxHigherPriorityTaskWoken)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xTimerChangePeriodFromISR</Name>
        <Symbol>xTimerChangePeriodFromISR</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>A version of xTimerChangePeriod() that can be called from an interrupt service routine. </Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>BaseType_t</ReturnType>
        <RetHint>pdFAIL will be returned if the command to change the timers period could not be sent to the timer command queue. pdPASS will be returned if the command was successfully sent to the timer command queue. When the command is actually processed will depend on the priority of the timer service/daemon task relative to other tasks in the system. The timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY configuration constant. </RetHint>
        <ParamCount>3</ParamCount>
        <Parameter>
          <ParName>xTimer</ParName>
          <ParType>TimerHandle_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The handle of the timer that is having its period changed. </ParHint>
        </Parameter>
        <Parameter>
          <ParName>xNewPeriod</ParName>
          <ParType>TickType_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The new period for xTimer. Timer periods are specified in tick periods, so the constant portTICK_PERIOD_MS can be used to convert a time that has been specified in milliseconds. For example, if the timer must expire after 100 ticks, then xNewPeriod should be set to 100. Alternatively, if the timer must expire after 500ms, then xNewPeriod can be set to ( 500 / portTICK_PERIOD_MS ) provided configTICK_RATE_HZ is less than or equal to 1000. </ParHint>
        </Parameter>
        <Parameter>
          <ParName>pxHigherPriorityTaskWoken</ParName>
          <ParType>BaseType_t</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>The timer service/daemon task spends most of its time in the Blocked state, waiting for messages to arrive on the timer command queue. Calling xTimerChangePeriodFromISR() writes a message to the timer command queue, so has the potential to transition the timer service/ daemon task out of the Blocked state. If calling xTimerChangePeriodFromISR() causes the timer service/daemon task to leave the Blocked state, and the timer service/daemon task has a priority equal to or greater than the currently executing task (the task that was interrupted), then *pxHigherPriorityTaskWoken will get set to pdTRUE internally within the xTimerChangePeriodFromISR() function. If xTimerChangePeriodFromISR() sets this value to pdTRUE, then a context switch should be performed before the interrupt exits. </ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>BaseType_t #M#_#C#(TimerHandle_t xTimer, TickType_t xNewPeriod, BaseType_t *pxHigherPriorityTaskWoken)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xTimerResetFromISR</Name>
        <Symbol>xTimerResetFromISR</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>A version of xTimerReset() that can be called from an interrupt service routine.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>BaseType_t</ReturnType>
        <RetHint>pdFAIL will be returned if the reset command could not be sent to the timer command queue. pdPASS will be returned if the command was successfully sent to the timer command queue. When the command is actually processed will depend on the priority of the timer service/daemon task relative to other tasks in the system, although the timers expiry time is relative to when xTimerResetFromISR() is actually called. The timer service/daemon task priority is set by the configTIMER_TASK_PRIORITY configuration constant. </RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>xTimer</ParName>
          <ParType>TimerHandle_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The handle of the timer that is to be started, reset, or restarted. </ParHint>
        </Parameter>
        <Parameter>
          <ParName>pxHigherPriorityTaskWoken</ParName>
          <ParType>BaseType_t</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>The timer service/daemon task spends most of its time in the Blocked state, waiting for messages to arrive on the timer command queue. Calling xTimerResetFromISR() writes a message to the timer command queue, so has the potential to transition the timer service/daemon task out of the Blocked state. If calling xTimerResetFromISR() causes the timer service/daemon task to leave the Blocked state, and the timer service/ daemon task has a priority equal to or greater than the currently executing task (the task that was interrupted), then *pxHigherPriorityTaskWoken will get set to pdTRUE internally within the xTimerResetFromISR() function. If xTimerResetFromISR() sets this value to pdTRUE then a context switch should be performed before the interrupt exits. </ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>BaseType_t #M#_#C#(TimerHandle_t xTimer, BaseType_t *pxHigherPriorityTaskWoken)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>pvTimerGetTimerID</Name>
        <Symbol>pvTimerGetTimerID</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint> Returns the ID assigned to the timer.\n
\n
IDs are assigned to timers using the pvTimerID parameter of the call to xTimerCreate() that was used to create the timer.\n
\n
If the same callback function is assigned to multiple timers then the timer ID can be used within the callback function to identify which timer actually expired. </Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>pointer</ReturnType>
        <RetHint>The ID assigned to the timer being queried. </RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>xTimer</ParName>
          <ParType>TimerHandle_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The timer being queried. </ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void* #M#_#C#(TimerHandle_t xTimer)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xTimerGetTimerDaemonTaskHandle</Name>
        <Symbol>xTimerGetTimerDaemonTaskHandle</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>INCLUDE_xTimerGetTimerDaemonTaskHandle and configUSE_TIMERS must both be set to 1 in FreeRTOSConfig.h for xTimerGetTimerDaemonTaskHandle() to be available. </Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>TaskHandle_t</ReturnType>
        <RetHint>Returns the task handle associated with the software timer daemon (or service) task. If configUSE_TIMERS is set to 1 in FreeRTOSConfig.h, then the timer daemon task is created automatically when the RTOS scheduler is started. </RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>TaskHandle_t #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>pcTimerGetTimerName</Name>
        <Symbol>pcTimerGetTimerName</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint/>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>string</ReturnType>
        <RetHint>A pointer to the timer's name, which is a standard NULL terminated C string. </RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>xTimer</ParName>
          <ParType>TimerHandle_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The handle of the timer being queried. </ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>char* #M#_#C#(TimerHandle_t xTimer)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xTimerPendFunctionCall</Name>
        <Symbol>xTimerPendFunctionCall</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint> Used to pend the execution of a function to the RTOS daemon task (the timer service task, hence this function is pre-fixed with 'Timer').\n
\n
Functions that can be deferred to the RTOS daemon task must have the following prototype:\n
\n
void vPendableFunction( void * pvParameter1, uint32_t ulParameter2 );\n
\n
The pvParameter1 and ulParameter2 are provided for use by the application code.\n
\n
INCLUDE_xTimerPendFunctionCall() and configUSE_TIMERS must both be set to 1 for xTimerPendFunctionCall() to be available. </Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>BaseType_t</ReturnType>
        <RetHint>pdPASS is returned if the message was successfully sent to the RTOS timer daemon task, otherwise pdFALSE is returned. </RetHint>
        <ParamCount>4</ParamCount>
        <Parameter>
          <ParName>xFunctionToPend</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The function to execute from the timer service/ daemon task. The function must conform to the PendedFunction_t prototype as shown above. </ParHint>
          <ParUserDeclaration>PendedFunction_t xFunctionToPend</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>pvParameter1</ParName>
          <ParType>pointer</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The value of the callback function's first parameter. The parameter has a void * type to allow it to be used to pass any type. For example, integer types can be cast to a void *, or the void * can be used to point to a structure. </ParHint>
        </Parameter>
        <Parameter>
          <ParName>ulParameter2</ParName>
          <ParType>uint32_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The value of the callback function's second parameter. </ParHint>
        </Parameter>
        <Parameter>
          <ParName>xTicksToWait</ParName>
          <ParType>TickType_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint> 	Calling this function will result in a message being sent to the timer daemon task on a queue. xTicksToWait is the amount of time the calling task should remain in the Blocked state (so not using any processing time) for space to become available on the timer queue if the queue is found to be full. The length of the queue is set by the value of configTIMER_QUEUE_LENGTH in FreeRTOSConfig.h. </ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>BaseType_t #M#_#C#(PendedFunction_t xFunctionToPend, void* pvParameter1, uint32_t ulParameter2, TickType_t xTicksToWait)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xTimerPendFunctionCallFromISR</Name>
        <Symbol>xTimerPendFunctionCallFromISR</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint> Used from application interrupt service routines to defer the execution of a function to the RTOS daemon task (the timer service task, hence this function is implemented in timers.c and is prefixed with 'Timer').\n
\n
Ideally an interrupt service routine (ISR) is kept as short as possible, but sometimes an ISR either has a lot of processing to do, or needs to perform processing that is not deterministic. In these cases xTimerPendFunctionCallFromISR() can be used to defer processing of a function to the RTOS daemon task.\n
\n
A mechanism is provided that allows the interrupt to return directly to the task that will subsequently execute the pended function. This allows the callback function to execute contiguously in time with the interrupt - just as if the callback had executed in the interrupt itself.\n
\n
Functions that can be deferred to the RTOS daemon task must have the following prototype:\n
\n
void vPendableFunction( void * pvParameter1, uint32_t ulParameter2 );\n
\n
The pvParameter1 and ulParameter2 are provided for use by the application code.\n
\n
INCLUDE_xTimerPendFunctionCall() and configUSE_TIMERS must both be set to 1 for xTimerPendFunctionCallFromISR() to be available. </Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>BaseType_t</ReturnType>
        <RetHint>pdPASS is returned if the message was successfully sent to the RTOS timer daemon task, otherwise pdFALSE is returned. </RetHint>
        <ParamCount>4</ParamCount>
        <Parameter>
          <ParName>xFunctionToPend</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The function to execute from the timer service/ daemon task. The function must conform to the PendedFunction_t prototype as shown above. </ParHint>
          <ParUserDeclaration>PendedFunction_t xFunctionToPend</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>pvParameter1</ParName>
          <ParType>pointer</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint> 	The value of the callback function's first parameter. The parameter has a void * type to allow it to be used to pass any type. For example, integer types can be cast to a void *, or the void * can be used to point to a structure. </ParHint>
        </Parameter>
        <Parameter>
          <ParName>ulParameter2</ParName>
          <ParType>uint32_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The value of the callback function's second parameter. </ParHint>
        </Parameter>
        <Parameter>
          <ParName>pxHigherPriorityTaskWoken</ParName>
          <ParType>BaseType_t</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>As mentioned above, calling xTimerPendFunctionCallFromISR() will result in a message being sent to the RTOS timer daemon task. If the priority of the daemon task (which is set using configTIMER_TASK_PRIORITY in FreeRTOSConfig.h) is higher than the priority of the currently running task (the task the interrupt interrupted) then *pxHigherPriorityTaskWoken will be set to pdTRUE within xTimerPendFunctionCallFromISR(), indicating that a context switch should be requested before the interrupt exits. For that reason *pxHigherPriorityTaskWoken must be initialised to pdFALSE. See the example code below. </ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>BaseType_t #M#_#C#(PendedFunction_t xFunctionToPend, void* pvParameter1, uint32_t ulParameter2, BaseType_t *pxHigherPriorityTaskWoken)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xTaskNotifyGive</Name>
        <Symbol>xTaskNotifyGive</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint> Each RTOS task has a 32-bit notification value which is initialised to zero when the RTOS task is created. An RTOS task notification is an event sent directly to a task that can unblock the receiving task, and optionally update the receiving task's notification value.\n
\n
xTaskNotifyGive() is a macro intended for use when an RTOS task notification value is being used as a light weight and faster binary or counting semaphore alternative. FreeRTOS semaphores are given using the xSemaphoreGive() API function, xTaskNotifyGive() is the equivalent that instead uses the receiving RTOS task's notification value.\n
\n
When a task notification value is being used as a binary or counting semaphore equivalent then the task being notified should wait for the notification using the ulTaskNotifyTake() API function rather than the xTaskNotifyWait() API function.\n
\n
xTaskNotifyGive() must not be called from an interrupt service routine. Use vTaskNotifyGiveFromISR() instead. </Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>BaseType_t</ReturnType>
        <RetHint>xTaskNotifyGive() is a macro that calls xTaskNotify() with the eAction parameter set to eIncrement resulting in all calls returning pdPASS. </RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>xTaskToNotify</ParName>
          <ParType>TaskHandle_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The handle of the RTOS task being notified, and having its notification value incremented.\nRTOS task handles are obtained using the pvCreatedTask parameter of the xTaskCreate() call used to create the task.\nThe handle of the currently executing RTOS task is returned by the xTaskGetCurrentTaskHandle() API function. </ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>BaseType_t #M#_#C#(TaskHandle_t xTaskToNotify)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>vTaskNotifyGiveFromISR</Name>
        <Symbol>vTaskNotifyGiveFromISR</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint> A version of xTaskNotifyGive() that can be called from an interrupt service routine (ISR).\n
\n
Each RTOS task has a 32-bit notification value which is initialised to zero when the RTOS task is created. An RTOS task notification is an event sent directly to a task that can unblock the receiving task, and optionally update the receiving task's notification value.\n
\n
vTaskNotifyGiveFromISR() is a function intended for use when an RTOS task notification value is being used as a light weight and faster binary or counting semaphore alternative. FreeRTOS semaphores are given from an interrupt using the xSemaphoreGiveFromISR() API function, vTaskNotifyGiveFromISR() is the equivalent that instead uses the receiving RTOS task's notification value.\n
\n
When a task notification value is being used as a binary or counting semaphore equivalent then the task being notified should wait for the notification using the ulTaskNotifyTake() API function rather than the xTaskNotifyWait() API function. </Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>xTaskToNotify</ParName>
          <ParType>TaskHandle_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The handle of the RTOS task being notified, and having its notification value incremented.\n\nRTOS task handles are obtained using the pvCreatedTask parameter of the xTaskCreate() call used to create the task.\n\nThe handle of the currently executing RTOS task is returned by the xTaskGetCurrentTaskHandle() API function. </ParHint>
        </Parameter>
        <Parameter>
          <ParName>pxHigherPriorityTaskWoken</ParName>
          <ParType>BaseType_t</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>*pxHigherPriorityTaskWoken must be initialised to 0.\n\nvTaskNotifyGiveFromISR() will set *pxHigherPriorityTaskWoken to pdTRUE if sending the notification caused a task to unblock, and the unblocked task has a priority higher than the currently running task.\n\nIf vTaskNotifyGiveFromISR() sets this value to pdTRUE then a context switch should be requested before the interrupt is exited. See the example below.\n\npxHigherPriorityTaskWoken is an optional parameter and can be set to NULL. </ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>ulTaskNotifyTake</Name>
        <Symbol>ulTaskNotifyTake</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint> Each RTOS task has a 32-bit notification value which is initialised to zero when the RTOS task is created. An RTOS task notification is an event sent directly to a task that can unblock the receiving task, and optionally update the receiving task's notification value.\n
\n
ulTaskNotifyTake() is intended for use when a task notification is used as a faster and lighter weight binary or counting semaphore alternative. FreeRTOS semaphores are taken using the xSemaphoreTake() API function, ulTaskNotifyTake() is the equivalent that instead uses a task notification.\n
\n
When a task is using its notification value as a binary or counting semaphore other tasks and interrupts should send notifications to it using either the xTaskNotifyGive() macro, or the xTaskNotify() function with the function's eAction parameter set to eIncrement (the two are equivalent).\n
\n
ulTaskNotifyTake() can either clear the task's notification value to zero on exit, in which case the notification value acts like a binary semaphore, or decrement the task's notification value on exit, in which case the notification value acts more like a counting semaphore.\n
\n
An RTOS task can use ulTaskNotifyTake() to [optionally] block to wait for a the task's notification value to be non-zero. The task does not consume any CPU time while it is in the Blocked state.\n
\n
Where as xTaskNotifyWait() will return when a notification is pending, ulTaskNotifyTake() will return when the task's notification value is not zero, decrementing the task's notification value before it returns. </Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>uint32_t</ReturnType>
        <RetHint>The value of the task's notification value before it is decremented or cleared (see the description of xClearCountOnExit). </RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>xClearCountOnExit</ParName>
          <ParType>BaseType_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>If an RTOS task notification is received and xClearCountOnExit is set to pdFALSE then the RTOS task's notification value is decremented before ulTaskNotifyTake() exits. This is equivalent to the value of a counting semaphore being decremented by a successful call to xSemaphoreTake().\n\nIf an RTOS task notification is received and xClearCountOnExit is set to pdTRUE then the RTOS task's notification value is reset to 0 before ulTaskNotifyTake() exits. This is equivalent to the value of a binary semaphore being left at zero (or empty, or 'not available') after a successful call to xSemaphoreTake(). </ParHint>
        </Parameter>
        <Parameter>
          <ParName>xTicksToWait</ParName>
          <ParType>TickType_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The maximum time to wait in the Blocked state for a notification to be received if a notification is not already pending when ulTaskNotifyTake() is called.\n\nThe RTOS task does not consume any CPU time when it is in the Blocked state.\n\nThe time is specified in RTOS tick periods. The pdMS_TO_TICKS() macro can be used to convert a time specified in milliseconds into a time specified in ticks. </ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>uint32_t #M#_#C#(BaseType_t xClearCountOnExit, TickType_t xTicksToWait)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xTaskNotify</Name>
        <Symbol>xTaskNotify</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint> [If you are using RTOS task notifications to implement binary or counting semaphore type behaviour then use the simpler xTaskNotifyGive() API function instead of xTaskNotify()]\n
\n
Each RTOS task has a 32-bit notification value which is initialised to zero when the RTOS task is created. xTaskNotify() is used to send an event directly to and potentially unblock an RTOS task, and optionally update the receiving task's notification value in one of the following ways:\n
\n
    - Write a 32-bit number to the notification value\n
    - Add one (increment) the notification value\n
    - Set one or more bits in the notification value\n
    - Leave the notification value unchanged\n
\n
This function must not be called from an interrupt service routine (ISR). Use xTaskNotifyFromISR() instead. </Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>BaseType_t</ReturnType>
        <RetHint>pdPASS is returned in all cases other than when eAction is set to eSetValueWithoutOverwrite and the subject task's notification value cannot be updated because the subject task already had a notification pending. </RetHint>
        <ParamCount>3</ParamCount>
        <Parameter>
          <ParName>xTaskToNotify</ParName>
          <ParType>TaskHandle_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The handle of the RTOS task being notified. This is the subject task.\n\nRTOS task handles are obtained using the pvCreatedTask parameter of the xTaskCreate() call used to create the task.\n\nThe handle of the currently executing RTOS task is returned by the xTaskGetCurrentTaskHandle() API function. </ParHint>
        </Parameter>
        <Parameter>
          <ParName>ulValue</ParName>
          <ParType>uint32_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Used to update the notification value of the subject task. See the description of the eAction parameter below. </ParHint>
        </Parameter>
        <Parameter>
          <ParName>eAction</ParName>
          <ParType>eNotifyAction</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>An enumerated type that can take one of the values documented in the table below in order to perform the associated action. \n- eNoAction: 	The subject task receives the event, but its notification value is not updated. In this case ulValue is not used.\n- eSetBits: 	The notification value of the subject task will be bitwise ORed with ulValue. For example, if ulValue is set to 0x01, then bit 0 will get set within the subject task's notification value. Likewise if ulValue is 0x04 then bit 2 will get set in the subject task's notification value. In this way the RTOS task notification mechanism can be used as a light weight alternative to an event group.\n- eIncrement: 	The notification value of the subject task will be incremented by one, making the call to xTaskNotify() equivalent to a call to xTaskNotifyGive(). In this case ulValue is not used.\n- eSetValueWithOverwrite: 	The notification value of the subject task is unconditionally set to ulValue. In this way the RTOS task notification mechanism is being used as a light weight alternative to xQueueOverwrite().\n- eSetValueWithoutOverwrite: 	If the subject task does not already have a notification pending then its notification value will be set to ulValue. If the subject task already has a notification pending then its notification value is not updated as to do so would overwrite the previous value before it was used. In this case the call to xTaskNotify() fails and pdFALSE is returned. In this way the RTOS task notification mechanism is being used as a light weight alternative to xQueueSend() on a queue of length 1. </ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>BaseType_t #M#_#C#(TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xTaskNotifyFromISR</Name>
        <Symbol>xTaskNotifyFromISR</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint> [If you are using RTOS task notifications to implement binary or counting semaphore type behaviour then use the simpler xTaskNotifyGive() API function instead of xTaskNotify()]\n
\n
A version of xTaskNotify() that can be called from an ISR. \n
\n
Each RTOS task has a 32-bit notification value which is initialised to zero when the RTOS task is created. xTaskNotify() is used to send an event directly to and potentially unblock an RTOS task, and optionally update the receiving task's notification value in one of the following ways:\n
\n
    - Write a 32-bit number to the notification value\n
    - Add one (increment) the notification value\n
    - Set one or more bits in the notification value\n
    - Leave the notification value unchanged\n
\n
This function must not be called from an interrupt service routine (ISR). Use xTaskNotifyFromISR() instead. </Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>BaseType_t</ReturnType>
        <RetHint>pdPASS is returned in all cases other than when eAction is set to eSetValueWithoutOverwrite and the subject task's notification value cannot be updated because the subject task already had a notification pending. </RetHint>
        <ParamCount>4</ParamCount>
        <Parameter>
          <ParName>xTaskToNotify</ParName>
          <ParType>TaskHandle_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The handle of the RTOS task being notified. This is the subject task.\n\nRTOS task handles are obtained using the pvCreatedTask parameter of the xTaskCreate() call used to create the task.\n\nThe handle of the currently executing RTOS task is returned by the xTaskGetCurrentTaskHandle() API function. </ParHint>
        </Parameter>
        <Parameter>
          <ParName>ulValue</ParName>
          <ParType>uint32_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Used to update the notification value of the subject task. See the description of the eAction parameter below. </ParHint>
        </Parameter>
        <Parameter>
          <ParName>eAction</ParName>
          <ParType>eNotifyAction</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>An enumerated type that can take one of the values documented in the table below in order to perform the associated action. \n- eNoAction: 	The subject task receives the event, but its notification value is not updated. In this case ulValue is not used.\n- eSetBits: 	The notification value of the subject task will be bitwise ORed with ulValue. For example, if ulValue is set to 0x01, then bit 0 will get set within the subject task's notification value. Likewise if ulValue is 0x04 then bit 2 will get set in the subject task's notification value. In this way the RTOS task notification mechanism can be used as a light weight alternative to an event group.\n- eIncrement: 	The notification value of the subject task will be incremented by one, making the call to xTaskNotify() equivalent to a call to xTaskNotifyGive(). In this case ulValue is not used.\n- eSetValueWithOverwrite: 	The notification value of the subject task is unconditionally set to ulValue. In this way the RTOS task notification mechanism is being used as a light weight alternative to xQueueOverwrite().\n- eSetValueWithoutOverwrite: 	If the subject task does not already have a notification pending then its notification value will be set to ulValue. If the subject task already has a notification pending then its notification value is not updated as to do so would overwrite the previous value before it was used. In this case the call to xTaskNotify() fails and pdFALSE is returned. In this way the RTOS task notification mechanism is being used as a light weight alternative to xQueueSend() on a queue of length 1. </ParHint>
        </Parameter>
        <Parameter>
          <ParName>pxHigherPriorityTaskWoken</ParName>
          <ParType>BaseType_t</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>*pxHigherPriorityTaskWoken must be initialised to 0.\n\nxTaskNotifyFromISR() will set *pxHigherPriorityTaskWoken to pdTRUE if sending the notification caused a task to unblock, and the unblocked task has a priority higher than the currently running task.\n\nIf xTaskNotifyFromISR() sets this value to pdTRUE then a context switch should be requested before the interrupt is exited. See the example below.\n\npxHigherPriorityTaskWoken is an optional parameter and can be set to NULL. </ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>BaseType_t #M#_#C#(TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, BaseType_t *pxHigherPriorityTaskWoken)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xTaskNotifyAndQuery</Name>
        <Symbol>xTaskNotifyAndQuery</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint> [If you are using RTOS task notifications to implement binary or counting semaphore type behaviour then use the simpler xTaskNotifyGive() API function instead of xTaskNotify()]\n
\n
Each RTOS task has a 32-bit notification value which is initialised to zero when the RTOS task is created. xTaskNotify() is used to send an event directly to and potentially unblock an RTOS task, and optionally update the receiving task's notification value in one of the following ways:\n
\n
    - Write a 32-bit number to the notification value\n
    - Add one (increment) the notification value\n
    - Set one or more bits in the notification value\n
    - Leave the notification value unchanged\n
\n
This function must not be called from an interrupt service routine (ISR). Use xTaskNotifyFromISR() instead. </Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>BaseType_t</ReturnType>
        <RetHint>pdPASS is returned in all cases other than when eAction is set to eSetValueWithoutOverwrite and the subject task's notification value cannot be updated because the subject task already had a notification pending. </RetHint>
        <ParamCount>4</ParamCount>
        <Parameter>
          <ParName>xTaskToNotify</ParName>
          <ParType>TaskHandle_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The handle of the RTOS task being notified. This is the subject task.\n\nRTOS task handles are obtained using the pvCreatedTask parameter of the xTaskCreate() call used to create the task.\n\nThe handle of the currently executing RTOS task is returned by the xTaskGetCurrentTaskHandle() API function. </ParHint>
        </Parameter>
        <Parameter>
          <ParName>ulValue</ParName>
          <ParType>uint32_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Used to update the notification value of the subject task. See the description of the eAction parameter below. </ParHint>
        </Parameter>
        <Parameter>
          <ParName>eAction</ParName>
          <ParType>eNotifyAction</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>An enumerated type that can take one of the values documented in the table below in order to perform the associated action. </ParHint>
        </Parameter>
        <Parameter>
          <ParName>pulPreviousNotifyValue</ParName>
          <ParType>uint32_t</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Can be used to pass out the subject task's notification value before any bits are modified by the action of xTaskNotifyAndQuery().\n\npulPreviousNotifyValue is an optional parameter, and can be set to NULL if it is not required. If pulPreviousNotifyValue is not used then consider using xTaskNotify() in place of xTaskNotifyAndQuery(). </ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>BaseType_t #M#_#C#(TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotifyValue)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xTaskNotifyAndQueryFromISR</Name>
        <Symbol>xTaskNotifyAndQueryFromISR</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint> [If you are using RTOS task notifications to implement binary or counting semaphore type behaviour then use the simpler xTaskNotifyGive() API function instead of xTaskNotify()]\n
\n
Each RTOS task has a 32-bit notification value which is initialised to zero when the RTOS task is created. xTaskNotify() is used to send an event directly to and potentially unblock an RTOS task, and optionally update the receiving task's notification value in one of the following ways:\n
\n
    - Write a 32-bit number to the notification value\n
    - Add one (increment) the notification value\n
    - Set one or more bits in the notification value\n
    - Leave the notification value unchanged\n
\n
This function must not be called from an interrupt service routine (ISR). Use xTaskNotifyFromISR() instead. </Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>BaseType_t</ReturnType>
        <RetHint>pdPASS is returned in all cases other than when eAction is set to eSetValueWithoutOverwrite and the subject task's notification value cannot be updated because the subject task already had a notification pending. </RetHint>
        <ParamCount>5</ParamCount>
        <Parameter>
          <ParName>xTaskToNotify</ParName>
          <ParType>TaskHandle_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The handle of the RTOS task being notified. This is the subject task.\n\nRTOS task handles are obtained using the pvCreatedTask parameter of the xTaskCreate() call used to create the task.\n\nThe handle of the currently executing RTOS task is returned by the xTaskGetCurrentTaskHandle() API function. </ParHint>
        </Parameter>
        <Parameter>
          <ParName>ulValue</ParName>
          <ParType>uint32_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Used to update the notification value of the subject task. See the description of the eAction parameter below. </ParHint>
        </Parameter>
        <Parameter>
          <ParName>eAction</ParName>
          <ParType>eNotifyAction</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>An enumerated type that can take one of the values documented in the table below in order to perform the associated action. </ParHint>
        </Parameter>
        <Parameter>
          <ParName>pulPreviousNotifyValue</ParName>
          <ParType>uint32_t</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Can be used to pass out the subject task's notification value before any bits are modified by the action of xTaskNotifyAndQuery().\n\npulPreviousNotifyValue is an optional parameter, and can be set to NULL if it is not required. If pulPreviousNotifyValue is not used then consider using xTaskNotify() in place of xTaskNotifyAndQuery(). </ParHint>
        </Parameter>
        <Parameter>
          <ParName>pxHigherPriorityTaskWoken</ParName>
          <ParType>BaseType_t</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>*pxHigherPriorityTaskWoken must be initialised to 0.\n\nxTaskNotifyFromISR() will set *pxHigherPriorityTaskWoken to pdTRUE if sending the notification caused a task to unblock, and the unblocked task has a priority higher than the currently running task.\n\nIf xTaskNotifyFromISR() sets this value to pdTRUE then a context switch should be requested before the interrupt is exited. See the example below.\n\npxHigherPriorityTaskWoken is an optional parameter and can be set to NULL. </ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>BaseType_t #M#_#C#(TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotifyValue, BaseType_t *pxHigherPriorityTaskWoken)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xTaskNotifyWait</Name>
        <Symbol>xTaskNotifyWait</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint> [If you are using RTOS task notifications to implement binary or counting semaphore type behaviour then use the simpler ulTaskNotifyTake() API function instead of xTaskNotifyWait()]\n
\n
Each RTOS task has a 32-bit notification value which is initialised to zero when the RTOS task is created. An RTOS task notification is an event sent directly to a task that can unblock the receiving task, and optionally update the receiving task's notification value in a number of different ways. For example, a notification may overwrite the receiving task's notification value, or just set one or more bits in the receiving task's notification value. See the RTOS task notifications use case documentation for examples.\n
\n
xTaskNotifyWait() waits, with an optional timeout, for the calling task to receive a notification.\n
\n
If the receiving RTOS task was already Blocked waiting for a notification when one arrives the receiving RTOS task will be removed from the Blocked state and the notification cleared. </Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>BaseType_t</ReturnType>
        <RetHint>pdTRUE if a notification was received, or a notification was already pending when xTaskNotifyWait() was called.\n\npdFALSE if the call to xTaskNotifyWait() timed out before a notification was received. </RetHint>
        <ParamCount>4</ParamCount>
        <Parameter>
          <ParName>ulBitsToClearOnEntry</ParName>
          <ParType>uint32_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Any bits set in ulBitsToClearOnEntry will be cleared in the calling RTOS task's notification value on entry to the xTaskNotifyWait() function (before the task waits for a new notification) provided a notification is not already pending when xTaskNotifyWait() is called.\n\nFor example, if ulBitsToClearOnEntry is 0x01, then bit 0 of the task's notification value will be cleared on entry to the function.\n\nSetting ulBitsToClearOnEntry to 0xffffffff (ULONG_MAX) will clear all the bits in the task's notification value, effectively clearing the value to 0. </ParHint>
        </Parameter>
        <Parameter>
          <ParName>ulBitsToClearOnExit</ParName>
          <ParType>uint32_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Any bits set in ulBitsToClearOnExit will be cleared in the calling RTOS task's notification value before xTaskNotifyWait() function exits if a notification was received.\n\nThe bits are cleared after the RTOS task's notification value has been saved in *pulNotificationValue (see the description of pulNotificationValue below).\n\nFor example, if ulBitsToClearOnExit is 0x03, then bit 0 and bit 1 of the task's notification value will be cleared before the function exits.\n\nSetting ulBitsToClearOnExit to 0xffffffff (ULONG_MAX) will clear all the bits in the task's notification value, effectively clearing the value to 0. </ParHint>
        </Parameter>
        <Parameter>
          <ParName>pulNotificationValue</ParName>
          <ParType>uint32_t</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Used to pass out the RTOS task's notification value. The value copied to *pulNotificationValue is the RTOS task's notification value as it was before any bits were cleared due to the ulBitsToClearOnExit setting.\n\nIf the notification value is not required then set pulNotificationValue to NULL. </ParHint>
        </Parameter>
        <Parameter>
          <ParName>xTicksToWait</ParName>
          <ParType>TickType_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The maximum time to wait in the Blocked state for a notification to be received if a notification is not already pending when xTaskNotifyWait() is called.\n\nThe RTOS task does not consume any CPU time when it is in the Blocked state.\n\nThe time is specified in RTOS tick periods. The pdMS_TO_TICKS() macro can be used to convert a time specified in milliseconds into a time specified in ticks. </ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>BaseType_t #M#_#C#(uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xTaskNotifyStateClear</Name>
        <Symbol>xTaskNotifyStateClear</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint> [If you are using RTOS task notifications to implement binary or counting semaphore type behaviour then use the simpler xTaskNotifyGive() API function instead of xTaskNotify()]\n
\n
 If the notification state of the task referenced by the handle xTask is eNotified, then set the task's notification state to eNotWaitingNotification. The task's notification value is not altered.  Set xTask to NULL to clear the notification state of the calling task.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>BaseType_t</ReturnType>
        <RetHint>pdPASS is returned in all cases other than when eAction is set to eSetValueWithoutOverwrite and the subject task's notification value cannot be updated because the subject task already had a notification pending. </RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>xTask</ParName>
          <ParType>TaskHandle_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The handle of the RTOS task. Use NULL for using the calling task.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>BaseType_t #M#_#C#(TaskHandle_t xTask)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>vTaskSetThreadLocalStoragePointer</Name>
        <Symbol>vTaskSetThreadLocalStoragePointer</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Only enabled if configNUM_THREAD_LOCAL_STORAGE_POINTERS is &gt;0.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>3</ParamCount>
        <Parameter>
          <ParName>xTaskToSet</ParName>
          <ParType>TaskHandle_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Task handle</ParHint>
        </Parameter>
        <Parameter>
          <ParName>xIndex</ParName>
          <ParType>BaseType_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Index of thread local storage item</ParHint>
        </Parameter>
        <Parameter>
          <ParName>pvValue</ParName>
          <ParType>pVoid</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint/>
          <ParUserDeclaration>void *pvValue</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(TaskHandle_t xTaskToSet, BaseType_t xIndex, void *pvValue)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>pvTaskGetThreadLocalStoragePointer</Name>
        <Symbol>pvTaskGetThreadLocalStoragePointer</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Sets the thread local storage. Only enabled if configNUM_THREAD_LOCAL_STORAGE_POINTERS is &gt;0</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>pointer</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>xTaskToQuery</ParName>
          <ParType>TaskHandle_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Task handle from which to get the local thread storage.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>xIndex</ParName>
          <ParType>BaseType_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Index of thread storage</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void* #M#_#C#(TaskHandle_t xTaskToQuery, BaseType_t xIndex)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>pcTaskGetName</Name>
        <Symbol>pcTaskGetName</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Looks up the name of a task from the task's handle. </Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>string</ReturnType>
        <RetHint>A pointer to the subject task's name, which is a standard NULL terminated C string.</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>xTaskToQuery</ParName>
          <ParType>TaskHandle_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The handle of the task being queried. xTaskToQuery can be set to NULL to query the name of the calling task.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>char* #M#_#C#(TaskHandle_t xTaskToQuery)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>vTaskGetInfo</Name>
        <Symbol>vTaskGetInfo</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Whereas uxTaskGetSystemState() populates a TaskStatus_t structure for each task in the system, vTaskGetInfo() populates a TaskStatus_t structures for just a single task. The TaskStatus_t structure contains, among other things, members for the task handle, task name, task priority, task state, and total amount of run time consumed by the task. </Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>4</ParamCount>
        <Parameter>
          <ParName>xTask</ParName>
          <ParType>TaskHandle_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The handle of the task being queried. Setting xTask to NULL will return information on the calling task. </ParHint>
        </Parameter>
        <Parameter>
          <ParName>pxTaskStatus</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The TaskStatus_t structure pointed to by pxTaskStatus will be filled with information about the task referenced by the handle passed in the xTask parameter. </ParHint>
          <ParUserDeclaration>TaskStatus_t *pxTaskStatus</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>xGetFreeStackSpace</ParName>
          <ParType>BaseType_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The TaskStatus_t structure contains a member to report the stack high water mark of the task being queried. The stack high water mark is the minimum amount of stack space that has ever existed, so the closer the number is to zero the closer the task has come to overflowing its stack.Calculating the stack high water mark takes a relatively long time, and can make the system temporarily unresponsive - so the xGetFreeStackSpace parameter is provided to allow the high water mark checking to be skipped. The high watermark value will only be written to the TaskStatus_t structure if xGetFreeStackSpace is not set to pdFALSE. </ParHint>
        </Parameter>
        <Parameter>
          <ParName>eState</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The TaskStatus_t structure contains a member to report the state of the task being queried. Obtaining the task state is not as fast as a simple assignment - so the eState parameter is provided to allow the state information to be omitted from the TaskStatus_t structure. To obtain state information then set eState to eInvalid - otherwise the value passed in eState will be reported as the task state in the TaskStatus_t structure. </ParHint>
          <ParUserDeclaration>eTaskState eState</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>ParseCommand</Name>
        <Symbol>ParseCommand</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Shell Command Line Parser</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>uint8_t</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>3</ParamCount>
        <Parameter>
          <ParName>cmd</ParName>
          <ParType>uint8_t</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to command string</ParHint>
          <ParUserDeclaration>const unsigned char *cmd</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>handled</ParName>
          <ParType>Boolean</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to variable which tells if the command has been handled or not</ParHint>
        </Parameter>
        <Parameter>
          <ParName>io</ParName>
          <ParType>uint8_t</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to I/O structure</ParHint>
          <ParUserDeclaration>const %@Shell@'ModuleName'%.StdIOType *io</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>uint8_t #M#_#C#(const unsigned char *cmd, bool *handled, const %@Shell@'ModuleName'%.StdIOType *io)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>AppConfigureTimerForRuntimeStats</Name>
        <Symbol>AppConfigureTimerForRuntimeStats</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Configures the timer for generating runtime statistics</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>AppGetRuntimeCounterValueFromISR</Name>
        <Symbol>AppGetRuntimeCounterValueFromISR</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>returns the current runtime counter. Function can be called from an interrupt service routine.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>uint32_t</ReturnType>
        <RetHint>runtime counter value</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>uint32_t #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>Deinit</Name>
        <Symbol>Deinit</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Module deinitialization method</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>Init</Name>
        <Symbol>Init</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Low level initialization routine called from startup code. This method ensures that the tick timer is  not enabled.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
  </MethodList>
  <EventList>
    <Event>
      <TStrgItem>
        <Name>Event module name</Name>
        <Symbol>EventModule</Symbol>
        <Hint>Name of the user module (without extension), where the events from this bean are placed.</Hint>
        <ItemLevel>ADVANCED</ItemLevel>
        <EditLine>true</EditLine>
        <DefaultValue>Events</DefaultValue>
        <StrDefine>nothing</StrDefine>
        <MinLength>0</MinLength>
        <MaxLength>-1</MaxLength>
      </TStrgItem>
    </Event>
    <Event>
      <TEvntItem>
        <Name>vApplicationStackOverflowHook</Name>
        <Symbol>vApplicationStackOverflowHook</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>if enabled, this hook will be called in case of a stack overflow.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <BoldName>true</BoldName>
        <EditLine>false</EditLine>
        <Description>generate code</Description>
        <Expanded>Yes</Expanded>
        <DefaultValue>true</DefaultValue>
        <DefineSymbol>YES_NO</DefineSymbol>
        <IfDisabled>setNOTHING</IfDisabled>
        <IsAssembler>false</IsAssembler>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>pxTask</ParName>
          <ParType>TaskHandle_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Task handle</ParHint>
        </Parameter>
        <Parameter>
          <ParName>pcTaskName</ParName>
          <ParType>char</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to task name</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #C#(TaskHandle_t pxTask, char *pcTaskName)</ANSIC>
        </Declarations>
        <Children>
          <GrupItem>
            <TEvntName>
              <Name>Event procedure name</Name>
              <Symbol>Name</Symbol>
              <Hint>vApplicationStackOverflowHook procedure name</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue/>
              <StrDefine>nothing</StrDefine>
              <MinLength>0</MinLength>
              <MaxLength>-1</MaxLength>
              <ErrorIfNotSet>true</ErrorIfNotSet>
              <IdentType>EVNT</IdentType>
            </TEvntName>
          </GrupItem>
        </Children>
      </TEvntItem>
    </Event>
    <Event>
      <TEvntItem>
        <Name>vApplicationTickHook</Name>
        <Symbol>vApplicationTickHook</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>If enabled, this hook will be called by the RTOS for every tick increment.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <BoldName>true</BoldName>
        <EditLine>false</EditLine>
        <Description>generate code</Description>
        <Expanded>Yes</Expanded>
        <DefaultValue>true</DefaultValue>
        <DefineSymbol>YES_NO</DefineSymbol>
        <IfDisabled>setNOTHING</IfDisabled>
        <IsAssembler>false</IsAssembler>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #C#(void)</ANSIC>
        </Declarations>
        <Children>
          <GrupItem>
            <TEvntName>
              <Name>Event procedure name</Name>
              <Symbol>Name</Symbol>
              <Hint>vApplicationTickHook procedure name</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue/>
              <StrDefine>nothing</StrDefine>
              <MinLength>0</MinLength>
              <MaxLength>-1</MaxLength>
              <ErrorIfNotSet>true</ErrorIfNotSet>
              <IdentType>EVNT</IdentType>
            </TEvntName>
          </GrupItem>
        </Children>
      </TEvntItem>
    </Event>
    <Event>
      <TEvntItem>
        <Name>vApplicationIdleHook</Name>
        <Symbol>vApplicationIdleHook</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>If enabled, this hook will be called when the RTOS is idle. This might be a good place to go into low power mode.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <BoldName>true</BoldName>
        <EditLine>false</EditLine>
        <Description>generate code</Description>
        <Expanded>Yes</Expanded>
        <DefaultValue>true</DefaultValue>
        <DefineSymbol>YES_NO</DefineSymbol>
        <IfDisabled>setNOTHING</IfDisabled>
        <IsAssembler>false</IsAssembler>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #C#(void)</ANSIC>
        </Declarations>
        <Children>
          <GrupItem>
            <TEvntName>
              <Name>Event procedure name</Name>
              <Symbol>Name</Symbol>
              <Hint>vApplicationIdleHook procedure name</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue/>
              <StrDefine>nothing</StrDefine>
              <MinLength>0</MinLength>
              <MaxLength>-1</MaxLength>
              <ErrorIfNotSet>true</ErrorIfNotSet>
              <IdentType>EVNT</IdentType>
            </TEvntName>
          </GrupItem>
        </Children>
      </TEvntItem>
    </Event>
    <Event>
      <TEvntItem>
        <Name>vApplicationMallocFailedHook</Name>
        <Symbol>vApplicationMallocFailedHook</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>If enabled, the RTOS will call this hook in case memory allocation failed.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <BoldName>true</BoldName>
        <EditLine>false</EditLine>
        <Description>generate code</Description>
        <Expanded>Yes</Expanded>
        <DefaultValue>true</DefaultValue>
        <DefineSymbol>YES_NO</DefineSymbol>
        <IfDisabled>setNOTHING</IfDisabled>
        <IsAssembler>false</IsAssembler>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #C#(void)</ANSIC>
        </Declarations>
        <Children>
          <GrupItem>
            <TEvntName>
              <Name>Event procedure name</Name>
              <Symbol>Name</Symbol>
              <Hint>vApplicationMallocFailedHook procedure name</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue/>
              <StrDefine>nothing</StrDefine>
              <MinLength>0</MinLength>
              <MaxLength>-1</MaxLength>
              <ErrorIfNotSet>true</ErrorIfNotSet>
              <IdentType>EVNT</IdentType>
            </TEvntName>
          </GrupItem>
        </Children>
      </TEvntItem>
    </Event>
    <Event>
      <TEvntItem>
        <Name>vOnPreSleepProcessing</Name>
        <Symbol>vOnPreSleepProcessing</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Used in tickless idle mode only, but required in this mode. Hook for the application to enter low power mode.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <BoldName>true</BoldName>
        <EditLine>false</EditLine>
        <Description>generate code</Description>
        <Expanded>Yes</Expanded>
        <DefaultValue>true</DefaultValue>
        <DefineSymbol>YES_NO</DefineSymbol>
        <IfDisabled>setNOTHING</IfDisabled>
        <IsAssembler>false</IsAssembler>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>expectedIdleTicks</ParName>
          <ParType>TickType_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>expected idle time, in ticks</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #C#(TickType_t expectedIdleTicks)</ANSIC>
        </Declarations>
        <Children>
          <GrupItem>
            <TEvntName>
              <Name>Event procedure name</Name>
              <Symbol>Name</Symbol>
              <Hint>vOnPreSleepProcessing procedure name</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue/>
              <StrDefine>nothing</StrDefine>
              <MinLength>0</MinLength>
              <MaxLength>-1</MaxLength>
              <ErrorIfNotSet>true</ErrorIfNotSet>
              <IdentType>EVNT</IdentType>
            </TEvntName>
          </GrupItem>
        </Children>
      </TEvntItem>
    </Event>
    <Event>
      <TEvntItem>
        <Name>vOnPostSleepProcessing</Name>
        <Symbol>vOnPostSleepProcessing</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Event called after the CPU woke up after low power mode. This event is optional.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <BoldName>true</BoldName>
        <EditLine>false</EditLine>
        <Description>generate code</Description>
        <Expanded>Yes</Expanded>
        <DefaultValue>true</DefaultValue>
        <DefineSymbol>YES_NO</DefineSymbol>
        <IfDisabled>setNOTHING</IfDisabled>
        <IsAssembler>false</IsAssembler>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>expectedIdleTicks</ParName>
          <ParType>TickType_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>expected idle time, in ticks</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #C#(TickType_t expectedIdleTicks)</ANSIC>
        </Declarations>
        <Children>
          <GrupItem>
            <TEvntName>
              <Name>Event procedure name</Name>
              <Symbol>Name</Symbol>
              <Hint>vOnPostSleepProcessing procedure name</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue/>
              <StrDefine>nothing</StrDefine>
              <MinLength>0</MinLength>
              <MaxLength>-1</MaxLength>
              <ErrorIfNotSet>true</ErrorIfNotSet>
              <IdentType>EVNT</IdentType>
            </TEvntName>
          </GrupItem>
        </Children>
      </TEvntItem>
    </Event>
  </EventList>
  <Links>
    <EmptySection_DummyValue/>
  </Links>
  <Revisions>
    <RevisionVersion>2</RevisionVersion>
  </Revisions>
</Bean>
