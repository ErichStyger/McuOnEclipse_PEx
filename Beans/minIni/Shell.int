<?xml version="1.0" encoding="UTF-8"?>
<Interface>
  <Name>Shell</Name>
  <Description>Interface "minIni\Shell" for component minIni, generated by Component Wizard</Description>
  <Author>Author</Author>
  <Version>01.000</Version>
  <FileVersion>2</FileVersion>
  <MethodList>
    <Method>
      <TMthdItem>
        <Name>PrintPrompt</Name>
        <Symbol>PrintPrompt</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Prints the prompt to the stdOut channel</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>void</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>io</ParName>
          <ParType>ConstStdIOType</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to IO to be used</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(ConstStdIOType *io)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>SendNum8u</Name>
        <Symbol>SendNum8u</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Sends an 8bit unsigned number to the given I/O</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>void</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>val</ParName>
          <ParType>uint8_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>number to print</ParHint>
        </Parameter>
        <Parameter>
          <ParName>io</ParName>
          <ParType>StdIO_OutErr_FctType</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>I/O callbacks to be used for printing.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(uint8_t val, StdIO_OutErr_FctType io)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>SendNum8s</Name>
        <Symbol>SendNum8s</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Sends an 8bit signed number to the given I/O</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>void</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>val</ParName>
          <ParType>int8_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>number to print</ParHint>
        </Parameter>
        <Parameter>
          <ParName>io</ParName>
          <ParType>StdIO_OutErr_FctType</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>I/O callbacks to be used for printing.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(int8_t val, StdIO_OutErr_FctType io)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>SendNum16u</Name>
        <Symbol>SendNum16u</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Sends a 16bit unsigned number to the given I/O</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>void</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>val</ParName>
          <ParType>uint16_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>number to print</ParHint>
        </Parameter>
        <Parameter>
          <ParName>io</ParName>
          <ParType>StdIO_OutErr_FctType</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>I/O callbacks to be used for printing.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(uint16_t val, StdIO_OutErr_FctType io)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>SendNum16s</Name>
        <Symbol>SendNum16s</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Sends a 16bit signed number to the given I/O</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>void</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>val</ParName>
          <ParType>int16_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>number to print</ParHint>
        </Parameter>
        <Parameter>
          <ParName>io</ParName>
          <ParType>StdIO_OutErr_FctType</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>I/O callbacks to be used for printing.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(int16_t val, StdIO_OutErr_FctType io)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>SendNum32u</Name>
        <Symbol>SendNum32u</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Sends a 32bit unsigned number to the given I/O</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>void</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>val</ParName>
          <ParType>uint32_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>number to print</ParHint>
        </Parameter>
        <Parameter>
          <ParName>io</ParName>
          <ParType>StdIO_OutErr_FctType</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>I/O callbacks to be used for printing.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(uint32_t val, StdIO_OutErr_FctType io)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>SendNum32s</Name>
        <Symbol>SendNum32s</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Sends a 32bit signed number to the given I/O</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>void</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>val</ParName>
          <ParType>int32_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>number to print</ParHint>
        </Parameter>
        <Parameter>
          <ParName>io</ParName>
          <ParType>StdIO_OutErr_FctType</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>I/O callbacks to be used for printing.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(int32_t val, StdIO_OutErr_FctType io)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>SendCh</Name>
        <Symbol>SendCh</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Prints a character using an I/O function</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>ch</ParName>
          <ParType>uint8_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Character to send</ParHint>
        </Parameter>
        <Parameter>
          <ParName>io</ParName>
          <ParType>StdIO_OutErr_FctType</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>I/O callbacks to be used for printing.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(uint8_t ch, StdIO_OutErr_FctType io)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>SendStr</Name>
        <Symbol>SendStr</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Prints a string using an I/O function</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>str</ParName>
          <ParType>uint8_t</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to string (zero terminated) to be printed.</ParHint>
          <ParUserDeclaration>const uint8_t *str</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>io</ParName>
          <ParType>StdIO_OutErr_FctType</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>I/O callbacks to be used for printing.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(const uint8_t *str, StdIO_OutErr_FctType io)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>PrintMemory</Name>
        <Symbol>PrintMemory</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Prints a chunk of memory bytes in a formatted way.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>uint8_t</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>7</ParamCount>
        <Parameter>
          <ParName>hndl</ParName>
          <ParType>pointer</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to </ParHint>
          <ParUserDeclaration>void *hndl</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>startAddr</ParName>
          <ParType>uint32_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Memory start address</ParHint>
        </Parameter>
        <Parameter>
          <ParName>endAddr</ParName>
          <ParType>uint32_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Memory end address</ParHint>
        </Parameter>
        <Parameter>
          <ParName>addrSize</ParName>
          <ParType>uint8_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Number of bytes for the address (1, 2, 3 or 4)</ParHint>
        </Parameter>
        <Parameter>
          <ParName>bytesPerLine</ParName>
          <ParType>uint8_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Number of bytes per line</ParHint>
        </Parameter>
        <Parameter>
          <ParName>readfp</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Function pointer to read the memory. Returns error code, uses a device handle, 32bit address with a pointer to a buffer and a buffer size.</ParHint>
          <ParUserDeclaration>uint8_t (*readfp)(void *, uint32_t, uint8_t*, size_t)</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>io</ParName>
          <ParType>ConstStdIOType</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to I/O to be used</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>uint8_t #M#_#C#(void *hndl, uint32_t startAddr, uint32_t endAddr, uint8_t addrSize, uint8_t bytesPerLine, uint8_t (*readfp)(void *, uint32_t, uint8_t*, size_t), ConstStdIOType *io)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>printfIO</Name>
        <Symbol>printfIO</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Printf() style function using XFormat component, using a custom I/O handler.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>unsigned</ReturnType>
        <RetHint>number of characters written</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>io</ParName>
          <ParType>ConstStdIOType</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to </ParHint>
        </Parameter>
        <Parameter>
          <ParName>fmt</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>printf style format string</ParHint>
          <ParUserDeclaration>const char *fmt, ...</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>unsigned #M#_#C#(ConstStdIOType *io, const char *fmt, ...)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>printf</Name>
        <Symbol>printf</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Printf() style function using XFormat component, using the shell default I/O handler.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>unsigned</ReturnType>
        <RetHint>number of characters written</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>fmt</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>printf style format string</ParHint>
          <ParUserDeclaration>const char *fmt, ...</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>unsigned #M#_#C#(const char *fmt, ...)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>SendData</Name>
        <Symbol>SendData</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Sends data using an I/O function. Unlike SendStr(), with this method it is possible to send binary data, including zero bytes.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>3</ParamCount>
        <Parameter>
          <ParName>data</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to data to be sent</ParHint>
          <ParUserDeclaration>const uint8_t *data</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>dataSize</ParName>
          <ParType>uint16_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Number of bytes to be sent.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>io</ParName>
          <ParType>StdIO_OutErr_FctType</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>I/O callbacks to be used for printing.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(const uint8_t *data, uint16_t dataSize, StdIO_OutErr_FctType io)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>PrintStatus</Name>
        <Symbol>PrintStatus</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Prints various available system status information</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>uint8_t</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>io</ParName>
          <ParType>ConstStdIOType</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to I/O callbacks</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>uint8_t #M#_#C#(ConstStdIOType *io)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>ParseCommand</Name>
        <Symbol>ParseCommand</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Parses a shell command. Use 'help' to get a list of supported commands.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>uint8_t</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>3</ParamCount>
        <Parameter>
          <ParName>cmd</ParName>
          <ParType>uint8_t</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to command string</ParHint>
          <ParUserDeclaration>const uint8_t *cmd</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>handled</ParName>
          <ParType>Boolean</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to variable to indicate if the command has been handled. The caller passes this variable to the command scanner to find out if the passed command has been handled. The variable is initialized by the caller.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>io</ParName>
          <ParType>ConstStdIOType</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to I/O callbacks</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>uint8_t #M#_#C#(const uint8_t *cmd, bool *handled, ConstStdIOType *io)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>IsHistoryCharacter</Name>
        <Symbol>IsHistoryCharacter</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Returns TRUE if character is a history character</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>Boolean</ReturnType>
        <RetHint>TRUE if it is an accepted history character</RetHint>
        <ParamCount>4</ParamCount>
        <Parameter>
          <ParName>ch</ParName>
          <ParType>uint8_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>current command character</ParHint>
        </Parameter>
        <Parameter>
          <ParName>cmdBuf</ParName>
          <ParType>uint8_t</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to command line buffer read so far</ParHint>
        </Parameter>
        <Parameter>
          <ParName>cmdBufIdx</ParName>
          <ParType>uint8_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Index of character into cmdBuf</ParHint>
          <ParUserDeclaration>size_t cmdBufIdx</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>isPrev</ParName>
          <ParType>Boolean</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to return value, if it is 'previous' history or not</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>bool #M#_#C#(uint8_t ch, uint8_t *cmdBuf, size_t cmdBufIdx, bool *isPrev)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>ReadLine</Name>
        <Symbol>ReadLine</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Reads a line from stdIn and returns TRUE if we have a line, FALSE otherwise.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>Boolean</ReturnType>
        <RetHint>TRUE if something has been read, FALSE otherwise</RetHint>
        <ParamCount>4</ParamCount>
        <Parameter>
          <ParName>bufStart</ParName>
          <ParType>uint8_t</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to start of buffer</ParHint>
        </Parameter>
        <Parameter>
          <ParName>buf</ParName>
          <ParType>uint8_t</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to buffer where to read in the information</ParHint>
        </Parameter>
        <Parameter>
          <ParName>bufSize</ParName>
          <ParType>uint16_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>size of buffer</ParHint>
          <ParUserDeclaration>size_t bufSize</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>io</ParName>
          <ParType>ConstStdIOType</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to I/O callbacks</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>bool #M#_#C#(uint8_t *bufStart, uint8_t *buf, size_t bufSize, ConstStdIOType *io)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>PrintCommandFailed</Name>
        <Symbol>PrintCommandFailed</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Prints a standard message for failed or unknown commands</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>cmd</ParName>
          <ParType>uint8_t</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to command which was failing</ParHint>
          <ParUserDeclaration>const uint8_t *cmd</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>io</ParName>
          <ParType>ConstStdIOType</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to I/O callbacks</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(const uint8_t *cmd, ConstStdIOType *io)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>IterateTable</Name>
        <Symbol>IterateTable</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Parses a shell command. It handles first the internal commands and will call the provided callback.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>uint8_t</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>4</ParamCount>
        <Parameter>
          <ParName>cmd</ParName>
          <ParType>uint8_t</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to command string</ParHint>
          <ParUserDeclaration>const uint8_t *cmd</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>handled</ParName>
          <ParType>Boolean</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to boolean which is set to TRUE if a command parser has handled the command.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>io</ParName>
          <ParType>ConstStdIOType</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to I/O callbacks</ParHint>
        </Parameter>
        <Parameter>
          <ParName>parserTable</ParName>
          <ParType>ConstParseCommandCallback</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to callback which will be called to parse commands in the user application, or NULL if not used.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>uint8_t #M#_#C#(const uint8_t *cmd, bool *handled, ConstStdIOType *io, ConstParseCommandCallback *parserTable)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>SetStdio</Name>
        <Symbol>SetStdio</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Sets an StdIO structure which is returned by GetStdio()</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>uint8_t</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>stdio</ParName>
          <ParType>ConstStdIOTypePtr</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>New stdio structure to be used.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>uint8_t #M#_#C#(ConstStdIOTypePtr stdio)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>GetStdio</Name>
        <Symbol>GetStdio</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Returns the default stdio channel. This method is only available if a shell is enabled in the component properties.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>ConstStdIOTypePtr</ReturnType>
        <RetHint>Pointer to the stdio descriptor</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>ConstStdIOTypePtr #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>RequestSerial</Name>
        <Symbol>RequestSerial</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Used to get mutual access to the shell console. Only has an effect if using an RTOS with semaphore for the console access.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>ReleaseSerial</Name>
        <Symbol>ReleaseSerial</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Used to release mutual access to the shell console. Only has an effect if using an RTOS with semaphore for the console access.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>ReadAndParseWithCommandTableExt</Name>
        <Symbol>ReadAndParseWithCommandTableExt</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Reads characters from the default input channel and appends it to the buffer. Once a new line has been detected, the line will be parsed using the handlers in the table.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>uint8_t</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>5</ParamCount>
        <Parameter>
          <ParName>cmdBuf</ParName>
          <ParType>uint8_t</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to buffer provided by the caller where to store the command to read in. Characters will be appended, so make sure string buffer is initialized with a zero byte at the beginning.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>cmdBufSize</ParName>
          <ParType>uint8_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Size of buffer</ParHint>
          <ParUserDeclaration>size_t cmdBufSize</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>io</ParName>
          <ParType>ConstStdIOType</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to I/O channels to be used</ParHint>
        </Parameter>
        <Parameter>
          <ParName>parseCallback</ParName>
          <ParType>ConstParseCommandCallback</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to callback table provided by the user application to parse commands. The table has a NULL sentinel.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>silent</ParName>
          <ParType>Boolean</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>If handling shall be silent, i.e. no command prompt printed</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>uint8_t #M#_#C#(uint8_t *cmdBuf, size_t cmdBufSize, ConstStdIOType *io, ConstParseCommandCallback *parseCallback, bool silent)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>ReadCommandLine</Name>
        <Symbol>ReadCommandLine</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Similar to ReadAndParseWithCommandTableExt, but does not call the parser. Reads characters from the default input channel and appends it to the buffer. Once a new line has been detected, it  removes it and returns ERR_OK</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>uint8_t</ReturnType>
        <RetHint>Error code, ERR_OK if a complete line has been detected</RetHint>
        <ParamCount>3</ParamCount>
        <Parameter>
          <ParName>cmdBuf</ParName>
          <ParType>uint8_t</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to buffer provided by the caller where to store the command to read in. Characters will be appended, so make sure string buffer is initialized with a zero byte at the beginning.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>cmdBufSize</ParName>
          <ParType>uint8_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Size of buffer</ParHint>
          <ParUserDeclaration>size_t cmdBufSize</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>io</ParName>
          <ParType>ConstStdIOType</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to I/O channels to be used</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>uint8_t #M#_#C#(uint8_t *cmdBuf, size_t cmdBufSize, ConstStdIOType *io)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>ReadAndParseWithCommandTable</Name>
        <Symbol>ReadAndParseWithCommandTable</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Reads characters from the default input channel and appends it to the buffer. Once a new line has been detected, the line will be parsed using the handlers in the table.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>uint8_t</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>4</ParamCount>
        <Parameter>
          <ParName>cmdBuf</ParName>
          <ParType>uint8_t</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to buffer provided by the caller where to store the command to read in. Characters will be appended, so make sure string buffer is initialized with a zero byte at the beginning.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>cmdBufSize</ParName>
          <ParType>uint8_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Size of buffer</ParHint>
          <ParUserDeclaration>size_t cmdBufSize</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>io</ParName>
          <ParType>ConstStdIOType</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to I/O channels to be used</ParHint>
        </Parameter>
        <Parameter>
          <ParName>parseCallback</ParName>
          <ParType>ConstParseCommandCallback</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to callback table provided by the user application to parse commands. The table has a NULL sentinel.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>uint8_t #M#_#C#(uint8_t *cmdBuf, size_t cmdBufSize, ConstStdIOType *io, ConstParseCommandCallback *parseCallback)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>ParseWithCommandTableExt</Name>
        <Symbol>ParseWithCommandTableExt</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Parses a shell command. It handles first the internal commands and will call the provided callback.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>uint8_t</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>4</ParamCount>
        <Parameter>
          <ParName>cmd</ParName>
          <ParType>uint8_t</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to command string</ParHint>
          <ParUserDeclaration>const uint8_t *cmd</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>io</ParName>
          <ParType>ConstStdIOType</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to I/O callbacks</ParHint>
        </Parameter>
        <Parameter>
          <ParName>parseCallback</ParName>
          <ParType>ConstParseCommandCallback</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to callback which will be called to parse commands in the user application, or NULL if not used.</ParHint>
        </Parameter>
        <Parameter>
          <ParName>silent</ParName>
          <ParType>Boolean</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>If handling shall be silent, i.e. no command prompt printed</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>uint8_t #M#_#C#(const uint8_t *cmd, ConstStdIOType *io, ConstParseCommandCallback *parseCallback, bool silent)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>ParseWithCommandTable</Name>
        <Symbol>ParseWithCommandTable</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Parses a shell command. It handles first the internal commands and will call the provided callback.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>uint8_t</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>3</ParamCount>
        <Parameter>
          <ParName>cmd</ParName>
          <ParType>uint8_t</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to command string</ParHint>
          <ParUserDeclaration>const uint8_t *cmd</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>io</ParName>
          <ParType>ConstStdIOType</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to I/O callbacks</ParHint>
        </Parameter>
        <Parameter>
          <ParName>parseCallback</ParName>
          <ParType>ConstParseCommandCallback</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to callback which will be called to parse commands in the user application, or NULL if not used.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>uint8_t #M#_#C#(const uint8_t *cmd, ConstStdIOType *io, ConstParseCommandCallback *parseCallback)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>GetSemaphore</Name>
        <Symbol>GetSemaphore</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Return the semaphore of the shell.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>pointer</ReturnType>
        <RetHint>semaphore, or NULL if not used or not allocated.</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void* #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>SendStatusStr</Name>
        <Symbol>SendStatusStr</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Prints a status string using an I/O function, formated for the 'status' command</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>3</ParamCount>
        <Parameter>
          <ParName>strItem</ParName>
          <ParType>char</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to string of the command</ParHint>
          <ParUserDeclaration>const uint8_t *strItem</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>strStatus</ParName>
          <ParType>char</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to help text string</ParHint>
          <ParUserDeclaration>const uint8_t *strStatus</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>io</ParName>
          <ParType>StdIO_OutErr_FctType</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>I/O callbacks to be used for printing.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(const uint8_t *strItem, const uint8_t *strStatus, StdIO_OutErr_FctType io)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>SendHelpStr</Name>
        <Symbol>SendHelpStr</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Prints a string using an I/O function, formated for the 'help' command</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>3</ParamCount>
        <Parameter>
          <ParName>strCmd</ParName>
          <ParType>char</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to string of the command</ParHint>
          <ParUserDeclaration>const uint8_t *strCmd</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>strHelp</ParName>
          <ParType>char</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to help text string</ParHint>
          <ParUserDeclaration>const uint8_t *strHelp</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>io</ParName>
          <ParType>StdIO_OutErr_FctType</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>I/O callbacks to be used for printing.</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(const uint8_t *strCmd, const uint8_t *strHelp, StdIO_OutErr_FctType io)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>ReadChar</Name>
        <Symbol>ReadChar</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Reads a character (blocking)</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>void</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>c</ParName>
          <ParType>uint8_t</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to character to be used to store the result</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(uint8_t *c)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>SendChar</Name>
        <Symbol>SendChar</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Sends a character (blocking)</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>void</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>ch</ParName>
          <ParType>uint8_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>character to be sent</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(uint8_t ch)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>KeyPressed</Name>
        <Symbol>KeyPressed</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Checks if a key has been pressed (a character is present in the input buffer)</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>Boolean</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>bool #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>SendCharFct</Name>
        <Symbol>SendCharFct</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Method to send a character using a standard I/O handle.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>void</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>ch</ParName>
          <ParType>uint8_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>character to be sent</ParHint>
        </Parameter>
        <Parameter>
          <ParName>fct</ParName>
          <ParType>pointer</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>Function pointer to output function: takes a byte to write and returns error code.</ParHint>
          <ParUserDeclaration>uint8_t (*fct)(uint8_t ch)</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(uint8_t ch, uint8_t (*fct)(uint8_t ch))</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>Init</Name>
        <Symbol>Init</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Initializes the module, especially creates the mutex semaphore if an RTOS is used.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>Deinit</Name>
        <Symbol>Deinit</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>De-Initializes the module, especially frees the mutex semaphore if an RTOS is used.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <Mode>meiAlwReq_!Exist</Mode>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
  </MethodList>
  <EventList>
    <EmptySection_DummyValue/>
  </EventList>
  <Registration>
    <Template>Shell</Template>
  </Registration>
  <UserTypes>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>StdIO_OutErr_FctType</Name>
      <Hint>Callback for an output or error I/O function</Hint>
      <Generate>yes</Generate>
      <Unique>yes</Unique>
      <GenerateHelp>yes</GenerateHelp>
      <PreparedHint>typedef void (*%'ModuleName'%.StdIO_OutErr_FctType)(uint8_t); /* Callback for an output or error I/O function */\n
</PreparedHint>
      <Type>typedef void (*%'ModuleName'%.StdIO_OutErr_FctType)(uint8_t);</Type>
      <HWTestType>pointer</HWTestType>
    </Type>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>StdIO_In_FctType</Name>
      <Hint>Callback for an I/O input function.</Hint>
      <Generate>yes</Generate>
      <Unique>yes</Unique>
      <GenerateHelp>yes</GenerateHelp>
      <PreparedHint>typedef void (*%'ModuleName'%.StdIO_In_FctType)(uint8_t *); /* Callback for an I/O input function. */\n
</PreparedHint>
      <Type>typedef void (*%'ModuleName'%.StdIO_In_FctType)(uint8_t *);</Type>
      <HWTestType>pointer</HWTestType>
    </Type>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>StdIO_KeyPressed_FctType</Name>
      <Hint>Callback which returns true if a key has been pressed</Hint>
      <Generate>yes</Generate>
      <Unique>yes</Unique>
      <GenerateHelp>yes</GenerateHelp>
      <PreparedHint>typedef bool (*%'ModuleName'%.StdIO_KeyPressed_FctType)(void); /* Callback which returns true if a key has been pressed */\n
</PreparedHint>
      <Type>typedef bool (*%'ModuleName'%.StdIO_KeyPressed_FctType)(void);</Type>
      <HWTestType>pointer</HWTestType>
    </Type>
    <Type>
      <UsrType>TRecordType</UsrType>
      <Name>StdIOType</Name>
      <Hint>Record containing input, output and error callback (stdin, stdout, stderr).</Hint>
      <Generate>yes</Generate>
      <Unique>yes</Unique>
      <GenerateHelp>yes</GenerateHelp>
      <PreparedHint>  typedef struct { /* Record containing input, output and error callback (stdin, stdout, stderr). */\n
    StdIO_In_FctType stdIn; /* standard input */\n
    StdIO_OutErr_FctType stdOut; /* standard output */\n
    StdIO_OutErr_FctType stdErr; /* standard error */\n
    StdIO_KeyPressed_FctType keyPressed; /* key pressed callback */\n
  } %'ModuleName'_StdIOType;\n
</PreparedHint>
      <RecordItem>
        <ItemName>stdIn</ItemName>
        <ItemType>StdIO_In_FctType</ItemType>
        <ItemHint>standard input</ItemHint>
        <ItemPointer>no</ItemPointer>
      </RecordItem>
      <RecordItem>
        <ItemName>stdOut</ItemName>
        <ItemType>StdIO_OutErr_FctType</ItemType>
        <ItemHint>standard output</ItemHint>
        <ItemPointer>no</ItemPointer>
      </RecordItem>
      <RecordItem>
        <ItemName>stdErr</ItemName>
        <ItemType>StdIO_OutErr_FctType</ItemType>
        <ItemHint>standard error</ItemHint>
        <ItemPointer>no</ItemPointer>
      </RecordItem>
      <RecordItem>
        <ItemName>keyPressed</ItemName>
        <ItemType>StdIO_KeyPressed_FctType</ItemType>
        <ItemHint>key pressed callback</ItemHint>
        <ItemPointer>no</ItemPointer>
      </RecordItem>
    </Type>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>ConstStdIOType</Name>
      <Hint>constant StdIOType</Hint>
      <Generate>yes</Generate>
      <Unique>yes</Unique>
      <GenerateHelp>yes</GenerateHelp>
      <PreparedHint>typedef const %'ModuleName'%.StdIOType %'ModuleName'%.ConstStdIOType; /* constant StdIOType */\n
</PreparedHint>
      <Type>typedef const %'ModuleName'%.StdIOType %'ModuleName'%.ConstStdIOType;</Type>
      <HWTestType>pointer</HWTestType>
    </Type>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>ParseCommandCallback</Name>
      <Hint>Callback for parsing a shell command</Hint>
      <Generate>yes</Generate>
      <Unique>yes</Unique>
      <GenerateHelp>yes</GenerateHelp>
      <PreparedHint>typedef uint8_t (*%'ModuleName'%.ParseCommandCallback)(const uint8_t *cmd, bool *handled, const %'ModuleName'%.StdIOType *io); /* Callback for parsing a shell command */\n
</PreparedHint>
      <Type>typedef uint8_t (*%'ModuleName'%.ParseCommandCallback)(const uint8_t *cmd, bool *handled, const %'ModuleName'%.StdIOType *io);</Type>
      <HWTestType>pointer</HWTestType>
    </Type>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>ConstStdIOTypePtr</Name>
      <Hint>Pointer to constant standard I/O descriptor</Hint>
      <Generate>yes</Generate>
      <Unique>yes</Unique>
      <GenerateHelp>yes</GenerateHelp>
      <PreparedHint>typedef const %'ModuleName'%.ConstStdIOType *%'ModuleName'%.ConstStdIOTypePtr; /* Pointer to constant standard I/O descriptor */\n
</PreparedHint>
      <Type>typedef const %'ModuleName'%.ConstStdIOType *%'ModuleName'%.ConstStdIOTypePtr;</Type>
      <HWTestType>pointer</HWTestType>
    </Type>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>ConstParseCommandCallback</Name>
      <Hint>Callback for parsing a shell command</Hint>
      <Generate>yes</Generate>
      <Unique>yes</Unique>
      <GenerateHelp>yes</GenerateHelp>
      <PreparedHint>typedef const %'ModuleName'%.ParseCommandCallback %'ModuleName'%.ConstParseCommandCallback; /* Callback for parsing a shell command */\n
</PreparedHint>
      <Type>typedef const %'ModuleName'%.ParseCommandCallback %'ModuleName'%.ConstParseCommandCallback;</Type>
      <HWTestType>pointer</HWTestType>
    </Type>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>uint8_t</Name>
      <Hint/>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>no</GenerateHelp>
      <PreparedHint>\n
</PreparedHint>
      <Type/>
      <HWTestType>pointer</HWTestType>
    </Type>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>uint32_t</Name>
      <Hint/>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>no</GenerateHelp>
      <PreparedHint>\n
</PreparedHint>
      <Type/>
      <HWTestType>pointer</HWTestType>
    </Type>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>uint16_t</Name>
      <Hint/>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>no</GenerateHelp>
      <PreparedHint>\n
</PreparedHint>
      <Type/>
      <HWTestType>pointer</HWTestType>
    </Type>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>int8_t</Name>
      <Hint/>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>no</GenerateHelp>
      <PreparedHint>\n
</PreparedHint>
      <Type/>
      <HWTestType>pointer</HWTestType>
    </Type>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>int32_t</Name>
      <Hint/>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>no</GenerateHelp>
      <PreparedHint>\n
</PreparedHint>
      <Type/>
      <HWTestType>pointer</HWTestType>
    </Type>
    <Type>
      <UsrType>TUserType</UsrType>
      <Name>int16_t</Name>
      <Hint/>
      <Generate>no</Generate>
      <Unique>no</Unique>
      <GenerateHelp>no</GenerateHelp>
      <PreparedHint>\n
</PreparedHint>
      <Type/>
      <HWTestType>pointer</HWTestType>
    </Type>
  </UserTypes>
</Interface>
