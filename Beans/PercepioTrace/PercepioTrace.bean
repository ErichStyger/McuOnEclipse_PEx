<?xml version="1.0" encoding="UTF-8"?>
<Bean>
  <Header>
    <Name>PercepioTrace</Name>
    <Description>Percepio FreeRTOS Trace</Description>
    <Author>Erich Styger</Author>
    <Version>01.140</Version>
    <Icon>irc</Icon>
    <TypesFiles>PE,PercepioTrace\PercepioTrace</TypesFiles>
    <FileVersion>6</FileVersion>
  </Header>
  <Options>
    <BW_HelpType>Basic</BW_HelpType>
    <BW_HelpFiles>,Properties,Methods,Events</BW_HelpFiles>
    <BW_AutoSaveHelp>yes</BW_AutoSaveHelp>
    <BW_AutoSaveDriver>yes</BW_AutoSaveDriver>
    <BW_DetailedHelp>yes</BW_DetailedHelp>
    <BW_NeedTps>yes</BW_NeedTps>
    <BW_NeedUst>5</BW_NeedUst>
    <BW_NeedCns>0</BW_NeedCns>
    <BeanStatus>PROPOSAL</BeanStatus>
    <Copyright> * (c) Copyright Percepio AB, 2013-2020\n * http      : www.percepio.se\n * mail      : info@percepio.com\n * See separate Percepio licensing terms.\n *\n * Processor Expert Component: (c) Copyright Erich Styger, 2013-2020\n * Web:         https://mcuoneclipse.com\n * SourceForge: https://sourceforge.net/projects/mcuoneclipse\n * Git:         https://github.com/ErichStyger/McuOnEclipse_PEx\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *\n * - Redistributions of source code must retain the above copyright notice, this list\n *   of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright notice, this\n *   list of conditions and the following disclaimer in the documentation and/or\n *   other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</Copyright>
    <Category>Operating Systems</Category>
    <DemoDriver>no</DemoDriver>
    <Shortcut>PTRC</Shortcut>
    <BeanLevel>High</BeanLevel>
    <OneBeanInstance>!yes</OneBeanInstance>
  </Options>
  <PropertyList>
    <Property>
      <TCompNameItem>
        <Name>Component name</Name>
        <Symbol>DeviceName</Symbol>
        <Hint>Name of the component.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>true</EditLine>
        <DefaultValue/>
      </TCompNameItem>
    </Property>
    <Property>
      <TStrgItem>
        <Name>RTOS+Trace Version</Name>
        <Symbol>RTOSplusTraceVersion</Symbol>
        <Hint>Identifies the RTOS+Trace version used from Percepio AB</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>true</EditLine>
        <DefaultValue>V4.4.1</DefaultValue>
        <StrDefine>nothing</StrDefine>
        <MinLength>0</MinLength>
        <MaxLength>-1</MaxLength>
      </TStrgItem>
    </Property>
    <Property>
      <TEnumItem>
        <Name>Recorder Mode</Name>
        <Symbol>TraceRecorderMode</Symbol>
        <TypeSpec>typeRecorderMode</TypeSpec>
        <Hint>Configrue TRC_CFG_RECORDER_MODE to TRC_RECORDER_MODE_SNAPSHOT or TRC_RECORDER_MODE_STREAMING</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>true</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>true</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
      </TEnumItem>
    </Property>
    <Property>
      <TEnumItem>
        <Name>Recorder Buffer Allocation</Name>
        <Symbol>RecorderBufferAllocation</Symbol>
        <TypeSpec>typeRecorderBufferAllocation</TypeSpec>
        <Hint>Configure the macro TRC_CFG_RECORDER_BUFFER_ALLOCATION to TRC_RECORDER_BUFFER_ALLOCATION_STATIC, TRC_RECORDER_BUFFER_ALLOCATION_DYNAMIC or TRC_RECORDER_BUFFER_ALLOCATION_CUSTOM. Note that CUSTOM is only supported in snapshot mode.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>true</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>true</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
      </TEnumItem>
    </Property>
    <Property>
      <TIntgItem>
        <Name>Max ISR Nesting</Name>
        <Symbol>TraceMaxISRNesting</Symbol>
        <Hint>Defines the maxium level of ISR nesting</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>true</EditLine>
        <DefaultValue>8</DefaultValue>
        <MinValue>1</MinValue>
        <MaxValue>-1</MaxValue>
        <Bases>DEC</Bases>
        <DefaultBase>DEC</DefaultBase>
        <ExtraHintDisabled>false</ExtraHintDisabled>
        <ChangeValueIntoRange>false</ChangeValueIntoRange>
        <RuntimeProperty>false</RuntimeProperty>
      </TIntgItem>
    </Property>
    <Property>
      <TGrupItem>
        <Name>Events Creation</Name>
        <Symbol>EventsCreationGroup</Symbol>
        <Hint>Configures which events are created</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <BoldName>true</BoldName>
        <EditLine>false</EditLine>
        <Description/>
        <Expanded>Yes</Expanded>
        <Children>
          <GrupItem>
            <TBoolItem>
              <Name>Include OS Tick events</Name>
              <Symbol>IncludeOSTickEvents</Symbol>
              <TypeSpec>typeYesNo</TypeSpec>
              <Hint>This sets TRC_CFG_INCLUDE_OSTICK_EVENTS. </Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>false</EditLine>
              <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
              <DefaultIndex>1</DefaultIndex>
              <TextValueIndex>false</TextValueIndex>
              <RuntimeProperty>false</RuntimeProperty>
              <CanDelete>false</CanDelete>
              <IconPopup>false</IconPopup>
              <DefaultValue>false</DefaultValue>
              <Popup>false</Popup>
            </TBoolItem>
          </GrupItem>
          <GrupItem>
            <TBoolItem>
              <Name>Include ready events</Name>
              <Symbol>IncludeReadyEvents</Symbol>
              <TypeSpec>typeYesNo</TypeSpec>
              <Hint>This sets INCLUDE_READY_EVENTS in trcConfig.h\n
If this is set to 'no', the code for recording Ready events is excluded. Note, this will make it impossible to calculate the correct response times.</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>false</EditLine>
              <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
              <DefaultIndex>1</DefaultIndex>
              <TextValueIndex>false</TextValueIndex>
              <RuntimeProperty>false</RuntimeProperty>
              <CanDelete>false</CanDelete>
              <IconPopup>false</IconPopup>
              <DefaultValue>false</DefaultValue>
              <Popup>false</Popup>
            </TBoolItem>
          </GrupItem>
          <GrupItem>
            <TBoolItem>
              <Name>Include memory manager events</Name>
              <Symbol>IncludeMemManageEvents</Symbol>
              <TypeSpec>typeYesNo</TypeSpec>
              <Hint>This sets TRC_CFG_INCLUDE_MEMMANG_EVENTS in trcConfig.h\n
This must be enabled (1) if memory allocation and deallocatinon have to be traced.</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>false</EditLine>
              <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
              <DefaultIndex>1</DefaultIndex>
              <TextValueIndex>false</TextValueIndex>
              <RuntimeProperty>false</RuntimeProperty>
              <CanDelete>false</CanDelete>
              <IconPopup>false</IconPopup>
              <DefaultValue>false</DefaultValue>
              <Popup>false</Popup>
            </TBoolItem>
          </GrupItem>
          <GrupItem>
            <TBoolItem>
              <Name>Include ISR tracing</Name>
              <Symbol>IncludeISRTracing</Symbol>
              <TypeSpec>typeYesNo</TypeSpec>
              <Hint>This sets INCLUDE_ISR_TRACING in trcConfig.h\n
If this is zero (0), the code for recording Interrupt Service Routines is excluded to reduce code size. Note, recording ISRs require that you insert calls to vTraceStoreISRBegin and vTraceStoreISREnd in your interrupt handlers. There is no automatic recording of ISRs like for task scheduling, since FreeRTOS does not have a central interrupt dispatcher.</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>false</EditLine>
              <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
              <DefaultIndex>1</DefaultIndex>
              <TextValueIndex>false</TextValueIndex>
              <RuntimeProperty>false</RuntimeProperty>
              <CanDelete>false</CanDelete>
              <IconPopup>false</IconPopup>
              <DefaultValue>false</DefaultValue>
              <Popup>false</Popup>
            </TBoolItem>
          </GrupItem>
          <GrupItem>
            <TBoolItem>
              <Name>Include object delete events</Name>
              <Symbol>IncludeObjectDelete</Symbol>
              <TypeSpec>typeYesNo</TypeSpec>
              <Hint>This sets INCLUDE_OBJECT_DELETE in trcConfig.h\n
This must be enabled (1) if tasks, queues or other traced kernel objects are deleted at runtime, e.g., using vTaskDelete or vQueueDelete. If no deletes are made, this can be set to 0 in order to exclude the delete-handling code. </Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>false</EditLine>
              <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
              <DefaultIndex>1</DefaultIndex>
              <TextValueIndex>false</TextValueIndex>
              <RuntimeProperty>false</RuntimeProperty>
              <CanDelete>false</CanDelete>
              <IconPopup>false</IconPopup>
              <DefaultValue>false</DefaultValue>
              <Popup>false</Popup>
            </TBoolItem>
          </GrupItem>
          <GrupItem>
            <TBoolItem>
              <Name>Include user events</Name>
              <Symbol>IncludeUserEvents</Symbol>
              <TypeSpec>typeYesNo</TypeSpec>
              <Hint>This sets TRC_CFG_INCLUDE_USER_EVENTS.\n
If this is zero (0) the code for creating User Events is excluded to reduce code size. User Events are application-generated events, like "printf" but for the trace log instead of console output. User Events are much faster than a printf and can therefore be used in timing critical code. See vTraceUserEvent() and vTracePrintF() in trcUser.h.</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>false</EditLine>
              <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
              <DefaultIndex>0</DefaultIndex>
              <TextValueIndex>false</TextValueIndex>
              <RuntimeProperty>false</RuntimeProperty>
              <CanDelete>false</CanDelete>
              <IconPopup>false</IconPopup>
              <DefaultValue>true</DefaultValue>
              <Popup>false</Popup>
            </TBoolItem>
          </GrupItem>
          <GrupItem>
            <TBoolItem>
              <Name>Include pend function call events</Name>
              <Symbol>IncludePendFuncCallEvents</Symbol>
              <TypeSpec>typeYesNo</TypeSpec>
              <Hint>This sets TRC_CFG_INCLUDE_PEND_FUNC_CALL_EVENTS.\n
If this is zero (0), the trace will exclude any "pending function call" events, such as xTimerPendFunctionCall().</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>false</EditLine>
              <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
              <DefaultIndex>1</DefaultIndex>
              <TextValueIndex>false</TextValueIndex>
              <RuntimeProperty>false</RuntimeProperty>
              <CanDelete>false</CanDelete>
              <IconPopup>false</IconPopup>
              <DefaultValue>false</DefaultValue>
              <Popup>false</Popup>
            </TBoolItem>
          </GrupItem>
          <GrupItem>
            <TBoolItem>
              <Name>Include event group events</Name>
              <Symbol>IncludeEventGroupEvents</Symbol>
              <TypeSpec>typeYesNo</TypeSpec>
              <Hint>This sets TRC_CFG_INCLUDE_EVENT_GROUP_EVENTS.\n
If this is zero (0), the trace will exclude any "event group" events.</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>false</EditLine>
              <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
              <DefaultIndex>1</DefaultIndex>
              <TextValueIndex>false</TextValueIndex>
              <RuntimeProperty>false</RuntimeProperty>
              <CanDelete>false</CanDelete>
              <IconPopup>false</IconPopup>
              <DefaultValue>false</DefaultValue>
              <Popup>false</Popup>
            </TBoolItem>
          </GrupItem>
          <GrupItem>
            <TBoolItem>
              <Name>Include queue events</Name>
              <Symbol>IncludeQueueEvents</Symbol>
              <TypeSpec>typeYesNo</TypeSpec>
              <Hint>This sets TRC_CFG_INCLUDE_QUEUE_EVENTS, used to enable/disable events for queues.</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>false</EditLine>
              <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
              <DefaultIndex>0</DefaultIndex>
              <TextValueIndex>false</TextValueIndex>
              <RuntimeProperty>false</RuntimeProperty>
              <CanDelete>false</CanDelete>
              <IconPopup>false</IconPopup>
              <DefaultValue>true</DefaultValue>
              <Popup>false</Popup>
            </TBoolItem>
          </GrupItem>
        </Children>
      </TGrupItem>
    </Property>
    <Property>
      <TGrupItem>
        <Name>Snapshot Mode</Name>
        <Symbol>SnapshotModeGroup</Symbol>
        <Hint>Settings for Snapshot mode, stored in trcSnapshotConfig.h</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <BoldName>true</BoldName>
        <EditLine>false</EditLine>
        <Description/>
        <Expanded>Yes</Expanded>
        <Children>
          <GrupItem>
            <TEnumItem>
              <Name>Snapshot trace enable method</Name>
              <Symbol>trcStartupEnableMethodSnapshot</Symbol>
              <TypeSpec>typeTraceEnableSnapshot</TypeSpec>
              <Hint>Chooses which trace init and startup method shall be used while the trace Startup() function gets called during application startup.\n
     Snapshot Mode:\n
        TRC_INIT: Initializes trace module. Application needs to start tracing later with vTraceEnable(TRC_START);\n
        TRC_START: Initializes and starts tracing\n
     Streaming Mode:\n
        TRC_INIT: Initializes trace module. Application needs to start tracing later with vTraceEnable(TRC_START);\n
        TRC_START_AWAIT_HOST: initialies trace module and blocks (waits for data to be retrieved */</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
              <DefaultIndex>1</DefaultIndex>
              <TextValueIndex>true</TextValueIndex>
              <RuntimeProperty>false</RuntimeProperty>
              <CanDelete>false</CanDelete>
              <IconPopup>false</IconPopup>
            </TEnumItem>
          </GrupItem>
          <GrupItem>
            <TEnumItem>
              <Name>Recorder store mode</Name>
              <Symbol>RecorderStoreMode</Symbol>
              <TypeSpec>typeRecorderStoreMode</TypeSpec>
              <Hint>This sets TRC_CFG_SNAPSHOT_MODE.</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
              <DefaultIndex>0</DefaultIndex>
              <TextValueIndex>true</TextValueIndex>
              <RuntimeProperty>false</RuntimeProperty>
              <CanDelete>false</CanDelete>
              <IconPopup>false</IconPopup>
            </TEnumItem>
          </GrupItem>
          <GrupItem>
            <TBoolItem>
              <Name>Scheduling only</Name>
              <Symbol>TraceSchedulingOnly</Symbol>
              <TypeSpec>typeYesNo</TypeSpec>
              <Hint>This defines TRACE_SCHEDULING_ONLY in trcConfig.h\n
When defined (set to 'yes', disables all events except scheduling. Useful for Free Edition users.</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>false</EditLine>
              <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
              <DefaultIndex>1</DefaultIndex>
              <TextValueIndex>false</TextValueIndex>
              <RuntimeProperty>false</RuntimeProperty>
              <CanDelete>false</CanDelete>
              <IconPopup>false</IconPopup>
              <DefaultValue>false</DefaultValue>
              <Popup>false</Popup>
            </TBoolItem>
          </GrupItem>
          <GrupItem>
            <TStrgItem>
              <Name>Description string</Name>
              <Symbol>TraceDescriptionString</Symbol>
              <Hint>This sets TRACE_DESCRIPTION in trcConfig.h\n
This string is stored in the trace and displayed in FreeRTOS+Trace. Can be used to store, e.g., system version or build date.</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue>FreeRTOS+Trace</DefaultValue>
              <StrDefine>nothing</StrDefine>
              <MinLength>0</MinLength>
              <MaxLength>63</MaxLength>
            </TStrgItem>
          </GrupItem>
          <GrupItem>
            <TIntgItem>
              <Name>Description max length</Name>
              <Symbol>TraceDescriptionMaxLength</Symbol>
              <Hint>Sets the TRACE_DESCRIPTION_MAX_LENGTH macro. Generic system information string, presented in the tool. Note that this is also used for storing any internal error messages from the recorder, so do not make TRACE_DESCRIPTION_MAX_LENGTH too small. 80 is recommended.</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue>80</DefaultValue>
              <MinValue>8</MinValue>
              <MaxValue>-1</MaxValue>
              <Bases>DEC</Bases>
              <DefaultBase>DEC</DefaultBase>
              <ExtraHintDisabled>false</ExtraHintDisabled>
              <ChangeValueIntoRange>false</ChangeValueIntoRange>
              <RuntimeProperty>false</RuntimeProperty>
            </TIntgItem>
          </GrupItem>
          <GrupItem>
            <TIntgItem>
              <Name>Event buffer size</Name>
              <Symbol>EventBufferSize</Symbol>
              <Hint>This sets TRC_CFG_EVENT_BUFFER_SIZE.\n
Macro which should be defined as an integer value.\n
This defines the capacity of the event buffer, i.e., the number of records it may store. An event typically use one record (4 byte), but there are exceptions:\n
In some cases, an XTS event is added if the time since the last event is longer that allowed by the current event's timestamp field. Such events thus use two records. vTracePrintF use a variable number of data records following the event, holding the data arguments. \n
If RECORDER_STORE_MODE is STORE_MODE_RING_BUFFER, the recorder will wrap around to index 0 when reached EVENT_BUFFER_SIZE. If RECORDER_STORE_MODE is STORE_MODE_STOP_WHEN_FULL, the recorder is instead stopped (see RECORDER_STORE_MODE).</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue>500</DefaultValue>
              <MinValue>1</MinValue>
              <MaxValue>-1</MaxValue>
              <Bases>DEC HEX</Bases>
              <DefaultBase>DEC</DefaultBase>
              <ExtraHintDisabled>false</ExtraHintDisabled>
              <ChangeValueIntoRange>false</ChangeValueIntoRange>
              <RuntimeProperty>false</RuntimeProperty>
            </TIntgItem>
          </GrupItem>
          <GrupItem>
            <TIntgItem>
              <Name>Symbol table size</Name>
              <Symbol>SymbolTableSize</Symbol>
              <Hint>This sets SYMBOL_TABLE_SIZE in trcConfig.h\n
Macro which should be defined as an integer value.\n
This defines the capacity of the symbol table, in bytes. This symbol table stores User Events labels and names of deleted tasks, queues, or other kernel objects. Note that the names of active objects not stored here but in the Object Table. Thus, if you don't use User Events or delete any kernel objects you set this to zero (0) to minimize RAM usage.</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue>50</DefaultValue>
              <MinValue>0</MinValue>
              <MaxValue>-1</MaxValue>
              <Bases>DEC</Bases>
              <DefaultBase>DEC</DefaultBase>
              <ExtraHintDisabled>false</ExtraHintDisabled>
              <ChangeValueIntoRange>false</ChangeValueIntoRange>
              <RuntimeProperty>false</RuntimeProperty>
            </TIntgItem>
          </GrupItem>
          <GrupItem>
            <TBoolItem>
              <Name>Use Trace Assert</Name>
              <Symbol>traceConfigUseAssert</Symbol>
              <TypeSpec>typeYesNo</TypeSpec>
              <Hint>Configures TRC_CFG_USE_TRACE_ASSERT. If set to yes, \n
the TRACE_ASSERT macro (used at various locations in the \n
trace recorder) will verify that a relevant condition is true. \n
If the condition is false, prvTraceError() will be called, which stops the\n
recording and stores an error message that is displayed when opening the\n
trace in Tracealyzer.\n
This is used on several places in the recorder code for sanity checks on\n
parameters. Can be switched off to reduce the footprint of the tracing, but\n
we recommend to have it enabled initially.</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>false</EditLine>
              <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
              <DefaultIndex>0</DefaultIndex>
              <TextValueIndex>false</TextValueIndex>
              <RuntimeProperty>false</RuntimeProperty>
              <CanDelete>false</CanDelete>
              <IconPopup>false</IconPopup>
              <DefaultValue>true</DefaultValue>
              <Popup>false</Popup>
            </TBoolItem>
          </GrupItem>
          <GrupItem>
            <TIntgItem>
              <Name>ISR Tailchaining Threshold</Name>
              <Symbol>traceConfigISRTailchainingThreshold</Symbol>
              <Hint>Configures TRC_CFG_ISR_TAILCHAINING_THRESHOLD.\n
If tracing multiple ISRs, this setting allows for accurate display of the \n
context-switching also in cases when the ISRs execute in direct sequence.</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue>0</DefaultValue>
              <MinValue>0</MinValue>
              <MaxValue>-1</MaxValue>
              <Bases>DEC</Bases>
              <DefaultBase>DEC</DefaultBase>
              <ExtraHintDisabled>false</ExtraHintDisabled>
              <ChangeValueIntoRange>false</ChangeValueIntoRange>
              <RuntimeProperty>false</RuntimeProperty>
            </TIntgItem>
          </GrupItem>
          <GrupItem>
            <TBoolGrupItem>
              <Name>Separate User Event Buffer</Name>
              <Symbol>traceConfigUseSeprateUserEventBuffer</Symbol>
              <TypeSpec>typeEnaDis</TypeSpec>
              <Hint>Configures TRC_CFG_USE_SEPARATE_USER_EVENT_BUFFER.\n
If set to yes, it enables a separate user event buffer (UB).\n
In this mode, user events are stored separately from other events, \n
e.g., RTOS events. Thereby you can get a much longer history of \n
user events as they don't need to share the buffer space with more \n
frequent events. </Hint>
              <ItemLevel>BASIC</ItemLevel>
              <BoldName>true</BoldName>
              <EditLine>false</EditLine>
              <Description>Disabled</Description>
              <Expanded>No</Expanded>
              <DefaultValue>false</DefaultValue>
              <DefineSymbol>YES_NO</DefineSymbol>
              <IfDisabled>setNOTHING</IfDisabled>
              <Children>
                <GrupItem>
                  <TIntgItem>
                    <Name>traceConfigSeparateUserEventBufferSize</Name>
                    <Symbol>Symbol0</Symbol>
                    <Hint>Defines TRC_CFG_SEPARATE_USER_EVENT_BUFFER_SIZE, the capacity of teh user event buffer</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <EditLine>true</EditLine>
                    <DefaultValue>200</DefaultValue>
                    <MinValue>0</MinValue>
                    <MaxValue>-1</MaxValue>
                    <Bases>DEC</Bases>
                    <DefaultBase>DEC</DefaultBase>
                    <ExtraHintDisabled>false</ExtraHintDisabled>
                    <ChangeValueIntoRange>false</ChangeValueIntoRange>
                    <RuntimeProperty>false</RuntimeProperty>
                  </TIntgItem>
                </GrupItem>
                <GrupItem>
                  <TIntgItem>
                    <Name>User Event Buffer Channels</Name>
                    <Symbol>traceConfigUserEventBufferChannels</Symbol>
                    <Hint>Configures TRC_CFG_UB_CHANNELS. \n
This defines the number of User Event Buffer Channels (UB channels).\n
These are used to structure the events when using the separate user\n
event buffer, and contains both a User Event Channel (the name) and\n
a default format string for the channel.</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <EditLine>true</EditLine>
                    <DefaultValue>32</DefaultValue>
                    <MinValue>0</MinValue>
                    <MaxValue>-1</MaxValue>
                    <Bases>DEC</Bases>
                    <DefaultBase>DEC</DefaultBase>
                    <ExtraHintDisabled>false</ExtraHintDisabled>
                    <ChangeValueIntoRange>false</ChangeValueIntoRange>
                    <RuntimeProperty>false</RuntimeProperty>
                  </TIntgItem>
                </GrupItem>
              </Children>
            </TBoolGrupItem>
          </GrupItem>
          <GrupItem>
            <TGrupItem>
              <Name>Objects</Name>
              <Symbol>ObjectsGroup</Symbol>
              <Hint>Configures the size of objects in the object property table</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <BoldName>true</BoldName>
              <EditLine>false</EditLine>
              <Description/>
              <Expanded>Yes</Expanded>
              <Children>
                <GrupItem>
                  <TIntgItem>
                    <Name>Number of tasks</Name>
                    <Symbol>NTask</Symbol>
                    <Hint>This sets TRC_CFG_NTASK:\n
A group of Macros which should be defined as an integer value of zero (0) or larger.\n
This defines the capacity of the Object Table, in number of objects, of each object class. The Object Table holds information about the currently active kernel objects (i.e., the ones that have been created but not terminated), such as name and Tracelayzer ID, for Tasks, Queues, Semaphores, Mutexes and user-registered ISRs.\n
This does not limit the total amount of objects created, if objects are deleted during runtime. The object table size however limits the number of objects active at any given time, since the slots in the Object Table are reused when objects are deleted.</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <EditLine>true</EditLine>
                    <DefaultValue>10</DefaultValue>
                    <MinValue>0</MinValue>
                    <MaxValue>-1</MaxValue>
                    <Bases>DEC</Bases>
                    <DefaultBase>DEC</DefaultBase>
                    <ExtraHintDisabled>false</ExtraHintDisabled>
                    <ChangeValueIntoRange>false</ChangeValueIntoRange>
                    <RuntimeProperty>false</RuntimeProperty>
                  </TIntgItem>
                </GrupItem>
                <GrupItem>
                  <TStrgItem>
                    <Name>Name length for task</Name>
                    <Symbol>NameLenTaskStr</Symbol>
                    <Hint>TRC_CFG_NAME_LEN_TASK:\n
Macros that specify the maximum lengths (number of characters) for names of\n
kernel objects, such as tasks and queues. If longer names are used, they will\n
be truncated when stored in the recorder.</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <EditLine>true</EditLine>
                    <DefaultValue>configMAX_TASK_NAME_LEN</DefaultValue>
                    <StrDefine>nothing</StrDefine>
                    <MinLength>0</MinLength>
                    <MaxLength>-1</MaxLength>
                  </TStrgItem>
                </GrupItem>
                <GrupItem>
                  <TIntgItem>
                    <Name>Number of ISR</Name>
                    <Symbol>NISR</Symbol>
                    <Hint>This sets TRC_CFG_NISR.\n
A group of Macros which should be defined as an integer value of zero (0) or larger.\n
This defines the capacity of the Object Table, in number of objects, of each object class. The Object Table holds information about the currently active kernel objects (i.e., the ones that have been created but not terminated), such as name and Tracelayzer ID, for Tasks, Queues, Semaphores, Mutexes and user-registered ISRs.\n
This does not limit the total amount of objects created, if objects are deleted during runtime. The object table size however limits the number of objects active at any given time, since the slots in the Object Table are reused when objects are deleted.</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <EditLine>true</EditLine>
                    <DefaultValue>4</DefaultValue>
                    <MinValue>0</MinValue>
                    <MaxValue>-1</MaxValue>
                    <Bases>DEC</Bases>
                    <DefaultBase>DEC</DefaultBase>
                    <ExtraHintDisabled>false</ExtraHintDisabled>
                    <ChangeValueIntoRange>false</ChangeValueIntoRange>
                    <RuntimeProperty>false</RuntimeProperty>
                  </TIntgItem>
                </GrupItem>
                <GrupItem>
                  <TIntgItem>
                    <Name>Number of queue</Name>
                    <Symbol>NQueue</Symbol>
                    <Hint>This sets TRC_CFG_NQUEUE.\n
A group of Macros which should be defined as an integer value of zero (0) or larger.\n
This defines the capacity of the Object Table, in number of objects, of each object class. The Object Table holds information about the currently active kernel objects (i.e., the ones that have been created but not terminated), such as name and Tracelayzer ID, for Tasks, Queues, Semaphores, Mutexes and user-registered ISRs.\n
This does not limit the total amount of objects created, if objects are deleted during runtime. The object table size however limits the number of objects active at any given time, since the slots in the Object Table are reused when objects are deleted.</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <EditLine>true</EditLine>
                    <DefaultValue>3</DefaultValue>
                    <MinValue>0</MinValue>
                    <MaxValue>-1</MaxValue>
                    <Bases>DEC</Bases>
                    <DefaultBase>DEC</DefaultBase>
                    <ExtraHintDisabled>false</ExtraHintDisabled>
                    <ChangeValueIntoRange>false</ChangeValueIntoRange>
                    <RuntimeProperty>false</RuntimeProperty>
                  </TIntgItem>
                </GrupItem>
                <GrupItem>
                  <TIntgItem>
                    <Name>Number of semaphore</Name>
                    <Symbol>NSemaphore</Symbol>
                    <Hint>This sets TRC_CFG_NSEMAPHORE.\n
A group of Macros which should be defined as an integer value of zero (0) or larger.\n
This defines the capacity of the Object Table, in number of objects, of each object class. The Object Table holds information about the currently active kernel objects (i.e., the ones that have been created but not terminated), such as name and Tracelayzer ID, for Tasks, Queues, Semaphores, Mutexes and user-registered ISRs.\n
This does not limit the total amount of objects created, if objects are deleted during runtime. The object table size however limits the number of objects active at any given time, since the slots in the Object Table are reused when objects are deleted.</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <EditLine>true</EditLine>
                    <DefaultValue>4</DefaultValue>
                    <MinValue>0</MinValue>
                    <MaxValue>-1</MaxValue>
                    <Bases>DEC</Bases>
                    <DefaultBase>DEC</DefaultBase>
                    <ExtraHintDisabled>false</ExtraHintDisabled>
                    <ChangeValueIntoRange>false</ChangeValueIntoRange>
                    <RuntimeProperty>false</RuntimeProperty>
                  </TIntgItem>
                </GrupItem>
                <GrupItem>
                  <TIntgItem>
                    <Name>Number of mutex</Name>
                    <Symbol>NMutex</Symbol>
                    <Hint>This sets TRC_CFG_NMUTEX.\n
A group of Macros which should be defined as an integer value of zero (0) or larger.\n
This defines the capacity of the Object Table, in number of objects, of each object class. The Object Table holds information about the currently active kernel objects (i.e., the ones that have been created but not terminated), such as name and Tracelayzer ID, for Tasks, Queues, Semaphores, Mutexes and user-registered ISRs.\n
This does not limit the total amount of objects created, if objects are deleted during runtime. The object table size however limits the number of objects active at any given time, since the slots in the Object Table are reused when objects are deleted.</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <EditLine>true</EditLine>
                    <DefaultValue>4</DefaultValue>
                    <MinValue>0</MinValue>
                    <MaxValue>-1</MaxValue>
                    <Bases>DEC</Bases>
                    <DefaultBase>DEC</DefaultBase>
                    <ExtraHintDisabled>false</ExtraHintDisabled>
                    <ChangeValueIntoRange>false</ChangeValueIntoRange>
                    <RuntimeProperty>false</RuntimeProperty>
                  </TIntgItem>
                </GrupItem>
                <GrupItem>
                  <TIntgItem>
                    <Name>Number of timer</Name>
                    <Symbol>NTimer</Symbol>
                    <Hint>This sets the TRC_CFG_NTIMER define.</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <EditLine>true</EditLine>
                    <DefaultValue>2</DefaultValue>
                    <MinValue>0</MinValue>
                    <MaxValue>-1</MaxValue>
                    <Bases>DEC</Bases>
                    <DefaultBase>DEC</DefaultBase>
                    <ExtraHintDisabled>false</ExtraHintDisabled>
                    <ChangeValueIntoRange>false</ChangeValueIntoRange>
                    <RuntimeProperty>false</RuntimeProperty>
                  </TIntgItem>
                </GrupItem>
                <GrupItem>
                  <TIntgItem>
                    <Name>Number of event groups</Name>
                    <Symbol>NEventGroup</Symbol>
                    <Hint>This sets the TRC_CFG_NEVENTGROUP macro.</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <EditLine>true</EditLine>
                    <DefaultValue>2</DefaultValue>
                    <MinValue>0</MinValue>
                    <MaxValue>-1</MaxValue>
                    <Bases>DEC</Bases>
                    <DefaultBase>DEC</DefaultBase>
                    <ExtraHintDisabled>false</ExtraHintDisabled>
                    <ChangeValueIntoRange>false</ChangeValueIntoRange>
                    <RuntimeProperty>false</RuntimeProperty>
                  </TIntgItem>
                </GrupItem>
                <GrupItem>
                  <TIntgItem>
                    <Name>Number of stream buffers</Name>
                    <Symbol>NStreamBuffers</Symbol>
                    <Hint>This sets the TRC_CFG_NSTREAMBUFFER macro.</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <EditLine>true</EditLine>
                    <DefaultValue>3</DefaultValue>
                    <MinValue>0</MinValue>
                    <MaxValue>-1</MaxValue>
                    <Bases>DEC</Bases>
                    <DefaultBase>DEC</DefaultBase>
                    <ExtraHintDisabled>false</ExtraHintDisabled>
                    <ChangeValueIntoRange>false</ChangeValueIntoRange>
                    <RuntimeProperty>false</RuntimeProperty>
                  </TIntgItem>
                </GrupItem>
                <GrupItem>
                  <TIntgItem>
                    <Name>Number of message buffers</Name>
                    <Symbol>NMessageBuffers</Symbol>
                    <Hint>This sets the TRC_CFG_NSTREAMBUFFER macro.</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <EditLine>true</EditLine>
                    <DefaultValue>3</DefaultValue>
                    <MinValue>0</MinValue>
                    <MaxValue>-1</MaxValue>
                    <Bases>DEC</Bases>
                    <DefaultBase>DEC</DefaultBase>
                    <ExtraHintDisabled>false</ExtraHintDisabled>
                    <ChangeValueIntoRange>false</ChangeValueIntoRange>
                    <RuntimeProperty>false</RuntimeProperty>
                  </TIntgItem>
                </GrupItem>
                <GrupItem>
                  <TIntgItem>
                    <Name>Name length for ISR</Name>
                    <Symbol>NameLenISR</Symbol>
                    <Hint>TRC_CFG_NAME_LEN_ISR:\n
Macros that specify the maximum lengths (number of characters) for names of\n
kernel objects, such as tasks and queues. If longer names are used, they will\n
be truncated when stored in the recorder.</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <EditLine>true</EditLine>
                    <DefaultValue>10</DefaultValue>
                    <MinValue>0</MinValue>
                    <MaxValue>-1</MaxValue>
                    <Bases>DEC</Bases>
                    <DefaultBase>DEC</DefaultBase>
                    <ExtraHintDisabled>false</ExtraHintDisabled>
                    <ChangeValueIntoRange>false</ChangeValueIntoRange>
                    <RuntimeProperty>false</RuntimeProperty>
                  </TIntgItem>
                </GrupItem>
                <GrupItem>
                  <TIntgItem>
                    <Name>Name length for queue</Name>
                    <Symbol>NameLenQueue</Symbol>
                    <Hint>TRC_CFG_NAME_LEN_QUEUE:\n
Macros that specify the maximum lengths (number of characters) for names of\n
kernel objects, such as tasks and queues. If longer names are used, they will\n
be truncated when stored in the recorder.</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <EditLine>true</EditLine>
                    <DefaultValue>15</DefaultValue>
                    <MinValue>0</MinValue>
                    <MaxValue>-1</MaxValue>
                    <Bases>DEC</Bases>
                    <DefaultBase>DEC</DefaultBase>
                    <ExtraHintDisabled>false</ExtraHintDisabled>
                    <ChangeValueIntoRange>false</ChangeValueIntoRange>
                    <RuntimeProperty>false</RuntimeProperty>
                  </TIntgItem>
                </GrupItem>
                <GrupItem>
                  <TIntgItem>
                    <Name>Name length for semaphore</Name>
                    <Symbol>NameLenSemaphore</Symbol>
                    <Hint>TRC_CFG_NAME_LEN_SEMAPHORE:\n
Macros that specify the maximum lengths (number of characters) for names of\n
kernel objects, such as tasks and queues. If longer names are used, they will\n
be truncated when stored in the recorder.</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <EditLine>true</EditLine>
                    <DefaultValue>15</DefaultValue>
                    <MinValue>0</MinValue>
                    <MaxValue>-1</MaxValue>
                    <Bases>DEC</Bases>
                    <DefaultBase>DEC</DefaultBase>
                    <ExtraHintDisabled>false</ExtraHintDisabled>
                    <ChangeValueIntoRange>false</ChangeValueIntoRange>
                    <RuntimeProperty>false</RuntimeProperty>
                  </TIntgItem>
                </GrupItem>
                <GrupItem>
                  <TIntgItem>
                    <Name>Name length for mutex</Name>
                    <Symbol>NameLenMutex</Symbol>
                    <Hint>TRC_CFG_NAME_LEN_MUTEX:\n
Macros that specify the maximum lengths (number of characters) for names of\n
kernel objects, such as tasks and queues. If longer names are used, they will\n
be truncated when stored in the recorder.</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <EditLine>true</EditLine>
                    <DefaultValue>15</DefaultValue>
                    <MinValue>0</MinValue>
                    <MaxValue>-1</MaxValue>
                    <Bases>DEC</Bases>
                    <DefaultBase>DEC</DefaultBase>
                    <ExtraHintDisabled>false</ExtraHintDisabled>
                    <ChangeValueIntoRange>false</ChangeValueIntoRange>
                    <RuntimeProperty>false</RuntimeProperty>
                  </TIntgItem>
                </GrupItem>
                <GrupItem>
                  <TIntgItem>
                    <Name>Name length for timer</Name>
                    <Symbol>NameLenTimer</Symbol>
                    <Hint>TRC_CFG_NAME_LEN_TIMER:\n
Macros that specify the maximum lengths (number of characters) for names of\n
kernel objects, such as tasks and queues. If longer names are used, they will\n
be truncated when stored in the recorder.</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <EditLine>true</EditLine>
                    <DefaultValue>15</DefaultValue>
                    <MinValue>0</MinValue>
                    <MaxValue>-1</MaxValue>
                    <Bases>DEC</Bases>
                    <DefaultBase>DEC</DefaultBase>
                    <ExtraHintDisabled>false</ExtraHintDisabled>
                    <ChangeValueIntoRange>false</ChangeValueIntoRange>
                    <RuntimeProperty>false</RuntimeProperty>
                  </TIntgItem>
                </GrupItem>
                <GrupItem>
                  <TIntgItem>
                    <Name>Name length for event group</Name>
                    <Symbol>NameLenEventGroup</Symbol>
                    <Hint>TRC_CFG_NAME_LEN_EVENTGROUP:\n
Macros that specify the maximum lengths (number of characters) for names of\n
kernel objects, such as tasks and queues. If longer names are used, they will\n
be truncated when stored in the recorder.</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <EditLine>true</EditLine>
                    <DefaultValue>15</DefaultValue>
                    <MinValue>0</MinValue>
                    <MaxValue>-1</MaxValue>
                    <Bases>DEC</Bases>
                    <DefaultBase>DEC</DefaultBase>
                    <ExtraHintDisabled>false</ExtraHintDisabled>
                    <ChangeValueIntoRange>false</ChangeValueIntoRange>
                    <RuntimeProperty>false</RuntimeProperty>
                  </TIntgItem>
                </GrupItem>
                <GrupItem>
                  <TIntgItem>
                    <Name>Name length for stream buffer</Name>
                    <Symbol>NameLenStreamBuffer</Symbol>
                    <Hint>TRC_CFG_NAME_LEN_STREAMBUFFER:\n
Macros that specify the maximum lengths (number of characters) for names of\n
kernel objects, such as tasks and queues. If longer names are used, they will\n
be truncated when stored in the recorder.</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <EditLine>true</EditLine>
                    <DefaultValue>15</DefaultValue>
                    <MinValue>0</MinValue>
                    <MaxValue>-1</MaxValue>
                    <Bases>DEC</Bases>
                    <DefaultBase>DEC</DefaultBase>
                    <ExtraHintDisabled>false</ExtraHintDisabled>
                    <ChangeValueIntoRange>false</ChangeValueIntoRange>
                    <RuntimeProperty>false</RuntimeProperty>
                  </TIntgItem>
                </GrupItem>
                <GrupItem>
                  <TIntgItem>
                    <Name>Name length for message buffer</Name>
                    <Symbol>NameLenMessageBuffer</Symbol>
                    <Hint>TRC_CFG_NAME_LEN_MESSAGEBUFFER:\n
Macros that specify the maximum lengths (number of characters) for names of\n
kernel objects, such as tasks and queues. If longer names are used, they will\n
be truncated when stored in the recorder.</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <EditLine>true</EditLine>
                    <DefaultValue>15</DefaultValue>
                    <MinValue>0</MinValue>
                    <MaxValue>-1</MaxValue>
                    <Bases>DEC</Bases>
                    <DefaultBase>DEC</DefaultBase>
                    <ExtraHintDisabled>false</ExtraHintDisabled>
                    <ChangeValueIntoRange>false</ChangeValueIntoRange>
                    <RuntimeProperty>false</RuntimeProperty>
                  </TIntgItem>
                </GrupItem>
              </Children>
            </TGrupItem>
          </GrupItem>
          <GrupItem>
            <TBoolItem>
              <Name>Heap Size below 16M</Name>
              <Symbol>HeapSizeBelow16M</Symbol>
              <TypeSpec>typeYesNo</TypeSpec>
              <Hint>This sets TRC_CFG_HEAP_SIZE_BELOW_16M:\n
An integer constant that can be used to reduce the buffer usage of memory\n
allocation events (malloc/free). This value should be 1 if the heap size is \n
below 16 MB (2^24 byte), and you can live with addresses truncated to the \n
lower 24 bit. Otherwise set it to 0 to get the full 32-bit addresses.</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>false</EditLine>
              <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
              <DefaultIndex>1</DefaultIndex>
              <TextValueIndex>false</TextValueIndex>
              <RuntimeProperty>false</RuntimeProperty>
              <CanDelete>false</CanDelete>
              <IconPopup>false</IconPopup>
              <DefaultValue>false</DefaultValue>
              <Popup>false</Popup>
            </TBoolItem>
          </GrupItem>
          <GrupItem>
            <TBoolItem>
              <Name>Float support</Name>
              <Symbol>floatingPointForvTracePrintF</Symbol>
              <TypeSpec>typeYesNo</TypeSpec>
              <Hint>If floating point is supported for vTracePrintF()</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>false</EditLine>
              <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
              <DefaultIndex>1</DefaultIndex>
              <TextValueIndex>false</TextValueIndex>
              <RuntimeProperty>false</RuntimeProperty>
              <CanDelete>false</CanDelete>
              <IconPopup>false</IconPopup>
              <DefaultValue>false</DefaultValue>
              <Popup>false</Popup>
            </TBoolItem>
          </GrupItem>
          <GrupItem>
            <TBoolItem>
              <Name>Use implicit IFE rules</Name>
              <Symbol>UseImplicitIFErules</Symbol>
              <TypeSpec>typeYesNo</TypeSpec>
              <Hint>This sets USE_IMPLICIT_IFE_RULES in trcConfig.h\n
### Instance Finish Events (IFE) ###\n
\n
For tasks with "infinite" main loops (non-terminating tasks), the concept of a task instance has no clear definition, it is an application-specific thing. FreeRTOS+Trace allows you to define Instance Finish Events (IFEs), which marks the point when a task instance ends. The IFE is a blocking kernel call, typically in the main loop of a task which typically reads a message queue, waits for a semaphore or performs an explicit delay.\n
\n
If USE_IMPLICIT_IFE_RULES is one (1), the following FreeRTOS kernel calls are considered by default to be IFEs (Implicit IFEs):\n
 - vTaskDelay\n
 - vTaskDelayUntil\n
 - vTaskSuspend\n
 - xQueueReceive\n
 - xSemaphoreTake\n
\n
However, Implicit IFEs only applies to blocking kernel calls. If an xQueueReceive reads a message without blocking, it does not create a new instance since no blocking occurred.\n
\n
Moreover, the actual IFE might sometimes be another blocking call such as xQueueSend or xSemaphoreGive. We therefore allow for user-defined explicit IFEs by calling\n
       vTraceTaskInstanceIsFinished()\n
right before the kernel call considered as IFE. This does not create an additional event but instead stores the service code and object handle of the IFE call as properties of the task.\n
\n
If using Explicit IFEs and the task also calls an Implicit IFE like vTaskDelay, this may result in additional incorrect task instances. This is solved by disabling the Implicit IFEs for the task, by adding a call to\n
       vTraceTaskSkipDefaultInstanceFinishedEvents()\n
in the very beginning of that task. This allows you to combine Explicit IFEs for some tasks with Implicit IFEs for the rest of the tasks, if USE_IMPLICIT_IFE_RULES is 1.\n
\n
By setting USE_IMPLICIT_IFE_RULES to zero (0), the implicit IFEs are disabled for all tasks. Tasks will then be considered to have a single instance only, covering all execution fragments, unless you define an explicit IFE in the task.</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>false</EditLine>
              <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
              <DefaultIndex>0</DefaultIndex>
              <TextValueIndex>false</TextValueIndex>
              <RuntimeProperty>false</RuntimeProperty>
              <CanDelete>false</CanDelete>
              <IconPopup>false</IconPopup>
              <DefaultValue>true</DefaultValue>
              <Popup>false</Popup>
            </TBoolItem>
          </GrupItem>
          <GrupItem>
            <TBoolItem>
              <Name>Use 16bit Object Handles</Name>
              <Symbol>Use16bitObjectHandles</Symbol>
              <TypeSpec>typeYesNo</TypeSpec>
              <Hint>This sets USE_16BIT_OBJECT_HANDLES in trcConfig.h\n
 * Macro which should be defined as either zero (0) or one (1).\n
 * Default is 0.\n
 *\n
 * If set to 0 (zero), the recorder uses 8-bit handles to identify kernel \n
 * objects such as tasks and queues. This limits the supported number of\n
 * concurrently active objects to 255 of each type (object class).\n
 *\n
 * If set to 1 (one), the recorder uses 16-bit handles to identify kernel \n
 * objects such as tasks and queues. This limits the supported number of\n
 * concurrent objects to 65535 of each type (object class). However, since the\n
 * object property table is limited to 64 KB, the practical limit is about\n
 * 3000 objects in total. \n
 * \n
 * NOTE: An object with a high ID (&gt; 255) will generate an extra event \n
 * (= 4 byte) in the event buffer. \n
 * \n
 * NOTE: Some internal tables in the recorder gets larger when using 16-bit \n
 * handles. The additional RAM usage is 5-10 byte plus 1 byte per kernel object\n
 *, i.e., task, queue, semaphore, mutex, etc.</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>false</EditLine>
              <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
              <DefaultIndex>1</DefaultIndex>
              <TextValueIndex>false</TextValueIndex>
              <RuntimeProperty>false</RuntimeProperty>
              <CanDelete>false</CanDelete>
              <IconPopup>false</IconPopup>
              <DefaultValue>false</DefaultValue>
              <Popup>false</Popup>
            </TBoolItem>
          </GrupItem>
        </Children>
      </TGrupItem>
    </Property>
    <Property>
      <TGrupItem>
        <Name>Streaming Mode</Name>
        <Symbol>StreamingModeGroup</Symbol>
        <Hint>Settings for streaming mode. For streaming mode the Segger RTT needs to be enabled.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <BoldName>true</BoldName>
        <EditLine>false</EditLine>
        <Description/>
        <Expanded>Yes</Expanded>
        <Children>
          <GrupItem>
            <TBoolGrupItem>
              <Name>Segger RTT</Name>
              <Symbol>StreamingTraceWithRTT</Symbol>
              <TypeSpec>typeEnaDis</TypeSpec>
              <Hint>Streaming trace data over Segger RTT. Enable if using Segger RTT for streaming</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <BoldName>true</BoldName>
              <EditLine>false</EditLine>
              <Description>Disabled</Description>
              <Expanded>No</Expanded>
              <DefaultValue>false</DefaultValue>
              <DefineSymbol>YES_NO</DefineSymbol>
              <IfDisabled>setNOTHING</IfDisabled>
              <Children>
                <GrupItem>
                  <TInhrLinkItem>
                    <Name>Segger RTT</Name>
                    <Symbol>SeggerRTT</Symbol>
                    <TypeSpec>PercepioTrace\SeggerRTT</TypeSpec>
                    <Hint>Interface to Segger RTT</Hint>
                    <ItemLevel>BASIC</ItemLevel>
                    <EditLine>false</EditLine>
                    <DefaultValue/>
                    <CanDelete>false</CanDelete>
                    <IconPopup>false</IconPopup>
                    <SortStyle/>
                  </TInhrLinkItem>
                </GrupItem>
              </Children>
            </TBoolGrupItem>
          </GrupItem>
          <GrupItem>
            <TEnumItem>
              <Name>Streaming trace enable method</Name>
              <Symbol>trcStartupEnableMethodStreaming</Symbol>
              <TypeSpec>typeTraceEnableStreaming</TypeSpec>
              <Hint>Chooses which trace init and startup method shall be used while the trace Startup() function gets called during application startup.\n
     Snapshot Mode:\n
        TRC_INIT: Initializes trace module. Application needs to start tracing later with vTraceEnable(TRC_START);\n
        TRC_START: Initializes and starts tracing\n
     Streaming Mode:\n
        TRC_INIT: Initializes trace module. Application needs to start tracing later with vTraceEnable(TRC_START);\n
        TRC_START_AWAIT_HOST: initialies trace module and blocks (waits for data to be retrieved */</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
              <DefaultIndex>1</DefaultIndex>
              <TextValueIndex>true</TextValueIndex>
              <RuntimeProperty>false</RuntimeProperty>
              <CanDelete>false</CanDelete>
              <IconPopup>false</IconPopup>
            </TEnumItem>
          </GrupItem>
          <GrupItem>
            <TIntgItem>
              <Name>Up Buffer Index</Name>
              <Symbol>RTTUpBufferIndex</Symbol>
              <Hint>RTT_UP_BUFFER_INDEX: Defines the RTT buffer to use for writing the trace data. Make sure that the PC application has the same setting (File-&gt;Settings).</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue>2</DefaultValue>
              <MinValue>0</MinValue>
              <MaxValue>-1</MaxValue>
              <Bases>DEC</Bases>
              <DefaultBase>DEC</DefaultBase>
              <ExtraHintDisabled>false</ExtraHintDisabled>
              <ChangeValueIntoRange>false</ChangeValueIntoRange>
              <RuntimeProperty>false</RuntimeProperty>
            </TIntgItem>
          </GrupItem>
          <GrupItem>
            <TIntgItem>
              <Name>Up Buffer Size</Name>
              <Symbol>TraceRTTUpBufferSize</Symbol>
              <Hint>Up Buffer Size (default 1024), only applicable for buffer index &gt; 0</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue>1024</DefaultValue>
              <MinValue>0</MinValue>
              <MaxValue>-1</MaxValue>
              <Bases>DEC HEX</Bases>
              <DefaultBase>DEC</DefaultBase>
              <ExtraHintDisabled>false</ExtraHintDisabled>
              <ChangeValueIntoRange>false</ChangeValueIntoRange>
              <RuntimeProperty>false</RuntimeProperty>
            </TIntgItem>
          </GrupItem>
          <GrupItem>
            <TIntgItem>
              <Name>Down Buffer Index</Name>
              <Symbol>RTTDownBufferIndex</Symbol>
              <Hint>RTT_DOWN_BUFFER_INDEX: Defines the RTT buffer to use for reading the trace data. Make sure that the PC application has the same setting (File-&gt;Settings).</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue>2</DefaultValue>
              <MinValue>0</MinValue>
              <MaxValue>-1</MaxValue>
              <Bases>DEC</Bases>
              <DefaultBase>DEC</DefaultBase>
              <ExtraHintDisabled>false</ExtraHintDisabled>
              <ChangeValueIntoRange>false</ChangeValueIntoRange>
              <RuntimeProperty>false</RuntimeProperty>
            </TIntgItem>
          </GrupItem>
          <GrupItem>
            <TIntgItem>
              <Name>Down Buffer Size</Name>
              <Symbol>TraceRTTDownBufferSize</Symbol>
              <Hint>Down Buffer Size (default 32), only applicable for buffer index &gt; 0</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue>32</DefaultValue>
              <MinValue>0</MinValue>
              <MaxValue>-1</MaxValue>
              <Bases>DEC</Bases>
              <DefaultBase>DEC</DefaultBase>
              <ExtraHintDisabled>false</ExtraHintDisabled>
              <ChangeValueIntoRange>false</ChangeValueIntoRange>
              <RuntimeProperty>false</RuntimeProperty>
            </TIntgItem>
          </GrupItem>
          <GrupItem>
            <TIntgItem>
              <Name>Symbol Table Slots</Name>
              <Symbol>SymbolTableSlots</Symbol>
              <Hint>SYMBOL_TABLE_SLOTS: The maximum number of symbols names that can be stored. This includes task names, named ISR's, named kernel objects and user event channels.</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue>30</DefaultValue>
              <MinValue>0</MinValue>
              <MaxValue>-1</MaxValue>
              <Bases>DEC</Bases>
              <DefaultBase>DEC</DefaultBase>
              <ExtraHintDisabled>false</ExtraHintDisabled>
              <ChangeValueIntoRange>false</ChangeValueIntoRange>
              <RuntimeProperty>false</RuntimeProperty>
            </TIntgItem>
          </GrupItem>
          <GrupItem>
            <TIntgItem>
              <Name>Symbol Max Length</Name>
              <Symbol>SymbolMaxLength</Symbol>
              <Hint>SYMBOL_MAX_LENGTH: The maximum length of symbol names.</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue>24</DefaultValue>
              <MinValue>0</MinValue>
              <MaxValue>-1</MaxValue>
              <Bases>DEC</Bases>
              <DefaultBase>DEC</DefaultBase>
              <ExtraHintDisabled>false</ExtraHintDisabled>
              <ChangeValueIntoRange>false</ChangeValueIntoRange>
              <RuntimeProperty>false</RuntimeProperty>
            </TIntgItem>
          </GrupItem>
          <GrupItem>
            <TIntgItem>
              <Name>Object Data Slots</Name>
              <Symbol>ObjectDataSlots</Symbol>
              <Hint>OBJECT_DATA_SLOTS: The maximum number of object data entries (used for task priorities) that can be stored at the same time. Must be sufficient for all tasks, otherwise there will be warnings (as User Events) from TzCtrl task, that monitors this.</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue>20</DefaultValue>
              <MinValue>0</MinValue>
              <MaxValue>-1</MaxValue>
              <Bases>DEC</Bases>
              <DefaultBase>DEC</DefaultBase>
              <ExtraHintDisabled>false</ExtraHintDisabled>
              <ChangeValueIntoRange>false</ChangeValueIntoRange>
              <RuntimeProperty>false</RuntimeProperty>
            </TIntgItem>
          </GrupItem>
          <GrupItem>
            <TStrgItem>
              <Name>Ctrl Task Priority</Name>
              <Symbol>CtrlTaskPrioStr</Symbol>
              <Hint>Configures TRC_CFG_CTRL_TASK_PRIORITY, the priority of the Ctrl task which streams the data. Priority can be rather low, except if your system load is very high, then use (configMAX_PRIORITIES-1)</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue>1</DefaultValue>
              <StrDefine>nothing</StrDefine>
              <MinLength>0</MinLength>
              <MaxLength>-1</MaxLength>
            </TStrgItem>
          </GrupItem>
          <GrupItem>
            <TStrgItem>
              <Name>Ctrl Task Stack Size</Name>
              <Symbol>CtrlTaskStackSize</Symbol>
              <Hint>CTRL_TASK_STACK_SIZE: The stack size of the Ctrl task, that receive commands.</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue>500/sizeof(StackType_t)</DefaultValue>
              <StrDefine>nothing</StrDefine>
              <MinLength>0</MinLength>
              <MaxLength>-1</MaxLength>
            </TStrgItem>
          </GrupItem>
          <GrupItem>
            <TStrgItem>
              <Name>Ctrl Task Delay</Name>
              <Symbol>CtrlTaskDelay</Symbol>
              <Hint>Configures TRC_CFG_CTRL_TASK_DELAY, the delay between every loop of the TzCtrl task. A high delay will reduce the CPU load, but may cause missed events if the TzCtrl task is performing the trace transfer.</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue>((10 * configTICK_RATE_HZ) / 1000)</DefaultValue>
              <StrDefine>nothing</StrDefine>
              <MinLength>0</MinLength>
              <MaxLength>-1</MaxLength>
            </TStrgItem>
          </GrupItem>
        </Children>
      </TGrupItem>
    </Property>
    <Property>
      <TBoolGrupItem>
        <Name>Source Folders</Name>
        <Symbol>SourceFolderGroup</Symbol>
        <TypeSpec>typeEnaDis</TypeSpec>
        <Hint>Settings to configure into which folders the sources shall be generated.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <BoldName>true</BoldName>
        <EditLine>false</EditLine>
        <Description>Disabled</Description>
        <Expanded>No</Expanded>
        <DefaultValue>false</DefaultValue>
        <DefineSymbol>YES_NO</DefineSymbol>
        <IfDisabled>setNOTHING</IfDisabled>
        <Children>
          <GrupItem>
            <TStrgItem>
              <Name>Recorder</Name>
              <Symbol>TraceRecorderFolderName</Symbol>
              <Hint>Main folder of the trace recorder</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue>TraceRecorder</DefaultValue>
              <StrDefine>nothing</StrDefine>
              <MinLength>0</MinLength>
              <MaxLength>-1</MaxLength>
            </TStrgItem>
          </GrupItem>
          <GrupItem>
            <TStrgItem>
              <Name>Config</Name>
              <Symbol>TraceRecorderConfigFolderName</Symbol>
              <Hint>Folder for the configuration files</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue>TraceRecorder/config</DefaultValue>
              <StrDefine>nothing</StrDefine>
              <MinLength>0</MinLength>
              <MaxLength>-1</MaxLength>
            </TStrgItem>
          </GrupItem>
          <GrupItem>
            <TStrgItem>
              <Name>Include</Name>
              <Symbol>TraceRecorderIncludeFolderName</Symbol>
              <Hint>Folder for the include files</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue>TraceRecorder/include</DefaultValue>
              <StrDefine>nothing</StrDefine>
              <MinLength>0</MinLength>
              <MaxLength>-1</MaxLength>
            </TStrgItem>
          </GrupItem>
          <GrupItem>
            <TStrgItem>
              <Name>RTT Include</Name>
              <Symbol>TraceRecorderRTTIncludeFolderName</Symbol>
              <Hint>Folder for the RTT include files</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue>TraceRecorder/streamports/Jlink_RTT/include</DefaultValue>
              <StrDefine>nothing</StrDefine>
              <MinLength>0</MinLength>
              <MaxLength>-1</MaxLength>
            </TStrgItem>
          </GrupItem>
        </Children>
      </TBoolGrupItem>
    </Property>
    <Property>
      <TGrupItem>
        <Name>System</Name>
        <Symbol>SystemGroup</Symbol>
        <Hint>Link to system interfaces</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <BoldName>true</BoldName>
        <EditLine>false</EditLine>
        <Description/>
        <Expanded>Yes</Expanded>
        <Children>
          <GrupItem>
            <TInhrLinkItem>
              <Name>SDK</Name>
              <Symbol>sdk</Symbol>
              <TypeSpec>PercepioTrace\sdk</TypeSpec>
              <Hint>Link to SDK</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>false</EditLine>
              <DefaultValue/>
              <CanDelete>false</CanDelete>
              <IconPopup>false</IconPopup>
              <SortStyle/>
            </TInhrLinkItem>
          </GrupItem>
          <GrupItem>
            <TInhrLinkItem>
              <Name>Utility</Name>
              <Symbol>Utility</Symbol>
              <TypeSpec>Utility_I</TypeSpec>
              <Hint>Interface to utility functions</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>false</EditLine>
              <DefaultValue/>
              <CanDelete>false</CanDelete>
              <IconPopup>false</IconPopup>
              <SortStyle/>
            </TInhrLinkItem>
          </GrupItem>
        </Children>
      </TGrupItem>
    </Property>
  </PropertyList>
  <MethodList>
    <Method>
      <TMthdItem>
        <Name>vTraceEnable</Name>
        <Symbol>vTraceEnable</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint/>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>startoption</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>* TRC_START: Starts the tracing directly. In snapshot mode this allows for \n* starting the trace at any point in your code, assuming vTraceEnable(TRC_INIT)\n* has been called in the startup.\n* Can also be used for streaming without Tracealyzer control, e.g. to a local\n* flash file system (assuming such a "stream port", see trcStreamingPort.h).\n* \n* TRC_START_AWAIT_HOST: For streaming mode only. Initializes the trace recorder\n* if necessary and waits for a Start command from Tracealyzer ("Start Recording"\n* button). This call is intentionally blocking! By calling vTraceEnable with\n* this option from the startup code, you start tracing at this point and capture\n* the early events.\n*\n* TRC_INIT: Initializes the trace recorder, but does not start the tracing.\n* In snapshot mode, this must be followed by a vTraceEnable(TRC_START) sometime\n* later.</ParHint>
          <ParUserDeclaration>int startOption</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(int startOption)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>uiTraceStart</Name>
        <Symbol>uiTraceStart</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Starts the trace.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>32bit unsigned</ReturnType>
        <RetHint>returns 1 if trace has been started, 0 otherwise.</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>dword #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>vTraceStop</Name>
        <Symbol>vTraceStop</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Stops the trace.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>vTraceClear</Name>
        <Symbol>vTraceClear</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Clears the trace.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>uiTraceGetTraceBufferSize</Name>
        <Symbol>uiTraceGetTraceBufferSize</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Gets the size of the recorder data structure. For use together with vTraceGetTraceBuffer if you wish to implement an own store/upload solution, e.g., in case a debugger connection is not available for uploading the data.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>32bit unsigned</ReturnType>
        <RetHint>Size of the trace buffer</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>dword #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xTraceGetTraceBuffer</Name>
        <Symbol>xTraceGetTraceBuffer</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Return a pointer to the recorder data structure. Use this together with uiTraceGetTraceBufferSize if you wish to implement an own store/upload solution, e.g., in case a debugger connection is not available for uploading the data.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>pointer</ReturnType>
        <RetHint>Pointer to the trace buffer</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void* #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xTraceRegisterString</Name>
        <Symbol>xTraceRegisterString</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Register strings in the recorder, e.g. for names of user event channels.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>traceString</ReturnType>
        <RetHint>trace label to be used with vTracePrintF</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>name</ParName>
          <ParType>char</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to label</ParHint>
          <ParUserDeclaration>const char* name</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>traceString #M#_#C#(const char* name)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>vTracePrint</Name>
        <Symbol>vTracePrint</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Generates a User Event with a text label. The label is created/looked up in the symbol table using xTraceRegisterString.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>chn</ParName>
          <ParType>traceString</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>trace label for the user event</ParHint>
        </Parameter>
        <Parameter>
          <ParName>str</ParName>
          <ParType>char</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to string</ParHint>
          <ParUserDeclaration>const char* str</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(traceString chn, const char* str)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>vTracePrintF</Name>
        <Symbol>vTracePrintF</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Advanced user event - like printf (but limited formatting support - will improve)</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>3</ParamCount>
        <Parameter>
          <ParName>eventLabel</ParName>
          <ParType>traceLabel</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>trace label</ParHint>
        </Parameter>
        <Parameter>
          <ParName>formatStr</ParName>
          <ParType>char</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to format string</ParHint>
        </Parameter>
        <Parameter>
          <ParName>Variable_1</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>open parameter list</ParHint>
          <ParUserDeclaration>...</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(traceLabel eventLabel, char *formatStr, ...)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>vTraceSetQueueName</Name>
        <Symbol>vTraceSetQueueName</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Assigns a name to a FreeRTOS Queue, Semaphore or Mutex. This function should  be called right after creation of the queue/mutex/semaphore. If not using this function, the queues/mutexes/semaphores will be presented by their numeric handle only.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>queue</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to the queue</ParHint>
          <ParUserDeclaration>void *queue</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>name</ParName>
          <ParType>char</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to name</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(void *queue, char *name)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>vTraceSetSemaphoreName</Name>
        <Symbol>vTraceSetSemaphoreName</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Assigns a name to a FreeRTOS Queue, Semaphore or Mutex. This function should  be called right after creation of the queue/mutex/semaphore. If not using this function, the queues/mutexes/semaphores will be presented by their numeric handle only.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>queue</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to the semaphore</ParHint>
          <ParUserDeclaration>void *semaphore</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>name</ParName>
          <ParType>char</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to name</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(void *semaphore, char *name)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>vTraceSetMutexName</Name>
        <Symbol>vTraceSetMutexName</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Assigns a name to a FreeRTOS Queue, Semaphore or Mutex. This function should  be called right after creation of the queue/mutex/semaphore. If not using this function, the queues/mutexes/semaphores will be presented by their numeric handle only.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>queue</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to the mutex</ParHint>
          <ParUserDeclaration>void *mutex</ParUserDeclaration>
        </Parameter>
        <Parameter>
          <ParName>name</ParName>
          <ParType>char</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to name</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(void *mutex, char *name)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xTraceSetISRProperties</Name>
        <Symbol>xTraceSetISRProperties</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Registers an Interrupt Service Routine in the recorder library, This must be called before using vTraceStoreISRBegin to store ISR events. This is typically called in the startup of the system, before the scheduler is started. Method is always enabled if 'Include ISR tracing' is set to 'yes' in the properties.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>traceHandle</ReturnType>
        <RetHint>trace handle to be used for vTaceStoreISRBegin()</RetHint>
        <ParamCount>2</ParamCount>
        <Parameter>
          <ParName>name</ParName>
          <ParType>char</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to name</ParHint>
        </Parameter>
        <Parameter>
          <ParName>prioritiy</ParName>
          <ParType>char</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>priority</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>traceHandle #M#_#C#(char *name, char prioritiy)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>vTraceStoreISRBegin</Name>
        <Symbol>vTraceStoreISRBegin</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Registers the beginning of an Interrupt Service Routine. This must not be interrupted by another ISR containing recorder library calls, so if allowing nested ISRs this must be called with interrupts disabled.  Method is always enabled if 'Include ISR tracing' is set to 'yes' in the properties.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>handle</ParName>
          <ParType>traceHandle</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>trace handle</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(traceHandle handle)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>vTraceStoreISREnd</Name>
        <Symbol>vTraceStoreISREnd</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Registers the end of an Interrupt Service Routine. This must not be interrupted by another ISR containing recorder library calls, so if allowing nested ISRs this must be called with interrupts disabled.  Method is always enabled if 'Include ISR tracing' is set to 'yes' in the properties.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>isTaskSwitchRequired</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>The parameter pendingISR indicates if the interrupt has requested a task-switch (= 1) or if the interrupt returns to the earlier context (= 0)</ParHint>
          <ParUserDeclaration>int isTaskSwitchRequired</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(int isTaskSwitchRequired)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>vGetGDBDumpCommand</Name>
        <Symbol>vGetGDBDumpCommand</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Gets the gdb command to dump the trace data to a file. Useful for copy-pasting it to the gdb console.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>3</ParamCount>
        <Parameter>
          <ParName>buf</ParName>
          <ParType>uint8_t</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to buffer for the command. Make it large enoug (about 64 bytes)</ParHint>
        </Parameter>
        <Parameter>
          <ParName>bufSize</ParName>
          <ParType>uint16_t</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>size of the buffer</ParHint>
        </Parameter>
        <Parameter>
          <ParName>fileName</ParName>
          <ParType>uint8_t</ParType>
          <ParPassing>Address</ParPassing>
          <ParHint>Pointer to the file name string, e.g. "C:\\tmp\\trace.dump"</ParHint>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(uint8_t *buf, uint16_t bufSize, uint8_t *fileName)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>vTraceSetStopHook</Name>
        <Symbol>vTraceSetStopHook</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Sets a function to be called when the recorder is stopped.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>none</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>stopHookFunction</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint/>
          <ParUserDeclaration>TRACE_STOP_HOOK stopHookFunction</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(TRACE_STOP_HOOK stopHookFunction)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>xTraceGetLastError</Name>
        <Symbol>xTraceGetLastError</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Gives the last error message, if any. NULL if no error message is stored. Any error message is also presented when opening a trace file.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>string</ReturnType>
        <RetHint>Error message</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>char* #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>vTraceClearError</Name>
        <Symbol>vTraceClearError</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Removes any previous error message generated by recorder calling vTraceError. By calling this function, it may be possible to start/restart the trace despite errors in the recorder, but there is no guarantee that the trace recorder will work correctly in that case, depending on the type of error.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>8bit unsigned</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>1</ParamCount>
        <Parameter>
          <ParName>resetErrorMessage</ParName>
          <ParType>8bit unsigned</ParType>
          <ParPassing>Value</ParPassing>
          <ParHint>parameter is not used</ParHint>
          <ParUserDeclaration>int resetErrorMessage</ParUserDeclaration>
        </Parameter>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>byte #M#_#C#(int resetErrorMessage)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
    <Method>
      <TMthdItem>
        <Name>Startup</Name>
        <Symbol>Startup</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Routine called during startup. Depending on the mode and settings, it starts tracing and might block!</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <EditLine>false</EditLine>
        <TypeSpecNameChangeAble>false</TypeSpecNameChangeAble>
        <DefaultIndex>0</DefaultIndex>
        <TextValueIndex>false</TextValueIndex>
        <RuntimeProperty>false</RuntimeProperty>
        <CanDelete>false</CanDelete>
        <IconPopup>false</IconPopup>
        <DefaultValue>true</DefaultValue>
        <Popup>false</Popup>
        <PublicMethod>true</PublicMethod>
        <IsAssembler>false</IsAssembler>
        <InDefinition>true</InDefinition>
        <ReturnType>void</ReturnType>
        <RetHint>Error code</RetHint>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #M#_#C#(void)</ANSIC>
        </Declarations>
      </TMthdItem>
    </Method>
  </MethodList>
  <EventList>
    <Event>
      <TStrgItem>
        <Name>Event module name</Name>
        <Symbol>EventModule</Symbol>
        <Hint>Name of the user module (without extension), where the events from this component are placed.</Hint>
        <ItemLevel>ADVANCED</ItemLevel>
        <EditLine>true</EditLine>
        <DefaultValue>Events</DefaultValue>
        <StrDefine>nothing</StrDefine>
        <MinLength>0</MinLength>
        <MaxLength>-1</MaxLength>
      </TStrgItem>
    </Event>
    <Event>
      <TEvntItem>
        <Name>OnTraceStop</Name>
        <Symbol>OnTraceStop</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Called if the library calls vTraceStop(). Useful to dump the trace if 'stop when recorder is full' mode is selected.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <BoldName>true</BoldName>
        <EditLine>false</EditLine>
        <Description>don't generate code</Description>
        <Expanded>No</Expanded>
        <DefaultValue>false</DefaultValue>
        <DefineSymbol>YES_NO</DefineSymbol>
        <IfDisabled>setNOTHING</IfDisabled>
        <IsAssembler>false</IsAssembler>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #C#(void)</ANSIC>
        </Declarations>
        <Children>
          <GrupItem>
            <TEvntName>
              <Name>Event procedure name</Name>
              <Symbol>Name</Symbol>
              <Hint>OnTraceStop procedure name</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue/>
              <StrDefine>nothing</StrDefine>
              <MinLength>0</MinLength>
              <MaxLength>-1</MaxLength>
              <ErrorIfNotSet>true</ErrorIfNotSet>
              <IdentType>EVNT</IdentType>
            </TEvntName>
          </GrupItem>
        </Children>
      </TEvntItem>
    </Event>
    <Event>
      <TEvntItem>
        <Name>OnTraceStart</Name>
        <Symbol>OnTraceStart</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Called when vTraceStart() gets called.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <BoldName>true</BoldName>
        <EditLine>false</EditLine>
        <Description>don't generate code</Description>
        <Expanded>No</Expanded>
        <DefaultValue>false</DefaultValue>
        <DefineSymbol>YES_NO</DefineSymbol>
        <IfDisabled>setNOTHING</IfDisabled>
        <IsAssembler>false</IsAssembler>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #C#(void)</ANSIC>
        </Declarations>
        <Children>
          <GrupItem>
            <TEvntName>
              <Name>Event procedure name</Name>
              <Symbol>Name</Symbol>
              <Hint>OnTraceStart procedure name</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue/>
              <StrDefine>nothing</StrDefine>
              <MinLength>0</MinLength>
              <MaxLength>-1</MaxLength>
              <ErrorIfNotSet>true</ErrorIfNotSet>
              <IdentType>EVNT</IdentType>
            </TEvntName>
          </GrupItem>
        </Children>
      </TEvntItem>
    </Event>
    <Event>
      <TEvntItem>
        <Name>OnTraceWrap</Name>
        <Symbol>OnTraceWrap</Symbol>
        <TypeSpec>typeMethod</TypeSpec>
        <Hint>Called for trace ring buffer wrap around. This gives the application a chance to dump the trace buffer.</Hint>
        <ItemLevel>BASIC</ItemLevel>
        <BoldName>true</BoldName>
        <EditLine>false</EditLine>
        <Description>generate code</Description>
        <Expanded>Yes</Expanded>
        <DefaultValue>true</DefaultValue>
        <DefineSymbol>YES_NO</DefineSymbol>
        <IfDisabled>setNOTHING</IfDisabled>
        <IsAssembler>false</IsAssembler>
        <ParamCount>0</ParamCount>
        <Scope>PRIVATE</Scope>
        <Declarations>
          <ANSIC>void #C#(void)</ANSIC>
        </Declarations>
        <Children>
          <GrupItem>
            <TEvntName>
              <Name>Event procedure name</Name>
              <Symbol>Name</Symbol>
              <Hint>OnTraceWrap procedure name</Hint>
              <ItemLevel>BASIC</ItemLevel>
              <EditLine>true</EditLine>
              <DefaultValue/>
              <StrDefine>nothing</StrDefine>
              <MinLength>0</MinLength>
              <MaxLength>-1</MaxLength>
              <ErrorIfNotSet>true</ErrorIfNotSet>
              <IdentType>EVNT</IdentType>
            </TEvntName>
          </GrupItem>
        </Children>
      </TEvntItem>
    </Event>
  </EventList>
  <Links>
    <EmptySection_DummyValue/>
  </Links>
  <Revisions>
    <RevisionVersion>2</RevisionVersion>
  </Revisions>
</Bean>
